---
title: 如何保证 TCP 的可靠传输
date: 2019-05-07 15:29:02
tags: [网络协议,TCP,趣谈网络协议(刘超)]
---


### 可靠的网络传输

客户端发起的每一个包，服务端都应该有相应的回复，如果服务器超过一定时间还没有回复，那么客户端会重复发送这个包，直到收到回复。


### 如何实现一个可靠的协议

为了保证顺序性，每个包都要一个 ID。

建立连接，确定其实 ID ，按照 ID 一个一个发送包，为了保证不丢包，对于 **发送的包都要进行应答**。但是对于包的应答不是一个一个来的，而是应答某个之前的 ID ，表示都收到了，这种模式称为 累计确认或者累计应答。




为了记录所有发送的包和接收的包， TCP 需要在发送端和接收端来缓存这些记录。

发送端的缓存中按照 ID 一个一个排列，按照情况分为四类：

1. 发送并且得到确认的包。
2. 发送尚未确认的包。
3. 没有发送，在等待发送的包。
4. 没有发送，暂时不会发送的包。

![](/../images/2019_08_28_01.png)

图中可以看到这部分的分界线。

接收端中的的缓存：

1. 接收并且确认过的。
2. 还没接收，但是马上能接收的。
3. 还没接收，也没法接收的。

![](/../images/2019_08_28_02.png)


MaxRcvBuffer：最大缓存的量；
LastByteRead 之后是已经接收了，但是还没被应用层读取；
NextByteExpected 是第一部分和第二部分的分界；


### 顺序问题和丢包问题



超时重试
对于每一个发送但是没有 ACK 的包，都有一个定时器，超过了一定时间，就尝试重试。

关于超时时间的计算:
    估计往返时间，通过 TCP 采样 RTT 时间，加权平均，算出一个值，这个值会根据网络状况不断变化。
由于重传时间不断变化，我们成为自适应重传算法。

有需要重传的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两倍。两次超时，就说明网络环境差，不宜频繁反复发送。


### 流量控制问题

在对于包的确认中，同时会携带一个窗口的大小。

假设窗口大小不变，那么在发送端得到包确认后，会向右移一个位置。

我们可以看一下发送和接收的过程，假设窗口始终为 9。

起始状态：

![](/../images/2019_08_28_01.png)

4 的发送确认到来，会右移一个，此时第 13 个包为可以发送了。

![](/../images/2019_08_28_03.png)


如果发送端发送过猛，会将 10、11、12、13 全部发完，之后就停止发送，未发送可发送部分为 0：

![](/../images/2019_08_28_04.png)


当包 5 的发送确认到来时，发送端此时相当于窗口向右再次滑动一个，此时若还有包可以发送就可以继续发送了，如 第14 个包现在可以发送：

![](/../images/2019_08_28_05.png)



如果此时接收方处理过慢，导致接收方缓存中没有空间了，发送方可以通过确认信息修改窗口大小，甚至为 0，那么发送方将暂时停止发送。

接收端情况：


假设接收端的应用一直不读取缓存中的数据，当数据包 6 确认后，窗口就不能再是 9 了，就会缩小为 8:

![](/../images/2019_08_28_06.png)

新窗口的 8 通过 6 的确认信息到达发送端时，此时窗口没有整体向右平移一格，而是仅左侧右移一格，窗口从 9 变成 8 。

![](/../images/2019_08_28_07.png)


如果接收端一直不处理数据，那么接收端随着确认的包越来越到，窗口会变的越来越小，直到为0：

![](/../images/2019_08_28_08.png)

当发送端接收到包 14 的确认后，发送端窗口也调整为 0，停止发送：

如果到达此情况，发送端会定时发送窗口探测数据包，看是否有机会调整窗口的大小。


### 拥塞控制问题


拥塞控制问题也是通过窗口(拥塞窗口)的大小来控制。


**前面的滑动窗口是怕发送端把接收端的缓存塞满，拥塞窗口是怕把网络塞满。**
这里有一个公式 LastByteSent - LastByteAcked <= min {cwnd, rwnd} ，是拥窗口和滑动窗口共同控制发送的速度。


TCP 的拥塞控制主要是避免两种现象：包丢失和超时重传。一旦出现这种现象就说明发送速度过快，