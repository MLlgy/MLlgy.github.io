---
title: Java 内存回收
tags:
---


Java 引用 与 内存回收关系

Java 对象在内存中的不同状态

软引用使用和使用注意
弱引用
虚引用


Java 内存泄漏的原因

Java 垃圾回收机制的基本算法

堆内存的分代回收

JVM 何时决定回收一个 Java 对象所占据的内存？
JVM 会不会漏掉回收某些 Java 对象，使之造成内存泄漏？
JVM 回收 Java 对象所占用内存的实现细节。
JVM 能否对不同 Java 对象占用的内存区别对待、回收？
常见垃圾回收机制的实现细节。


## 1.  Java 引用类型


在 Java 中通过 new 关键字创建 Java 对象，为 Java 对象申请内存空间，JVM 会在堆内存为每一个对象分配空间；当 Java 对象失去引用时，JVM 的垃圾回收机制会自动清除它们，回收它们占用的内存空间。


Java 内存管理分为内存分配和内存回收两方面。

### 1.1 对象在内存中的状态


对于 JVM 垃圾回收机制来说，能否回收一个对象的标准：是否还有引用变量引用该对象？

当 Java 对象被创建出来后，JVM 会实时监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值。


在 JVM 内存中，可以有以下类比：

* 对象引用：有向图
* 引用变量、对象：有向图的顶点
* 引用关系：有向图的有向边

有向边总是从引用端指向被引用的 Java 对象，由于 Java 对象是在线程中创建出来的，因此可以吧线程对象当成有向图的起始顶点。


```
public main(){
    Node node = new Node();
    Node node2 = new Node();
    Node node3 = new Node();
    node.next = node2;
    node3 = node2;
    node2 = null;
}
```

Java 对象在内存中的状态：

* 可达状态
* 可恢复状态
* 不可达状态

一个对象 A 能够被以下变量引用：

* 被方法的局部变量引用
* 被其他类(B)的类变量引用

只有该类(B) 被销毁后，该对象(A) 才会进入可恢复状态。

* 被其他类(C)的实例变量引用

只有当该类(C)的对象被销毁或者处于不可达状态后，该对象(A)才会进入不可达状态。

前文说，对于 JVM 垃圾回收机制来说，能否回收一个对象的标准：是否还有引用变量引用该对象？所以引用是 JVM 进行内存管理的一个重要概念，为了更好的管理对象的引用，在 Java1.2 后，java.lang.ref包下提供了3个类：SoftReference 、PhantomReference 和 WeakReference，分别代表系统对对象的三种引用方式：软引用、虚引用、弱引用。


### 1.2 强引用


通过 new 创建一个对象，并把这个对象赋值给一个引用变量，这个引用变量就是强引用。


JVM 不会回收强引用所引用的 Java 对象，因此强引用是造成 Java 内存泄漏的主要原因之一。


### 1.3 软引用

软引用通过 SoftReference 来实现。

当一个对象只具有软引用时，它有可能被垃圾回收机制回收。

对于只有软引用的对象而言，回收分为两种情况：

1. 当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；
2. 当系统内存空间不足时，系统将会回收它。

软引用通常用于内存敏感的程序中，对强引用是一个很好的替代。当程序需要大量创建某个类的新对象，而且 **有可能重新访问已创建老对象时**，可以充分使用软引用来解决内存紧张。

关于软引用的使用，可以查看 疯狂 Java 讲义。

### 1.4 弱引用

弱引用通过 WeakReference 来实现。

弱引用和软引用相似，区别是弱引用所引用对象的生存期更短。


对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，在执行  GC 时，总会回收该对象所占用的内存。


与 WeakReference 功能类似的还有 WeakHashMap。其实程序很少会考虑直接使用单个的 WeakReference 来引用某个Java对象，因此这种时候系统内存往往不会特别紧张。当程序有大量的Java对象需要使用弱引用来引用时，可以考虑使用 WeakHashMap 来保存它们。

在垃圾回收机制运行之前，WeakHashMap的功能与普通HashMap并没有太大的区别，它们的功能完全相似。但一旦垃圾回收机制被执行，WeakHashMap中所有key-value对都会被清空，除非某些key还有强引用在引用它们。


### 1.5 虚引用

虚引用通过 PhantomReference 来实现。

软引用和弱引用可以单独使用，但是虚引用不可以，单独使用没有任何意义。

虚引用必须和引用队列一起使用，虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查 **与虚引用关联的引用队列中是否已经包含指定的虚引用**，从而了解虚引用所引用对象是否即将被回收。

同时也可以把软引用、弱引用和引用队列联合使用时，系统回收被引用的对象之后，将会把被回收对象对应的引用添加到关联的引用队列中。


### 1.6 使用注意


要使用这些特殊的引用类，**就不能保留对对象的强引用**。如果保留了对对象的强引用，就会浪费这些类所提供的任何好处。


### 2. 内存泄漏


* 什么是内存泄漏？

程序在运行过程中，不再使用的内存空间应该回收它们，从而保证系统能够再次使用这些内存空间，如果无用的内存不能得到有效的回收，那就是内存泄漏。

### 3. 垃圾回收机制


垃圾回收机制主要完成了两个事情：


1. 跟踪并监控每个 Java 对象，当某个对象处于不可达状态时，回收该对象占用的内存空间；
2. 清理内存分配、回收过程中产生的内存碎片。

而垃圾回收机制的这两方面工作的工作量其实都不是很大，那么影响 Java 运行效率的因素为：垃圾回收算法。

#### 3.1 垃圾回收的基本算法


对于一个垃圾回收器的算法，有以下选择：


* 串行回收和并行回收
* 并发执行和应用程序停止
* 压缩和不压缩和复制

 复制：


复制是将堆内存分为两个相同的空间，从根开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收空间A

复制算法遍历空间成本小，但是复制成本大。


* 有关标记清除算法：


不压缩的回收方式，从根开始访问所有的可达对象，将它们标记为可达状态，然后在遍历一次整个内存空间，把没有标记的对象回收清理。


无需进行大规模的复制，需要两次遍历，遍历成本大，不连续回收内存空间，产生大量的内存碎片。


* 有关标记压缩算法：


压缩方式，利用以上两种算法的优点。垃圾回收期从根访问所有的可达对象，将它们标记为可达状态，接下来垃圾回收器会将这些可达对象搬移到一起，称为 **内存压缩**，然后垃圾回收器回收不可达对象，避免产生内存碎片。


现行的垃圾回收器用分代的方式来采用不同的回收设计，根据对象的生存时间长短，将堆内存分为以下3个代：

* Young：新生代
* Old：年老代
* Permanent：永久代


垃圾回收器根据不同代的特点，使用不同的垃圾回收算法，充分利用不同回收算法的优点。

#### 3.2 堆内存的分代回收

分代回收的一个依据就是对象生存时间的长短，然后根据不同代采取不同的垃圾回收策略。

分代回收策略基于以下两个事实：

1. 绝大多数的对象不会被长时间引用，这些对象在 Young 期间就会被回收。
2. 很老的对象和很年轻的对象之间很少存在相互引用的情况。


* Young 代(新生代)

存放对象：新分配的对象

基于以上两个事实，处于 Young 代的大部分对象很快就会进入不可达状态，只有少量的对象能够熬过垃圾回收执行是，此时垃圾回收器中只会保留 Young 代处于可达状态的对象，这些对象的数量很少，复制成本不大，所以大部分垃圾回收器对 Young 代对象 **采用复制算法**。

`Young` 代由一个 `Eden` 和 `两个 Survivor` 组成。

绝大数新对象首先被分配到 Eden 区，Survivor 中的对象至少经历一次垃圾回收，同一时间两个 Survivor 区中的一个用来保存对象，另外一个是空的，这个空的区域用来保存下次内存回收时 Young 代中存活的对象（垃圾回收时 Eden 和 不为空的 Survivor 区域中可达对象），然后清除 Eden 和原先不为空的 Survivor 区域。


* Old 代(老年代)

存放的对象：长生命周期的对象，通常都是从 Survivor 区域拷贝过来的对象、大对象

Young 代中的对象经历多次垃圾回收依然没有被回收掉，那么垃圾回收机制就会将这个对象移至 Old 代。

Old 代中的对象没有那么容易被回收，所以随着时间，Old 代中的对象越来越多，所以 Old 代空间比 Young 代空间更大。

Old 代垃圾回收具有以下两个特性：

1. 垃圾回收执行效率无需太高，因为极少的对象会死掉；
2. 由于对象多，每次垃圾回收的需要更长的时间来完成。

基于以上特定，垃圾回收器对 Old 代采取 **标记压缩算法**，避免赋值大量的对象。


* Permanent 代(永久代)

Permanent代主要用于装载Class、方法等信息，默认为64M，垃圾回收机制通常不会回收Permanent代中的对象。

在 JDK8 以后不存在永久代区域。


### 利用 JVM 参数，改变堆和内部区域的大小


* 最大堆体积

> -Xmx value

* 初始的最小堆体积

> -Xms value


* 老年代和新生代的比例

> -XX:NewRatio=value

默认为 2 ，老年代是新生代的 2 倍。


* 调整新生代的大小

> -XX:NewSize=value

* Eden 和 Survivor 的大小是按照比例设置

> -XX:SurvivorRatio=value

注意新生代区域的大小 YoungGen= Eden + 2 * Survivor = value * Survivor + 2 * Survivor = (value + 2) * Survivor

### 内存管理小技巧


* 使用StringBuilder和StringBuffer进行字符串连接
* 尽早释放无用对象的引用
* 尽量少用静态变量

某个对象被static变量所引用，那么垃圾回收机制通常是不会回收这个对象所占的内存

obj变量是Person类的静态变量，因此它的生命周期与Person类同步。在Person类不被卸载的情况下，Person类对应的Class对象会常驻内存，直到程序运行结束。因此obj所引用的Object对象一旦被创建，也会常驻内存，直到程序运行结束。

分代回收机制，JVM会将程序中Person类的信息存入Permanent代。也就是说，Person类、obj引用变量都将存在Permanent代里，这将导致obj对象一直有效，从而使得obj所引用的Object得不到回收

* 避免在经常调用的方法、循环中创建Java对象
* 缓存经常使用的对象

比如说 HashMap、第三方开源工具等，对对象进行缓存。


* 尽量不要使用finalize方法
* 考虑使用SoftReference