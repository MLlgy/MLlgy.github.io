---
title: 深入浅出计算机组成原理(三)-函数调用以及栈溢出
date: 2019-05-16 10:45:08
tags: [深入浅出计算机组成原理(徐文浩)]
---

计算机指令在内存中是 **顺序存储** 的，在 [深入浅出计算机组成原理(二)-CPU是如何执行指令的深入浅出计算机组成原理(二)-CPU是如何执行指令的]() 中阐述了执行 if/else 语句 时计算机指令的执行过程：指令跳转后继续顺序执行指令。

方法调用时计算机指令如何执行的，才能够完成函数调用？

实例代码：

```
// function_example.c
#include <stdio.h>
int static add(int a, int b)
{
    return a+b;
}


int main()
{
    int x = 5;
    int y = 10;
    int u = add(x, y);
}
```

编译源代码以及 dump 出汇编代码指令：

```
gcc -g -c function_example.c
$ objdump -d -M intel -S function_example.o
```

具体汇编代码如下：


```
int static add(int a, int b)
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
}
  12:   5d                      pop    rbp
  13:   c3                      ret    
0000000000000014 <main>:
int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);
  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 <add>
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    
```

从以上汇编代码中我们看到该代码的顺序存储空间为：0 ~ 42 。


在执行 add() 函数时在函数的开始和结束我们分别看到 `push   rbp` 和 `pop    rbp`，结合我们日常开发，push 为 **压栈** 操作，而 push 为 **出栈** 操作。

结合 Java 中的堆栈概念，函数的信息会被存储在栈中，执行方法会将该函数进行压栈操作，而函数执行后进行出栈操作。虽然 Java 是基于虚拟机的语言，但是虚拟机是运行在操作系统中，底层实现还是本地代码。


#### 使用栈记录函数调用过程

基于函数调用的栈的形象图如下：

![栈：记录函数调用(图片来自：极客时间，若侵权必删)](https://static001.geekbang.org/resource/image/d0/be/d0c75219d3a528c920c2a593daaf77be.jpeg)

在上图中存在一个关键的概念：**栈帧**。

何为栈帧，每个栈帧对应一个特定的函数，所以栈帧中存储着函数的基本信息，包括传输的数据、返回的地址等。


#### 函数执行过程


抽象出程序中描述的计算机指令在内存中的存储的示意图，如下：

![内存中指令的存储示意图(图片来自：极客时间，若侵权必删)](https://static001.geekbang.org/resource/image/23/d1/2361ecf8cf08f07c83377376a31869d1.jpeg)

由于 栈底 的内存地址在程序运行就已经为固定，针对于此文件，位于栈底当然为 入口函数 main() 了，所以栈底的内存地址为 14。

1. main 函数调用 add() 函数，add 函数的入口为 0~1 行，而 add 函数结束后在 12 ~13 行。
2. 程序在调用 34 行的 call 指令时，会把当前 PC 寄存器中的下一条指令的地址进行压栈，这个地址即为 图一 中的返回地址。
3. add 函数的执行开始：0 行处的 push rbp 这个指令就是在进行压栈操作。rbp 又叫做栈指针(Frame Pointer)，是一个存放当前栈帧位置的寄存器，push rbp 就是把之前调用的函数，也就是 main 函数的栈帧的栈帧地址，压到栈顶。
4. 第 1 行指令：mov rbp, rsp 则是把 rsp 这个栈指针的值复制到 rbp 中，而 rsp 始终会指向栈顶，**即为 add 函数的栈帧的栈底地址了**。
   
        这里会存在一个理解误区，以为栈顶为栈帧的头部地址，这样理解是错误的，因为在栈中栈帧的存储规则为从地址从小到大顺序存储，这也就解释了为什么 add 函数的栈顶为栈帧的栈底地址了。
    
    该过程的意义是开辟 add 函数的栈帧。

5. add 函数执行完毕，调用 12 行处的 pop rbp 将当前的栈顶出栈，接着调用 13 行的 ret ，这时候要把第 2 步中的压入栈的地址出栈，更新到 PC 寄存器中，将程序的控制权交还给出栈后栈顶，即为 main 栈帧。



https://blog.csdn.net/zhuoya_/article/details/80516246