---
title: '数据结构与算法:排序算法(一)'
tags:
---


## 内部排序的分类

一个分为 6 大类，每个类中可能包含子类：

1. 选择排序
   1. 直接排序
   2. 堆排序
2. 归并排序
3. 交换排序
   1. 冒泡排序
   2. 快速排序
4. 基数排序
5. 桶式排序
6. 插入排序
   1. 直接插入
   2. 折半插入
   3. Shell 排序

## 选择排序

* 直接排序简单直观，但是性能较差。
* 堆排序性能高效，但是实现复杂。

### 直接排序


比较次数比较多，时间复杂度为 O(n^2)，
需要一个额外的空间进行数据交换，所以空间复杂度为 O(1)。


### 堆排序


当 n 个元素构成的序列 **同时** 满足以下条件时：
1. K(i) <= K(2i) + 1 
2. K(i) <= K(2i) + 2

其中 (n-1)/2=>i >=0被称为 **小根堆**（根的值最小）。


当 n 个元素构成的序列 **同时** 满足以下条件时：
1. K(i) >= K(2i) + 1 
2. K(i) >= K(2i) + 2

其中 (n-1)/2=>i >=0被称为 **大根堆**（根的值最小）。


小根堆可以抽象为一个树中 **所有的节点值都小于左右节点值** 的完全二叉树，
大根堆可以抽象为一个树中 **所有的节点值都大于左右节点值** 的完全二叉树


## 交换排序


### 冒泡排序

第1次遍历：1~n 个元素 0和1、1和2。。。n-2和n-1 元素分别比较，得到n 个元素中最大的值，进行 n-1 次比较。
第2次遍历：1~n 个元素 0和1、1和2。。。n-3和n-2元素分别比较，得到前n-1 个元素中最大的值，进行 n-2 次比较。

第 n-1 遍历，比较 0 和 1 个元素，得到前2个元素的最大值，进行1次比较。






### 快速排序

快速排序是速度非常快的交换排序方法。

快速排序的思想：

1. 从数据序列中取出任意一个数，以此数作为分界值，比它大的值放在右边，比它小的值放在左边。
2. 对左右两个子序列重新选择中心，进行元素位置调整，直到每个子表的元素只剩一个为止。


具体实现思路：

1. 定义一个变量 i，i 变量从左边第一个索引开始遍历，找到大于分界值的索引，用 i 记录。
2. 定义一个变量 j，j 变量从右边第一个索引开始遍历，找到小于分界值的索引，用 j 记录。
3. 如果 i < j，交换两个索引处的元素。



快速排序为不稳定的排序算法



## 插入排序


包括直接插入排序、Shell 排序、折半传入等几种。


### 直接插入排序


空间效率 O(1)，为稳定排序算法。

### 折半插入排序

对直接插入排序的简单改进。



### Shell 排序

在直接排序中，将第i个元素添加到前i-1个元素组成的有序序列中，但是如果第 i 个元素十分小，那么此时就会发生前 i-1 个元素都会发生平移复制，这样的执行效率是十分低的。


Shell 排序对直接排序做了简单的改进：序列以间隔数进行排序，后减小间隔数的大小进行排序。


![](/source/images/2020_01_01_01.png)


## 归并排序


归并排序的思想将两个有序的序列合并成一个新的有序序列。

稳定排序。需要一个和原始数组同样大小的数组，空间效率较差。


## 桶式排序


使用桶式排序的序列需要满足的条件：

1. 待排序的序列为可枚举的
2. 序列的范围不应过大，否则开销较大。



