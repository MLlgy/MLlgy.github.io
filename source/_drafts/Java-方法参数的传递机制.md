---
title: Java 方法参数的传递机制
tags:
---


>自己关注这个问题是在一次编码过程中，将一个实例变量传递给一个方法，在该方法中对该形参变量做一些操作后，赋给一个新的对象。这些步骤后发现该形参对应的实参也发生了相应的改变。



Java 里方法的参数传递方式只有一种：**值传值**，所谓的值传递就是将实际参数的副本传入方法内，而参数本身不会受到任何影响。

<!-- more -->

### 基本数据类型

对于基本数据类型的参数传递是值传值。

```
public static void main(String[] args) {
    int a = 9;
    int b = 6;
    swap(a, b);
    System.out.println("a " + a + " b is " + b);
}
private static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("after swap a " + a + " b is " + b);
}
```

打印日志：
```
after swap a 6 b is 9
origin data a 9 b is 6
```




main() 方法中调用 swap()，系统为 两方法分别创建方法栈区，将 a、b 传入 swap() 中，实际是在 swap 方法栈中重新产生了两个变量a、b(main 方法将传入实战其实就是对 swap 方法栈的 a、b 形参进行初始化)，此时系统中存在两个 a、b，只是它们存在的方法栈不同。


![](/../images/2019_08_01_01.png)


在 swap 方法栈中交换 a、b 的值，此过程只改变了本栈中的变量，没有对 main 方法栈中的 a、b 变量产生影响，即形参改变不会对实参造成影响。

![](/../images/2019_08_02_01.png)

### 引用数据类型的值传递

对于引用数据类型的参数传递同样是值传递。


但是为什么在前文描述中，出现了形参的改变从而导致了实参的变化？

其实这是自己当时对引用对象的值传值认识错误而引起的。


与基本数据类型不同的是：基本数据类型作为参数时传入的为实参值本身，而引用数据类型传入的为对象的一个引用(即：对象内存的其实地址)，而不是真实的对象。


```
DataDraw dw = new DataDraw();
swap(dw);
```

在 main 中真实的创建对象

![](/../images/2019_08_02_02.png)

将引用传给 swap

![](/../images/2019_08_02_03.png)


在 swap 中对形参进行相应更改:

![](/../images/2019_08_02_03.png)


引用数据类型的值传递是指 **对象引用的传递(内存地址的传递)**，那么对该引用的操作最终都会映射到 Java 堆中的真实对象，那么在 swap 方法栈对形参所做的变更在 main 方法中 实参 同样会发生变更。



---

**形参和实参**

形参变量：方法中声明中的变量
实参变量：调用方法传递给形参的变量
