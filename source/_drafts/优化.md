---
title: 优化
tags:
---
 ## 1


 大多数用户感知到的卡顿等性能问题的最主要根源都是因为 **渲染性能**。


 用户容易在UI执行动画或者滑动ListView的时候感知到卡顿不流畅，是因为这里的操作相对复杂，容易发生 **丢帧** 的现象，从而感觉 **卡顿**。
 
 有很多原因可以导致丢帧：
1. 也许是因为你的layout太过复杂，无法在16ms内完成渲染，
2. 有可能是因为你的UI上有层叠太多的绘制单元，
3. 还有可能是因为动画执行的次数过多。

这些都会导致CPU或者GPU负载过重。

**卡顿本质原因： CPU 或者 GPU 负载过重，导致无法在 16ms 内完成绘制工作**



## 卡顿原因

### 1. 过度渲染

**什么是过度绘制以及导致问题**

Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被 **绘制了多次**。

在多层次的UI结构里面，如果不可见的 UI 也在做绘制的操作，这就会导致某些像素区域 **被绘制了多次**，这就浪费大量的CPU以及GPU资源，从而造成卡顿。


**过度绘制原因：**

Overdraw 有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。

**过度渲染检测工具：Show GPU Overdraw**

不同的颜色，表示不同的过度绘制层级，减少过度绘制区域。

**过度绘制解决：**

Overdraw 有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。移除非必需的背景图片，可以大幅提升程序的性能。

使得布局尽量扁平化，移除非必需的UI组件，这些操作能够减少Measure，Layout的计算时间


### 2. 频繁 GC 

频繁 GC 导致的卡顿问题：不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。

**检测频繁 GC 工具**

Memory Profiler

**如何避免频繁 GC**


1. 避免在for循环里面分配对象占用内存
2. 自定义 View中的 onDraw 方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw 方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象
3. 对于那些无法避免需要创建对象的情况，我们可以考虑 **对象池** 模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象



**卡顿检测工具**

1. 手机开发者选项：Show GPU Overdraw，查看手机页面渲染时间

2. 使用 TraceView 或者 AS CPU profiler 观察 CPU 的执行情况，更加快捷的找到性能瓶颈。

**卡顿解决**


## 检测每帧绘制的时间

开发者选项开启 **Profile GPU Rendering**，界面分别显示关于StatusBar，NavBar，激活的程序 Activity 区域的 GPU Rending信息。

柱状图来表示每帧画面所需要渲染的时间。