---
title: '数据结构与算法:树与二叉树(五):哈夫曼树以及哈弗曼编码'
tags:
---



## 相关概念


**节点之间的路径长度**

![](/source/images/2019_12_19_01.png)

从一个节点到另外一个节点之间的 **分支数量** 称为两个节点间的路径长度。

**树的路径长度**

从根节点到树中每一个节点的路径长度之和。

**节点的带权路径长度**

![](/source/images/2019_12_19_02.png)

从该节点到根节点的路径长度与节点上的权的乘积。


**树的带权路径长度**

树中所有叶子节点的带权路径长度。

带权路径最小的二叉树被称为哈夫曼树或者最优二叉树。

## 哈弗曼树概述

哈弗曼树称为最优二叉树，是一类 **带权路径最短** 的二叉树。

对于哈弗曼树，有一个重要的定理：**对于有 n 个叶子节点的哈弗曼树，一共需要 2*n-1 个节点。**对于二叉树而言，共有 3 中类型的节点：度分别为 2、1、0 的节点，而哈夫曼的非叶子节点都是由两个节点合并产生，所以不会出现度为 1 的节点。

非叶子节点的个数 = 叶子节点的个数 - 1

所以哈夫曼由以上定理。


## 创建哈夫曼树

1. 给定 n 个权值不同的节点集合，此时的每个节点可以称为只有一个根结点的树。
2. 选取节点集合中两个权值最小的阶段，分别作为左、右子树构建一棵树（一般左节点权值小于右结点区权值），且新树的根结点的权值设为左右子树根节点的权值之和，并将两个节点在节点集合中删除。
3. 选取节点集合中最小的节点，合并到构建的数上，并将该节点从节点集合中删除。
4. 重复 （3） 步，直到节点集合为空，构建成功的数就为哈夫曼树。


![](/source/images/2019_12_19_03.png)



## 哈夫曼编码

依据哈夫曼树可以进行报文的编码，将字符串进行编码转换为唯一的二进制码，使用哈夫曼编码转换出来的 **二进制长度最小**。

对 `abcdabcaba` 进行哈夫曼编码，字符串中共有 a、b、c、四个字符，出现的频率分别为 4、3、2、1，已出现的次数为权值构造哈弗曼树，如下：


![](/source/images/2019_12_19_04.png)

为哈夫曼树分配代码，左子树为 0，右子树为 1，如下图：


![](/source/images/2019_12_19_04.png)


每个字符的编码为根结点到相应叶子节点的代码的排列，所以各个字符的哈夫曼编码如下：

a:0
b:10
c:110
d:111

那么对于字符串的编码为：0101101110101100100，长度为 19，为该字符串的最短编码，称为哈夫曼编码。

哈夫曼编码的规律：

假设有 n 个叶子节点需要编码，最终得到的哈夫曼树一定有 n 层，哈夫曼编码得到的字符最大长度为 n -1。

