---
title: '数据结构与算法(二):栈和队列'
tags:
---


## 栈和队列基本概述


栈和队列都是一种功能弱化的线性表，比普通的线性表功能相对弱一点，栈和队列的存取元素位置都是有限制的。

## 栈

只能在固定一端(通常认为是线性表的尾端)进行插入和删除的线性表。

![](/source/images/2019_12_16_01.png)

栈的插入和删除操作如上图所示，可见**栈是一种后进先出(LIFO)的线程表**。


## 栈的顺序存储结构及实现


顺序存储结构的栈称为顺序栈，利用一组地址连续的存储单元一次存放从栈底到栈顶的元素。

顺序栈可以通过数组来实现。


## 栈的链式存储结构及实现

同时可以采用单链表来保存栈中所有的元素，这种链式结构的栈称为链栈。

实现方式：

使用 top 引用来记录当前栈的栈顶元素，出栈和入栈只要改变 top 引用指向的对象即可。


## Java 集合中的栈

Java 集合提供了栈供开发者使用，有以下两种：

1. Stack

    * 顺序栈，底层由数组实现，
    * 线程安全。

2. LinkedList

    * LinkedList 是一个双向链表，但是 API 同时提供了 push、pop、peek 等方法，所以可以将 LinkedList 当做栈来使用。
    * 线程不安全，可以使用 Collections 工具类改造为线程安全的类。



## 队列

队列也是一种被限制的线性表，只能使用固定的一端插入数据，另一端用来删除数据，所以队列中元素的移动方式总是固定的，先入先出(FIFO)。

插入数据的一端称为队尾，删除数据的一端称为队头。

![](/source/images/2019_12_16_02.png)


## 队列的顺序存储结构及实现

使用一系列地址连续的存储单元依次存放从队头到队尾间的所有元素，程序只需要通过两个变量记录队头和队尾两个元素的 **索引值**：front(队头)、rear(队尾)，队列中元素的个数为 rear-front

### 顺序队列

对于顺序队列来说，队列底层采用数组来保存队列元素，当新元素进入队列中，rear 的值加一，而当队列移除元素时，front 的值加一。

但是对于顺序队列存在队列假满的情况，假满情况：
* 队列元素已满，数量为 5，此时 front = 0，rear = 5；
* 移除队列中所有元素，此时 rear = 5，front = 5，队列为空，但是由于此时 rear 无法增加，所以此时队列无法添加数据，造成假满的情况。

解决办法：

每次移除数据后，重新搬移队列中元素，使 front 恒为 0.


###  循环队列

将顺序队列改为循环队列，可以避免假满现象。


![](/source/images/2019_12_16_03.png)


循环队列是首尾相连的队列：当 front、rear 变量达到底层数组的 `capactiy -1` 后，再前进一位自动变为 0。


在循环队列中，front == rear 时：

* 如果底层数组 elements[front] == null，表明队列为空
* 否则，表明队列已满


## 队列的链式存储结构以及实现


同时可以使用链式结构来存储队列的各个元素，被称为链队列。

链队列中维护 front、rear 两个变量，分别指向链对列的头节点和尾节点。

* 插入队列
  * rear 的 next 引用指向新节点
  * rear 指向新节点
  
* 移除队列

    * front 指向 front 的 next 引用
    * 释放原 front 节点引用

## JDK 集合中的队列

* Queue 接口，代表队列，实现类可以当做队列使用

实现类有：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、PriorityQueue、ConcurrentLinkedQueue、SynchronousQueue



ArrayBlockingQueue(顺序队列)、LinkedBlockingQueue(链对列)、ConcurrentLinkedQueue(其他种类的队列，基于先进的、无等等队列算法) 为线程安全的队列



## 双向队列

双向连接可以在队列的两端进行添加、删除操作，如果限制在一端操作元素，那么就变成了栈这种数据结构。

JDK 提供了 Deque 来表示这种双向的队列。



Lin

 


