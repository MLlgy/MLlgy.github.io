---
title: 加密的简单了解
tags:
---


`PKCS8EncodedKeySpec(byte[] encodedKey)`

 根据给定的编码密钥创建一个新的 PKCS8EncodedKeySpec。


----

[JAVA——RSA加密【X509EncodedKeySpec、PKCS8EncodedKeySpec、RSAPublicKeySpec、RSAPrivateKeySpec】](https://blog.csdn.net/weixin_43272781/article/details/103995547)



Java 密钥工厂 - KeyFactory，可以使用该类使用指定的方法(DH、DSA、EC、RSA、X.509)进行加密。

密钥工厂是双向的，给定密钥规范可以构建不透明的密钥对象，或者以特定的格式恢复密钥对象的密钥规范。同一密钥可能存在多个兼容密钥规范。 例如，可以使用DSAPublicKeySpec或X509EncodedKeySpec指定DSA公共密钥。 密钥工厂可用于在兼容的密钥规范之间进行转换。

[KeyFactory](https://developer.android.google.cn/reference/kotlin/java/security/KeyFactory?hl=zh-cn)

以下是如何使用密钥工厂以从其编码实例化DSA公共密钥的示例。假设爱丽丝已收到鲍勃的数字签名。Bob还向她发送了他的公共密钥（以编码格式）以验证他的签名。然后，爱丽丝执行以下操作：

以下示例展示通过密钥工厂使用 DSA 的支持的变编码格式初始化 DSA 公钥。假设 Alice 收到了 Bob 的数字签名以及用来验证签名的公钥，那么 Alice 需要做如下处理：

```
// 为的编码密钥创建一个新的 X509EncodedKeySpec，bobEncodedPubKey：Bob 给定的编码公钥
X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);
// 获得相应加密算法的 KeyFactory 实例对象
KeyFactory keyFactory = KeyFactory.getInstance("DSA");
// 根据给定编码对象，获得相应的公钥实例对象
PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);
// 返回实现指定签名算法的Signature对象
Signature sig = Signature.getInstance("DSA");
// 初始化此对象以进行验证。如果使用不同的参数再次调用此方法，则该调用的效果无效。
sig.initVerify(bobPubKey);
// data: 原数据(经过 Bob 私钥加密后的数据)，更新数据签名或者进行验证
sig.update(data);
// signature：需要验证的签名，验证签名，如果返回 true，说明验证签名通过
sig.verify(signature);
// 或者进行如下操作，获得签名
byte[] signed = signature.sign(); 
```


---

### URLEncoder、URLDecoder

主要用来http get请求不能传输中文参数问题。http请求是不接受中文参数的。这就需要发送方，将中文参数encode，接收方将参数decode，这样接收方就能收到准确的原始字符串了。


1. URLEncoder.encode(String s, String enc) 

使用指定的编码机制将字符串转换为 application/x-www-form-urlencoded 格式 

URLDecoder.decode(String s, String enc) 
使用指定的编码机制对 application/x-www-form-urlencoded 字符串解码。 

2. 发送的时候使用URLEncoder.encode编码，接收的时候使用URLDecoder.decode解码，都按指定的编码格式进行编码、解码，可以保证不会出现乱码
