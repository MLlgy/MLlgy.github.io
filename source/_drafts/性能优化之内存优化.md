---
title: 内存优化
tags:
---




## 调查 RAM 使用情况

这一部分是 Android Developer 关于如何查看 RAM 情况的文档，在这里抽出其大概，阐述获取 RAM 的基本方法，具体细节可以查看 [调查 RAM 使用情况](https://developer.android.google.cn/studio/profile/investigate-ram)。

### **1. 解读日志信息**

AS 集成的日志打印系统，可以显示应用在运行期间的日志信息，所以在 **发生垃圾回收** 时，可以通过 logcat 日志获取相应的信息。

根据 Android 虚拟机的不同，Logcat 的信息分为 Dalvik 日志信息、ART 日志信息，具体查看以上链接。根据相应的日志信息可以获得垃圾回收原因、内存释放量、堆容量等。


### **2. 访问 Android Monitor**

打开 AS 编辑器中的 Android Monitor，进入 Memory 监视器可以查看应用内存情况。


#### 2.1 捕获堆转储

**堆转储是应用堆中所有对象的快照**，为后缀名为 .hrof 的二进制文件，包含应用堆整体状态的相关信息，以便您能够跟踪在 查看堆更新 时发现的问题。可以通过分析工具分析信息。在监视面板，可以获得应用的堆转储文件，也可以打开其他堆转储文件。

#### 2.2 查看堆更新

在监视器面板，可以 **实时查看应用堆内存的变化状况**，可以查看 Free 和 Alloated 内存，也可以手动触发 GC 已查看此时应用内存的变化。


怎么使用该面板：**对应用进行相关操作、交互，然后启动垃圾回收，观察每次垃圾回收的堆分配更新，确定应用中哪些操作导致过多分配，以及可以从何处减少分配和释放资源**。

#### 2.3 分析堆转储文件

1. 文件转换。

使用 ANDROID_SDK/platform-tools/ 目录中提供的 hprof-conv 工具，

```
hprof-conv heap-original.hprof heap-converted.hprof
```

2. 文件分析

使用相关工具，对转换后的文件进行分析。分析期间，请注意由下列任意情况引起的内存泄漏：

* 长时间引用 Activity、Context、View、Drawable 和其他对象，可能会保持对 Activity 或 Context 容器的引用。
* 可以保持 Activity 实例的非静态内部类，如 Runnable。
* 对象保持时间比所需时间长的缓存。


#### 2.4 跟踪内存分配

跟踪内存分配可以**更好地了解分配占用内存的对象的位置**。使用分配跟踪器查看特定的内存使用以及分析应用中的关键代码路径，如滚动。

一个场景：

在应用中滑动列表时跟踪分配。跟踪内存分配可以滑动列表所需的所有内存分配，**内存分配位于哪些线程上**，以及 **内存分配来自何处**。此类信息可以帮助简化执行路径以减少执行的工作，从而改进应用的整体操作及其界面。


相应步骤：

1. 在控制面板，点击 Allocation Tracker 按钮，开启内存分配跟踪；
2. 对关注点页面进行相关操作；
3. 再次点击 Allocation Tracker 按钮，停止跟踪内存分配；

此操作会生成 `application-id_yyyy.mm.dd_hh.mm.alloc` 文件，可以在 AS 中打开，在该文件中可以确定引起内存过多分配的操作，以及在何处进行操作尝试减少内存分配和释放资源。



### **3. 查看整体内存分配**

可以使用  adb 命令观察应用内存在不同类型的 RAM 分配之间的划分情况：

```
adb shell dumpsys meminfo <package_name|pid> [-d]
```

该命令输出当前应用的所有内存分配，单位为 KB。

需要关注的指标：Private Dirty RAM、Private Clean RAM、PSS 等，具体含义可以查看链接文档。

----





### 什么是内存泄漏

关于这个问题，我们都有自己的回答，我们看一下 Square 工程师在[LeakCanary: Detect all memory leaks!](https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745) 中怎样阐述这个问题
:

```
Some objects have a limited lifetime. When their job is done, they are expected to be garbage collected. If a chain of references holds an object in memory after the end of its expected lifetime, this creates a memory leak. When these leaks accumulate, the app runs out of memory.
```

一些对象的声明周期是有限的。当它们不再被使用时，它们就应该被 GC 回收。但是当该对象结束它的生命周期后，另外一个对象的引用链引用了该对象，这就导致了内存泄漏。当泄漏的内存达到一定程度时，App 就会 OOM。



### 



----

[Square 工程师怎么阐述这个问题](https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745)


[Java 引用关系](https://letcheng.github.io/2016/05/24/java-ref-type.html)

[9 ways to avoid memory leaks in Android](https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e)


[使用Profiler来查看内存泄漏](https://mp.weixin.qq.com/s/_CO7uHm-rn4-LNknOeHPzA)


[用弱引用堵住内存泄漏](https://www.ibm.com/developerworks/cn/java/j-jtp11225/index.html)

[Android内存优化杂谈](https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg)



