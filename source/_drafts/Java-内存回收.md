---
title: Java 内存回收
tags:
---


Java 引用 与 内存回收关系

Java 对象在内存中的不同状态

软引用使用和使用注意
弱引用
虚引用


Java 内存泄漏的原因

Java 垃圾回收机制的基本算法

堆内存的分代回收




JVM 何时决定回收一个 Java 对象所占据的内存？
JVM 会不会漏掉回收某些 Java 对象，使之造成内存泄漏？
JVM 回收 Java 对象所占用内存的实现细节。
JVM 能否对不同 Java 对象占用的内存区别对待、回收？
常见垃圾回收机制的实现细节。


## 1.  Java 引用类型


在 Java 中通过 new 关键字创建 Java 对象，为 Java 对象申请内存空间，JVM 会在堆内存为每一个对象分配空间；当 Java 对象失去引用时，JVM 的垃圾回收机制会自动清除它们，回收它们占用的内存空间。


Java 内存管理分为内存分配和内存回收两方面。

### 1.1 对象在内存中的状态


对于 JVM 垃圾回收机制来说，能否回收一个对象的标准：是否还有引用变量引用该对象？

当 Java 对象被创建出来后，JVM 会实时监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值。


在 JVM 内存中，可以有以下类比：

* 对象引用：有向图
* 引用变量、对象：有向图的顶点
* 引用关系：有向图的有向边

有向边总是从引用端指向被引用的 Java 对象，由于 Java 对象是在线程中创建出来的，因此可以吧线程对象当成有向图的起始顶点。


```
public main(){
    Node node = new Node();
    Node node2 = new Node();
    Node node3 = new Node();
    node.next = node2;
    node3 = node2;
    node2 = null;
}
```

Java 对象在内存中的状态：

* 可达状态
* 可恢复状态
* 不可达状态

一个对象 A 能够被以下变量引用：

* 被方法的局部变量引用
* 被其他类(B)的类变量引用

只有该类(B) 被销毁后，该对象(A) 才会进入可恢复状态。

* 被其他类(C)的实例变量引用

只有当该类(C)的对象被销毁或者处于不可达状态后，该对象(A)才会进入不可达状态。

前文说，对于 JVM 垃圾回收机制来说，能否回收一个对象的标准：是否还有引用变量引用该对象？所以引用是 JVM 进行内存管理的一个重要概念，为了更好的管理对象的引用，在 Java1.2 后，java.lang.ref包下提供了3个类：SoftReference 、PhantomReference 和 WeakReference，分别代表系统对对象的三种引用方式：软引用、虚引用、弱引用。


### 1.2 强引用


通过 new 创建一个对象，并把这个对象赋值给一个引用变量，这个引用变量就是强引用。


JVM 不会回收强引用所引用的 Java 对象，因此强引用是造成 Java 内存泄漏的主要原因之一。


### 1.3 软引用

软引用通过 SoftReference 来实现。

当一个对象只具有软引用时，它有可能被垃圾回收机制回收。

对于只有软引用的对象而言，回收分为两种情况：

1. 当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；
2. 当系统内存空间不足时，系统将会回收它。

软引用通常用于内存敏感的程序中，对强引用是一个很好的替代。当程序需要大量创建某个类的新对象，而且 **有可能重新访问已创建老对象时**，可以充分使用软引用来解决内存紧张。

关于软引用的使用，可以查看 疯狂 Java 讲义。

### 1.4 弱引用

弱引用通过 WeakReference 来实现。

弱引用和软引用相似，区别是弱引用所引用对象的生存期更短。


对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，在执行  GC 时，总会回收该对象所占用的内存。


与 WeakReference 功能类似的还有 WeakHashMap。其实程序很少会考虑直接使用单个的 WeakReference 来引用某个Java对象，因此这种时候系统内存往往不会特别紧张。当程序有大量的Java对象需要使用弱引用来引用时，可以考虑使用 WeakHashMap 来保存它们。

在垃圾回收机制运行之前，WeakHashMap的功能与普通HashMap并没有太大的区别，它们的功能完全相似。但一旦垃圾回收机制被执行，WeakHashMap中所有key-value对都会被清空，除非某些key还有强引用在引用它们。


### 1.5 虚引用

虚引用通过 PhantomReference 来实现。

软引用和弱引用可以单独使用，但是虚引用不可以，单独使用没有任何意义。

虚引用必须和引用队列一起使用，虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查 **与虚引用关联的引用队列中是否已经包含指定的虚引用**，从而了解虚引用所引用对象是否即将被回收。

同时也可以把软引用、弱引用和引用队列联合使用时，系统回收被引用的对象之后，将会把被回收对象对应的引用添加到关联的引用队列中。


### 1.6 使用注意


要使用这些特殊的引用类，**就不能保留对对象的强引用**。如果保留了对对象的强引用，就会浪费这些类所提供的任何好处。


### 2. 内存泄漏


* 什么是内存泄漏？

程序在运行过程中，不再使用的内存空间应该回收它们，从而保证系统能够再次使用这些内存空间，如果无用的内存不能得到有效的回收，那就是内存泄漏。

### 3. 垃圾回收机制


垃圾回收机制主要完成了两个事情：


1. 跟踪并监控每个 Java 对象，当某个对象处于不可达状态时，回收该对象占用的内存空间；
2. 清理内存分配、回收过程中产生的内存碎片。

而垃圾回收机制的这两方面工作的工作量其实都不是很大，那么影响 Java 运行效率的因素为：垃圾回收算法。

#### 3.1 垃圾回收的基本算法


对于一个垃圾回收器的算法，有以下选择：


* 串行回收和并行回收
* 并发执行和应用程序停止
* 压缩和不压缩和复制

 复制：


复制是将堆内存分为两个相同的空间，从根开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收空间A

复制算法遍历空间成本小，但是复制成本大。


* 有关标记清除算法：


不压缩的回收方式，从根开始访问所有的可达对象，将它们标记为可达状态，然后在遍历一次整个内存空间，把没有标记的对象回收清理。


无需进行大规模的复制，需要两次遍历，遍历成本大，不连续回收内存空间，产生大量的内存碎片。


* 有关标记压缩算法：


压缩方式，利用以上两种算法的优点。垃圾回收期从根访问所有的可达对象，将它们标记为可达状态，接下来垃圾回收器会将这些可达对象搬移到一起，称为 **内存压缩**，然后垃圾回收器回收不可达对象，避免产生内存碎片。


现行的垃圾回收器用分代的方式来采用不同的回收设计，根据对象的生存时间长短，将堆内存分为以下3个代：

* Young：年轻代
* Old：年老代
* Permanent：永久代


垃圾回收器根据不同代的特点，使用不同的垃圾回收算法，充分利用不同回收算法的优点。

#### 3.2 堆内存的分代回收



