---
title: 'Dagger2 前奏篇:依赖注入概念'
date: 2019-01-17 14:57:56
tags: [Dagger2,DI]
---


## 一、What is Dagger2 ?
 [Dagger2](https://github.com/google/dagger) 是一个谷歌开源的依赖注入(`Dependency Injection`)框架，简称`DI`。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 **2** 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。
 那么 **什么是 `依赖注入`** 呢？
 ### 1.1 何为依赖注入（控制反转 -- IOC（Inversion of Control））
 
我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：
1. 在一个类的具体业务逻辑中，需要另一个类的实例进行相应的操作时，在传统的设计中，通常由调用者来创建被调用者的实例（一般的，我们通过 new 的方式创建），然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由 `IOC 容器` 来完成，然后`注入`到调用者。因此也被称为 **`依赖注入`**。
2.  **`依赖注入`** 就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，`解决了各个类之间的耦合`。那么这个外部，到底指的是哪里，如果指的是另一个类，那么，另一个类内部就耦合了,这种拆东墙补西墙的做法我们是不推荐的。能不能有一种方式，将这些构造的对象放到一个容器中，具体需要哪个实例时，就从这个容器中取就行了。那么，类的实例和使用就不在有联系了，而是通过一个容器将他们联系起来。实现了解耦。

个人理解：**控制反转** ,把自己新建实例对象的权利由交给了第三方工具或容器。
目标类将创建其他实例类的权利交给了第三方工具，也就是说，原来需要程序员把自主在目标类通过 new 的方式创建相关类的实例的权利，交给具体的业务（所谓的 IOC 容器） ，该容器在需要的时候通过它自己的方式创建该类的实例，即：`创建类实例权利的移交`。


## 1.2 依赖注入的好处
`依赖注入`就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，`解决了各个类之间的耦合`。

通俗一点讲：将该对象的实例化交给其调用者，通过某种方式传入进来，这种模式就是依赖注入。常见的降低耦合的方式： 
- 构造方法注入。 
- Setter方式注入。 
- 接口注入。

<!--more-->

## 二、Why Dagger2
Dagger2 的原理是在`编译期生成相应的依赖注入代码`。这也是和其他依赖注入框架不同的地方，其他框架是在运行时期反射获取注解内容，影响了运行效率。

**栗子**
```
public class MainClass {
    private  void main(String [] args){
        John john = new John("john",12);
        john.introduceSelf();
    }
}
```

上面例子面临着一个问题，一旦 `John` 的创建方式（如构造参数）发生改变，那么你不但需要修改 `MainClass` 中创建`John`的代码，还要修改其他所有地方创建 `John` 的代码。如果我们使用了` Dagger2` 的话，就不需要管这些了，只需要在需要`John`的地方写下：
```
@Inject
John john;
```


### 知识链接

[Dagger 详解](https://www.jianshu.com/p/269c3f70ec1e)、
[这就是Dagger2](http://www.qingpingshan.com/rjbc/az/170191.html)、
[Dagger2 入门实践](https://juejin.im/entry/589bd2cf8d6d8100585fd86c)、
[最简单的Dagger2入门教程](https://blog.csdn.net/lisdye2/article/details/51942511)、
[Android：dagger2让你爱不释手-终结篇](https://www.jianshu.com/p/65737ac39c44)