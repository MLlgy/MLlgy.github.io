---
title: 图解 HTTP 学习笔记(二)：简单了解 HTTP
date: 2019-12-10 11:09:44
tags: [网络协议,图解 HTTP,读书笔记]
---



### 1. HTTP 协用于客户端和服务端之间的通信

**HTTP 协议能够区分哪一端是客户端，哪一端是服务端。**

### 2. 通过请求和响应的交换达成通信

肯定是客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。

#### 请求报文

```
GET /index.html HTTP/1.1
Host: abc.jp
```
<!-- more -->
这段请求的内容的意思是：请求访问某台 HTTP 服务器上的 /index.html 页面资源。

请求报文是由请求方法(GET)、请求 URI(上文中的 index.html)、协议版本HTTP/1.1)、可选的请求首部字段和内容实体构成。

![dns.jpg](/source/images/2019_12_09_04.jpg)

#### 响应报文


### 3. HTTP 是不保存状态的协议

无状态的协议

HTTP 协自身不对请求和响应之间的通信状态进行保存。**协议本身不保留之前一切的请求或者响应报文的信息**，为的是更快的处理大量事务，确保协议的可伸缩性，这就是为什么把 HTTP 协议设计如此简单的原因。

为了实现保存状态的功能，引入了 Cookie 技术。

### 4. 请求 URI 定位资源

Uniform Resource identies

HTTP 协议通过 URI 定位互联网上的资源，正是因为 URI 的特定功能，所以在互联网上的任意资源都是可以访问的到的。

当客户端访问网络资源发起请求时，URI 将作为请求报文包含在其中。


### 5. 持久连接节省通信量

在 HTTP 的初始版本时，每进行一次 HTTP 通信就要经过 TCP 连接、TCP 断开操作，客户端和服务端在频繁的交互过程中，会产生大量无谓的 TCP 连接和断开，增大了通信量。


#### 持久连接

在 HTTP1.1 版本中，通过引入持久连接的概念，解决了上述问题，在 HTTP 中表现为 HTTP 首部字段 keep-alive 为 true，并且在 HTTP1.1 版本中，more所有的连接都是持久连接。

持久连接的特点就是没有明确提出断开连接，则会保持 TCP 连接。


持久化连接，减少了 TCP 连接的重复建立和断开，减少了额外的开销，减轻了服务器的负载。

#### 管道化

HTTP/2 支持管道化，不过自己还没有使用过 HTTP/2，故在此不详述，在使用时再学习。


### 6. 使用 Cookie 进行状态该管理


HTTP 是无状态协议，即不会对之前发生的请求和响应进行状态管理，所以无法实现根据之前的状态进行本次请求的处理。

所以就会存在这样一个场景：需要登录验证的页面，需要在每次跳转都需要进行登录，当然这是很不合理的。

基于 HTTP 的无状态连接，引入了 Cookie 技术，该技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

具体流程：


* 如果服务端的响应报文中存在 Set-Cookie 的首部字段，那么 Cookie 就会通过客户端保存 cookie。
* 如果客户端再向服务端发送请求，那么就会自动在请求报文中添加 Cookie值，然后发送出去。
* 服务端发现客户端发送的 Cookie 后，就会查明是哪一个客户端发来的连接请求，然后在服务器中进行对比，**得到之前的状态**。



1. 请求报文（此时的请求报文没有 Cookie 信息）
```
GET /show/ HTTP/1.1
Host: baidu.com
```
2. 响应报文(服务端生成 Cookie 信息)

```
HTTP/1.1 200 OK
Date:xxx
Server:Ngix
<Set-Cookie: sid=24143434334;path=/;expires=Wed 10-Oct-12 07:12:20 GMT>
Content-Type:text/plain;charset=UTF-8
```

3. 请求报文(自动填充 Cookie 信息)

```
GET /getImage/ HTTP1.1
Host:baidu.com
Cookie:sid=24143434334
```
