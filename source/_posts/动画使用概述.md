---
title: 动画使用概述
date: 2019-07-03 11:28:57
tags:
---



## 视图动画

View动画， 从名字上我们也可以看出，此动画只能对派生自 View 的控件实例起作用，它改变的只是控件的显示位置，但是并没有更改控件本身的值。

View 动画其实是通过其 Parent View 实现的，在 View 被绘制时 Parent View 改变它的绘制参数，这样虽然 View 的大小或位置改变，但是却没有改变 View 本身的值。


### 缺点







## 属性动画

属性动画，从名字上来看，此动画针对于控件的某个属性做动画。

属性动画和 View 动画只能作用于 View 不同，它可以对任何对象做动画效果。要想对一个对使用属性动画，那么这个对象必须满足以下两个条件：

1. 对象作动画的属性有 set 和 get 方法，如果对象没有可以考虑使用包装为对象添加 set get 方法，比如一些 view 就没有这两个方法，我们可以自己实现。
2. 对象属性的变化必须通过某种形式表现出来，比如 UI 的变化。


### ViewPropertyAnimator

 view.animate().xxx；
 
### ValueAnimator

属性动画的核心所在，其本身不提供任何动画效果，它更像一个数值发生器，产生具有一定规律的数字，调用者使用数字控制动画的实现。


#### 使用 ofObject

我们看一下 ValueAnimator#ofObject 的 API：
```
public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values);  
```

当我们使用 ofObject 时，我们需要同时传入 自定义估值器 和 相应的值，至于为什么要传入 自定义估值器，因为不像其他 API 有默认的 估值器，通过传入的指的类型使用相应的估值器进行计算相应的值（Int-IntEvalutor,Float-FloatEvalutor等）,如果我们在这里不传入自定义估值器，那么将不知道如果计算值。


 ## 插值器(TimeInterpolator)和估值器(TypeEvaluator)
 
插值器 ：根据时间流逝的百分比计算属性值改变的百分比。
 
 类型估值算法: 根据当前属性改变的百分比(此值由时间插值器获得)来计算改变后的属性值.
 
 
 属性动画的默认插值器和估值器分别为 LinearInterpolator 和 IntEvaluator。两者协同工作共同完成动画：
 
 使用插值器根据时间流逝的百分比获得属性改变的百分比，然后使用估值器根据得到属性改变的百分比计算改变后的属性值。
 
 
 ### 自定义插值器
 
 自定义插值器需要继承 TimeInterpolator，实现 getInterpolation(float intput) 方法:
 
 ```
 class CustomeInterplotor : TimeInterpolator {
    override fun getInterpolation(input: Float): Float = 1 - input
}
```
其中 getInterpolation 的参数 input 为时间流逝的百分比，其值只与时间的流逝有关，方法的返回值表示动画的当前属性的改变比例。

 ### 自定义估值器
 
 自定义估值器需要继承 TypeEvalutor ,实现 evaluate(...) 方法：
 
```
 class CustomTypeEvalutor : TypeEvaluator<Float> {
    override fun evaluate(fraction: Float, startValue: Float, endValue: Float): Float
            = (startValue + (endValue - startValue) * fraction)
}
```

不过我们需要注意的是 TypeEvaluator evaluate方法的 startValue、endValue、返回值类型要与 ofInt()、ofFloat 对应，否则就会在计算具体的属性值时出现转型错误。


### ValueAnimator、TimeInterpolator 与 TypeEvaluator

知道了时间插值器和类型估值器，现在在来理解一下属性动画的整体流程：

 
![动画流程图](/../images/2019_07_03_03.png)


#### ObjectAnimator

ValueAnimator 不产生动画，它只是产生一系列的数字，通过控制数字来控制动画，谷歌派生出 ObjectAnimator 类，来直接对控件实现动画。

在 ValueAnimator 中我们通过流程图的方式来具体理解动画的流程，同样我们通过流程图来认识 ObjectAnimator 的动画流程：

![动画流程图](/../images/2019_07_03_02.png)


根据时间插值器和类型估值器最终得到变化后的属性值，此时根据属性拼装成最终的 set 函数的名字，如 setAlpha、setRorate 等，通过反射找到控件的 setXXX 函数，并把最终的计算值作为参数传递到相应的 setXXX 函数中。

ObjectAnimator 的作用只是把计算后的数值传递到 set 方法中，至于之后的操作 ObjectAnimator 将不能作用。要想控件产生 移动、平移、旋转、透明度变换等操作，还需要在 set 方法中进行相应的绘制。

根据以上描述不难发现，ObjectAnimator 的目标控件必须有 set 方法(要想获得控件的值还需要有 get 方法)，而且 set 方法中必须可以操作(绘制)控件进行相应的变换，两者缺一不可。



#### PropertyValuesHolder

PropertyValuesHolder 这个类保存了动画过程中所需要操作的属性和对应的值。

ObjectAnimator 的 ofInt() 实现函数构造，它的内部其实是将传进来的参数封装成 PropertyValuesHolder 实例来保存动画状态，所以说 PropertyValuesHolder 对整个动画实现上的地位是举足轻重的。


看一下 PropertyValuesHolder相关的的两个比较重要的方法：


```
public static PropertyValuesHolder ofFloat(String propertyName, float... values)  

public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values)

```

上面说到 ObjectAnimator 是在内部实现了 PropertyValuesHolder ，那么我们通过一个方法对比一下两者：


```
public static ObjectAnimator ofFloat(Object target, String propertyName, float... values);
```

对比两者方法的参数： target -- target、propertyName -- propertyName、values -- values,可以看出 ObjectAnimator 中的方法是 PropertyValuesHolder 对应两方法的集合，也证明了 ObjectAnimator 是在内部实现了 PropertyValuesHolder 来完成动画的控制。

通过以下代码实现来理解以上内容：


```
val rotation = PropertyValuesHolder.ofFloat("Rotation",0f,90f,150f,-100f,0f)
val color = PropertyValuesHolder.ofInt("BackgroundColor", 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff)
val objectAnimator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotation, color)
objectAnimator.duration = 1000
objectAnimator.start()
```

ObjectAnimator.ofPropertyValuesHolder 可以实现多个属性的动画同时进行。

##### PropertyValuesHolder  的 ofObject 方法

如果 ValueAnimator 的 ofObject 一样，我们可以从方法名可以推测动画实现的操作对象为一个 Object 对象，那么这样的话我们还需要自定义属于该对象的 TypeEvalutor ，来计算对象改变后的值。

```
val change = PropertyValuesHolder.ofObject("CharText", CharEvalutor(), 'A', 'Z')
val animator = ObjectAnimator.ofPropertyValuesHolder(myTextView, change)
animator.duration = 2000
animator.interpolator = AccelerateInterpolator()
animator.start()

```
在此例中，调用 ofObject 方法操作的 'A'、'Z' 为 Char 类型，所以针对 Char 自定义类型估值器：
```
class CharEvalutor : TypeEvaluator<Char> {
    override fun evaluate(fraction: Float, startValue: Char?, endValue: Char?): Char {
        val start = startValue?.toInt()
        val end = endValue?.toInt()
        val current = (start!! + fraction * (end!! - start)).toInt()
        return current.toChar()
    }
}
```
在 ObjectAnimator.ofPropertyValuesHolder() 方法中传入操作的控件和PropertyValuesHolder 属性，到此动画定义的大部分工作已经完成。如上面的例子可见，我们通过控件 myTextView 的 setCharText 方法将值传递给相应控件，这就是 PropertyValuesHolder 的 ofObject 的用法，其实和 ValueAnimator 的 ofObject 的用法大同小异。


### KeyFrame -- 关键帧

具体的方法为:`Keyframe.ofFloat(float fraction, Object value)`

关键帧定义了属性值在某个时间点上具体值，明白了这些基本使用就比较简单了。

```
val keyFrame1 = Keyframe.ofFloat(0f, 1f)
val keyFrame2 = Keyframe.ofFloat(0.5f, 0.7f)
keyFrame2.interpolator = LinearInterpolator()// keyFrame1 与 keyFrame2 之间设置了 线性插值器
val keyFrame3 = Keyframe.ofFloat(0.7f, 0.8f)
val keyframe4 = Keyframe.ofFloat(1f)
keyframe4.value = 1f
val propertyValueHolder = PropertyValuesHolder.ofKeyframe("alpha", keyFrame1, keyFrame2, keyFrame3, keyframe4)
val animator = ObjectAnimator.ofPropertyValuesHolder(mIVKeyFrame, propertyValueHolder)
animator.duration = 2000
animator.start()
```

##### KeyFrame 的 ofObject 方法

由于 KeyFrame 的 ofObject 方法和上文中几种情况的 ofObject 的意义一样，其使用方法的指导思想也一致，直接看例子理解一下：


```
Keyframe frame0 = Keyframe.ofObject(0f, new Character('A'));  
Keyframe frame1 = Keyframe.ofObject(0.1f, new Character('L'));  
Keyframe frame2 = Keyframe.ofObject(1,new Character('Z'));  
PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe("CharText",frame0,frame1,frame2);  
frameHolder.setEvaluator(new CharEvaluator());  
ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mMyTv,frameHolder);  
animator.setDuration(3000);  
animator.start(); 

```
 
使用注意事项：

* 如果去掉第 0 帧，将以第一个关键帧为起始位置
* 如果去掉结束帧，将以最后一个关键帧为结束位置
* 使用 Keyframe 来构建动画，至少要有两个或两个以上帧


## 布局动画




---

Camera的处理结果只是生成一个Matrix，该Matrix用于Bitmap或Canvas绘制Bitmap时才能产生旋转或缩放的效果。



A camera instance can be used to compute 3D transformations and generate a matrix that can be applied, for instance, on a Canvas.