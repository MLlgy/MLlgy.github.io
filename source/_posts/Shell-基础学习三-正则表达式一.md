---
title: Shell 基础学习三--正则表达式一
tags: [Shell,Linux]
date: 2019-05-25 20:57:11
---



### 基本正则表达式


1. 正则表达式与通配符


正则表达式用来在 **文件中** 匹配符合条件的 **字符串**，正则是 **包含匹配**。grep、awk、 sed等命令可以支持正则表达式。


通配符用来匹配 **系统 中** 符合条件的 **文件名**，通配符是 **完全匹配**。ls、find、cp 这些命令不支持正则表达式，所以只能使用shell自己 的通配符来进行匹配了。


* ? []

#### * :前一个字符匹配 0 次或任意多次

注意是前一个字符。

> grep "a*" file

匹配所有内容，包括空白行，所以没有任何意义。

> grep "aa*" file

至少有一个 a 的字符串。


#### ".": 匹配除换行符的任意一个字符

> grep "s..d" test_rule.txt

“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词 

> grep "s.*d" test_rule.txt

匹配在s和d字母之间有任意字符。

在正则表达式中 ".*" 代表任意字符。

> grep ".*" test_rule.txt 

匹配所有内容

#### ”^“: 匹配行首，"$": 匹配行尾。


> grep "^M" test_rule.txt

匹配以大写“M”开头的行 

> grep "n$" test_rule.txt

匹配以小写“n”结尾的行 

> grep -n "^$" test_rule.txt
会匹配空白行


#### "[]":匹配中括号中的任意一个字符，注意是只匹配一个


> grep "s[ao]id" test_rule.txt 

匹配s和i字母中，要不是a、要不是o

>grep "[0-9]" test_rule.txt

匹配任意一个数字
>grep "^[a-z]" test_rule.txt

匹配用小写字母开头的行


#### "[^]":匹配中括号中以外的任意一个字符

> grep "^[^a-z]" test_rule.txt 
 
匹配不用小写字母开头的行


> grep "^[^a-zA-Z]" test_rule.txt 

匹配不用字母开头的行

#### "\"：使特殊符号失去特殊含义

> grep "\.$" test_rule.txt 
 
匹配使用“.”结尾的行


#### “\{n\}”：表示其前面的字符恰好出现n次 
 
> grep "a\{3\}" test_rule.txt

匹配a字母连续出现三次的字符串 

>grep "[0-9]\{3\}" test_rule.txt

匹配包含连续的三个数字的字符串

#### “\{n,\}”表示其前面的字符出现不小于n次

>grep "^[0-9]\{3,\}[a-z]" test_rule.txt 

匹配最少用连续三个数字开头的行


#### “\{n,m\}”匹配其前面的字符至少出现n次， 最多出现m次

> grep "sa\{1,3\}i" test_rule.txt 
 
匹配在字母s和字母i之间有最少一个a，最多三个a


### cut 字段提取命令


cut 命令

可以使用 cut 进行列提取，主要用途是配合 grep 提取相应的列。


### printf 格式化输出

和 Java 等语言的格式化输出用法基本相同


### awk 命令

> awk ‘条件1{动作1} 条件2{动作2}...’ 文件名


条件：一般使用表达式作为条件。

动作：格式化输出 printf、流程控制语句。


> awk '{printf $2 "\t" $6 "\n"}' student

打印 student 文件的第 2 列和第 6 列，再格式化输出。

awk 在执行时，是一行一行的输入，通过条件判断是否执行动作。


awk 可以识别以空格为列间的分割，而 cut 只能识别以 tab 为列分割。



BEGIN 在所有的动作前，先执行一个动作。


> awk 'BEGIN{printf "This is a transcript \n" } {printf $2 "\t" $6 "\n"}' student


awk 指定分隔符,使用 FS

> awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}'


END: 在所有的动作后，再执行一个动作。


> awk 'END{printf "The End \n" } {printf $2 "\t" $6 "\n"}' student


awk 使用关系运算符


awk 是复杂的命令，具体细节，使用时再查。


> cat student| grep -v Name | \ awk '$6 >= 87 {printf $2 "\n" }'


将第 6 列的数据是否大于数字打印出来。



### Sed 命令


**流** 编辑器，用来将数据进行选取、替换、删除、新
 增的命令。支持管道符操作，可以从管道符接收数据，不仅可以修改文件的内容，也可以修改命令的结果，这是 sed 与 vim 的主要区别。


sed 为 **行操作**



> sed [选项] ‘[动作]’ 文件名 
 
选项:

-n: 一般sed命令会把所有数据都输出到屏幕 ， 如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。
-e: 允许对输入数据应用多条sed命令编辑
-i: 用sed的修改结果直接修改读取数据的文件， 而不是由屏幕输出
-e: 允许对输入数据应用多条sed命令编辑
-i: 用sed的修改结果直接修改读取数据的文件， 而不是由屏幕输出

动作(单引号内):

a \:追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。
c \:
行替换，用c后面的字符串替换原数据行，替换多行时，除最 后一行外，每行末尾需用“\”代表数据未完结。
i \:插入，在当期行前插入一行或多行。插入多行时，除最后 一行 外，每行末尾需要用“\”代表数据未完结。
d:删除，删除指定的行。
p:打印，输出指定的行。
s: 字串替换，用一个字符串替换另外一个字符串。格式为“行范 围s/旧字串/新字串/g”(和vim中的替换格式类似)。

示例：

**打印：**
> sed '2p' student.txt 

查看文件的第二行,但是会将整个文件打印出来。

> sed -n '2p' student.txt

只会讲第 2 行打印出来。

**删除：**

> sed '2,4d' student.txt

删除第二行到第四行的数据，但不修改文件本身。


**追加：**

> sed '2a hello' student.txt
在第二行后追加hello。

**插入：**

> sed '2i hello \ world' student.txt

在第二行前插入两行数据。

**替换：**

> sed '2c No such person‘ student.txt

数据替换，将第2 行替换为具体内容。

**字符串替换：**

> sed ‘s/旧字串/新字串/g’ 文件名

> sed '3s/74/99/g' student.txt

在第三行中，把74换成99。

>sed -e 's/Liming//g ; s/Gao//g' student.txt

同时进行多个替换动作。

**写入文件：**

> sed -i '3s/74/99/g' student.txt

将 sed 操作写入文件。



### 条件判断


### 流程控制


