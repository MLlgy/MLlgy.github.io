<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GY</title>
  
  <subtitle>Enjoy the life, enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-08-08T10:03:56.287Z</updated>
  <id>/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 对象拷贝</title>
    <link href="/2019/08/08/Java-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <id>/2019/08/08/Java-对象拷贝/</id>
    <published>2019-08-08T10:02:13.000Z</published>
    <updated>2019-08-08T10:03:56.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。</p><p>在对象属性复制过程中不同的是：</p><ul><li>如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；</li><li>如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。</li></ul><p>也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。</p><a id="more"></a><p><img src="/../images/2019_07_03_01.jpg" alt="图例"></p><h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><p>实现 Cloneable 接口：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/Student.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><p><a href></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(1, &quot;杰克&quot;);</span><br><span class="line">        Student copyStudent = (Student) student.clone();</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        student.setName(&quot;再见杰克&quot;);</span><br><span class="line">        student.setAge(2);</span><br><span class="line">        student.getSubject().setName(&quot;Subject Rename Origin Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        copyStudent.setAge(3);</span><br><span class="line">        copyStudent.setName(&quot;幻觉&quot;);</span><br><span class="line">        copyStudent.getSubject().setName(&quot;Subject Rename Copy Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printMessage(Student originStudent, Student copiedStudent) &#123;</span><br><span class="line">        System.out.println(&quot;student Name is:&quot; + originStudent.getName() + &quot; ,age is &quot; + originStudent.getAge() + &quot; , subject Name is &quot; + originStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;copyStudent Name is:&quot; + copiedStudent.getName() + &quot; ,age is &quot; + copiedStudent.getAge() + &quot; , subject Name is &quot; + copiedStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">student Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Origin Change</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject Rename Origin Change</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Copy Change</span><br><span class="line">copyStudent Name is:幻觉 ,age is 3 , subject Name is Subject Rename Copy Change</span><br><span class="line">================</span><br></pre></td></tr></table></figure><p>可以很明显的看出，如果对象的属性为对象引用时，原对象和拷贝对象指向的为同一块内存地址，当任何一个对象改变该属性时，另外一个对象的相应属性也会发生改变。</p><p><a href="https://github.com/leeGYPlus/JavaCode/tree/master/src/copy/Main.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝会赋值所有的属性，属性为基本数据类型时，直接拷贝属性值；当属性为对象引用时会同时拷贝其所指向的内存。相较于浅拷贝，深拷贝拷贝速度更慢花销会更大。</p><p>深拷贝只是借助源对象在堆中产生一份源对象的复制，自此两者互不干涉。</p><p><img src="/../images/2019_07_03_04.jpg" alt="图例"></p><h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/DeepMain.kt" target="_blank" rel="noopener">GitHub 完整代码</a></p><p>打印日志发现，对两个对象的任何操作都只对自己的对象有影响。</p><h3 id="通过序列化实现深拷贝"><a href="#通过序列化实现深拷贝" class="headerlink" title="通过序列化实现深拷贝"></a>通过序列化实现深拷贝</h3><p>序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。</p><p>需要类实现序列化相关接口。详细内容可参见序列化相关内容。</p><h3 id="如何选择拷贝类型"><a href="#如何选择拷贝类型" class="headerlink" title="如何选择拷贝类型"></a>如何选择拷贝类型</h3><p>如果对象的属性全是基本类型的，那么可以使用浅拷贝，但是如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。我的意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。</p><hr><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad" target="_blank" rel="noopener">Android Road</a></p><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/copy.html" target="_blank" rel="noopener">Java 对象的浅拷贝和深拷贝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;p&gt;浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。&lt;/p&gt;
&lt;p&gt;在对象属性复制过程中不同的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；&lt;/li&gt;
&lt;li&gt;如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="对象拷贝" scheme="/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>AIDL 浅析</title>
    <link href="/2019/08/07/AIDL-%E6%B5%85%E6%9E%90/"/>
    <id>/2019/08/07/AIDL-浅析/</id>
    <published>2019-08-07T10:01:49.000Z</published>
    <updated>2019-08-08T09:59:11.397Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL 是理解 Android 系统不可避免的知识点。</p><p>0x0001 自定义 AIDL</p><p>为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。</p><p>自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。</p><a id="more"></a><ol><li>建立 java 同级目录 aidl：</li></ol><img src="/../images/2019_08_06_01.png" width="50%" height="50%"><ol><li>自定义 Aidl 文件</li></ol><p>建立与 java 目录相同的包层级结构。</p><p>定义该该过程使用到的 Java 实体类，由于类对象会在 IPC 中使用，所以 <strong>类需要实现序列化</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line">    private int bookId;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Book.aidl(需要保证 Book.java 和 Book.aidl 在相同的包层级结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure><p>定义 IBookManager.aidl 文件，添加相关方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IBookManager &#123;</span><br><span class="line">    List&lt;Book&gt; getBookList();</span><br><span class="line">    void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 aidl 的文件目录如下：</p><img src="/../images/2019_08_06_02.png" width="50%" height="50%"><ol start="3"><li>AS build 目录下生成对应的 Java 文件</li></ol><p>此处不会生成 Book.aidl 的 Java 文件，因为已经有 Book 类。</p><img src="/../images/2019_08_06_03.png" width="50%" height="50%"><p>将 build 文件中的 IBookManager.java 拷贝出来,新建 IBookManager2.java，源码如下:<a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/server/IBookManager2.java" target="_blank" rel="noopener">IBookManager.java</a></p><p>IBookManager 的内部层级结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IBookManager extends android.os.IInterface &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IBookManager 的成员方法如下：</p><img src="/../images/2019_08_08_01.png" width="50%" height="50%"><h3 id="0X0002-流程分析"><a href="#0X0002-流程分析" class="headerlink" title="0X0002 流程分析"></a>0X0002 流程分析</h3><p>为什么不生成 3 个文件(一个接口、两个类)，而是放在了一个文件中，这是因为当多个 AIDL 类时， Stub 和  Proxy 就会重名或者多个类会显得比较繁杂，而把它们放在各自的 AIDL 类中，就会比较容易区分。</p><p>下面分析如何进行跨进程通信。</p><p>起决定性作用的是 Stub 的 asInterface 方法和 onTranscact 方法，首先通过一个示意图大致了解其过程。</p><img src="/../images/2019_08_07_01.jpg" width="50%" height="50%"><ol><li>对于 Client 端，作为 AIDL 的使用端，调用相关方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBookManager.asInterface(IBinder 对象).addBook(Book(countId, &quot;Book $countId&quot;))</span><br></pre></td></tr></table></figure><blockquote><p>这个 Binder 对象就是在 bindService 时 Service 中的 onBinder 方法返回的 IBinder 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  override fun onBind(intent: Intent?): IBinder? &#123;</span><br><span class="line">&gt;      return mBinder</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>该方法用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.Proxy 。</p><p>asInterface 方法主要是判断参数，也就是 IBinder 对象，<strong>是和与自己同处一个进程</strong>：</p><ul><li>是，则直接转换、直接使用，则接下来的操作与 Binder 跨进程无关。</li><li>否，则会把这个 IBinder 对象包装成一个 Proxy 对象，这时调用的 Stub 的方法，间接调用 Proxy 的相应方法。</li></ul><p>此处为两者位于不同进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static IBookManager2 asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">    if ((obj == null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    if (((iin != null) &amp;&amp; (iin instanceof IBookManager2))) &#123;</span><br><span class="line">        return ((IBookManager2) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Proxy 中调用相关的方法，会使用 Pracelable 数据来准备数据，把函数名、函数的参数都写入 _data,使用 _reply 来接收函数的返回值，使用 Binder 的 transact 方法，把数据传给 Binder 的 Server 端。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void addBook(com.mk.aidldemo.Book book) throws android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    try &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        if ((book != null)) &#123;</span><br><span class="line">            _data.writeInt(1);</span><br><span class="line">            book.writeToParcel(_data, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;process proxy add&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">        // mRemote 对象为构建 Proxy 对象时传入</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Server 端通过 onTransact 方法来接收 Client 传过来的数据(包括函数名称、函数的参数、函数的标识)，找到指定的函数，就相应的数据传入，得到结果并将结果写回。</li></ol><h3 id="0x0003-具体分析"><a href="#0x0003-具体分析" class="headerlink" title="0x0003 具体分析"></a>0x0003 具体分析</h3><p>针对 Binder 跨进程通信机制，在每次通信过程中都需要有 Binder Client 端和 Binder Server 端。</p><p>在上面例子中应用程序进程(<code>com.mk.aidldemo</code>)为 Binder Client 端，用来发起请求，而新进程(<code>com.mk.aidldemo:remote</code>)为 Binder Server 端，用以处理请求。</p><p>在上文的流程图中，可以看到  Stub 为相应的 Binder Server 端，即为 Service 所在的进程中，我们通过加入 Log 日志，查看相应的操作执行哪个进程。</p><p>具体 Log 打点查看源码: <a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/MainActivity.kt" target="_blank" rel="noopener">GitHub 源码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/process binderService: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line"></span><br><span class="line">E/process service addBook: com.mk.aidldemo:remote</span><br><span class="line">E/process onTransact add: com.mk.aidldemo:remote</span><br></pre></td></tr></table></figure><p>可以看到在进程 <code>com.mk.aidldemo:remote</code> 中执行的操作有：onTransact 和 Server 中实例化 Binder 中的方法，即为 Binder Server 端，其他均处于 Binder Client 端。</p><p>这其中的关键方法有 mRemote.transact  和 onTransact。</p><p><strong>onTransact</strong></p><p>这个方法运行在 <strong>服务端中的 Binder线程池</strong> 中，当客户端发起跨进程请求时，远程请求会通过 <code>系统底层封装</code> 后交由此方法来处理。该方法的原型为<code>publicBooleanonTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>。服务端通过 code 可以确定客户端所请求的目标方法是什么，接着从 data 中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就向 reply 中写入返回值（如果目标方法有返回值的话）。</p><p>onTransact 方法的执行过程就是这样的。需要注意的是，如果此方法返回 false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p><p><strong>transact</strong></p><p><code>Proxy#getBookList、Proxy#addBook</code> 这个方法运行在 <strong>客户端</strong>，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入型 Parcel 对象_data、输出型Parcel对象 _reply 和返回值对象 List；然后把该方法的参数信息写入 _data 中（如果有参数的话）；<strong>接着调用 transact 方法来发起 RPC（远程过程调用）请求，同时当前线程挂起</strong>； 然后 <strong>服务端的onTransact 方法会被调用</strong>，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据。</p><p>这两个方法都为 Binder 的方法，至于底层是如何实现 RPC 实现了，需学习相关细节，期待。</p><hr><p>知识链接：</p><p><a href="http://product.dangdang.com/25325752.html" target="_blank" rel="noopener">Android 插件化开发指南</a></p><p><a href="http://product.dangdang.com/23766472.html" target="_blank" rel="noopener">Android 开发艺术探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIDL 是理解 Android 系统不可避免的知识点。&lt;/p&gt;
&lt;p&gt;0x0001 自定义 AIDL&lt;/p&gt;
&lt;p&gt;为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。&lt;/p&gt;
&lt;p&gt;自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIDL" scheme="/tags/AIDL/"/>
    
      <category term="Android" scheme="/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浮点型数据的精度问题</title>
    <link href="/2019/08/01/%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>/2019/08/01/浮点型数据的精度问题/</id>
    <published>2019-08-01T10:05:17.000Z</published>
    <updated>2019-08-01T10:21:52.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何表示定点数"><a href="#如何表示定点数" class="headerlink" title="如何表示定点数"></a>如何表示定点数</h3><p>使用二进制来表示十进制的编码称为 <strong>BCD 编码</strong>。这种编码方式把小数点固定在某一位，所以其表示的数称为 <strong>定点数</strong>。</p><p>那么 4 个比特最大的表示是十进制数为 9 (1001)。</p><p>32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。</p><a id="more"></a><p>缺点：</p><ul><li>极大的浪费。本来 4 bit 可以表示 0-15，现在只可以表示 0-9。</li><li>无法表示很大和很小的数。</li></ul><h3 id="如何表示浮点数"><a href="#如何表示浮点数" class="headerlink" title="如何表示浮点数"></a>如何表示浮点数</h3><ul><li>32 bit 表示单精度的浮点数，float 或 float32。</li><li>64 bit 表示双精度的浮点数，double 或 float64。</li></ul><p>以单精度为准看如何表示浮点数</p><table><thead><tr><th>s:符号位</th><th>e:指数位</th><th>f:有效数位</th></tr></thead><tbody><tr><td>1 bit</td><td>8 bit</td><td>23 bit</td></tr></tbody></table><p>e:8 bit 组成的指数位，表示整数范围 0<del>254,其中 1</del>254 映射到带符号的整数 -126~127，这样浮点数不仅可以表示很大的数，也可以表示很小的数。</p><p>最终浮点数表示为：<br>(-1)^s×1.f×2^e (e = 指数位对应的整数 -127)</p><p>关于 e 为什么要这样计算查看 <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示–阮一峰</a> 中关于 IEEE-754 的相关内容。</p><p>以 0.5 为准：</p><p>0.5=(−1)^0×1.0×2^−1=0.5</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><h3 id="浮点数的二进制表示"><a href="#浮点数的二进制表示" class="headerlink" title="浮点数的二进制表示"></a>浮点数的二进制表示</h3><p>十进制浮点数二进制表示：9.1</p><p>9：1001</p><p>小数部分转换成二进制使用乘法操作，就是乘以 2，然后看看是否超过 1。如果超过 1，我们就记下 1，并把结果减去 1，进一步循环操作。</p><p><img src="https://static001.geekbang.org/resource/image/f9/ae/f9213c43f5fa658a2192a68cd26435ae.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.1：000110011...(0011 无限循环)</span><br><span class="line"></span><br><span class="line">9.1:1001.000110011，使用科学计数法，将小数点向左移三位，表示如下：</span><br><span class="line"></span><br><span class="line">1.001000110011..x2^3</span><br></pre></td></tr></table></figure><p>匹配浮点数表示的公式：(-1)^s×1.f×2^e </p><p>s=0、f=001000110011( 0011 循环至23位)、e=3 (根据指数位计算方式 指数位对于的十进制整数为 +3+127 = 130，对应二进制为 01111110)，所以 9.1 在 32bit 下的二进制表示为：</p><p><img src="https://static001.geekbang.org/resource/image/9a/27/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg" alt></p><p>在一位的小数中，只有 0.5 可以精确表示：</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><p>其他均为近似表示，这就是为什么浮点数计算出现精度问题的原因。</p><h3 id="浮点数的加法与精度丢失"><a href="#浮点数的加法与精度丢失" class="headerlink" title="浮点数的加法与精度丢失"></a>浮点数的加法与精度丢失</h3><p>浮点数的加法规则：<strong>先对齐，再计算</strong>。</p><p>其中对齐是将两个浮点数的指数位对齐，即通过位移使指数位相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.5 + 0.125：</span><br><span class="line"></span><br><span class="line">0.5：1.0x2^(-1)</span><br><span class="line">0.125: 1.0x2^(-3)=0.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.0x2^(-1) + 0.01x2^(-1) = 1.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.01x2^(-1) 的十进制表示为 0.625</span><br></pre></td></tr></table></figure><p>在加法前，浮点型数据的二进制表示就可能会发生精度丢失，如果相加的两个数相差比较大，那么在指数对齐过程中，有可能会丢失有效位，位移就会越大，那么丢失的精度就越大，那么产生的误差也会越大。但是如果丢失的全为 0 ，那么加法的数值不会有精度丢失。</p><h3 id="如何避免精度损失"><a href="#如何避免精度损失" class="headerlink" title="如何避免精度损失"></a>如何避免精度损失</h3><p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm" target="_blank" rel="noopener"><strong>Kahan Summation 算法</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class KahanSummation &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    float sum = 0.0f;</span><br><span class="line">    float c = 0.0f;</span><br><span class="line">    for (int i = 0; i &lt; 20000000; i++) &#123;</span><br><span class="line">    float x = 1.0f;</span><br><span class="line">    float y = x - c;</span><br><span class="line">    float t = sum + y;</span><br><span class="line">    c = (t-sum)-y;</span><br><span class="line">    sum = t;    </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sum is &quot; + sum);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 BigDecimal</strong></p><p>BigDecimal 是专门为弥补浮点数无法精确计算的缺憾而设计的，它本身提供了加减乘除。</p><p><strong>使用整型</strong></p><p>如果保留小数点后 2 位，那么将参与运算的值扩大 100 倍 并转换为整型，在展示时再缩小 100 倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何表示定点数&quot;&gt;&lt;a href=&quot;#如何表示定点数&quot; class=&quot;headerlink&quot; title=&quot;如何表示定点数&quot;&gt;&lt;/a&gt;如何表示定点数&lt;/h3&gt;&lt;p&gt;使用二进制来表示十进制的编码称为 &lt;strong&gt;BCD 编码&lt;/strong&gt;。
这种编码方式把小数点固定在某一位，所以其表示的数称为 &lt;strong&gt;定点数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么 4 个比特最大的表示是十进制数为 9 (1001)。&lt;/p&gt;
&lt;p&gt;32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="极客时间笔记" scheme="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浮点型精度问题" scheme="/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hprof 拾遗</title>
    <link href="/2019/07/09/Hprof-%E6%8B%BE%E9%81%97/"/>
    <id>/2019/07/09/Hprof-拾遗/</id>
    <published>2019-07-09T09:43:11.000Z</published>
    <updated>2019-07-09T09:45:56.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-引用一"><a href="#0x0001-引用一" class="headerlink" title="0x0001 引用一"></a>0x0001 引用一</h3><p>以下内容来自：<a href="https://www.baeldung.com/java-heap-dump-capture" target="_blank" rel="noopener">Different Ways to Capture Java Heap Dumps</a></p><p>A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. <strong>Heap dumps are usually stored in binary format hprof files.</strong> </p><a id="more"></a><h3 id="0x0002-引用二"><a href="#0x0002-引用二" class="headerlink" title="0x0002 引用二"></a>0x0002 引用二</h3><p>以下内容来自：<a href="https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/heapdump.html" target="_blank" rel="noopener">Understanding heap dumps</a></p><p><strong>A heap dump is a snapshot of the memory of a Java™ process</strong>.</p><p>The snapshot contains information about the Java objects and classes in the heap at the moment the snapshot is triggered. Because there are different formats for persisting this data, there might be some differences in the information provided. Typically, a full garbage collection is triggered before the heap dump is written, so the dump contains information about <strong>the remaining objects in the heap</strong>.</p><p>The Memory Analyzer works with HPROF binary heap dumps, IBM® system dumps, and IBM portable heap dumps (PHD) from various platforms. See Supported dump file types.</p><p>Typical information in a heap dump, depending on the heap dump type, includes(堆转储文件中包含的信息):</p><p><strong>All Objects</strong></p><pre><code>Class, fields, primitive values, and references.</code></pre><p><strong>All Classes</strong></p><pre><code>Class loader, name, super class, and static fields.</code></pre><p><strong>Garbage collection roots</strong></p><pre><code>Objects defined to be reachable by the JVM.</code></pre><p><strong>Thread Stacks and Local Variables</strong></p><pre><code>Call-stacks of threads at the moment of the snapshot, and information about local objects on a frame by frame basis.</code></pre><h3 id="0x0003-Android-中的-Hprof"><a href="#0x0003-Android-中的-Hprof" class="headerlink" title="0x0003 Android 中的 Hprof"></a>0x0003 Android 中的 Hprof</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.dumpHprofData(String filePath);</span><br></pre></td></tr></table></figure><p>在 Android 中使用以上代码将对转储文件生成到指定的文件上。</p><p>在 AS 中如何分析 Hprof 见官方文档：<a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-引用一&quot;&gt;&lt;a href=&quot;#0x0001-引用一&quot; class=&quot;headerlink&quot; title=&quot;0x0001 引用一&quot;&gt;&lt;/a&gt;0x0001 引用一&lt;/h3&gt;&lt;p&gt;以下内容来自：&lt;a href=&quot;https://www.baeldung.com/java-heap-dump-capture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Different Ways to Capture Java Heap Dumps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. &lt;strong&gt;Heap dumps are usually stored in binary format hprof files.&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Hprof" scheme="/tags/Hprof/"/>
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 LeakCanary(1.6.3之前版本) 寻找内存泄漏位置</title>
    <link href="/2019/07/04/LeakCanary-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>/2019/07/04/LeakCanary-是如何工作的/</id>
    <published>2019-07-04T07:40:01.000Z</published>
    <updated>2019-07-10T03:16:54.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何使用-Leakmemory-泄漏链路-Trace-图"><a href="#如何使用-Leakmemory-泄漏链路-Trace-图" class="headerlink" title="如何使用 Leakmemory 泄漏链路(Trace 图)"></a>如何使用 Leakmemory 泄漏链路(Trace 图)</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.</p></blockquote><a id="more"></a><blockquote><p>[个人译] 如果你知道在 Trace 图中出现的对象是否应该存在于内存中，这会帮助你很好的分析内存泄漏位置。如果对象不应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象上面的位置；如果对象应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象下面的位置。</p></blockquote><blockquote><p>[12:37] Method:<br>Find an object and ask should this object should be alive or should be in garbage collection?</p></blockquote><h3 id="如何使用-package-leakmomory-进程进行问题定位"><a href="#如何使用-package-leakmomory-进程进行问题定位" class="headerlink" title="如何使用 package:leakmomory 进程进行问题定位"></a>如何使用 package:leakmomory 进程进行问题定位</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[15：00] Should this object should be alive at this point in time? how we know that?</p></blockquote><p>不只是根据 leakcanary 在手机上的 Trace 图，leakcanary 可以在 package:leakmomory 进程显示详细的 Trace 日志。其实现在手机上的 Trace 图也可以显示出关键的 Trace 日志，只是手机品牌不同显示的详细程度不同，如果手机上信息语言简略，推荐查看 AS 中 package:leakmomory 中的相关日志。</p><!-- ![展示](/../images/2019_07_03_05.jpg) --><p><strong>package:leakmomory 中关于对象的详细信息</strong>：</p><img src="/../images/2019_07_03_05.jpg" height="70%" width="70%"><p>图中包名显示为 package:leakmomory 线程，以下为 Trace 的详细信息。</p><blockquote><p>[16：00] We will dump the states of every singleInstance and that’s where you can find the problem.</p></blockquote><p>可以在这里可以根据实例对象或其属性值判断每个实例是否应该被回收，当然这需要相应有关该类的一些知识。如果该实例对象应该被回收，那么说明内存泄漏的对象在上面。</p><p>在上面的视频中的一个例子：</p><pre><code>根据 LeakCanary 的内存泄漏 Trace 图，发现存在 ChangeHandlerFramLayout 对象存在泄漏链路中，在 leakmomory 进程中可以详细获知该对象的各个属性值，从而可以判断该对象的状态。在此处中 ChangeHandlerFramLayout 对象的 mAttachInfo = null，说明该对象不再与屏幕关联，该对象在此时应该被 GC 回收掉，不应该存活，说明内存泄漏是 Trace 图上面的对象引起的，进一步定位内存泄漏位置。</code></pre><!-- ![Trace 图](/../images/2019_07_05_01.jpg) --><p><strong>Trace</strong> 图：</p><img src="/../images/2019_07_05_01.jpg" height="50%" width="50%"><!-- ![ChangeHandlerFramLayout 对象](/../images/2019_07_05_02.png) --><p><strong>ChangeHandlerFramLayout</strong> 对象：</p><img src="/../images/2019_07_05_02.png" height="70%" width="70%"><!-- ![ChangeHandlerFramLayout 对象的 mAttachInfo 值](/../images/2019_07_05_03.png) --><p><strong>ChangeHandlerFramLayout 对象的 mAttachInfo 值</strong>：</p><img src="/../images/2019_07_05_03.png" height="70%" width="70%"><p>接下来分析了位于 ChangeHandlerFramLayout 上的 MainActivity 实例对象，同理，在 leakmomory 查看该实例的状态，与ChangeHandlerFramLayout 对象不同的是此时我们关注属性值为 mDestoryed = true，说明 MainActivity 对象已经销毁，说明该对象也应该被 GC 回收。</p><p>如此往复，结合 trace 图和 leakmomory 进程信息，判断对象是否应该存在，<strong>不过根据对象的不同，判断该对象是否应该存活标准不同</strong>，如例子中的 mAttachInfo、mDestoryed。</p><h3 id="LeakCanary-实践一"><a href="#LeakCanary-实践一" class="headerlink" title="LeakCanary 实践一"></a>LeakCanary 实践一</h3><p>使用官方 <a href="https://github.com/square/leakcanary/tree/v1.6.3" target="_blank" rel="noopener">LeakCanary 1.6.3 </a> 库的 demo 进行展示如何定位内存泄漏。此处演示的为 LeakCanary 1.6.3 ，master 分支已于 2019-05-21 变更为 由 1.x 变更为 2.x ，具体查看 <a href="https://github.com/square/leakcanary/blob/4bbc0f6f2e3c9a25ca890ece6770f81cf9059510/docs/changelog.md" target="_blank" rel="noopener">Chnage Log</a>。</p><p>LeakCanary 2.x 功能更加全面，定位难度更加简单，但是方法基本一致，这里以 1.6.3 版本为主展示如何寻找内存泄漏位置。</p><!-- ![Trace 图](/../images/2019_07_05_04.png) --><p><strong>Demo 的 Trace 图为</strong>：</p><img src="/../images/2019_07_05_04.png" height="50%" width="50%"><!-- ![MainActivity 相关信息](/../images/2019_07_05_05.png) --><p>点击 MainActivity 所在行，显示详细信息。<br><strong>详细信息</strong>：</p><img src="/../images/2019_07_05_05.png" height="50%" width="50%"><p>可以发现 MainActivity 的 mDestoryed = true,说明 MainActivity 应该被 GC 回收，那么内存泄漏的应该发生在 <strong>之上</strong>。</p><!-- ![MainActivity$2.this.0 相关信息](/../images/2019_07_05_06.png) --><p>点击 <code>MainActivity$2.this$0</code> 显示具体信息:</p><img src="/../images/2019_07_05_06.png" height="70%" width="70%"><p>从图中得知 <code>MainActivity$2.this$0</code> 为 <strong>anonymous implent Runnable(继承 Runnble 的匿名对象)</strong> 。从截图中值 <code>this$0</code> 为 <code>com.example.MainActivity</code> 实例对象,此时 <code>this$0</code> 所指向的 MainActivity 在旋转屏幕后会被销毁、被回收，但是 <code>Runnable 对象</code> 执行后台任务导致 <code>MainActivity$2</code> 对象依旧存在,即该对象此时应该存在于内存中，那么导致其所持有的 MainActivity 引用不能被回收，从而导致了 MainActivity 对象的泄漏。</p><p>匿名对象的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable work = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>这在 Java 中是一个经典的内存泄漏的案例，原因是匿名对象持有外部类的引用引起的，我们要做的就是将匿名对象静态化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class CustomRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CustomRunnable work = new CustomRunnable();</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>针对匿名内部类具体分析一下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line"></span><br><span class="line">        Runnable work = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // Do some slow work in background</span><br><span class="line">//                SystemClock.sleep(20000</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(work).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Java 命令编译该 Java 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>编译出两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Main.class</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public Main() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        Runnable var1 = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        (new Thread(var1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Main$1.class</span><br><span class="line">class Main$1 implements Runnable &#123;</span><br><span class="line">    Main$1(Main var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>this$0</code> 就为上面截图中的 <code>com.example.MainActivity</code> 实例对象，所以匿名内部类持有外部类的引用。</p><h3 id="LeakCanary-实践二"><a href="#LeakCanary-实践二" class="headerlink" title="LeakCanary 实践二"></a>LeakCanary 实践二</h3><p>这个例子更能够体现一步一步寻找内存泄漏点：</p><p>首先此次内存泄漏产生的 Trace 图如下：</p><!-- ![Trace 图](/../images/2019_07_06_01.png) --><p><strong>步骤一： Trace 图</strong></p><img src="/../images/2019_07_06_01.png" height="50%" width="50%"><p>首先我们通过截图 Title( MainActivity Leaked)明确 <strong>产生泄漏的对象为 MainActivity 的实例对象</strong>，Title 下面展示产生泄漏的 Trace 图。</p><p>我们根据 Trace 图一步一步分析:</p><p><strong>步骤二</strong>：</p><img src="/../images/2019_07_06_02.png" height="50%" width="50%"><p><strong>步骤三</strong>：</p><img src="/../images/2019_07_06_03.png" height="50%" width="50%"><p><strong>步骤四</strong>：</p><img src="/../images/2019_07_06_04.png" height="50%" width="50%"><p><strong>步骤五</strong>：</p><img src="/../images/2019_07_06_05.png" height="50%" width="50%"><p><strong>步骤六</strong>：</p><img src="/../images/2019_07_06_06.png" height="50%" width="50%"><!-- ![步骤一](/../images/2019_07_06_02.png) --><!-- ![步骤二](/../images/2019_07_06_03.png) --><!-- ![步骤三](/../images/2019_07_06_04.png) --><!-- ![步骤四](/../images/2019_07_06_05.png) --><!-- ![步骤五](/../images/2019_07_06_06.png) --><p>通过以上步骤，我们知道由于反转屏幕后 MainActivity 中的 Button 实例对象需要被回收，但是由于 HttpRequestHelper 对象在反转屏幕后继续存在，同时 HttpRequestHelper 实例对象持有 Button 对象的引用，所以 Button 不能成功被回收，导致 Button 持有的 MainActivity 实例对象在  Destory 后不能成功销毁，从而导致了 MainActivity 内存泄漏。</p><p>为了验证以上结论，我们可以继续向上查看 Trace：</p><!-- ![验证一](/../images/2019_07_06_07.png)![验证二](/../images/2019_07_06_08.png) --><img src="/../images/2019_07_06_07.png" height="50%" width="50%"><p><strong>实例对象详细信息</strong>：</p><img src="/../images/2019_07_06_08.png" height="50%" width="50%"><hr><p><strong>有用的资源：</strong></p><p><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">leakcanary 官方网站</a></p><p><a href="https://square.github.io/leakcanary/fundamentals/" target="_blank" rel="noopener">leakcanary 基本原理</a></p><p><a href="https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745" target="_blank" rel="noopener">Detect all memory</a></p><p><a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><p><a href="https://www.youtube.com/watch?v=LEX8dn4BLUw" target="_blank" rel="noopener">LeakCanary 2: Leaner, Better, Faster, Kotliner! by Pierre-Yves Ricau, Square, Inc EN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何使用-Leakmemory-泄漏链路-Trace-图&quot;&gt;&lt;a href=&quot;#如何使用-Leakmemory-泄漏链路-Trace-图&quot; class=&quot;headerlink&quot; title=&quot;如何使用 Leakmemory 泄漏链路(Trace 图)&quot;&gt;&lt;/a&gt;如何使用 Leakmemory 泄漏链路(Trace 图)&lt;/h3&gt;&lt;p&gt;以下英文部分摘自 &lt;a href=&quot;https://www.youtube.com/watch?v=KwArTJHLq5g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="LeakCanary" scheme="/tags/LeakCanary/"/>
    
      <category term="内存优化" scheme="/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>刷机资源</title>
    <link href="/2019/06/26/%E5%88%B7%E6%9C%BA%E8%B5%84%E6%BA%90/"/>
    <id>/2019/06/26/刷机资源/</id>
    <published>2019-06-26T09:42:53.000Z</published>
    <updated>2019-07-09T09:48:00.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-TWRP"><a href="#1-TWRP" class="headerlink" title="1.TWRP"></a>1.TWRP</h3><p><a href="https://twrp.me/Devices/" target="_blank" rel="noopener">TeamWin - TWRP</a></p><h3 id="2-SuperSu"><a href="#2-SuperSu" class="headerlink" title="2.SuperSu"></a>2.SuperSu</h3><p><a href="http://www.supersu.com/download" target="_blank" rel="noopener">SuperSu</a></p><p>2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。</p><a id="more"></a><h3 id="3-Magisk"><a href="#3-Magisk" class="headerlink" title="3.Magisk"></a>3.Magisk</h3><p><a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445" target="_blank" rel="noopener">Magisk</a></p><p><a href="https://github.com/topjohnwu/Magisk" target="_blank" rel="noopener">Magisk-Github</a></p><!-- ### Xposed Framework --><h3 id="4-Rom-资源"><a href="#4-Rom-资源" class="headerlink" title="4.Rom 资源"></a>4.Rom 资源</h3><p><a href="https://www.lineageos.org/" target="_blank" rel="noopener">LineageOS</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/lineage-rom/full/" target="_blank" rel="noopener">LineageOS 清华源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-TWRP&quot;&gt;&lt;a href=&quot;#1-TWRP&quot; class=&quot;headerlink&quot; title=&quot;1.TWRP&quot;&gt;&lt;/a&gt;1.TWRP&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://twrp.me/Devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TeamWin - TWRP&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-SuperSu&quot;&gt;&lt;a href=&quot;#2-SuperSu&quot; class=&quot;headerlink&quot; title=&quot;2.SuperSu&quot;&gt;&lt;/a&gt;2.SuperSu&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.supersu.com/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SuperSu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android 刷机" scheme="/tags/Android-%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>灵感来源</title>
    <link href="/2019/06/12/%E7%81%B5%E6%84%9F%E6%9D%A5%E6%BA%90/"/>
    <id>/2019/06/12/灵感来源/</id>
    <published>2019-06-12T10:54:16.000Z</published>
    <updated>2019-06-12T10:54:16.689Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/" target="_blank" rel="noopener">GayHub 交友社区</a></p><p><a href="https://www.ctolib.com/article/compares/53292" target="_blank" rel="noopener">CTOLib码库</a></p><p><a href="https://p.codekk.com/" target="_blank" rel="noopener">CodeKK</a></p><p><a href="https://www.diycode.cc/categories/Android" target="_blank" rel="noopener">diycode</a></p><p><a href="https://android-arsenal.com/" target="_blank" rel="noopener"> Android Arsenal</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GayHub 交友社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctolib.com/article/compares/5329
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化之优化 App 启动速度</title>
    <link href="/2019/06/11/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BC%98%E5%8C%96-App-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    <id>/2019/06/11/性能优化之优化-App-启动速度/</id>
    <published>2019-06-11T09:13:48.000Z</published>
    <updated>2019-06-11T09:13:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>主要面临的问题：<br> APP 冷启动白屏。</p><p>针对于这个问题，基本上主流的解决方法存在两个：</p><pre><code>1. 主题替换。2. 减少冷启动时主线程的工作量。</code></pre><p>本文的重点不在解决问题方法，而在于解决问题的过程，包括影响启动速度的因素、时间统计工具、解决思路。</p><p>优化 App 启动速度主要是优化冷启动时的 App 启动速度，官方文档 (<a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a>) 中指出优化冷启动方式的同时，温启动和热启动也会得到改善。</p><p>在分析过程之前，首先了解启动方式。</p><h3 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h3><ul><li><p>冷启动</p><p>App 安装后第一次启动或者杀死 App 进程后重新启动称为冷启动。冷启动的启动成本较高，一切都要重新建立，包括新建应用进程、初始化应用以及首页的布局、渲染等操作。</p></li></ul><ul><li><p>热启动</p><p>  App 所在进程存活，并且所有 Activity 均未被销毁，热启动做的只是把应用从后台切换至前台，如果 Activity 实例中的被回收的实例变量会重新创建。</p><p>  具体场景为在微信中切换到桌面，后马上回到微信。</p></li><li><p>温启动</p><p>  Activity 被杀死但是 App 所在的进程在内存中依然存在。</p></li></ul><h4 id="启动时间组成"><a href="#启动时间组成" class="headerlink" title="启动时间组成"></a>启动时间组成</h4><p>很多时候解决问题需要我们拥有上帝视角，全面把控事态的发展，跳出事件本身，以俯视的角度看待整个流程，找出问题的关键点。总的来说我们需要纵观全局来看待问题、解决问题。</p><p>从在 Launcher 中点击 App 的 icon 到 App 的第一面展示的时间差称为冷启动时间，那么这段时间整个系统都经历了什么。用上帝之眼看待整个流程，从而寻找解决问题的切入点，首先我们分析一下整个过程都经历了什么。</p><p>在 Launcher 中我们点击 App 图标，经过一系列过程，涉及 AMS、 Binder、IPC 等组件和过程。</p><p>在启动 App 的主页面之前，系统操作如下：</p><ol><li>创建并启动 App 所在应用</li><li>启动 App 后会马上展示系统的 start window</li><li>创建 App 进程</li></ol><p>在系统创建完成 App 所在的进程后，App 进程负责完成下列一系列步骤：</p><ol><li>创建 App 对象</li><li>启动 App 主线程</li><li>创建主 Activity</li><li>加载 View 视图</li><li>布局屏幕</li><li>执行初始化绘制 View</li></ol><p>在 App 进程完成第一帧的绘制后，start window 会被替换，此时在屏幕上展示的就是在主 Activity 加载的布局。</p><p><img src="/../images/2019_06_01_01.png" alt="App 页面替换"></p><p>根据 <a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Colt McAnlis</a> 在 Yutobe 上的关于 App 启动时间的描述，以上过程可以形象的图形化表示如下：</p><p><img src="/../images/2019_06_01_02.png" alt="App 启动时间"></p><h4 id="为什么是白屏或黑屏"><a href="#为什么是白屏或黑屏" class="headerlink" title="为什么是白屏或黑屏"></a>为什么是白屏或黑屏</h4><p>在清单文件中我们需要设置 Application 的 Theme，比如自己设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        ...</span><br><span class="line">        android:theme=&quot;@style/sixcatTheme&quot;&gt;</span><br></pre></td></tr></table></figure><p>我们需要查看 sixcatTheme 主题的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;style name=&quot;sixcatTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">2. &lt;style name=&quot;Theme.AppCompat.Light&quot; parent=&quot;Base.Theme.AppCompat.Light&quot;/&gt;</span><br><span class="line"></span><br><span class="line">3. &lt;style name=&quot;Base.Theme.AppCompat.Light&quot; parent=&quot;Base.V7.Theme.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">4. &lt;style name=&quot;Base.V7.Theme.AppCompat.Light&quot; parent=&quot;Platform.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">5. &lt;style name=&quot;Platform.AppCompat.Light&quot; parent=&quot;android:Theme.Holo.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">6. &lt;style name=&quot;Theme.Holo.Light&quot; parent=&quot;Theme.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. &lt;style name=&quot;Theme.Light&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">8. &lt;style name=&quot;Theme&quot;&gt;</span><br></pre></td></tr></table></figure><p>层级自 1~8 自上而下具有继承关系。</p><p>可以看到在第 7 层中存在 windowBackground 属性，这是一路下来与背景唯一相关属性。</p><p>看一下 windowBackground 的 drawable 显示如何：</p><p><img src="/../images/2019_06_11_01.jpg" alt="drawable"></p><p>事实证明确实是这个属性决定着点击 App 后显示的白屏或黑屏，当然这也为解决此问题提供了一个思路。</p><p>官方图</p><p>拆解为两部分。</p><p>分析、找出优化点</p><h4 id="启动时间统计"><a href="#启动时间统计" class="headerlink" title="启动时间统计"></a>启动时间统计</h4><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>更换主题</p><p>截图 + 解决方法 + 截图</p><p>延时加载</p><p>CPU profile<br>trace 文件<br>命令行<br>Displayed Time</p><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>在原来的 MainActivity 设定的主题中添加以上代码。</p><p>带来的效果：<br>透明效果，即点击 App icon 后的白屏时间变为 透明 状态，避免了白屏，但是两者的时间几乎相同。给人的错觉时点击 icon 后一段时间后，app 才调起，给人的印象不好。</p><p>方法二 主题替换</p><p>在 App 启动时</p><hr><p>App 启动时间统计</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W package/activity</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Google Developer</a></p><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Youtube 性能优化视频</a></p><p><a href="https://www.zhihu.com/question/35487841" target="_blank" rel="noopener">https://www.zhihu.com/question/35487841</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要面临的问题：&lt;br&gt; APP 冷启动白屏。&lt;/p&gt;
&lt;p&gt;针对于这个问题，基本上主流的解决方法存在两个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 主题替换。
2. 减少冷启动时主线程的工作量。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文的重点不在解决问题方法，而在于解决问题的过程，
      
    
    </summary>
    
    
      <category term="性能优化" scheme="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binder基本原理</title>
    <link href="/2019/06/05/Binder%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>/2019/06/05/Binder基本原理/</id>
    <published>2019-06-05T05:33:02.000Z</published>
    <updated>2019-06-05T05:36:07.356Z</updated>
    
    <content type="html"><![CDATA[<p>Binder 机制是 Android 特有的跨进程通信机制，本文为 <a href>Android 插件化开发</a> 相关章节的阅读笔记。</p><h4 id="00x01"><a href="#00x01" class="headerlink" title="00x01"></a>00x01</h4><p>Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。</p><h4 id="00x02"><a href="#00x02" class="headerlink" title="00x02"></a>00x02</h4><p>Binder 组成：</p><ul><li>Client</li><li>Server</li><li>ServerManager(管理 Server )</li></ul><a id="more"></a><h4 id="00x03"><a href="#00x03" class="headerlink" title="00x03"></a>00x03</h4><p>为了更好的帮助读者理解，我们可以看一个场景：<strong>打电话</strong>。</p><ul><li>ServerManager: 相当于电话局，储存每个用户的电话。</li><li>Client: 用户 A</li><li>Server: 用户 B</li></ul><p><code>用户 A 向用户 B 拨打电话</code></p><ol><li>A 拨打电话</li><li>电话会被转接到电话局</li><li>电话局查询 A 拨打的电话，若电话存在，则接通电话；若电话不存在，则提示该号码不存在。</li></ol><p>在这个过程中还有一个十分重要的角色：<strong>接线员</strong>，它做了很多事情，承担了十分重要的角色，映射到 Binder 机制，接线员相当于 <strong>Binder 驱动</strong>。</p><h4 id="00x04"><a href="#00x04" class="headerlink" title="00x04"></a>00x04</h4><p>Binder 基本运行机制如下图：</p><p><img src="/../images/2019_06_05_01.jpg" alt="Binder 运行机制"></p><h4 id="00x05-Binder-的通信过程"><a href="#00x05-Binder-的通信过程" class="headerlink" title="00x05 Binder 的通信过程"></a>00x05 Binder 的通信过程</h4><p>假如 Client 进程调用 Server 进程中的方法 add(),因为两者隶属于不同进程，此时需要在 Binder 的协助下完成 IPC(Inter-process Communication) 通信。</p><ol><li>Server 端在 SM(ServerManager) 中完成注册。</li><li>Client 要想调用 Server 的 add 方法，必须获得 Server 对象，但是 SM 不会吧真正的 Server 对象返回给 Client，而是把 Server 的代理对象 Proxy 返回给 Client。</li><li>Client 调用 Proxy 中的 add 方法，SM 会帮助它调用 Server 的 add 方法，并把结果返回给 Client。</li></ol><p>此时 Client 和 Server 实现了进程间通信，在此过程中 Binder 驱动做了许多事情，但是我们目前不需要关心。</p><p><img src="/../images/2019_06_05_02.png" alt="Binder 通信过程"></p><h4 id="00x06"><a href="#00x06" class="headerlink" title="00x06"></a>00x06</h4><p>在研究系统框架或第三方库时，我们不要陷入细节中，要先熟悉基本的运行机制、运行流程，根据自我需求，选择性的查看实现细节，但是需要注意的还是不能陷入细节，要有的放矢的跳出细节，把控全局。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binder 机制是 Android 特有的跨进程通信机制，本文为 &lt;a href&gt;Android 插件化开发&lt;/a&gt; 相关章节的阅读笔记。&lt;/p&gt;
&lt;h4 id=&quot;00x01&quot;&gt;&lt;a href=&quot;#00x01&quot; class=&quot;headerlink&quot; title=&quot;00x01&quot;&gt;&lt;/a&gt;00x01&lt;/h4&gt;&lt;p&gt;Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。&lt;/p&gt;
&lt;h4 id=&quot;00x02&quot;&gt;&lt;a href=&quot;#00x02&quot; class=&quot;headerlink&quot; title=&quot;00x02&quot;&gt;&lt;/a&gt;00x02&lt;/h4&gt;&lt;p&gt;Binder 组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;ServerManager(管理 Server )&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Binder" scheme="/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 资源网站集</title>
    <link href="/2019/05/30/Kindle-%E8%B5%84%E6%BA%90%E9%9B%86/"/>
    <id>/2019/05/30/Kindle-资源集/</id>
    <published>2019-05-30T02:28:29.000Z</published>
    <updated>2019-06-01T02:02:51.829Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kaka3.com/" target="_blank" rel="noopener">kaka</a></p><p><a href="http://www.ireadweek.com/index.php/Index/index.html" target="_blank" rel="noopener">行行</a></p><a id="more"></a><p><a href="http://www.tushugu.com/" target="_blank" rel="noopener">图书馆</a></p><p><a href="https://book.shuyuzhe.com/" target="_blank" rel="noopener">书语者</a></p><p><a href="https://bookset.me/" target="_blank" rel="noopener">Bookset</a></p><p><a href="https://kgbook.com/" target="_blank" rel="noopener">苦瓜书盘</a></p><p><a href="http://mebook.cc/" target="_blank" rel="noopener">我的小书屋</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.kaka3.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kaka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ireadweek.com/index.php/Index/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;行行&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kindle" scheme="/tags/Kindle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合工具类--Collections</title>
    <link href="/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/"/>
    <id>/2019/05/29/Java-集合工具类-Collections/</id>
    <published>2019-05-29T09:17:24.000Z</published>
    <updated>2019-05-29T10:18:39.903Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的</strong>，如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 <strong>线程同步问题</strong>。</p><p>Java 提供了 Collections 工具类，使用 synchronizedxxx()  方法可以将集合类包装成线程安全的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections collections = Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"></span><br><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br><span class="line"></span><br><span class="line">Set set = Collections.synchronizedSet(new HashSet());</span><br><span class="line"></span><br><span class="line">Map map = Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure><p>同时 Collections 还提供了排序、查找、替换、设置不可变集合等功能，有空自己看 API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的&lt;/strong&gt;，
如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 &lt;strong&gt;线程同步问
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Collections" scheme="/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 单例模式的实现</title>
    <link href="/2019/05/24/Kotlin-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/05/24/Kotlin-单例模式的实现/</id>
    <published>2019-05-24T10:35:39.000Z</published>
    <updated>2019-05-29T09:45:44.388Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最简单的实现方式"><a href="#最简单的实现方式" class="headerlink" title="最简单的实现方式"></a>最简单的实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line">  fun method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在Kotlin里调用</span><br><span class="line">Singleton.method()</span><br><span class="line"></span><br><span class="line">//在Java中调用</span><br><span class="line">Singleton.INSTANCE.method();</span><br></pre></td></tr></table></figure><p>其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123;</span><br><span class="line">   public static final Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void method() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Singleton() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Singleton var0 = new Singleton();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java 中的 饿汉式获得单例方式相同。</p><p>同样也与 Java 中饿汉方式获得单例拥有相同的问题：</p><ul><li>如果没有使用该类的对象，那么已经实例化的对象，造成了内存浪费。</li><li>当构造器中执行复杂操作，造成实例化过程缓慢，可能造成性能问题。</li></ul><h4 id="懒汉式-一"><a href="#懒汉式-一" class="headerlink" title="懒汉式 一"></a>懒汉式 一</h4><p>在 Kotlin 中单例的实现和 Java 中一样，必须有：</p><ol><li>私有化的构造函数</li><li>获得对象的方法</li></ol><p>那么在 Kotlin 中有：</p><ul><li>显式声明构造方法为 private</li><li>companion object 用来在 class 内部声明一个对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        @Volatile</span><br><span class="line">        private var instance: Singleton? = null</span><br><span class="line"></span><br><span class="line">        fun getInstance() =</span><br><span class="line">                instance ?: synchronized(this) &#123;</span><br><span class="line">                    instance ?: Singleton().also &#123; instance =it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此写法 <a href="https://leegyplus.github.io/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/" target="_blank" rel="noopener">Java 单例模式的几种写法</a> 中懒汉模式的 <strong>方式三</strong> 相同。</p><p>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin 调用</span><br><span class="line">val singleton = Singleton.getInstance()</span><br><span class="line"></span><br><span class="line">//Java 调用</span><br><span class="line">Singleton singleton = Singleton.Companion.getInstance()</span><br></pre></td></tr></table></figure><h4 id="懒汉式-二"><a href="#懒汉式-二" class="headerlink" title="懒汉式 二"></a>懒汉式 二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance: Singleton by lazy &#123; Singleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Singleton</code> 通过 <code>lazy</code>来实现懒汉式加载。</li><li><code>lazy</code> 默认情况下是 <strong>线程安全</strong> 的，这就可以避免多个线程同时访问生成多个实例的问题。</li></ul><p>所以就不用象方式一中那样，对 Singleton 对象进行 <strong>加同步锁</strong> 和 <strong>双重校验</strong> 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最简单的实现方式&quot;&gt;&lt;a href=&quot;#最简单的实现方式&quot; class=&quot;headerlink&quot; title=&quot;最简单的实现方式&quot;&gt;&lt;/a&gt;最简单的实现方式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fun method() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;调用单例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//在Kotlin里调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.method()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//在Java中调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.INSTANCE.method();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="/tags/Kotlin/"/>
    
      <category term="Singleton" scheme="/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="/2019/05/23/%E9%9A%8F%E7%AC%94/"/>
    <id>/2019/05/23/随笔/</id>
    <published>2019-05-22T23:36:36.000Z</published>
    <updated>2019-05-23T03:14:25.537Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条随意的随笔，欢迎欢迎！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我是一条随意的随笔，欢迎欢迎！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(二)-CPU是如何执行指令的</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%8C-CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-二-CPU是如何执行指令的/</id>
    <published>2019-05-15T10:04:03.000Z</published>
    <updated>2019-05-29T07:35:01.658Z</updated>
    
    <content type="html"><![CDATA[<p>代码变成指令后，是一条一条顺序执行的。</p><p>在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。</p><p>在硬件上，寄存器有锁存器或触发器组成。</p><p><img src="https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg" alt="常见寄存器"></p><p>每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。</p><a id="more"></a><ul><li>PC 寄存器(指令地址寄存器)：用来存放下一条需要执行的计算机指令的 <strong>内存地址</strong>。</li><li>指令寄存器：用来存放正在执行的指令。</li><li>条件码寄存器：用里面的一个个标志位，用来存在 CPU 进行计算或逻辑运算的结果。</li></ul><p>以下图片展示如何根据机器码执行指令；</p><p><img src="https://static001.geekbang.org/resource/image/ad/8a/ad91b005e97959d571bbd2a0fa30b48a.jpeg" alt="执行指令"></p><p>我们可以看到，执行程序时，CPU 会根据 PC 寄存器中的内存地址，将指定内存的指令码读取到指令寄存器中，指令长度自增，开始顺序执行下一个指令，执行上面相同的操作。</p><p>以上可见程序的指令码是在内存中顺序保存的，也会一条一条加载。</p><h3 id="指令码跳转执行"><a href="#指令码跳转执行" class="headerlink" title="指令码跳转执行"></a>指令码跳转执行</h3><p>程序的指令码在内存中是顺序执行的，那么在程序执行跳转逻辑是，机器指令是如何执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  int r = rand() % 2;</span><br><span class="line">  int a = 10;</span><br><span class="line">  if (r == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -M intel -S test.o</span><br></pre></td></tr></table></figure><p>在 Mac 上对应的汇编码如下，限于平台问题，和原博客有所差别，所以直接参看原博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 // test.c</span><br><span class="line">26:   99  cltd</span><br><span class="line">27:   b9 02 00 00 00  movl    $2, %ecx</span><br><span class="line">2c:   f7 f9   idivl   %ecx</span><br><span class="line">2e:   89 55 f8    movl    %edx, -8(%rbp)</span><br><span class="line">; int a = 10;</span><br><span class="line">31:   c7 45 f4 0a 00 00 00    movl    $10, -12(%rbp)</span><br><span class="line">; if (r == 0)</span><br><span class="line">38:   83 7d f8 00     cmpl    $0, -8(%rbp)</span><br><span class="line">3c:   0f 85 0c 00 00 00   jne 12 &lt;_main+0x4e&gt;</span><br><span class="line">; a = 1;</span><br><span class="line">42:   c7 45 f4 01 00 00 00    movl    $1, -12(%rbp)</span><br><span class="line">; &#125; else &#123;</span><br><span class="line">49:   e9 07 00 00 00  jmp 7 &lt;_main+0x55&gt;</span><br><span class="line">; a = 2;</span><br><span class="line">4e:   c7 45 f4 02 00 00 00    movl    $2, -12(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">55:   8b 45 fc    movl    -4(%rbp), %eax</span><br><span class="line">58:   48 83 c4 10     addq    $16, %rsp</span><br><span class="line">5c:   5d  popq    %rbp</span><br><span class="line">5d:   c3  retq</span><br></pre></td></tr></table></figure><p> 原博客汇编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (r == 0)</span><br><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br><span class="line">&#123;</span><br><span class="line">a = 1;</span><br><span class="line">41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1</span><br><span class="line">48:   eb 07                   jmp    51 &lt;main+0x51&gt;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a = 2;</span><br><span class="line">4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2</span><br><span class="line">51:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注以下两行(r == 0 的编译结果)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br></pre></td></tr></table></figure><p>判断当条件成立时，跳转到操作数为 4a 的指令，进行接下来的指令执行。</p><p>执行过程图：</p><p><img src="https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg" alt="跳转指令执行"></p><p>所以代码变成指令后，是一条一条顺序执行的，这个顺序执行是基于跳转的顺序执行。</p><hr><p>常见指令解释：</p><p>cmp DWORD PTR [rbp-0x4],0x0</p><pre><code>从寄存器地址为[rbp-0x4]取出值与 0x0 比较</code></pre><p>mov DWORD PTR [rbp-0x8],0x2</p><pre><code>将 0x2 存入寄存器地址为 [rbp-0x8] 的内存中</code></pre><p>jne 指令，是 jump if not equal </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码变成指令后，是一条一条顺序执行的。&lt;/p&gt;
&lt;p&gt;在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。&lt;/p&gt;
&lt;p&gt;在硬件上，寄存器有锁存器或触发器组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg&quot; alt=&quot;常见寄存器&quot;&gt;&lt;/p&gt;
&lt;p&gt;每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(一)--计算机指令</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-一-计算机指令/</id>
    <published>2019-05-15T02:21:30.000Z</published>
    <updated>2019-05-15T09:25:42.585Z</updated>
    
    <content type="html"><![CDATA[<p>因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 是计算机的大脑，Central Processing Unit，中文为 <strong>中央处理器</strong>。</p><p>从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。</p><p>从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 <strong>机器语言</strong>。</p><p>每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 <strong>计算机指令</strong>。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。</p><p>一个计算机程序编译后，有很多的计算机指令。<br> <a id="more"></a></p><h3 id="从编译到汇编，代码是怎样变成机器码的？"><a href="#从编译到汇编，代码是怎样变成机器码的？" class="headerlink" title="从编译到汇编，代码是怎样变成机器码的？"></a>从编译到汇编，代码是怎样变成机器码的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 1; </span><br><span class="line">  int b = 2;</span><br><span class="line">  a = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让这段程序在 Linux 系统上跑起来，我们需要把整个程序翻译成一个 汇编语言(ASM,Assembly Language)的程序,这个过程我们叫做 <strong>编译(Compile)</strong> 成汇编代码。之后再使用汇编器将汇编代码翻译成用 “0”和”1” 组成的机器码。这一条条机器码就是一条条 <strong>计算机指令</strong>。</p><p>使用 GCC 编译器 和 objdump 命令，把对应的汇编代码和机器代码打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//MacOS 环境下</span><br><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -S test.o &gt; text.txt</span><br></pre></td></tr></table></figure><p>text.txt 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test.o: file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line">_main:</span><br><span class="line">; int main()&#123;</span><br><span class="line">       0:   55  pushq   %rbp</span><br><span class="line">       1:   48 89 e5    movq    %rsp, %rbp</span><br><span class="line">       4:   31 c0   xorl    %eax, %eax</span><br><span class="line">; int a = 1;</span><br><span class="line">       6:   c7 45 fc 01 00 00 00    movl    $1, -4(%rbp)</span><br><span class="line">; int b = 2;</span><br><span class="line">       d:   c7 45 f8 02 00 00 00    movl    $2, -8(%rbp)</span><br><span class="line">; a = a + b;</span><br><span class="line">      14:   8b 4d fc    movl    -4(%rbp), %ecx</span><br><span class="line">      17:   03 4d f8    addl    -8(%rbp), %ecx</span><br><span class="line">      1a:   89 4d fc    movl    %ecx, -4(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">      1d:   5d  popq    %rbp</span><br><span class="line">      1e:   c3  retq</span><br></pre></td></tr></table></figure><p>汇编语言其实就是让程序员能够看懂机器语言。</p><p>将上面文件中的汇编语言和机器语言分别拆分出来，分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">xorl    %eax, %eax</span><br><span class="line">movl    $1, -4(%rbp)</span><br><span class="line">movl    $2, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %ecx</span><br><span class="line">addl    -8(%rbp), %ecx</span><br><span class="line">movl    %ecx, -4(%rbp)</span><br><span class="line">popq    %rbp</span><br><span class="line">c3  retq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:   55</span><br><span class="line">1:   48 89 e5</span><br><span class="line">4:   31 c0 </span><br><span class="line">6:   c7 45 fc 01 00 00 00</span><br><span class="line">d:   c7 45 f8 02 00 00 00</span><br><span class="line">14:   8b 4d fc</span><br><span class="line">17:   03 4d f8</span><br><span class="line">1a:   89 4d fc</span><br><span class="line">1d:   5d</span><br><span class="line">1e:   c3</span><br></pre></td></tr></table></figure><h3 id="解析指令和机器码"><a href="#解析指令和机器码" class="headerlink" title="解析指令和机器码"></a>解析指令和机器码</h3><p>CPU 常见指令分类：</p><ul><li>算术类指令</li><li>数据传输类指令</li><li>逻辑指令</li><li>条件分支类指令</li><li>无条件跳转指令</li></ul><p>不同的 CPU 对应着不同的指令，也就对应着不同的汇编语言和机器码。</p><p>场景：</p><p>在 Android 开发过程中，我们需要添加第三方 so 库，根据不同的手机需要添加不同的 CPU 架构的 so 包,具体参见资料-<a href="****">Android的.so文件、ABI和CPU的关系</a></p><p>除了 C 这样的编译型语言之外，不管是 Python 这样的解释型语言，还是像 Java 这样使用虚拟机的语言，最终都是把写好的代码转换为 CPU 理解的机器码来执行。</p><p>解释型的语言，通过解释器在程序运行的时候逐句翻译，而 Java 这样 <strong>使用虚拟机的语言</strong>，则由虚拟机对编译出来的中间代码(.class)进行解释，或者即时编译成为机器码来最终执行。</p><p><strong>运行编译型语言：</strong> 是相对于解释型语言存在的，编译型语言的首先将源代码编译生成机器语言，再由机器运行机器码（二进制）。像C/C++等都是编译型语言。编译型语言程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等.  </p><p><strong>解释性语言</strong> 编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。&lt;/p&gt;
&lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;p&gt;CPU 是计算机的大脑，Central Processing Unit，中文为 &lt;strong&gt;中央处理器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。&lt;/p&gt;
&lt;p&gt;从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 &lt;strong&gt;机器语言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 &lt;strong&gt;计算机指令&lt;/strong&gt;。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。&lt;/p&gt;
&lt;p&gt;一个计算机程序编译后，有很多的计算机指令。&lt;br&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之WorkManager基本了解</title>
    <link href="/2019/05/14/Jetpack%E4%B9%8BWorkManager%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/14/Jetpack之WorkManager笔记/</id>
    <published>2019-05-14T07:15:58.000Z</published>
    <updated>2019-05-23T02:54:04.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。</p><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><ul><li><p>向后兼容到 API 14</p><ul><li>在 API 23+ 的设备上使用 JobScheduler。</li><li>在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。</li></ul></li><li><p>为网络或获取充电状态添加约束</p></li><li><p>安排一次性异步任务或定期任务  </p></li><li><p>监控和管理计划任务</p></li><li><p>链接多个任务</p></li><li><p>即使应用程序或设备重新启动，也可确保任务执行</p></li><li><p>坚持Doze模式等省电模式</p></li></ul><a id="more"></a><p>WorkManager 适用于可延迟的任务-即不需要立即运行，即使应用程序退出或设备重新启动也需要可靠运行的情况。例如：</p><ul><li>将日志或分析发送到后端服务</li><li>定期将应用程序数据与服务器同步</li></ul><p>WorkManager 不适用于在应用程序进程消失时，安全退出的后台工作，也不适用于需要立即执行的任务。</p><h3 id="使用-Work"><a href="#使用-Work" class="headerlink" title="使用 Work"></a>使用 Work</h3><ol><li>通过 Work 来定义 任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UploadWorker(context:Context,workerParameters: WorkerParameters):Worker(context,workerParameters) &#123;</span><br><span class="line"></span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        return Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过 WorkRequest 来管理 任务怎样以及何时运行任务。</p><ul><li><p>对于一次性的 WorkRequest ，使用  OneTimeWorkRequest。</p></li><li><p>对于定时 WorkRequest，使用 PeriodicTimeWorkRequest。</p><p>WorkRequest 还可以包含其他信息，例如任务运行的约束条件，工作输入，延迟以及重试工作的退避策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;().build()</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>将您的任务交给系统。</li></ol><p>Work 执行的确切时间取决于 WorkRequest 和系统优化中使用的约束。WorkManager 旨在根据这些限制提供最佳行为。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance().enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure><h3 id="Work、WorkRequest、WorkManager-关系"><a href="#Work、WorkRequest、WorkManager-关系" class="headerlink" title="Work、WorkRequest、WorkManager 关系"></a>Work、WorkRequest、WorkManager 关系</h3><p>Work 定义任务, WorkRequest 基于 Work 创建 执行任务的请求，WorkManager 作为管理者执行 任务请求。</p><h3 id="定义-WorkRequest"><a href="#定义-WorkRequest" class="headerlink" title="定义 WorkRequest"></a>定义 WorkRequest</h3><h4 id="为-WorkRequest-添加约束条件"><a href="#为-WorkRequest-添加约束条件" class="headerlink" title="为 WorkRequest 添加约束条件"></a>为 WorkRequest 添加约束条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Create a Constraints object that defines when the task should run</span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(true)</span><br><span class="line">        .setRequiresCharging(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">// ...then create a OneTimeWorkRequest that uses those constraints</span><br><span class="line">val compressionWork = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>当所有的约束条件满足时，work 会执行。如果在执行 work 过程中不再满足约束条件，那么 WorkManager 会停止 work 的执行，等待约束条件满足后再次执行 work。</p><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>以下是将任务设置为在排队后至少10分钟后运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInitialDelay(10, TimeUnit.MINUTES)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。&lt;/p&gt;
&lt;h3 id=&quot;feature&quot;&gt;&lt;a href=&quot;#feature&quot; class=&quot;headerlink&quot; title=&quot;feature&quot;&gt;&lt;/a&gt;feature&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;向后兼容到 API 14&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 API 23+ 的设备上使用 JobScheduler。&lt;/li&gt;
&lt;li&gt;在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为网络或获取充电状态添加约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安排一次性异步任务或定期任务  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监控和管理计划任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接多个任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即使应用程序或设备重新启动，也可确保任务执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;坚持Doze模式等省电模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java集合之Map</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/"/>
    <id>/2019/05/10/Java集合之Map/</id>
    <published>2019-05-10T10:17:08.000Z</published>
    <updated>2019-05-29T10:18:07.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Map 用于保存具有 <strong>映射关系</strong> 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。</p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><p>可以把 Map 里的 Key 放在一起，它们组成一个 <strong>Set 集合</strong>(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 <strong>List 集合</strong>(可重复，此时的索引为 key)。</p><p>如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。</p><a id="more"></a><h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p>HashMap 和 Hashtable 是 Map 的典型实现类。 Hashtable 在 JDK1.0 起就已经存在。在 Java8 时改进了 HashMap 的实现，使其在 HashMap 存在 key 冲突时具有更好的性能。</p><p>Hashtable 与 HashMap 主要区别：</p><ul><li>Hashtable: <strong>线程安全</strong> 的 Map 实现，但是 HashMap 是线程不安全的实现，所以 HashMap 的性能更高一些。多个线程访问同一个 Map 对象时，使用 Hashtable 会更好。</li><li>Hashtable 不允许使用 null 作为 key 和 value，否则会引起异常，但是 HashMap 可以。</li></ul><p>为了更好的在 HashMap 和 Hashtable 中存储、获取对象，<strong>用作 key 的对象必须实现 hashCode() 和 equals() 方法</strong>。</p><p>HashMap、Hashtable <strong>key 相同的标准</strong> 是：<strong>两个 key 通过 equals() 方法比较返回为 true，那么两个 key 的 hashcode 值必须相等</strong>。</p><p>HashMap、Hashtable <strong>value 相等</strong> 的标准：只要两个对象的 equals() 方法比较返回为 true 即可。</p><p>与 HashSet 相同，采用自定义类作为 HashMap、Hashtable 的 key，如果程序修改了作为 key 的可变对象，那么也会出现与 HashSet 类似的情形：程序无法准确访问到 Map 中被修改过的 key。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>与 LinkedHashSet 一致，LinkedHashMap 内部也是通过双向链表来维护添加的 key-value 的顺序(以 key 的添加顺序为准)。</p><p>同样的，由于维护链表 LinkedHashMap 的性能比 HashMap 差一些，但是也正是这个原因在遍历 Map 中元素时，LinkedHashMap 的效率更高一些。</p><h3 id="SortedMap-amp-amp-TreeMap"><a href="#SortedMap-amp-amp-TreeMap" class="headerlink" title="SortedMap &amp;&amp; TreeMap"></a>SortedMap &amp;&amp; TreeMap</h3><p>SortedMap 为 Map 派生的一个子接口，而 TreeMap 为 SortedMap 的一个实现类。</p><p>TreeMap 是一个红黑树结构，每个 key-value 为红黑树的一个节点，而 TreeMap 存储数据时，是以 key 为标准对 key-value 进行排序。</p><p>TreeMap 的两种排序方式：</p><ul><li><p>自然排序</p><p>  TreeMap 的所有的 key 必须实现 Comparable 接口，而且所有的 key 必须为同一个类的对象，否则会报 ClassCastException 。</p><p>  key 相同的标准为：两个 key 通过 compareTo() 方法返回 0，则认为相等。</p></li><li><p>定制排序</p><p>  在 创建 TreeMap 时，传入 Comparator 对象，该对象负责对 key 进行排序，此时 key 不要求实现 Comparator 接口。 </p><p>  如果想让排序更加顺利的进行，那么需要重写 key 对应类的 equal() 方法，并且 equal() 方法的返回值与 compareTo() 的返回值表达的结果一致，否则将于 Map 接口规则冲突。</p></li></ul><p><strong>自然排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Bean implements Comparable &#123;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (this == obj) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj != null &amp;&amp; obj.getClass() == Bean.class) &#123;</span><br><span class="line">            Bean bean = (Bean) obj;</span><br><span class="line">            return age == bean.age;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object obj) &#123;</span><br><span class="line">        Bean bean = (Bean) obj;</span><br><span class="line">        return Integer.compare(age, bean.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap();</span><br><span class="line">Bean bean = new Bean(1, &quot;mike&quot;);</span><br><span class="line">Bean bean2 = new Bean(4, &quot;mike2&quot;);</span><br><span class="line">Bean bean3 = new Bean(3, &quot;mike3&quot;);</span><br><span class="line">Bean bean4 = new Bean(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><p>TreeMap 按照 Bean 重写的 compareTo() 规则进行排序，注意重写的 equal() 需要满足以上逻辑。</p><p><strong>定制排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap((o1, o2) -&gt; &#123;</span><br><span class="line">    Bean2 bean = (Bean2) o1;</span><br><span class="line">    Bean2 bean2 = (Bean2) o2;</span><br><span class="line">    return Integer.compare(bean.getAge(), bean2.getAge());</span><br><span class="line">&#125;);</span><br><span class="line">Bean2 bean = new Bean2(1, &quot;mike&quot;);</span><br><span class="line">Bean2 bean2 = new Bean2(4, &quot;mike2&quot;);</span><br><span class="line">Bean2 bean3 = new Bean2(3, &quot;mike3&quot;);</span><br><span class="line">Bean2 bean4 = new Bean2(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>观字识意，WeakHashMap 与 HashMap 的区别是 WeakHashMap 中存在弱引用。</p><p>WeakHashMap 中的 key 只保留了对实际对象的弱引用，如果 WeakHashMap 对象的 key 引用的对象没有被其它强引用的变量引用，那么 key 所引用的对象在垃圾回收时很有可能被销毁，同时 WeakHashMap 也会自动移除 key 对应的 key-value 键值对。</p><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 中的所有的 key 必须是 单个枚举类中的枚举值。创建 EnumMap 对象时需要指定其对应的枚举类。</p><p>EnumMap 的特征：</p><ul><li>EnumMap 内部以数组的形式保存，所以高效。</li><li>EnumMap 根据 key 的自然排序(枚举类中枚举值的定义顺序)维护 key-value 的顺序。</li><li>EnumMap key 不可为 null。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enum Num&#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumMap enumMap = new EnumMap(Num.class);</span><br><span class="line">enumMap.put(Num.TWO,&quot;two&quot;);</span><br><span class="line">enumMap.put(Num.ONE,&quot;one&quot;);</span><br><span class="line">enumMap.put(Num.THREE,&quot;three&quot;);</span><br><span class="line">sout(enumMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ONE=oen,TWO=two,THREE=three&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>Hashtable 和 HashMap 的内部实现机制几乎一样，但是由于 Hashtable 为线性安全的集合，所以 HashMap 要比 Hashtable 要快。</p><p>TreeMap 的内部通过红黑树来维护添加顺序，所以比 Hashtable、HashMap 要慢(特别是在添加元素、删除元素时，此时需要重新整理红黑树)。同时也是因为内部红黑树 TreeMap 在变量元素时比较高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.binarySearch( treeMap.keySet().toArray(),new Bean(3, &quot;mike3&quot;)));</span><br></pre></td></tr></table></figure><p>一般场景下使用 HashMap，因为 HashMap 为快速查询而设计(底层使用数组存储 key-value)。如果需要对元素进行排序，那么使用 TreeMap。</p><p>由于需要维护内部链表，LinkedHashMap 比 HashMap慢一些，与 HashMap 实现基本一致，但是 LinkedHashMap 使用 == 而不是 equal() 来判断 key 相等。</p><p>EnumMap 性能最好，但是它的 key 只能是枚举值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Map 用于保存具有 &lt;strong&gt;映射关系&lt;/strong&gt; 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_02.jpg&quot; alt=&quot;Map&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以把 Map 里的 Key 放在一起，它们组成一个 &lt;strong&gt;Set 集合&lt;/strong&gt;(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 &lt;strong&gt;List 集合&lt;/strong&gt;(可重复，此时的索引为 key)。&lt;/p&gt;
&lt;p&gt;如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)&lt;/p&gt;
&lt;h3 id=&quot;操作&quot;&gt;&lt;a href=&quot;#操作&quot; class=&quot;headerlink&quot; title=&quot;操作&quot;&gt;&lt;/a&gt;操作&lt;/h3&gt;&lt;p&gt;向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Map" scheme="/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之Queue</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/"/>
    <id>/2019/05/10/Java集合之Queue/</id>
    <published>2019-05-10T09:57:03.000Z</published>
    <updated>2019-05-29T10:18:06.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Queue 用于模拟 “队列” 这种数据结构，队列为 先进先出(First In First Out,FIFO) 的容器。队列可以将元素插入尾部，可以访问位于队列头部的元素，所以队列不能随机访问队列的元素。</p><p>常用的 API：</p><ol><li>void add(Object obj):将指定元素加入队列的尾部。</li><li>boolean offer(Object obj):将指定元素加入队列的尾部。</li><li>Object element(): 获取队列头部的元素，但是不删除该元素。</li><li>Object peek():获取队列头部的元素，不删除该元素。</li><li>Object poll():获取队列头部的元素，并删除该元素。</li><li>Object remove():获取队列头部的元素，并删除该元素。<a id="more"></a></li></ol><p>Queue 有 PriorityQueue 实现类，同时 Queue 还有一个 Deque 接口，Deque 代表一个 “双端队列”，双端队列可以在两端进行添加、删除元素，Deque 的实现类既可以当做队列来使用也可以当做栈来使用，其有两个实现类： ArrayDeque、LinkedList。</p><h3 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h3><p>PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按队列元素的大小进行重新排序。而其排序方式有：自然排序和定制排序。两种排序规则的实现与 TreeSet 相同，不赘述。</p><h3 id="Deque-接口与-ArrayDeque-实现类"><a href="#Deque-接口与-ArrayDeque-实现类" class="headerlink" title="Deque 接口与 ArrayDeque 实现类"></a>Deque 接口与 ArrayDeque 实现类</h3><p>Deque 为 Queue 的子接口，代表了一个 <strong>双端队列</strong>，可以在双端添加、删除数据的，具体操作可以查看 Deque 的 Api。</p><p>与 Queue 方法不同为以上方法可以拆分为 xxxFirst()、xxxLast() 方法，代表对队列的两端进行的处理。</p><p>我们可以把 Deque 当做 <strong>队列</strong> 使用，也可以当做 <strong>栈</strong> 来使用。</p><p>与 ArrayList 相同，它们底层都是采用 <strong>一个动态的、可重新分配的 Objectp[] 数组</strong> 来存储集合元素。</p><p><strong>把 ArrayDeque 当做 “栈”(Fitst In Last Out,FILO) 来使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    //将 3 个元素 push 入栈</span><br><span class="line">    arrayDeque.push(&quot;one&quot;);</span><br><span class="line">    arrayDeque.push(&quot;two&quot;);</span><br><span class="line">    arrayDeque.push(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 访问第一个元素，但不出栈</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 第一个元素出栈</span><br><span class="line">    System.out.println(arrayDeque.pop());// 实现栈的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[two, one]</span><br></pre></td></tr></table></figure><p>ArrayDeque 很好的实现了 “栈” – <strong>先入后出</strong> 这种数据结构。在程序中使用栈时推荐使用 ArrayDeque ，避免使用 Stack(性能较差)。</p><p><strong>把 ArrayDeque 当做 “队列” 来使用</strong></p><p>当然 ArrayDeque 也可以当做队列使用，使用 <strong>先进先出</strong> 的方式操作集合元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void test3() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    // 将 3 个元素加入队列</span><br><span class="line">    arrayDeque.offer(&quot;one&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;two&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.poll());//实现队列的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[two, three]</span><br></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList 是 List 的实现类，同时它也实现了 Deque 接口，所以 LinkedList 可以 根据 <strong>索引</strong> 来随机访问集合的元素，也可以被当做 <strong>双端队列</strong><br> 来使用，由此可见 LinkedList <strong>既可以当做队列也可以当做栈来使用</strong>。</p><p>LinkedList 内部实现机制与 ArrayList 、 ArrayDeque 不同，后两者内部维护动态、可扩容的 Object[] 数组，<strong>因此访问随机集合元素的性能较高</strong>；LinkedList 内部以 <strong>链表</strong> 的形式来保存集合中的元素，因此随机访问集合元素的性能较差，但是在 <strong>插入、删除集合元素性能较高(只需改变指针所指的地址)</strong>。</p><h3 id="各种线性表的性能表现"><a href="#各种线性表的性能表现" class="headerlink" title="各种线性表的性能表现"></a>各种线性表的性能表现</h3><p>Java 中 List 是一个线性表接口，最具代表性的实现类为：ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)。Queue 代表了队列，Deque 代表了双端队列。</p><p>由于数组以一块连续内存来保存数组元素，所以数组的随机访问的性能较好，那么以数组为底层实现的集合在随机访问时性能较好；而内部以链表为顶层实现的集合在添加、删除集合元素时有较好的性能。总体上 ArrayList 的性能比 LinkedList 的性能较好，因此大部分时候选用 ArrayList。</p><p>关于使用 List 几点建议：</p><ol><li>遍历 List 集合。对于 ArrayList 、ArrayDeque 等底层实现为数组集合使用随机访问来遍历元素，这样性能更好；而对于 LinkedList 则应该使用 Itertor 迭代器来遍历集合元素。</li><li>经常添加、删除元素操作的集合，可考虑 LinkedList。使用 ArrayList、Vector 集合可能需要经常重新分配内部数组的大小，性能较差。</li><li>多个线程访问 List 集合，可以使用 Collections 工具类对集合进行包装来实现线程安全。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Queue 用于模拟 “队列” 这种数据结构，队列为 先进先出(First In First Out,FIFO) 的容器。队列可以将元素插入尾部，可以访问位于队列头部的元素，所以队列不能随机访问队列的元素。&lt;/p&gt;
&lt;p&gt;常用的 API：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;void add(Object obj):将指定元素加入队列的尾部。&lt;/li&gt;
&lt;li&gt;boolean offer(Object obj):将指定元素加入队列的尾部。&lt;/li&gt;
&lt;li&gt;Object element(): 获取队列头部的元素，但是不删除该元素。&lt;/li&gt;
&lt;li&gt;Object peek():获取队列头部的元素，不删除该元素。&lt;/li&gt;
&lt;li&gt;Object poll():获取队列头部的元素，并删除该元素。&lt;/li&gt;
&lt;li&gt;Object remove():获取队列头部的元素，并删除该元素。
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Queue" scheme="/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之List</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/"/>
    <id>/2019/05/10/Java集合之List/</id>
    <published>2019-05-10T08:59:47.000Z</published>
    <updated>2019-05-29T11:00:52.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>List 集合为元素有序、可重复的集合。</p><p>List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。</p><p>实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new ClassE(2));</span><br><span class="line">        list.add(new ClassE(1));</span><br><span class="line">        list.add(new ClassE(3));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.sort((o1, o2) -&gt;</span><br><span class="line">            ((ClassE)o1).getNum() -((ClassE)o2).getNum()</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ClassD&#123;num=2&#125;, ClassD&#123;num=1&#125;, ClassD&#123;num=3&#125;]</span><br><span class="line">[ClassD&#123;num=1&#125;, ClassD&#123;num=2&#125;, ClassD&#123;num=3&#125;]</span><br></pre></td></tr></table></figure><a id="more"></a><p>迭代遍历：</p><p>与 Set 集合只提供了 iterator() 方法不同，List 还提供了 listiterator() 方法，返回一个 ListIterator 对象， ListIterator 接口继承了 Itertor 接口，提供了专门操作 List 的方法。</p><p>ListIterator 在遍历过程中可以通过 add() 方法向上一个迭代元素后面添加一个新的元素,如果 list 对象为排过序的集合，以上操作不会触发再次排序，而 Itertor 只能实现删除元素的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListIterator listIterator = list.listIterator();</span><br><span class="line">int a = 6;</span><br><span class="line">while (listIterator.hasNext()) &#123;</span><br><span class="line">    ClassE classE = (ClassE) listIterator.next();</span><br><span class="line">    if (classE.getNum() == 3) &#123;</span><br><span class="line">        listIterator.add(new ClassE(6));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;listIterator &quot; + classE.toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>打印日志为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listIterator ClassE&#123;num=1&#125;</span><br><span class="line">listIterator ClassE&#123;num=2&#125;</span><br><span class="line">listIterator ClassE&#123;num=3&#125;</span><br><span class="line">[ClassE&#123;num=1&#125;, ClassE&#123;num=2&#125;, ClassE&#123;num=3&#125;, ClassE&#123;num=6&#125;]</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-Vector-类"><a href="#ArrayList-和-Vector-类" class="headerlink" title="ArrayList 和 Vector 类"></a>ArrayList 和 Vector 类</h3><p>ArrayList 和 Vector 在用法上几乎一致， Vector 在 JDK 1.0 就有了，那时候还没有 Java 集合框架的概念。在 JDK 1.2 将 Vector改为实现 List 接口，而 Vector 作为 List 的实现之一。</p><p>ArrayList 和 Vector 作为 List 的典型实现，支持 List 接口的全部功能。</p><p>ArrayList 和 Vector 都是基于数组实现的 List 类，在ArrayList 和 Vector <strong>内部封装了一个动态的、允许再分配的 Object[] 数组</strong>，使用 initiaCapacity 来初始化数组的长度，当数组元素超过数组的长度时，数组长度自动增加 initiaCapacity ,即长度增加 <strong>0.5</strong> 倍。</p><p>线程安全性：</p><ul><li>ArrayList 为线程不安全的，可以使用 Collections 工具类使 ArrayList 变成线程安全的。</li><li>Vector 时线程安全的，所以 Vector 性能比 ArrayList 低， 但是不推荐使用 Vector。</li></ul><h3 id="Vector-的子类-–-Stack"><a href="#Vector-的子类-–-Stack" class="headerlink" title="Vector 的子类 – Stack"></a>Vector 的子类 – Stack</h3><p>Vector 有一个子类 Stack，用于模拟 “栈”  这种数据结构：</p><ol><li>出栈 <ol><li>peek()：返回栈中的第一个元素，但是不将该元素移除。</li><li>pop():返回栈中的第一个元素，会将该元素移除</li></ol></li><li>进栈<ol><li>push(Object obj): 将元素压入栈，该元素位于集合的顶部。</li></ol></li></ol><p><strong>但是也应该尽量的避免使用 Stack，如果需要“栈”这种数据结构，可以使用 ArrayDeque</strong>。</p><p>ArrayDeque 是实现了 List 接口，也实现了 Deque 接口，因此可以作为栈使用，其也是基于数组的实现。</p><h3 id="固定长度的-List"><a href="#固定长度的-List" class="headerlink" title="固定长度的 List"></a>固定长度的 List</h3><p>Java 中有一个操作数组的工具类：<code>Arrays</code>，该工具类的 asList(Object …obj) 方法 <strong>可以把一个数组或指定个数的对象转换成一个 List 集合</strong>，这个 List 不是 ArrayList 或 Vector 的实现类，<strong>而是 Arrays 的内部类 ArrayList 的实例</strong>。 Arrays$ArrayList 为一个固定大小的 List  集合，不可删除或增加集合里的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = Arrays.asList(new Object());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;List 集合为元素有序、可重复的集合。&lt;/p&gt;
&lt;p&gt;List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。&lt;/p&gt;
&lt;p&gt;实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List list = new ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(2));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(3));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.sort((o1, o2) -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ((ClassE)o1).getNum() -((ClassE)o2).getNum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;打印日志：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="List" scheme="/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之Lifecycle 笔记</title>
    <link href="/2019/05/10/Jetpack%E4%B9%8BLifecycle-%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/10/Jetpack之Lifecycle-笔记/</id>
    <published>2019-05-10T02:42:25.000Z</published>
    <updated>2019-07-10T07:25:59.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。</p><p>传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。</p><p><code>android.arch.lifecycle</code> 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。</p><h3 id="0x0001-Lifecycle"><a href="#0x0001-Lifecycle" class="headerlink" title="0x0001 Lifecycle"></a>0x0001 Lifecycle</h3><p>Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，  可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。</p><a id="more"></a><p>Lifecycle 使用两个重要的枚举类来跟踪它所关联的组件的生命周期状态：</p><ul><li><p>Event</p><p>  从 Android Framework 层面和 Lifecycle 类调度的生命周期事件,这些事件映射到 A/F 中的回调事件。</p></li><li><p>State</p><p>  Lifecycle 对象跟踪的组件的当前状态。</p></li></ul><p>下图展示 Event 和 State 的关联关系</p><p><img src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png" alt="Event和Statue"></p><p>在图中 State 作为一个个结点，作为事件间的边缘。</p><p>LifecycleObserver 通过在在其方法上添加注解来监听组件的状态，LifecycleOwner 通过 addObserver() 关联此 Observer 。</p><h3 id="0x0002-LifecycleOwner"><a href="#0x0002-LifecycleOwner" class="headerlink" title="0x0002 LifecycleOwner"></a>0x0002 LifecycleOwner</h3><p>通过实现 LifecycleOwner 接口来 <strong>表明该类具有生命周期</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ComponentActivity extends Activity</span><br><span class="line">        implements LifecycleOwner, KeyEventDispatcher.Component</span><br></pre></td></tr></table></figure><p>LifecycleOwner 只有一个方法 getLifecycle()。</p><p>可见我们最常使用的 AppCompatActivity 已经对 LifecycleOwner 做了兼容。实现 LifecycleObserver 的类作为 <code>观察者</code> 监听实现 实现 LifecycleOwner 接口类的声明周期的变化。</p><p><strong>LiveData 的生命周期相关就是通过这种方式实现的。</strong></p><h3 id="0x0003-自定义-LifecycleOwner"><a href="#0x0003-自定义-LifecycleOwner" class="headerlink" title="0x0003 自定义 LifecycleOwner"></a>0x0003 自定义 LifecycleOwner</h3><p>如果自定义实现 LifecycleOwner ,那么需要使用 LifecycleRegistry ,这个类用来管理多个 LifecycleObserver ,在其内部通过 Map 来存储 LifecycleObserver 对象。</p><p>自定义 LifecycleOwner 时，需要在相应的方法中显示的声明事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : Activity(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(this)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override fun onStart() &#123;</span><br><span class="line">        super.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getLifecycle(): Lifecycle &#123;</span><br><span class="line">        return lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0004-LifecycleObserver"><a href="#0x0004-LifecycleObserver" class="headerlink" title="0x0004 LifecycleObserver"></a>0x0004 LifecycleObserver</h3><p>生命周期的观察者，它的主要作用是监听 LifecycleOwner 对象的生命周期变化，通过注解的方式,将 LifecycleOwner 生命周期的变化映射到自己相应的方法上，并在自己的方法中进行相关业务处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CustomObserver : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun initObserver()&#123;</span><br><span class="line">        Log.e(&quot;initObserver&quot;,&quot;initObserver&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    fun back()&#123;</span><br><span class="line">        Log.e(&quot;back&quot;,&quot;back&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TestLifecycleActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test_lifecycle)</span><br><span class="line">        lifecycle.addObserver(CustomObserver())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-Lifecycle-aware-组件最佳实践"><a href="#0x0005-Lifecycle-aware-组件最佳实践" class="headerlink" title="0x0005 Lifecycle-aware 组件最佳实践"></a>0x0005 Lifecycle-aware 组件最佳实践</h3><ol><li>尽可能保证 UI 组件简单，比如不要在 UI 中获取数据，而在 ViewModel 中做这些事情， LiveData 对象会在数据变化后更新 UI。</li><li>尽可能在 ViewModel 中编写逻辑代码，ViewModel 应该是 UI(A/F) 和其他部分的桥梁。 但是这并不是说 ViewModel 的职责是获取数据，而应该调用其他组件来获取数据并返回 UI。</li><li>使用 DataBinding 来维护 UI 和 View 间关系。这使得可以使用更少的代码来更新 UI 。</li><li>如果 UI 十分复杂，可以考虑创建 presenter 来处理 UI 更改工作，虽然这个过程是费精力的，但是这对测试是十分友好的。</li><li>避免在 ViewModel 中引用 View 和 Context，避免造成内存泄漏。</li><li>使用 Kotlin 的协程来管理长时间运行的任务以及可以异步运行的其他操作。</li></ol><h3 id="0x0006-何时使用-lifecycle-awar-组件"><a href="#0x0006-何时使用-lifecycle-awar-组件" class="headerlink" title="0x0006 何时使用 lifecycle-awar 组件"></a>0x0006 何时使用 lifecycle-awar 组件</h3><ol><li>在粗粒度和细粒度的两种状态的地图切换展示。当 UI 在前台时使用细粒度的地图，在后台时切换为粗粒度的地图。</li><li>暂停和恢复动画。UI 在后台暂停动画，在前台恢复动画。</li></ol><h3 id="0x0007-关于-LiveData-的实现"><a href="#0x0007-关于-LiveData-的实现" class="headerlink" title="0x0007 关于 LiveData 的实现"></a>0x0007 关于 LiveData 的实现</h3><p>LiveData 同为 生命中期感知组件，其实它这种功能的实现主要是依托了 Lifecycle 的实现。在 LiveData 的 obsever() 方法中将 LiveData的 Observer 包装成 LifecycleObserver 并与 LifecycleOwner 相关联，至此 LiveData 实现了生命周期的感知功能。</p><p>LiveData#observe(@NonNull LifecycleOwner owner, @NonNull Observer<t> observer) 源码：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123;</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // LifecycleOwnner 添加 LifecycleObserver</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上为个人翻译官方文档</p><p>以下为优秀博客：</p><p><a href="https://www.jianshu.com/p/b1208012b268" target="_blank" rel="noopener">Android官方架构组件Lifecycle:生命周期组件详解&amp;原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。&lt;/p&gt;
&lt;p&gt;传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android.arch.lifecycle&lt;/code&gt; 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-Lifecycle&quot;&gt;&lt;a href=&quot;#0x0001-Lifecycle&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Lifecycle&quot;&gt;&lt;/a&gt;0x0001 Lifecycle&lt;/h3&gt;&lt;p&gt;Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，  可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="Lifecycle" scheme="/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合之 Set 集合 </title>
    <link href="/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/"/>
    <id>/2019/05/09/Java-集合之-Set/</id>
    <published>2019-05-09T07:49:35.000Z</published>
    <updated>2019-05-29T10:12:10.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>Set 集合的特点无序、不可重复。</p><p>Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。</p><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>HashSet 集合按 <code>Hash 算法</code> 来存储集合的元素，<strong>因此具有很好的存取和查找功能</strong>。</p><p>HashSet 具有以下特点：</p><ol><li>不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。</li><li>HashSet 不是线程安全的。</li><li>元素可以为 null。</li></ol><a id="more"></a><h3 id="如何存储元素"><a href="#如何存储元素" class="headerlink" title="如何存储元素"></a>如何存储元素</h3><p>当向 HashSet 集合存入一个元素时， HashSet 会调用该对象的 <code>hashcode()</code> 方法来得到对象的 <code>hashcode</code> 值，<strong>然后根据该 hashcode 值决定对象在 HashSet 中的存储位置</strong>。如果两个元素通过 equals() 方法比较返回 true，但是它们的 hashcode() 方法返回值不相等，那么 HashSet 会把它们存储在不同的位置，可以添加成功。</p><h3 id="HashSet-如果定义元素相等"><a href="#HashSet-如果定义元素相等" class="headerlink" title="HashSet 如果定义元素相等"></a>HashSet 如果定义元素相等</h3><p>HashSet 集合判断两个元素相等的标准是：</p><ol><li>两个对象通过 equals() 方法比较相等。</li><li>两个对象的 hashcode() 方法的返回值也相等。</li></ol><p><strong>两者缺一不可</strong>。</p><p>所以当把一个对象放入 HashSet 中时，如果需要重写对象的 equals() 方法，那么也应该重写 hashcode() 方法。<strong>重写两方法的规则是：如果两个对象的 equals() 方法返回 true，这两个对象的 hashcode 也应该相同。</strong></p><p>两个对象的 equals() 方法返回 true，hashcode 返回不同的 hashcode 值，HashSet 会把两个对象保存在 Hash 表的不同位置，两个元素都会添加成功，但是这与 Set 集合的规则冲(元素不可重复)突了。如果是 equals() 方法返回 false，但是 hashcode 值相同，也会导致一些问题：hashcode 相同，HashSet 会尝试将多个元素保存在同一个位置，但又不行(这样的结果就是只剩下一个对象)，所以这样的结果就是在这个位置上通过链式结构来保存多个对象。HashSet 的特点就是通过元素的 hashcode 值来快速定位，而现在 HashSet 对象中有两个以上的元素具有相同的hashcode 值，导致性能下降。</p><h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><p>哈希算法的功能是，他能快速的查找被检索的对象，<strong>hash 算法的价值在于速度</strong>。当查询集合中的某个元素时，hash 算法可以直接根据该元素的 hashcode 值计算出该元素的存储位置，从而快速定位该元素。实现快速定位的原因是 HashSet 通过 hashcode 的值进行存储元素。</p><h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><p>由上面可知 hashCode() 方法对于 HashSet 的重要性，那么针对 hashCode() 方法的重写有如下规则：</p><ol><li>同一个对象多次调用 hashCode 方法应该返回相同的值。</li><li>两个对象通过 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法应返回相同的值。</li><li>对象中用于比较 equals() 方法比较标准的实例变量都应该用于计算 hashCode 值。</li><li>程序把可变对象添加到 HashSet 中之后，尽量不要去修改集合元素中参与计算 hashCode()、equals() 的实例变量，否则会导致 HashSet 无法正确的操作这些集合元素。</li></ol><h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>LinkedHashSet 为 HashSet 的一个子类，LinkedHashSet 也是通过hashcode 的值来决定元素的存储位置，<strong>但同时使用链表维护元素的次序</strong>，使得元素看起来是以插入顺序保存的。因为需要维护元素的插入顺序，所以性能略低于 HashSet。但是在迭代访问 Set 集合中的全部元素时有很好的性能，因为它以链表维护内部顺序。</p><p>遍历 LinkedHashSet 集合元素时，元素的顺序与添加顺序一致。</p><h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>TreeSet 为 SortSet 接口的实现类，其可以确保集合元素处于 <strong>排序状态</strong>。TreeSet 不是根据添加顺序进行排序而是 <strong>根据元素的实际值进行排序</strong>。</p><p>与 HashSet 根据 hash 算法来决定元素的存储位置不同，TreeSet 采用 <strong>红黑树</strong> 的数据结构来存储集合元素。TreeSet 支持两种排序算法：自然排序(默认)和定制排序。</p><h3 id="TreeSet-自然排序"><a href="#TreeSet-自然排序" class="headerlink" title="TreeSet 自然排序"></a>TreeSet 自然排序</h3><p>如果将一个对象添加到 TreeSet 中，那么 <strong>这个对象必须实现 Comparable 接口</strong>，依次来实现排序功能，否则程序会报出异常。</p><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后按升序排列，这就是 TreeSet 的自然排序。</p><p><strong>元素如何存储到集合中</strong></p><p>当把一个元素添加到 TreeSet 集合中， TreeSet 会调用这个对象的 compareTo(Object obj) 方法与集合中的其他元素比较大小，<strong>然后根据红黑树结构找到它的存储位置</strong>。如果两个对象通过 compareTo(Object obj) 方法比较相等，那么新的对象将不会添加到集合中。</p><p>如果想要 TreeSet 能够正常运行，那么 TreeSet 只能添加同一种类型的对象。</p><p><strong>判断集合元素相同</strong></p><p><strong>TreeSet 集合元素相等的唯一标准为：两个对象的 compareTo(Object obj) 方法是否返回 0，返回 0 则认为两个对象相等，反之不相等</strong>。基于以上标准，在重写 equals() 方法时，其返回值需要与 compareTo(Object obj) 的返回结果一致，否则 equals() 方法的返回值没有实际意义。</p><p>通过重写 compareTo(Object obj) 方法，使其不返回 0，此时可以实现将一个对象多次添加到 TreeSet集合中，但是此时集合多个元素均指向一个对象引用，如果对象发生变化，那么集合中的多个元素会同时发生相同变化。</p><p>基于以上描述，在重写对象类的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果，如果equals() 方法返回 true ，那么这两个对象通过 compareTo(Object obj) 方法应该返回 0。</p><p>改变Treeset 集合中的可变元素的实例变量后，这会导致它与其他对象的大小顺序发生改变，但是 TreeSet 不会再次调整它们的顺序。当尝试删除该对象时，TreeSet 也会删除失败。所以基于此原因 <strong>TreeSet 可以删除没有被修改实例变量、且不与其他被修改的实例变量的对象重复的对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeSet treeSet = new TreeSet();</span><br><span class="line">Dog dog1 = new Dog(&quot;mike&quot;,1);</span><br><span class="line">Dog dog2 = new Dog(&quot;mike&quot;,2);</span><br><span class="line">Dog dog3 = new Dog(&quot;mike&quot;,3);</span><br><span class="line">Dog dog4 = new Dog(&quot;mike&quot;,4);</span><br><span class="line">treeSet.add(dog1);</span><br><span class="line">treeSet.add(dog2);</span><br><span class="line">treeSet.add(dog3);</span><br><span class="line">treeSet.add(dog4);</span><br><span class="line">System.out.println(&quot;1 &quot; + treeSet);</span><br><span class="line">treeSet.remove(dog1);</span><br><span class="line">System.out.println(&quot;2 &quot; +treeSet);</span><br><span class="line">Dog showDog = (Dog) treeSet.first();</span><br><span class="line">showDog.setAge(6);</span><br><span class="line">System.out.println(&quot;3 &quot; +treeSet);</span><br><span class="line">System.out.println(&quot;4 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,6)));</span><br><span class="line">System.out.println(&quot;5 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,2)));</span><br><span class="line">System.out.println(&quot;6 &quot; +treeSet.first());</span><br><span class="line">System.out.println(&quot;7 &quot; +treeSet.remove(treeSet.first()));</span><br><span class="line">System.out.println(&quot;8 &quot; +treeSet);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 [Dog&#123;name=&apos;mike&apos;, age=1&#125;, Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">2 [Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">3 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">4 false</span><br><span class="line">5 false</span><br><span class="line">6 Dog&#123;name=&apos;mike&apos;, age=6&#125;</span><br><span class="line">7 false</span><br><span class="line">8 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br></pre></td></tr></table></figure><p>可以看到 日志3 TreeSet 对象并没有重新排序，通过日志 4、5、7 可以对象更改后 TreeSet 无法对其进行删除。</p><h3 id="TreeSet-定制排序"><a href="#TreeSet-定制排序" class="headerlink" title="TreeSet 定制排序"></a>TreeSet 定制排序</h3><p>实现定制排序，则需要在创建 TreeSet 集合对象时结合 Comparator 对象，<strong>并由 Comparator 负责集合元素的排序逻辑</strong>。</p><p>如例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">        TreeSet treeSet = new TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            ClassD classD1 = (ClassD) o1;</span><br><span class="line">            ClassD classD = (ClassD) o1;</span><br><span class="line">            return classD1.getNum() &gt; classD2.getNum() ? -1 : 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(new ClassD(1));</span><br><span class="line">        treeSet.add(new ClassD(-1));</span><br><span class="line">        treeSet.add(new ClassD(0));</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 打印日志：[ClassD&#123;num=1&#125;, ClassD&#123;num=-1&#125;, ClassD&#123;num=0&#125;]</span><br></pre></td></tr></table></figure><p>对于自然排序和定制排序而言，添加到 TreeSet 集合对象中的元素应该为同一种类型的对象，否则会引发 ClassCastException 异常。</p><h3 id="3-EnumSet-类"><a href="#3-EnumSet-类" class="headerlink" title="3. EnumSet 类"></a>3. EnumSet 类</h3><p>EnumSet 是一个专门为枚举类设计的集合类， EnumSet 中的所有的元素都必须是枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式的指定。EnumSet 的集合元素也是有顺序的，<strong>EnumSet 以枚举值在枚举类中的定义顺序来决定集合元素在顺序</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumA &#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void test4() &#123;</span><br><span class="line">        EnumSet enumSet = EnumSet.noneOf(EnumA.class);</span><br><span class="line">        enumSet.add(EnumA.ONE);</span><br><span class="line">        enumSet.add(EnumA.THREE);</span><br><span class="line">        enumSet.add(EnumA.TWO);</span><br><span class="line">        System.out.println(enumSet);</span><br><span class="line">        EnumSet enumSet2 = EnumSet.allOf(EnumA.class);</span><br><span class="line">        System.out.println(enumSet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">// 打印日志：</span><br><span class="line">[ONE, TWO, THREE]</span><br><span class="line">[ONE, TWO, THREE]</span><br></pre></td></tr></table></figure><p>EnumSet在内部以位向量的形式保存，这种存储方式十分的高效，所以 EnumSet 占用的内存小、运行效率高。</p><p><strong>EnumSet 不可添加 null 元素。</strong></p><h3 id="各-Set-集合的性能"><a href="#各-Set-集合的性能" class="headerlink" title="各 Set 集合的性能"></a>各 Set 集合的性能</h3><p>HashSet 和 TreeSet 为 Set 集合的两个典型实现，两者如何选择呢？</p><p>由于 TreeSet 内部需要额外的红黑二叉树维护元素的添加顺序，所以 HashSet 的效率高于 TreeSet。<strong>当需要保持排序的 Set 时才使用 TreeSet，否则使用 HashSet。</strong></p><p>LinkedHashSet 为 HashSet 的子类，对于删除、插入操作 LinkedHashSet 比 HashSet 稍慢一些，这是因为 LinkedHashSet 内部需要维护链表造成的，但正是这个原因，遍历操作时 LinkedHashSet 会更快一些。</p><p>EnumSet 是所有 Set 集合中效率最好的，但是它只能保存他一个枚举类的枚举值作为集合元素。</p><p>Set 的三个实现类 HashSet 、TreeSet、 EnumSet 都是 <strong>线程不安全的</strong>，多个线程操作 Set 集合时需保证线程同步。通常使用 Collections  工具类的 synchronizedSortSet 方法来包装该 Set 集合，此操作最好在创建时进行，以防止对 Set 集合意外的非同步访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet treeSet = Collections.synchronizedSortedSet(new TreeSet((o1,o2)-&gt;&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Set-集合&quot;&gt;&lt;a href=&quot;#Set-集合&quot; class=&quot;headerlink&quot; title=&quot;Set 集合&quot;&gt;&lt;/a&gt;Set 集合&lt;/h3&gt;&lt;p&gt;Set 集合的特点无序、不可重复。&lt;/p&gt;
&lt;p&gt;Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。&lt;/p&gt;
&lt;h3 id=&quot;HashSet-类&quot;&gt;&lt;a href=&quot;#HashSet-类&quot; class=&quot;headerlink&quot; title=&quot;HashSet 类&quot;&gt;&lt;/a&gt;HashSet 类&lt;/h3&gt;&lt;p&gt;HashSet 集合按 &lt;code&gt;Hash 算法&lt;/code&gt; 来存储集合的元素，&lt;strong&gt;因此具有很好的存取和查找功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HashSet 具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。&lt;/li&gt;
&lt;li&gt;HashSet 不是线程安全的。&lt;/li&gt;
&lt;li&gt;元素可以为 null。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Set" scheme="/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合概述</title>
    <link href="/2019/05/09/Java-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <id>/2019/05/09/Java-集合概述/</id>
    <published>2019-05-09T03:06:58.000Z</published>
    <updated>2019-05-29T10:15:36.611Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java<br> 集合来实现常见的数据结构，如堆、栈等。</p><h3 id="Java-集合的分类"><a href="#Java-集合的分类" class="headerlink" title="Java 集合的分类"></a>Java 集合的分类</h3><p> Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：</p><ul><li>List：有序、可重复的集合。</li><li>Set：无序、不可重复的集合。</li><li>Map：具有映射关系的集合。</li><li>Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。</li></ul><p>谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。</p><p>Java 集合可用来 <strong>存储对象</strong>，因此被称为 <strong>容器类</strong>。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。</p><a id="more"></a><h3 id="Java-集合继承树"><a href="#Java-集合继承树" class="headerlink" title="Java 集合继承树"></a>Java 集合继承树</h3><p>Java 集合主要是 Collection 和 Map 的派生类，集合的继承关系如下:</p><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><h3 id="Collection-和-Iterator-接口"><a href="#Collection-和-Iterator-接口" class="headerlink" title="Collection 和 Iterator 接口"></a>Collection 和 Iterator 接口</h3><p>List、Set、Queue 都是继承了 Collection 接口，那么该接口定义的方法都可以操作以上集合。</p><p>集合本就是容器，那么相应的操作：增加、删除、替换、清空等，也就对应了相应的方法。</p><p>Iterator 与 Collection 、Map 不同，Collection 、Map 主要的功能是为了盛放其他对象，而 <strong>Iterator 的主要用于遍历 Collection 集合中的元素</strong>，所以 Iterator 对象也被称为 <strong>迭代器</strong>。</p><p>Itertor 仅用于遍历元素，其本身不能盛放对象的能力，Itertor 对象的创建必须依托于 Collection，没有 Collection 的 Itertor 没有任何价值。</p><p>为了更好的理解 Itertor 看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList();</span><br><span class="line">    list.add(&quot;a&quot;);</span><br><span class="line">    list.add(&quot;b&quot;);</span><br><span class="line">    list.add(&quot;c&quot;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        String str = (String) iterator.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        if (str.equals(&quot;c&quot;))&#123;</span><br><span class="line">            iterator.remove();//2</span><br><span class="line">            // 使用 Itertor 遍历集合时，不可修改集合元素，以下代码引发异常</span><br><span class="line">            //list.remove(str);//3</span><br><span class="line">        &#125;</span><br><span class="line">        str = &quot;Chage&quot;;//1</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[a, b]</span><br></pre></td></tr></table></figure><p>在这里我们看到了一个很有意思的现象，在 <code>代码1</code> 处对迭代变量 str 赋了新值，但是通过打印日志我们看到 list 的元素并没有被改变。</p><p><strong>这是因为 Itertor 在对集合进行遍历时，Itertor 并不是把集合元素本身传给了迭代变量 str，仅仅是把集合元素的值传给 迭代变量 str，所以修改迭代变量 str 的值不会对集合元素有任何影响。</strong></p><p>当通过 <code>Itertor</code> 迭代遍历 <code>Collection</code> 中的集合元素时，Collection 集合中的元素不能被改变，<strong>只有通过 Itertor 的 remove() 方法删除上一次 next() 方法返回的值，否则就会引起 java.util.ConcurrentModificationException 异常</strong>，将 <code>代码2</code> 处替换为 <code>代码3</code> 就会报出异常。</p><h3 id="使用-foreach-遍历集合元素"><a href="#使用-foreach-遍历集合元素" class="headerlink" title="使用 foreach 遍历集合元素"></a>使用 foreach 遍历集合元素</h3><p>同 Itertor 一样，通过 foreach 遍历元素过程中也不能修改集合元素，系统同样也是把集合的元素的值赋值个迭代变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123;</span><br><span class="line">    String value = str;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    if (str.equals(&quot;c&quot;)) &#123;</span><br><span class="line">        // 下面的代码同样也会引起 ConcurrentModificationException 异常</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java&lt;br&gt; 集合来实现常见的数据结构，如堆、栈等。&lt;/p&gt;
&lt;h3 id=&quot;Java-集合的分类&quot;&gt;&lt;a href=&quot;#Java-集合的分类&quot; class=&quot;headerlink&quot; title=&quot;Java 集合的分类&quot;&gt;&lt;/a&gt;Java 集合的分类&lt;/h3&gt;&lt;p&gt; Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：有序、可重复的集合。&lt;/li&gt;
&lt;li&gt;Set：无序、不可重复的集合。&lt;/li&gt;
&lt;li&gt;Map：具有映射关系的集合。&lt;/li&gt;
&lt;li&gt;Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。&lt;/p&gt;
&lt;p&gt;Java 集合可用来 &lt;strong&gt;存储对象&lt;/strong&gt;，因此被称为 &lt;strong&gt;容器类&lt;/strong&gt;。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之LiveData 笔记</title>
    <link href="/2019/05/08/Jetpack%E4%B9%8BLiveData-%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/08/Jetpack之LiveData-笔记/</id>
    <published>2019-05-08T03:21:37.000Z</published>
    <updated>2019-07-10T07:41:28.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x000-概述"><a href="#0x000-概述" class="headerlink" title="0x000 概述"></a>0x000 概述</h3><p>在官方文档中首先对 LiveData 做了一个概述 : <code>LiveData is an observable data holder class</code>, LiveData 是一个 <strong>可观察的</strong> <strong>数据持有者类</strong>。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 <strong>活跃状态下</strong> 更新组件。</p><p>LiveData 认为上述中的 <strong>活跃状态</strong> 为对应的 Observer 处于 <strong>STARTED</strong> 或 <strong>RESUMED</strong> 状态。LiveData 数据更改不会触发非活跃组件的更新。</p><p>LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。</p><h3 id="0x0001-个人理解"><a href="#0x0001-个人理解" class="headerlink" title="0x0001 个人理解"></a>0x0001 个人理解</h3><p>官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:</p><p><code>public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)</code> </p><a id="more"></a><p>第一个参数为 LifecycleOwner 对象，一般为 Activity/Fragment/Servic 对象，第二参数为 Observer 对象，它的重要工作是一个回调– <code>onChanged(T t)</code>，用于更新 UI 等工作。</p><p> LiveData#observe() 方法中完成了对 observer 的包装，并将其添加到 LifecycleOwner 对象观察者列表中，完成了 observer 关联 LifecycleOwner 生命周期的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    assertMainThread(&quot;observe&quot;);</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    ....</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 LiveData 就实现了如下功能；<br>    1. 数据更改时触发处于 ACTIVE 的组件的功能。<br>    2. UI 生命周期变更时，LiveData 会通知 Observer。</p><h4 id="0x0002-LiveData-优点"><a href="#0x0002-LiveData-优点" class="headerlink" title="0x0002 LiveData 优点"></a>0x0002 LiveData 优点</h4><ol><li><p>保证 UI 与 实时数据完美匹配，这种模式下：</p><ol><li>UI 生命周期变更时，LiveData 会通知 Observer。</li><li>LiveData 在数据发生变化时，通知 Observer 对象更新 UI，这就保证了数据在每次变更时 <strong>自动更新 UI</strong>, 而不需要手动的更新 UI。</li></ol></li></ol><ol start="2"><li><p>不会内存泄漏</p><p> Lifecycle 对象销毁后(Activity/Framgent/Service)，Observer 与 Lifecycle 对象 的绑定关系会被移除，这样就不会因为两者的互相引用而导致无法回收对象。</p></li><li><p>不会因为 Activity 的停止而导致崩溃</p><p> Observer 处于 InActive 状态时, 它不会接收到 LiveData 的 Event。根据 LiveData 的相关定义只有在 LifecycleOwner 的状态为 START 或 RESUME 时 Observer 才处于 Active 状态。</p></li><li><p>不再需要手动生命周期处理</p><p> UI组件只是观察相关数据，不会停止或恢复观察。LiveData自动管理生命周期，因为它可以观察到组件的生命周期状态变化。</p></li><li><p>时刻保持最新的数据</p><p> 当 LifecycleOwner 的生命周期从 incative 转换到 active 时，会更新最新的数据。</p></li><li><p>旋转屏幕等配置发生变化时，可以收到最新数据</p></li><li><p>共享数据资源<br>LiveData 对象一致，那么那所持有的数据或资源就可以被多个页面共享。</p></li></ol><h3 id="0x0003-使用-LiveData"><a href="#0x0003-使用-LiveData" class="headerlink" title="0x0003 使用 LiveData"></a>0x0003 使用 LiveData</h3><ol><li>创建 LiveData 对象。</li><li>观察 LiveData 对象，传入 LifecycleOwner 和 Observer ,以 LiveData 为桥梁，创建两者的监听关系。</li><li>变更 LiveData 所持有的数据。</li></ol><p>能够触发 App 组件更新的唯一情况是 LiveData 的数据源发生变化，即</p><pre><code>1. 调用了 LiveData 的 setValue(T)// 在主线程中变更数据2. 调用了 LiveData 的 postValue(T)// 在 Worker 线程执行操作</code></pre><h3 id="0x0004-自定义-LiveData"><a href="#0x0004-自定义-LiveData" class="headerlink" title="0x0004 自定义 LiveData"></a>0x0004 自定义 LiveData</h3><h3 id="1-转换-LiveData"><a href="#1-转换-LiveData" class="headerlink" title="1. 转换 LiveData"></a>1. 转换 LiveData</h3><p>和 Rxjava 相似，通过使用 <code>Transformations</code> 的操作符转换 LiveData 对象。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>该操作符做转换的工作如下：</p><pre><code>LiveData&lt;T&gt; -&gt; LiveData&lt;R&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line">val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; &quot;$&#123;user.name&#125; $&#123;user.lastName&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中通过 map 实现了 LiveData<user> 向 LiveData<string> 的转换。</string></user></p><h4 id="3-switchMap"><a href="#3-switchMap" class="headerlink" title="3. switchMap()"></a>3. switchMap()</h4><p>该操作符做转换的工作如下：</p><pre><code>LiveData&lt;T&gt; -&gt; LiveData&lt;R&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private fun getUser(id: String): LiveData&lt;User&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">val userId: LiveData&lt;String&gt; = ...</span><br><span class="line">val user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure><p>本例中通过 map 实现了 LiveData<string> 向 LiveData<user> 的转换。</user></string></p><p>switchMap 和 map 都实现了 LiveData 所持有数据类型的转换，但是与 map() 不同的 switchMap 的第二个参数 Function 的返回值类型必须为 LiveData。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x000-概述&quot;&gt;&lt;a href=&quot;#0x000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x000 概述&quot;&gt;&lt;/a&gt;0x000 概述&lt;/h3&gt;&lt;p&gt;在官方文档中首先对 LiveData 做了一个概述 : &lt;code&gt;LiveData is an observable data holder class&lt;/code&gt;, LiveData 是一个 &lt;strong&gt;可观察的&lt;/strong&gt; &lt;strong&gt;数据持有者类&lt;/strong&gt;。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 &lt;strong&gt;活跃状态下&lt;/strong&gt; 更新组件。&lt;/p&gt;
&lt;p&gt;LiveData 认为上述中的 &lt;strong&gt;活跃状态&lt;/strong&gt; 为对应的 Observer 处于 &lt;strong&gt;STARTED&lt;/strong&gt; 或 &lt;strong&gt;RESUMED&lt;/strong&gt; 状态。LiveData 数据更改不会触发非活跃组件的更新。&lt;/p&gt;
&lt;p&gt;LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-个人理解&quot;&gt;&lt;a href=&quot;#0x0001-个人理解&quot; class=&quot;headerlink&quot; title=&quot;0x0001 个人理解&quot;&gt;&lt;/a&gt;0x0001 个人理解&lt;/h3&gt;&lt;p&gt;官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&amp;lt;? super T&amp;gt; observer)&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="LiveData" scheme="/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之ViewModle 笔记</title>
    <link href="/2019/05/06/Jetpack%E4%B9%8BViewModle%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/06/Jetpack之ViewModle笔记/</id>
    <published>2019-05-06T03:52:23.000Z</published>
    <updated>2019-07-11T11:18:51.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>ViewModel 是一个设计通过用来存储、管理 UI 相关的数据类。</p><p>ViewModel 类旨在通过生命周期感知的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 <strong>存活</strong> 的状态。</p><p>Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。响应用户的动作系统可能会新建或重建 UI，但是这并不在用户的控制范围内。</p><a id="more"></a><p><strong>面临问题：</strong></p><ol><li><p>如果系统销毁或者新建 UI，则存储在其中的任何与 UI 相关短暂的数据都将丢失。对于简单的数据， Activity 可以在  onSaveInstanceState() 中保存下来，在新建的 Activity 的 onCreate() 方法中重新获得这些数据，但是这方法只适用于数据量较小、可以序列化和反序列化的数据，不使用大量的数据，例如对象列表、Bitmap 列表。</p></li><li><p>另外一个问题是：UI 中频繁的异步任务会占用一些时间返回数据。UI 控制器需要管理这些请求并且保证系统能够在 UI 销毁后回收这些请求，避免潜在的内存泄漏，而管理上述情况会占用大量的资源。</p></li></ol><p>UI 的主要职责是用来展示数据、响应用户的动作或者组件间交流，例如权限请求。让 UI 承担从网络或者数据库获取数据等职责，使得类变的十分的臃肿，同时使 UI 变得难以测试。我们不应该为 UI 分配过多的职责，不能让一个类去处理所有的工作，而不是将工作委托给其他类。这其实是 MVC、MVP、MVVM 这些架构演进的重要原因。</p><p>将视图数据所有权与 UI 控制器逻辑分离，使逻辑更加简单、更易于维护。</p><h3 id="0x0001-ViewModel-使用"><a href="#0x0001-ViewModel-使用" class="headerlink" title="0x0001 ViewModel 使用"></a>0x0001 ViewModel 使用</h3><p>ViewModel 的主要职责是为 UI 提供数据，Activity 重建后会复用第一次建立 Activity 的 ViewModel 对象。与之前的写法不同，现在我们需要将获取到的数据保存到 ViewModel，这样就保证数据在当前 Activity 重建后可以复用数据。</p><p>官方文档示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData().also &#123;</span><br><span class="line">            loadUsers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">        return users</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun loadUsers() &#123;</span><br><span class="line">        // Do an asynchronous operation to fetch users.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        // Create a ViewModel the first time the system calls an activity&apos;s onCreate() method.</span><br><span class="line">        // Re-created activities receive the same MyViewModel instance created by the first activity.</span><br><span class="line"></span><br><span class="line">        val model = ViewModelProviders.of(this).get(MyViewModel::class.java)</span><br><span class="line">        model.getUsers().observe(this, Observer&lt;List&lt;User&gt;&gt;&#123; users -&gt;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the activity is re-created, it receives the same MyViewModel instance that was created by the first activity。<br>当 ViewModel 的宿主 Activity 销毁后，系统会调用 ViewModel 对象的 onCleared() 方法，用来清除资源。</p><p><strong>ViewModel 禁止引用 View、Lifecycle 以及其他任何引用 Activity 环境变量的对象。</strong></p><p>ViewModel 旨在创建超过 View 或 LifecycleOwners 对象生命周期的对象。这使得你可以更加容易的测试 ViewModel ，因为不需要知道 View 或 Lifecycle 对象。</p><p>ViewModel 可以持有 LifecycleObserver ，例如 LiveData 对象。但是 ViewModel 对象不能观察到生命周期感知的可观察对象（例如LiveData对象）的更改。</p><p>如果 ViewModel 需要 Application 上下文，例如查找系统服务，可以使用 ViewModel 的子类 AndroidViewModel 类，并在构造函数中传入 Application 对象。</p><h3 id="0x0002-ViewModel-的生命周期"><a href="#0x0002-ViewModel-的生命周期" class="headerlink" title="0x0002 ViewModel 的生命周期"></a>0x0002 ViewModel 的生命周期</h3><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="ViewModel 的生命周期"></p><p>You usually request a ViewModel the first time the system calls an activity object’s onCreate() method. The system may call onCreate() several times throughout the life of an activity, such as when a device screen is rotated. The ViewModel exists from when you first request a ViewModel until the activity is finished and destroyed.</p><p>ViewModel 会在 Activity 第一次创建存在，直到该 Activity 被彻底销毁不再重建。</p><p>获取 ViewModel 对象时，ViewModel 对象的范围限定为传递给ViewModelProvider 的对象的生命周期。</p><hr><p>有问题欢迎点击：<a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;ViewModel 是一个设计通过用来存储、管理 UI 相关的数据类。&lt;/p&gt;
&lt;p&gt;ViewModel 类旨在通过生命周期感知的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 &lt;strong&gt;存活&lt;/strong&gt; 的状态。&lt;/p&gt;
&lt;p&gt;Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。响应用户的动作系统可能会新建或重建 UI，但是这并不在用户的控制范围内。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="ViewModle" scheme="/tags/ViewModle/"/>
    
  </entry>
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/2019/05/06/TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>/2019/05/06/TCP-的三次握手和四次挥手/</id>
    <published>2019-05-06T03:35:16.000Z</published>
    <updated>2019-05-07T07:25:45.260Z</updated>
    
    <content type="html"><![CDATA[<p>TCP 协议做的是：在算法层面保证可靠性。</p><p>有关可靠性的指标：</p><ul><li>保证顺序</li><li>不丢包</li><li>维护 TCP 连接</li><li>流量控制</li><li>拥塞控制</li></ul><p>为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：</p><a id="more"></a><p><img src="/../images/2019_05_06_01.jpg" alt="TCP 包头格式"></p><h3 id="TCP-三次握手基本流程"><a href="#TCP-三次握手基本流程" class="headerlink" title="TCP 三次握手基本流程"></a>TCP 三次握手基本流程</h3><p>为了更好的理解 TCP 三次握手，来看一下生活中场景(A、B 两人彼此自我介绍的场景):</p><hr><p><strong>1、A (A -&gt; B):</strong> 你好，我是 A(此时 A 不知道 B 是否收到自己的介绍，所以 A 现在等待 B 的 <strong>应答</strong>)。</p><p><strong>2、B (B -&gt; A):</strong> 你好，我是 B(此时 B 不知道 A 是否收到自己的介绍，所以 B 现在等待 A 对自己的应答进行应答，可称为 <strong>应答之应答</strong>)。</p><p><strong>3、A (A -&gt; B):</strong> 你好 B (此时 A 已经知道了 B，同时 B 也知道了 A , A 认为双方建立了连接，即使此次数据发送失败，当 A 开始发送数据时，也可完成连接)。</p><hr><p>以上情况是在比较顺畅的情况两人建立了友谊关系，当然也会存在异常情况，如下几种：</p><h4 id="异常情况一"><a href="#异常情况一" class="headerlink" title="异常情况一"></a>异常情况一</h4><p>步骤一中 A 发送的数据包丢失，因为各种原因：丢失、绕路、B 没有响应等情况，无法进入到步骤二，由于 A 没有收到发送数据包的应答，所以 A 会再次发送数据包，如果还是无法收到应答，还会再发。</p><h4 id="异常情况二"><a href="#异常情况二" class="headerlink" title="异常情况二"></a>异常情况二</h4><p>A 发送的请求到达 B ,此时 B 已经知道了 A 的存在，如果 B 想要建立连接，就会发送应答给 A；如果 B 不想建立连接，就不会发送应答，A 在尝试发送数据包一段时间后就会放弃，此时建立连接失败。</p><h4 id="异常请求三"><a href="#异常请求三" class="headerlink" title="异常请求三"></a>异常请求三</h4><p>在 A 多次发送请求数据包时，各步骤终于顺畅的进行下去，A、B 建立连接。 在两者进行短暂的交流后结束了谈话后，此时结束了连接，但是此时 A 建立连接时发送的数据包经过一段时间的绕路后，来到了 B ，如果 B 认为这是一个正常的请求的话建立了连接，此时这个连接不会进行下去，但是也不会有结束的时候，极大的浪费了网络资源。</p><p>这个异常情况在说明了 <strong>两次握手是不可以的</strong>。</p><h4 id="异常情况四"><a href="#异常情况四" class="headerlink" title="异常情况四"></a>异常情况四</h4><p>B 发送的应答可能会发送多次，但是只要有一次到达了 A ，那么 A 就会认为已经建立了连接，因为 <strong>对于 A 来说消息有去有回</strong>。当 A 为此次应答发送的应答到达 B 后，B 就认为已经建立了连接，因为 <strong>对于 A 来说消息也是有去有回</strong>。</p><p>但是此时也会出现异常情况，如果 A 发送的应答消息丢失。按理来说，针对每一个应答都会有对方的应答之应答，依次循环往复，那么多少次握手都是可以的，但是并不能保证连接都是可靠的，所以 <strong>只要保证 A、B 双方的消息都有去有回就可以了</strong>，这也是为什么 <strong>TCP 建立连接需要三次握手的原因</strong> 了。</p><p>如果 A 发送的应答丢失了，此时对于 B 是怎样的情况？ 好在 A 在建立连接后就会发送数据，如果 A 发送的应答丢失了，后续 A 发送的数据到了 B，那么 B 就会认为已经建立了连接；如果 B 出现异常，那么 A 发送的数据会报错，说 B 是不可达的，A就知道了 B 出现了异常，就会做出相应的处理。</p><p>至此 TCP 三次握手过程大致梳理清楚了。</p><h3 id="TCP-数据包的序号问题"><a href="#TCP-数据包的序号问题" class="headerlink" title="TCP 数据包的序号问题"></a>TCP 数据包的序号问题</h3><p>TCP 三次握手处理建立连接外，主要还是为了沟通一件事情：  <strong>TCP 包的序号问题。</strong></p><p>A 需要告诉 B 自己发送的包的序号的起始是从哪个号开始的，同理 B 也要做相同的事情。</p><p>为什么序号不能都从 1 开始呢？</p><p>针对这个问题，我们来看一个场景：</p><p>A 发送 1、2、3 包给 B，1、2 安全可靠的到达 B，包 3 由于各种原因绕了原路，没有到达 B ，此时 A 短暂掉线，后重新连接，发送的数据序号从 1 开始，然后发送 2，至此该发送过程结束，但是绕路的 3 数据包有回来了，此时 B 认为它是一个正常包，于是产生了错误。</p><p>所以每个连接都要有不同的序号，这个序号的起始序号是随时间变化的，可以认为一个 32 位计数器，每 4ms 加 1，重复的序列号至少需要 4 h，此时由于 IP 包头中 TTL 的存在，绕路的包已经在该时间内就不复存在了。</p><p><strong>正是因为 TCP 序号的机制，才保证了 TCP 连接过程中的保证顺序、不丢包的指标。</strong></p><h3 id="TCP-三次握手中的状态机"><a href="#TCP-三次握手中的状态机" class="headerlink" title="TCP 三次握手中的状态机"></a>TCP 三次握手中的状态机</h3><p>在建立 TCP 连接时，为了维护这个连接，双方需要维护一个状态机<a href="状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。">^1</a>，在建立连接过程中，双方的状态变化时序图如下：</p><p><img src="/../images/2019_05_07_01.jpg" alt="状态时序图"></p><ol><li>Client 和 Server 均处于 CLOSED 状态，此时 Server <span style="color: #5bdaed;font-weight: bold;">主动</span> 监听某个端口号。</li><li>Client 主动发起连接 SYN ,之后 Client 处于 SYN-SENT 状态。</li><li>Server 收到 Client 发起的连接，返回 SYN，并且 ACK Client 的 SYN，之后 Server 进入到 SYN-RCVD 状态。</li><li>Client 收到 Server 发送的 SYN 和 ACK，发送 ACK 的 ACK ,之后 Client 进入 ESTABLISHED 状态，因为它一发一收成功了。</li><li>Server收到 ACK 的ACK 后，进入 ESTABLISHED 状态，因为它一发一收成功了。</li></ol><hr><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>使用上面同样的例子，A、B 相同认识，进行简单的交流后，挥手说再见，各回各家。</p><p><strong>1、A (A -&gt; B):</strong> B ,我不能和你再聊了，我要回家了。<br><strong>2、B (B -&gt; A):</strong> 好的 A，我知道了。</p><p>此时只是 A 单方面的不想再聊，即 A 在此后不会发送数据了。但是 B 不能再应答 A 之后马上就关闭连接，为什么呢？因为在此状况下，只是 A 在发送数据后不再发送数据了，B 还有自己没有做完的事情，此时 B 还是可以发送数据的，此时处于 <strong>半关闭状态</strong>。</p><p><strong>此时 A 可以选择不再接收数据，也可以选择最后在接收一段数据，等待 B 也主动关闭。</strong></p><p><strong>3、B (B -&gt; A):</strong> A 我也不玩了，Bye。<br><strong>4、A (A -&gt; B):</strong> 好的，Bye。</p><p>这样整个连接就关闭了，如建立连接时存在异常，同样关闭连接也会存在异常，如下：</p><h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>A 在说完“我不和你聊天了”，直接跑路，这是是会出现问题的，因为 B 还没发起结束，就算发起了，也得不到回答，此时 B 不知道怎么办。</p><p>还有一种异常情况是，当 A 说完 “我不和你聊天了， B 直接跑路，A 的发送的数据包没有得到应答，它不知道 B 是在处理自己的事情还是等一会发送结束。</p><h3 id="TCP-四次挥手的时序图"><a href="#TCP-四次挥手的时序图" class="headerlink" title="TCP 四次挥手的时序图"></a>TCP 四次挥手的时序图</h3><p><img src="/../images/2019_05_07_02.jpg" alt="四次挥手时序图"></p><ol><li><p>Clinet 自己断开连接，发送 FIN 后进入 FIN-WAIT-1 状态。</p></li><li><p>Server 收到 Client 的 FIN 请求，发送 FIN 的 ACK ，Server 进入 CLOSED-WAIT 的状态。</p></li><li><p>Client 收到 Server 的 ACK 后进入 FIN-WAIT-2 的状态。</p><p>若这个时候 Server 跑路，那么 A 将永远处在 FIN-WAIT-2 状态，TCP 协议没有对这个状态处理，但是 Linux 可以调整 tcp_fin_timeout 参数，来设置超时时间。</p></li><li><p>Server 发送 FIN 的请求到达 Client , Client 发送该请求的 ACK ,然后结束了 FIN-WAIT-2 状态，按理说 Client 可以跑路了，但是万一自己发送的 ACK 没有成功到达 Server 怎么办？如果是这样的情况，Server 在一段时间后会重新发送 FIN 请求，但是 Client 已经跑路了，Server 永远也收不到 ACK 了。基于此原因 TCP 协议要求 Cleint 在最后需要等待一段时间 TIME-WAIT ,这个时间需要足够长，长到下面的步骤能够成功执行。</p><p> 如果 Server 超过了 2MSL 依然没有收到 ACK ，虽然 Server 会重发 FIN ，但是 Client 收到这个数据包后表示我已经等待了这么长时间，也够意思了，朋友再见，发送 RST 请求，Server 收到这个请求后就知道 Client 已经跑路了。</p></li></ol><p>MSL(Maximum Segment Lifetime)，报文最大生存时间，它是报文在网络中存在的最大时间，超过这个时间报文会被丢弃。</p><p>IP 头中有 TTL域，IP 数据包每经过一个处理它的路由器后，该值减 1，此值为 0 是数据包被丢且。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP 协议做的是：在算法层面保证可靠性。&lt;/p&gt;
&lt;p&gt;有关可靠性的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证顺序&lt;/li&gt;
&lt;li&gt;不丢包&lt;/li&gt;
&lt;li&gt;维护 TCP 连接&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络协议" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="TCP" scheme="/tags/TCP/"/>
    
      <category term="趣谈网络协议(刘超)" scheme="/tags/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%88%98%E8%B6%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="/2019/04/30/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>/2019/04/30/Java-反射/</id>
    <published>2019-04-30T02:35:03.000Z</published>
    <updated>2019-05-29T10:12:06.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据一个对象获得一个类"><a href="#根据一个对象获得一个类" class="headerlink" title="根据一个对象获得一个类"></a>根据一个对象获得一个类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;adb&quot;;</span><br><span class="line">Class class = str.getClass();</span><br></pre></td></tr></table></figure><h2 id="根据一个字符串获得一个类"><a href="#根据一个字符串获得一个类" class="headerlink" title="根据一个字符串获得一个类"></a>根据一个字符串获得一个类</h2><p>字符串需要包括完整的包名和类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">Class class2 = Class.forName(&quot;android.widget.Button&quot;);</span><br><span class="line"></span><br><span class="line">// 获得对象的父类型</span><br><span class="line">Class class3 = class2.getSuperClass();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h2><h3 id="实例类"><a href="#实例类" class="headerlink" title="实例类"></a>实例类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private String name = &quot;default&quot;;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String tag;</span><br><span class="line"></span><br><span class="line">    public TestClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestClass(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String showName(String string) &#123;</span><br><span class="line">        return name + &quot; &amp;&amp; &quot; + string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void testStaticsMethod() &#123;</span><br><span class="line">        System.out.println(&quot;testStaticsMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printStatics()&#123;</span><br><span class="line">        System.out.println(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TestClass&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得所有构造函数"><a href="#获得所有构造函数" class="headerlink" title="获得所有构造函数"></a>获得所有构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestClass testClass = new TestClass();</span><br><span class="line">Class clazz = testClass.getClass();</span><br><span class="line">String className = clazz.getName();</span><br><span class="line">// 获得所有的构造函数</span><br><span class="line">Constructor[] classList = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 获得所有 public 构造函数</span><br><span class="line">Constructor[] classList2 = clazz.getConstructors();</span><br></pre></td></tr></table></figure><h3 id="获得无参构造函数"><a href="#获得无参构造函数" class="headerlink" title="获得无参构造函数"></a>获得无参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">// 获得 public 无参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br></pre></td></tr></table></figure><h3 id="获得有参构造器"><a href="#获得有参构造器" class="headerlink" title="获得有参构造器"></a>获得有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line"></span><br><span class="line">// 获得指定的 public 有参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor(params);</span><br></pre></td></tr></table></figure><h2 id="调用类的构造器"><a href="#调用类的构造器" class="headerlink" title="调用类的构造器"></a>调用类的构造器</h2><h3 id="调用无参构造器"><a href="#调用无参构造器" class="headerlink" title="调用无参构造器"></a>调用无参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure><h3 id="调用有参构造器"><a href="#调用有参构造器" class="headerlink" title="调用有参构造器"></a>调用有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line">Object obj = constructor.newInstance(&quot;Mike&quot;,23);</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><h3 id="调用私有实例方法"><a href="#调用私有实例方法" class="headerlink" title="调用私有实例方法"></a>调用私有实例方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//通过反射获得实例对象</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;test&quot;, 1);</span><br><span class="line">TestClass testClass = (TestClass) object;</span><br><span class="line"></span><br><span class="line">//获得指定的 private 方法</span><br><span class="line">Class[] params = &#123;String.class&#125;;</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;showName&quot;, params);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 调用指定对象的的方法</span><br><span class="line">Object[] argList = &#123;&quot;call private method&quot;&#125;;</span><br><span class="line">Object returnParam = method.invoke(testClass, argList);</span><br><span class="line">System.out.println(returnParam);</span><br></pre></td></tr></table></figure><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取私有静态方法</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;testStaticsMethod&quot;);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">method.invoke(null);</span><br></pre></td></tr></table></figure><h2 id="获得类的实例变量并修改"><a href="#获得类的实例变量并修改" class="headerlink" title="获得类的实例变量并修改"></a>获得类的实例变量并修改</h2><h3 id="非静态变量"><a href="#非静态变量" class="headerlink" title="非静态变量"></a>非静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 通过反射获得类实例</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;Mike&quot;, 3);</span><br><span class="line"></span><br><span class="line">//获得实例变量 getField 获取一个类的public 成员变量包括基类</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//非静态实例变量传入object ,获得 object 的实例变量的值，并把它包装成类</span><br><span class="line">Object fieldObject = field.get(object);</span><br><span class="line"></span><br><span class="line">//修改 object 对应属于的值,注意只会修改 object 这个对象的字段值</span><br><span class="line">field.set(object, &quot;test Field&quot;);</span><br><span class="line">System.out.println(fieldObject);</span><br><span class="line"></span><br><span class="line">Object fieldObject1 = field.get(object);</span><br><span class="line">System.out.println(fieldObject1);</span><br></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line"></span><br><span class="line">// 获取类的 name 静态字段</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;tag&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 为 static 变量时传入 null,获得静态变量，并包装</span><br><span class="line">Object fieldObject = field.get(null);</span><br><span class="line"></span><br><span class="line">//修改值</span><br><span class="line">field.set(fieldObject, &quot;ABCD&quot;);</span><br><span class="line"></span><br><span class="line">//查看值，静态变量一次修改，一生受用</span><br><span class="line">TestClass.printStatics();</span><br></pre></td></tr></table></figure><h2 id="对泛型进行反射"><a href="#对泛型进行反射" class="headerlink" title="对泛型进行反射"></a>对泛型进行反射</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;根据一个对象获得一个类&quot;&gt;&lt;a href=&quot;#根据一个对象获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个对象获得一个类&quot;&gt;&lt;/a&gt;根据一个对象获得一个类&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String str = &amp;quot;adb&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class = str.getClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;根据一个字符串获得一个类&quot;&gt;&lt;a href=&quot;#根据一个字符串获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个字符串获得一个类&quot;&gt;&lt;/a&gt;根据一个字符串获得一个类&lt;/h2&gt;&lt;p&gt;字符串需要包括完整的包名和类名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class class = Class.forName(&amp;quot;java.lang.String&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class2 = Class.forName(&amp;quot;android.widget.Button&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获得对象的父类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class3 = class2.getSuperClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Inflection" scheme="/tags/Inflection/"/>
    
  </entry>
  
  <entry>
    <title>理解JNI</title>
    <link href="/2019/04/09/%E7%90%86%E8%A7%A3JNI/"/>
    <id>/2019/04/09/理解JNI/</id>
    <published>2019-04-09T08:28:01.000Z</published>
    <updated>2019-05-23T02:57:06.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI-概述"><a href="#JNI-概述" class="headerlink" title="JNI 概述"></a>JNI 概述</h3><p>JNI(Java Native Interface),意为 <strong>Java 本地调用</strong>,是连接 Java 和 native 的桥梁。</p><p>JNI 推出的原因：</p><ol><li>Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。</li><li>执行效率和速度。</li></ol><h3 id="JNI之-Java-层操作"><a href="#JNI之-Java-层操作" class="headerlink" title="JNI之 Java 层操作"></a>JNI之 Java 层操作</h3><p>Java 层主要有两个关键：</p><ol><li>加载 native 动态库</li><li>声明 Java 的 native 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MediaScanner implements AutoCloseable &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;media_jni&quot;);// 加载 so 库</span><br><span class="line">        native_init();//调用 native 方法</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private static native final void native_init();</span><br><span class="line">    private native final void native_setup();</span><br><span class="line">    private native final void native_finalize();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JNI-之-native-层操作-一"><a href="#JNI-之-native-层操作-一" class="headerlink" title="JNI 之 native 层操作 (一)"></a>JNI 之 native 层操作 (一)</h3><p>实例代码：<br>MediaScanner.cpp 代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// MediaScanner.java 的 native 的 JNI 实现</span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_init&quot;);</span><br><span class="line">    jclass clazz = env-&gt;FindClass(kClassMediaScanner);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    if (fields.context == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_setup(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_setup&quot;);</span><br><span class="line">    MediaScanner *mp = new StagefrightMediaScanner;</span><br><span class="line"></span><br><span class="line">    if (mp == NULL) &#123;</span><br><span class="line">        jniThrowException(env, kRunTimeException, &quot;Out of memory&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.context, (jlong)mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNI-之-native-层操作-二-–-注册-JNI-函数"><a href="#JNI-之-native-层操作-二-–-注册-JNI-函数" class="headerlink" title="JNI 之 native 层操作 (二) – 注册 JNI 函数"></a>JNI 之 native 层操作 (二) – 注册 JNI 函数</h3><p>如何知道 Java 层的 MediaScanner 中的 native_init 函数对于 JNI 层的 android_media_MediaScanner_native_init 函数,这时就需要 JNI 注册，将两个层面的函数关联起来。注册后，有了这层关联关系，Java 层调取 JNI 层函数就可以实现。</p><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>静态注册实现方法参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/84028290" target="_blank" rel="noopener">Android Studio 配置 javah 生成 C/C++ 头文件，完成 JNI 调用</a> 中相关内容。</p><p>当 Java 层调用 native_init 函数式，就会去 JNI 库中寻找 android_media_MediaScanner_native_init 函数，如果没有，就会报错，如果存在该函数，就会建立关联，<strong>此关联其实就是保存的 JNI 层函数的函数指针</strong>。以后再调用此函数，直接调用该函数指针就可以了，这部分的工作是在 Java 虚拟机中完成的。</p><p><strong>Java native 是通过函数指针来与 JNI 层的函数建立联系的。</strong></p><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>在静态注册中可知，Java 层和 JNI 层的函数是一一对应的，那么可以使用结构体来保存这种关联关系。JNI 中可以使用 JNINativeMethod 这种结构体来实现以上功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_init&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_init</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_setup&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_setup</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AndroidRuntime.cpp 类中提供了 registerNativeMethod 来完成注册工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Register native methods using JNI.</span><br><span class="line"> */</span><br><span class="line">/*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env,</span><br><span class="line">    const char* className, const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jniRegisterNativeMethods 为 JNIHelper 中提供的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Registering %s&apos;s %d native methods...&quot;, className, numMethods);</span><br><span class="line"></span><br><span class="line">    scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的工作只要两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 找到对应的类</span><br><span class="line">scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line"></span><br><span class="line">// 这句话其实是调用 JINEnv 的 RegisterNatives方法，将 JNI 类中结构体注册进来，从而完成注册关系</span><br><span class="line">(*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods)</span><br></pre></td></tr></table></figure><p>注册的函数在什么地方以及什么时候执行？</p><p>当 Java 层通过 <code>System.loadLibrary()</code> 加载完 JNI 动态库后，接着会查找库中的 <code>JNI_Onload</code> 的函数，如果有的话，就会调用他，而动态注册的工作就是在此处完成的。</p><h3 id="native-函数的参数含义"><a href="#native-函数的参数含义" class="headerlink" title="native 函数的参数含义"></a>native 函数的参数含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Java 层的 processFile 只有 3 个参数，而 JNI 中的方法有 5 中方法。</span><br><span class="line">* JNIEnv *env 为 代表 JNI 环境的结构体</span><br><span class="line">* jobject thiz：代表 Java 层的 MediaScanner 对象，如果方法为 static，参数为 jclass ,代表在调用 Java 的哪一个 Class 中的函数</span><br><span class="line">* 剩下的为 Java 层中该方法的参数</span><br><span class="line">*/</span><br><span class="line">static jboolean android_media_MediaScanner_processFile(</span><br><span class="line">        JNIEnv *env, jobject thiz, jstring path,</span><br><span class="line">        jstring mimeType, jobject client)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNIEnv-介绍"><a href="#JNIEnv-介绍" class="headerlink" title="JNIEnv 介绍"></a>JNIEnv 介绍</h3><p>JNIEnv 是一个 <strong>线程相关</strong> 的 <strong>代表 JNI 环境</strong> 的 <strong>结构体</strong>。</p><p><img src="/images/2019_04_10_1.jpg" alt="JNIEnv 内部结构简图"></p><p>JNIEnv 实际上是提供了一系列 JNI 系统函数，通过这些函数可以做到：</p><ol><li>调用 Java 函数</li><li>操作 jobject 对象</li></ol><h3 id="JNIEnv-的使用"><a href="#JNIEnv-的使用" class="headerlink" title="JNIEnv 的使用"></a>JNIEnv 的使用</h3><p>获得 Filed 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">android_media_MediaPlayer_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    // 获得 jclass</span><br><span class="line">    clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;);</span><br><span class="line">    // 获得 clazz 中的 </span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, &quot;postEventFromNative&quot;,</span><br><span class="line">                                               &quot;(Ljava/lang/Object;IIILjava/lang/Object;)V&quot;);</span><br><span class="line"></span><br><span class="line">    fields.surface_texture = env-&gt;GetFieldID(clazz, &quot;mNativeSurfaceTexture&quot;, &quot;J&quot;);</span><br><span class="line">    env-&gt;DeleteLocalRef(clazz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Field 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用 JNIEnv 的 CallVoidMethod 函数</span><br><span class="line">// 参数含义：mClient 为 MediaScannerClient 对象</span><br><span class="line">// 第二个参数为函数 scanFile 的 jmedthodid ,后面为 scanFile 的参数</span><br><span class="line">eEnv -&gt; CallVoidMethod(mClient,mScanFileMethod,pathStr,lastModified,fileSize)</span><br></pre></td></tr></table></figure><p>JNIEnv 有一系列类似 CallVoidMethod 的函数，形式如下：</p><p>NativeType Call<type>Method(JNIEnv *env,jobject obj,jmethodId methodId,….)</type></p><h3 id="jstring"><a href="#jstring" class="headerlink" title="jstring"></a>jstring</h3><p>jstring 对象可以看成 Java 中 String 对象在 JNI 层的代表。</p><ol><li>JNIEnv 调用 NewString(JNIEnv *env,const jchar *unicodeChars,jsize len):从 Native 的字符得到 jstring 对象(Unicode)。</li><li>JNIEnv 的 NewStringUTF 将 Native 的一个 UTF 字符串得到一个 jstring 对象(UTF)。</li><li>JNIEnv 提供 GetStringChar 函数，将 Java String对象转换成本地 Unicode 字符串。</li><li>JNIEnv 提供 GetStringUTFChars 函数 ，将 Java String 对象转换为本地 UTF 字符串。</li><li>调用上面四个函数后需要调用 ReleaseStringChars 或 ReleaseStringUTFChars 函数来释放相应资源。</li></ol><h3 id="JNI-中的三种引用"><a href="#JNI-中的三种引用" class="headerlink" title="JNI 中的三种引用"></a>JNI 中的三种引用</h3><ol><li>Local Reference：本地引用。JNI 函数执行完成后，这些 jobject 可能被回收。</li><li>Global Reference：这种方式的引用，不主动释放，永远不会被回收。</li><li>Weak Global Reference：  在使用过程中，可能会被回收。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JNI-概述&quot;&gt;&lt;a href=&quot;#JNI-概述&quot; class=&quot;headerlink&quot; title=&quot;JNI 概述&quot;&gt;&lt;/a&gt;JNI 概述&lt;/h3&gt;&lt;p&gt;JNI(Java Native Interface),意为 &lt;strong&gt;Java 本地调用&lt;/strong&gt;,是连接 Java 和 native 的桥梁。&lt;/p&gt;
&lt;p&gt;JNI 推出的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。&lt;/li&gt;
&lt;li&gt;执行效率和速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;JNI之-Java-层操作&quot;&gt;&lt;a href=&quot;#JNI之-Java-层操作&quot; class=&quot;headerlink&quot; title=&quot;JNI之 Java 层操作&quot;&gt;&lt;/a&gt;JNI之 Java 层操作&lt;/h3&gt;&lt;p&gt;Java 层主要有两个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载 native 动态库&lt;/li&gt;
&lt;li&gt;声明 Java 的 native 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class MediaScanner implements AutoCloseable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.loadLibrary(&amp;quot;media_jni&amp;quot;);// 加载 so 库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        native_init();//调用 native 方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static native final void native_init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_setup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JNI" scheme="/tags/JNI/"/>
    
      <category term="深入理解 Android 读书笔记" scheme="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Android-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想的思考</title>
    <link href="/2019/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>/2019/04/09/面向对象/</id>
    <published>2019-04-09T03:36:13.000Z</published>
    <updated>2019-04-09T06:01:42.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OOP-Object-Oriented-Programming-面向对象程序设计"><a href="#OOP-Object-Oriented-Programming-面向对象程序设计" class="headerlink" title="OOP (Object Oriented Programming) 面向对象程序设计"></a>OOP (Object Oriented Programming) 面向对象程序设计</h3><ol><li>OOP 强调的是数据。OOP 不像面向过程编程那样，试图使问题满足语言的过程性方法，而是试图让语言满足问题的要求。前者是让编程语言去 <strong>实现问题的解决方法</strong>，即以算法为主，而后者是让编程语言去 <strong>实现问题中的主体</strong>。</li><li>OOP 程序设计方法首先设计类，它准确的表示程序要处理的东西，然后设计一个使用这些类的对象的程序，从低级组织(如类)到高级组织的处理过程叫做 <strong>自下而上编程</strong>。</li><li>设计一个有用、可靠的类是十分重要的任务，一个优秀的类可以极大的减轻编程的难度及工作量。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OOP-Object-Oriented-Programming-面向对象程序设计&quot;&gt;&lt;a href=&quot;#OOP-Object-Oriented-Programming-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;OOP (Object 
      
    
    </summary>
    
    
      <category term="OOP" scheme="/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Four</title>
    <link href="/2019/04/04/Java-Basic-%E5%9B%9B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>/2019/04/04/Java-Basic-四内部类/</id>
    <published>2019-04-04T06:47:26.000Z</published>
    <updated>2019-06-14T09:04:24.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h3><ol><li>内部类为什么会出现</li><li>内部类的调用</li><li>内部类与外部类访问成员变量的不同</li><li>静态内部类和非静态内部类</li></ol><h4 id="1-1-为什么使用内部类"><a href="#1-1-为什么使用内部类" class="headerlink" title="1.1 为什么使用内部类"></a>1.1 为什么使用内部类</h4><ol><li><p>内部类提供了 <strong>更好的封装</strong>，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。</p></li><li><p><strong>内部类可以访问外部类的数据 (包括私有变量)</strong>，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。</p><p>内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。</p><p>真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用</p></li><li><p><strong>可以使用匿名内部类创建访问一次的类</strong>，十分方便。</p></li></ol><h3 id="2-非静态内部类"><a href="#2-非静态内部类" class="headerlink" title="2. 非静态内部类"></a>2. 非静态内部类</h3><p>例子 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private int num2 = 3;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        private int num = 2;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            System.out.println(&quot;innerclass method&quot;);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + num);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num &quot; + OutClass.this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num2 &quot; + num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass outclass = new OutClass();</span><br><span class="line">        System.out.println(&quot;main &quot;+ outclass.num);</span><br><span class="line">        outclass.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass();</span><br><span class="line">        inner.method();</span><br><span class="line">        System.out.println(&quot;outclass test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打印日志：</span><br><span class="line"></span><br><span class="line">main 1</span><br><span class="line">innerclass method</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method out num 1</span><br><span class="line">innerclass method out num2 3</span><br><span class="line">outclass test</span><br></pre></td></tr></table></figure><h4 id="2-1-内部类可以访问外部类的成员变量-包括私有变量"><a href="#2-1-内部类可以访问外部类的成员变量-包括私有变量" class="headerlink" title="2.1 内部类可以访问外部类的成员变量(包括私有变量)"></a>2.1 内部类可以访问外部类的成员变量(包括私有变量)</h4><p>原因：<br>在非静态内部类对象里，保存了 <strong>外部类对象的引用</strong>。</p><p>内存模型：</p><p><img src="/images/2019_04_04_1.jpg" alt="内存模型图"></p><p>但是当外部类与内部类有相同名字的变量时，引用外部类变量需要指定外部类对象 –  <code>Outclass.this</code> </p><h4 id="2-2-编译后的-Class-文件"><a href="#2-2-编译后的-Class-文件" class="headerlink" title="2.2 编译后的 Class 文件"></a>2.2 编译后的 Class 文件</h4><p>在 JVM 中没有内部类这个概念，所有的类都是普通类（POJO），内部类也会被编译成带有前缀的类。</p><p>编译后，得到两个 class 文件:</p><ol><li><code>OutClass.java</code> </li><li><code>OutClass$InnerClass.class</code></li></ol><h4 id="内部类方法中的变量的访问顺序"><a href="#内部类方法中的变量的访问顺序" class="headerlink" title="内部类方法中的变量的访问顺序"></a>内部类方法中的变量的访问顺序</h4><p>内部类方法内部中 –&gt; 内部类中的成员变量 –&gt; 外部类中的成员变量 –&gt; 不存在，编译异常</p><h4 id="2-3-内、外部类变量名相同"><a href="#2-3-内、外部类变量名相同" class="headerlink" title="2.3 内、外部类变量名相同"></a>2.3 内、外部类变量名相同</h4><p>访问使用如下格式：</p><p><code>this.field</code> : 内部类变量</p><p><code>OutClass.this.field</code> : 外部类变量</p><h4 id="2-4-外部类不可直接访问内部类成员"><a href="#2-4-外部类不可直接访问内部类成员" class="headerlink" title="2.4 外部类不可直接访问内部类成员"></a>2.4 外部类不可直接访问内部类成员</h4><p>非静态内部类成员只在非静态内部类范围内是可知的，外部类不能直接访问，但是可以通过 <strong>内部类实例对象来访问</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InnerClass().method();</span><br><span class="line">new InnerClass().num++;</span><br></pre></td></tr></table></figure><h4 id="2-5-外部类中静态成员中不允许直接使用非静态内部类"><a href="#2-5-外部类中静态成员中不允许直接使用非静态内部类" class="headerlink" title="2.5 外部类中静态成员中不允许直接使用非静态内部类"></a>2.5 外部类中静态成员中不允许直接使用非静态内部类</h4><p>静态成员为类成员，如静态变量、静态初始化块、静态内部类等，静态成员在编译期对其初始化，如果直接使用非静态成员(如非静态内部类)，则会发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OutterClass&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        // 这种情况是不被允许的</span><br><span class="line">        //new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-内、外部类关系"><a href="#2-6-内、外部类关系" class="headerlink" title="2.6 内、外部类关系"></a>2.6 内、外部类关系</h4><p>非静态内部类对象寄生在外部类对象里，有非静态内部类对象一定存在外部类对象，反之不成立。</p><h4 id="2-7-非静态内部类中的静态成员-重点理解"><a href="#2-7-非静态内部类中的静态成员-重点理解" class="headerlink" title="2.7 非静态内部类中的静态成员(重点理解)"></a>2.7 非静态内部类中的静态成员(重点理解)</h4><p>如果非静态内部类声明静态成员变量，那么必须使用 <code>final</code> 修饰，由于被 <code>final</code> 修饰该变量必须在声明处初始化。</p><p>因为一个静态变量只有一个实例，而对于每一个外部对象，分别有一个单独的内部类实例，如果这个变量不是 final 的，那么他就不是唯一的，这与 static 的含义相互冲突。</p><p><strong>非静态内部类中不能含有静态方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OutterClass &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private void outMethod()&#123;&#125;</span><br><span class="line">     class InnerClass &#123;</span><br><span class="line">        private final static String name = &quot;&quot;;</span><br><span class="line">        private /*static*/ void innerMethod() &#123;</span><br><span class="line">            age++;</span><br><span class="line">            outMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private static int age = 2;</span><br><span class="line"></span><br><span class="line">    private void doSomething()&#123;</span><br><span class="line">        StaticInnerClass.staticNum++;</span><br><span class="line">        StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">        staticInnerClass.method();</span><br><span class="line">        staticInnerClass.num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static class StaticInnerClass &#123;</span><br><span class="line">        private static int staticNum = 10;</span><br><span class="line">        private int num = 100;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            num++;</span><br><span class="line">            staticNum++;</span><br><span class="line">            age++;</span><br><span class="line">            // &apos;four.OutClass.this&apos; cannot be referenced from a static context</span><br><span class="line">            // -- four.OutClass.this 不能再 static 环境下被引用</span><br><span class="line">            // OutClass.this.num++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-静态内部类不可以访问外部类实例成员，可以访问类成员"><a href="#3-1-静态内部类不可以访问外部类实例成员，可以访问类成员" class="headerlink" title="3.1 静态内部类不可以访问外部类实例成员，可以访问类成员"></a>3.1 静态内部类不可以访问外部类实例成员，可以访问类成员</h4><p>静态内部类为外部类的类成员，只能访问外部类的静态变量，不可以访问非静态变量，还是一样牵涉到类加载、初始化顺序的问题。</p><h4 id="3-2-编译后的-Class-文件"><a href="#3-2-编译后的-Class-文件" class="headerlink" title="3.2 编译后的 Class 文件"></a>3.2 编译后的 Class 文件</h4><p>与非静态内部类相同，编译后得到两个 class 文件 – OutClass.class 、StaticInnerClass.class</p><h4 id="3-3-外部类不可直接访问静态内部类成员"><a href="#3-3-外部类不可直接访问静态内部类成员" class="headerlink" title="3.3 外部类不可直接访问静态内部类成员"></a>3.3 外部类不可直接访问静态内部类成员</h4><p>静态内部类成员、实例成员只在静态内部类范围内是可知的，外部类不能直接访问。</p><ul><li><p>通过 内部类名 来访问静态内部类类成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass.staticNum++;</span><br></pre></td></tr></table></figure></li><li><p>通过内部类实例对象访问静态内部类实例成员(不推荐，这样就忽视了 static 的含义)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">staticInnerClass.method();</span><br><span class="line">staticInnerClass.num++;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-内部类使用"><a href="#4-内部类使用" class="headerlink" title="4. 内部类使用"></a>4. 内部类使用</h3><h4 id="4-1-外部类使用内部类"><a href="#4-1-外部类使用内部类" class="headerlink" title="4.1 外部类使用内部类"></a>4.1 外部类使用内部类</h4><ul><li>基本的使用</li><li>外部类使用内部类的子类</li></ul><p>外部类中的静态代码块、静态方法中不可使用非静态内部类，因为静态成员不能使用非静态成员。</p><h4 id="4-2-外部类以外使用非静态内部类"><a href="#4-2-外部类以外使用非静态内部类" class="headerlink" title="4.2 外部类以外使用非静态内部类"></a>4.2 外部类以外使用非静态内部类</h4><p>根据内部类的访问权限修饰符，内部类对其他类的可见性不同。</p><p>外部类以外建立非静态内部类实例必须外部类实例和 new 来调用非静态内部类的构造器。</p><ul><li>非静态内部类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass innerclass = new OutClass().new InnerClass();</span><br><span class="line">innerclass.num++;</span><br><span class="line">innerclass.method();</span><br></pre></td></tr></table></figure><ul><li>非静态内部类子类</li></ul><h4 id="外部类以外使用静态内部类"><a href="#外部类以外使用静态内部类" class="headerlink" title="外部类以外使用静态内部类"></a>外部类以外使用静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected static InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass staticInnerClass = new OutClass.InnerClass();</span><br><span class="line">staticInnerClass.</span><br></pre></td></tr></table></figure><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5. 局部内部类"></a>5. 局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        class InnerBase&#123;</span><br><span class="line">            int a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class SubInnerClass extends InnerBase&#123;</span><br><span class="line">            int b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubInnerClass subInnerClass = new SubInnerClass();</span><br><span class="line">        subInnerClass.a = 1;</span><br><span class="line">        subInnerClass.b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类，顾名思义内部类定义在 方法内部，其有效范围也在方法内部，方法外部无法访问,即：对外部世界完全的隐藏起来。</p><p>通过 <code>javac Test.java</code> 对该类进行编译，生成的 class 有 3 个，分别为： <code>Test.class</code>、<code>Test$1InnerBase.class</code>、<code>Test$1SubInnerClass.class</code>。</p><p>局部内部类遵循如下命名格式：<br><strong>OutClassName$NInnerClassName 其中 N 表示第 N 个内部类。</strong></p><h3 id="6-匿名内部类-Anonymous-Inner-Class"><a href="#6-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="6. 匿名内部类(Anonymous Inner Class)"></a>6. 匿名内部类(Anonymous Inner Class)</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>匿名内部类适合创建只需要一次使用的类。</p><p>定义内部类的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 实现接口 或 父类构造器(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    类的主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由其格式可知，<strong>匿名内部类必须且只能继承一个父类，或实现且最多一个接口</strong>。</p><p>由于构造器必须与类名相同，而匿名内部类不能有类名，所以匿名类不能有构造器。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IClick &#123;</span><br><span class="line">    void change();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public  void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final String  name = &quot;name&quot;;</span><br><span class="line">        show(new IClick() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void change() &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  void show(IClick click)&#123;</span><br><span class="line">        click.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名内部类的时机：</p><p>show 方法参数为 IClick，此时考虑传入 IClick 的实现类的对象，如果 IClick 的实现类除了在此处使用外，还有其他类或方法使用该接口的实现类，那么此时应该定义一个该接口的实现类。但是如果 IClick 的实现类只会使用一次，那么可以定义一个匿名内部类，如上面实现方式。</p><p>在 Java8 之前，要求被匿名内部类、局部内部类访问的局部变量必须使用 final 修饰，Java8 则取消了这个限制，其实是 Java 自动添加了 final 修饰符。</p><p>原因：</p><p>对于普通局部变量而言，它的作用域停留在方法内，当方法执行完毕，该局部变量也随之消失，但局部内部类或匿名内部类，则可能产生隐式的 “闭包”，闭包使得局部变量脱离它所在的方法继续存在。</p><p>内部类和外部类处于同一层级，也就是说如果在方法内声明内部类实例的对象不会和局部变量一样在方法执行完毕后就会被回收</p><p>个人理解，匿名内部类是一个实现了接口或继承类的类。</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>由于系统在创建匿名内部类时，会创建匿名内部类的对象，所以匿名内部类 <strong>不能定义为抽象类</strong>。</li><li>由于匿名内部类没有类名，所以匿名内部类 <strong>无法定义构造器</strong>，但可以使用初始化块进行初始化。</li></ul><p>方法的返回值的生成和表示这个返回值的类的定义结合在一起。</p><hr><p><strong>Q:</strong> 为什么需要内部类？</p><p><strong>A:</strong> 如果你想实现一个接口，但是这个接口中的一个方法和你构想的这个类中的一个方法的名称，参数相同，你应该怎么办？这时候，你可以建一个内部类实现这个接口。由于内部类对外部类的所有内容都是可访问的，所以这样做可以完成所有你直接实现这个接口的功能。</p><p>真正的原因，java中的内部类和接口加在一起，可以很好的实现多继承的效果。</p><p><strong>Q:</strong> 内部类是否有用、必要和安全</p><p><strong>A:</strong> 内部类是一种编译器现象，与虚拟机无关。编译器会把内部了翻译成用 <code>$</code> 分割外部类名与内部类名的常规文件，而虚拟机对此一无所知。</p><hr><p><a href="https://www.zhihu.com/question/21395848" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内部类为什么会出现&lt;/li&gt;
&lt;li&gt;内部类的调用&lt;/li&gt;
&lt;li&gt;内部类与外部类访问成员变量的不同&lt;/li&gt;
&lt;li&gt;静态内部类和非静态内部类&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-1-为什么使用内部类&quot;&gt;&lt;a href=&quot;#1-1-为什么使用内部类&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么使用内部类&quot;&gt;&lt;/a&gt;1.1 为什么使用内部类&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内部类提供了 &lt;strong&gt;更好的封装&lt;/strong&gt;，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内部类可以访问外部类的数据 (包括私有变量)&lt;/strong&gt;，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。&lt;/p&gt;
&lt;p&gt;内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。&lt;/p&gt;
&lt;p&gt;真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可以使用匿名内部类创建访问一次的类&lt;/strong&gt;，十分方便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-非静态内部类&quot;&gt;&lt;a href=&quot;#2-非静态内部类&quot; class=&quot;headerlink&quot; title=&quot;2. 非静态内部类&quot;&gt;&lt;/a&gt;2. 非静态内部类&lt;/h3&gt;&lt;p&gt;例子 ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class OutClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num2 = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private class InnerClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private int num = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private void method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num &amp;quot; + OutClass.this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num2 &amp;quot; + num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OutClass outclass = new OutClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;main &amp;quot;+ outclass.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        outclass.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private void test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InnerClass inner = new InnerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inner.method();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;outclass test&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="内部类" scheme="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本使用</title>
    <link href="/2019/04/02/Vim/"/>
    <id>/2019/04/02/Vim/</id>
    <published>2019-04-02T03:33:55.000Z</published>
    <updated>2019-05-23T02:58:41.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插入命令"><a href="#1、插入命令" class="headerlink" title="1、插入命令"></a>1、插入命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">在光标所在字符<code>后</code>插入</td></tr><tr><td align="center">A</td><td align="center">在光标所在<code>行尾</code>插入</td></tr><tr><td align="center">i</td><td align="center">在光标所在字符<code>前</code>插入</td></tr><tr><td align="center">I</td><td align="center">在光标所在<code>行首</code>插入</td></tr><tr><td align="center">o</td><td align="center">在光标<code>下</code>插入行</td></tr><tr><td align="center">O</td><td align="center">在光标<code>上</code>插入行</td></tr></tbody></table><h3 id="2、定位命令"><a href="#2、定位命令" class="headerlink" title="2、定位命令"></a>2、定位命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:set nu</td><td align="center">设置行号</td></tr><tr><td align="center">:set nonu</td><td align="center">取消行号</td></tr><tr><td align="center">gg</td><td align="center">到第一行</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr><tr><td align="center">nG</td><td align="center">到第n行</td></tr><tr><td align="center">:n</td><td align="center">到第n行</td></tr><tr><td align="center">$</td><td align="center">移至行尾</td></tr><tr><td align="center">0</td><td align="center">移至行首</td></tr></tbody></table><a id="more"></a><h3 id="3、删除命令"><a href="#3、删除命令" class="headerlink" title="3、删除命令"></a>3、删除命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除光标所在处字符</td></tr><tr><td align="center">nx</td><td align="center">删除光标所在处后 n 个字符</td></tr><tr><td align="center">dd</td><td align="center">删除光标所在行</td></tr><tr><td align="center">ndd</td><td align="center">删除n行</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在行到<code>文件末尾</code>的内容</td></tr><tr><td align="center">D</td><td align="center">删除光标所在处到<code>行尾</code>的内容</td></tr><tr><td align="center">:n1,n2d</td><td align="center">删除指定范围的行</td></tr></tbody></table><h3 id="4、复制和剪切命令"><a href="#4、复制和剪切命令" class="headerlink" title="4、复制和剪切命令"></a>4、复制和剪切命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制当前行</td></tr><tr><td align="center">nyy</td><td align="center">复制当前行以下 n 行</td></tr><tr><td align="center">dd</td><td align="center">剪切当前行</td></tr><tr><td align="center">ndd</td><td align="center">剪切当前行以下 n 行</td></tr><tr><td align="center">p</td><td align="center">粘贴在当前光标所在行下</td></tr><tr><td align="center">P</td><td align="center">粘贴在当前光标所在行上</td></tr></tbody></table><h3 id="5、替换和取消命令"><a href="#5、替换和取消命令" class="headerlink" title="5、替换和取消命令"></a>5、替换和取消命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">取代光标所在处字符</td></tr><tr><td align="center">R</td><td align="center">从光标所在处开始替换字符，按 Esc 结束</td></tr><tr><td align="center">u</td><td align="center">取消上一步操作</td></tr></tbody></table><h3 id="6、搜索和搜索替换命令"><a href="#6、搜索和搜索替换命令" class="headerlink" title="6、搜索和搜索替换命令"></a>6、搜索和搜索替换命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">/string</td><td align="center">搜索指定字符串 、搜索时忽略大小写 <code>:set ic</code></td></tr><tr><td align="center">n</td><td align="center">搜索指定字符串的下一个出现位置</td></tr><tr><td align="center">：%s/old/new/g</td><td align="center">全文替换指定字符串</td></tr><tr><td align="center">：n1，n2/old/new/g</td><td align="center">在一定范围内替换指定字符串</td></tr></tbody></table><h3 id="7、保存和退出命令"><a href="#7、保存和退出命令" class="headerlink" title="7、保存和退出命令"></a>7、保存和退出命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">保存修改</td></tr><tr><td align="center">:w new_filename</td><td align="center">另存为指定文件</td></tr><tr><td align="center">：wq</td><td align="center">保存修改并退出</td></tr><tr><td align="center">ZZ</td><td align="center">快捷键，保存修改并退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存修改退出</td></tr><tr><td align="center">：wq!</td><td align="center">保存修改并退出（文件所有者及root 用户可使用）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、插入命令&quot;&gt;&lt;a href=&quot;#1、插入命令&quot; class=&quot;headerlink&quot; title=&quot;1、插入命令&quot;&gt;&lt;/a&gt;1、插入命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;a&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;后&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;A&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行尾&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;i&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;前&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;I&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行首&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;下&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;上&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;2、定位命令&quot;&gt;&lt;a href=&quot;#2、定位命令&quot; class=&quot;headerlink&quot; title=&quot;2、定位命令&quot;&gt;&lt;/a&gt;2、定位命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;设置行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nonu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;取消行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;gg&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;G&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;nG&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:n&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行首&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="VIM" scheme="/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>IntentFilter匹配规则</title>
    <link href="/2019/04/02/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>/2019/04/02/IntentFilter匹配规则/</id>
    <published>2019-04-02T02:28:45.000Z</published>
    <updated>2019-05-16T07:52:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。</p><h3 id="action-匹配规则"><a href="#action-匹配规则" class="headerlink" title="action 匹配规则"></a>action 匹配规则</h3><p>action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。</p><p>action 的匹配规则是：<strong>Intent 中的 action 必须能够和过滤规则中的 action 匹配</strong>，匹配是指两个 action 的字符串完全相同。</p><p>一个过滤规则的中可以有多个 action，<strong>只要 Intent 中的任何一个 action 和其中的一个 action 匹配，则可匹配成功</strong>。</p><p>action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，<strong>action 区分大小写</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(&quot;xxaction&quot;)</span><br><span class="line">intent.setAction(&quot;&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="category-匹配规则"><a href="#category-匹配规则" class="headerlink" title="category 匹配规则"></a>category 匹配规则</h3><p>category 是一个字符串，系统预定义了一些 category，用户也可以定义自己的 category。</p><p>category 的匹配规则：Intent 中如果含有 category，那么 Intent <strong>所有的</strong> category 必须和过滤规则中的一个相同。</p><p>为 Intent 的添加 category 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addCategory(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>系统在调用 <code>startActivity</code> 或 <code>startActivityForResult</code> 时会为 Intent 添加 <code>android.intent.category.DEFAULT</code> 这个 category,所以在隐式调用 Activity 时需要在清单文件中显示的添加 <code>android.intent.category.DEFAULT</code> 这条过滤规则。</p><p>Activity 的显示调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this,SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>Activity 的隐式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intent.setAction(&quot;xxx&quot;)</span><br><span class="line">intent.addCategory(&quot;xxx&quot;)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;</span><br><span class="line">    &lt;intent-filter&gt;   </span><br><span class="line">        &lt;category android:name = &quot;android.intent.category.DEFAULT&quot; //&gt;   </span><br><span class="line">    &lt;/intent-filter&gt;       </span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="data-的匹配规则"><a href="#data-的匹配规则" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h3><h4 id="data-的结构"><a href="#data-的结构" class="headerlink" title="data 的结构"></a>data 的结构</h4><p>data 由两部分组成， mimeType 和 URI。</p><ul><li><p>mimeType</p><p>  mimeType 指的是 <strong>媒体类型</strong>，例如：如image/jpeg、audio/mpeg4generic和video/* 等，可以表示图片、文本、视频等不同的媒体类型。</p></li><li><p>URI(统一资源标识符)</p><p>  URI 的结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;](中括号中表示三者可选)</span><br></pre></td></tr></table></figure><p>  如下面的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/info</span><br></pre></td></tr></table></figure><ul><li><p>Scheme</p><p>  URI 模式，比如 http、file、content 等，如果 URI 没有指定有效 scheme，那么整个 URI 都是无效的。</p></li><li><p>Host</p><p>  URI 的主机名，如果没有指定 host ，那么其他的参数都是无效的，整个 URI 都是无效的。</p></li><li><p>Port</p><p>  URI 的端口号。当 URI 的 Scheme 和 Host 指定后 Port 才会有效。</p></li><li><p>Path、PathPrefix、PathPattern</p><p>  三者均表示路径信息。Path 表示完整的路径信息，PathPattern 也表示完整的路径信息，但是其中可以包含通配符 “*” ，表示 0 个或任意多个字符；PathPrefix 表示路径的前缀信息。</p></li></ul></li></ul><h4 id="data-的匹配规则-1"><a href="#data-的匹配规则-1" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h4><p>data 的匹配规则：<strong>Intent 中的 data 数据必须和过滤规则中的某一个 data 完全匹配。</strong><br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intnet.setDataAndType((Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)</span><br></pre></td></tr></table></figure><p>那么对应的 IntentFilter 中的匹配过滤信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot; android:scheme=&quot;file&quot; android:host=&quot;abc&quot;&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot;/&gt; </span><br><span class="line">    &lt;data android:scheme=&quot;file&quot;/&gt;</span><br><span class="line">    &lt;data android:host=&quot;abc&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">// 两组是完全相同的，只是第二组把 URI 的各个部分分开表示。</span><br></pre></td></tr></table></figure><p>在 App 中吊起系统相册时，我们就需要设置 Intent 的 data 属性来调取系统中特定的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。&lt;/p&gt;
&lt;h3 id=&quot;action-匹配规则&quot;&gt;&lt;a href=&quot;#action-匹配规则&quot; class=&quot;headerlink&quot; title=&quot;action 匹配规则&quot;&gt;&lt;/a&gt;action 匹配规则&lt;/h3&gt;&lt;p&gt;action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。&lt;/p&gt;
&lt;p&gt;action 的匹配规则是：&lt;strong&gt;Intent 中的 action 必须能够和过滤规则中的 action 匹配&lt;/strong&gt;，匹配是指两个 action 的字符串完全相同。&lt;/p&gt;
&lt;p&gt;一个过滤规则的中可以有多个 action，&lt;strong&gt;只要 Intent 中的任何一个 action 和其中的一个 action 匹配，则可匹配成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，&lt;strong&gt;action 区分大小写&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val intent = Intent(&amp;quot;xxaction&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;intent.setAction(&amp;quot;&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android编程中的一些概念(Wiki)</title>
    <link href="/2019/04/01/Android%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/04/01/Android编程中的一些概念/</id>
    <published>2019-04-01T02:38:59.000Z</published>
    <updated>2019-04-09T03:33:34.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器(compiler) ,是一种 <strong>应用程序</strong>，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。</p><p>它的主要目的是将人编写、维护的高级计算机语言所写出的 <strong>源代码程序</strong>，翻译为计算机能解读、运行的低价 <strong>机器语言</strong> 的程序，也就是 <strong>可执行文件</strong>。</p><p>常见的编译器：</p><ol><li>GCC(GUN Compiler Collection)</li></ol><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><ol start="2"><li>LLVM</li></ol><p>LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。</p><a id="more"></a><h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><ol><li>即时编译(JIT,Just In Time)</li></ol><p>动态编译的一种形式，提高程序运行效率的方法。程序运行有两种方式：<br>    1. 静态编译。执行程序前程序全部被翻译为机器码。<br>    2. 动态解释。解释执行则是边执行边翻译。<br>即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p><p>即时编译器有两种类型：</p><pre><code>1. 字节码翻译。2. 动态编译翻译。</code></pre><ol start="2"><li>提前编译(AOT,Ahead Of Time)</li></ol><h3 id="运行时系统"><a href="#运行时系统" class="headerlink" title="运行时系统"></a>运行时系统</h3><p>运行环境有称运行时系统，是指把半编译的运行码在目标机器上运行的环境，如 Java<br> 的 JRE。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p> 可执行文件，是指 <strong>内容可被计算机解释为程序</strong> 的文件，通常可执行文件内含有二进制编码的微处理器指令，所以可执行文件也可被称为 二进制文件。<br> <strong>扩展名：</strong></p><ul><li><p>.exe</p></li><li><p>.com</p></li><li><p>.run</p><p><strong>脚本：</strong></p><p>不是所有的可执行文件都只存在计算机识别的数据，脚本中也是可执行文件，但是内含人类识别的数据，原因：<strong>脚本语言无需经过编译器先编译，就可经过解释器运行(Perl、Python、Shell)</strong>。</p></li></ul><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释器(interpreter),是一种 <strong>计算机程序</strong>，能够把高级编程语言一行一行解释运行，每次运行程序都需要将先转成另外一种语言再作运行，因此解释器的程序运行速度比较慢，运行程序只能将程序一行一行的翻译。</p><p>解释器的好处是它消除了编译整个程序的负担，程序可以拆分成多个部分来模块化，但这会让运行时的效率打了折扣。相对地，编译器已一次将所有源代码翻译成另一种语言，如机器代码，运行时便无需再依赖编译器或额外的程序，故而其运行速度比较快。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>在计算机科学体系结构中，虚拟机指一种 <strong>特殊的软件</strong>，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是 <strong>基于这个软件所创建的环境来操作的软件</strong>。</p><h3 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h3><p>为 Google 开发的 Android 移动设备平台的核心组成部分之一，它支持 .dex(Dalvik Executable) 格式的 Java 应用程序的运行，.dex 格式为专门为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。</p><p>Java 虚拟机和大部分虚拟机包括 JVM 都是基于堆栈的虚拟机，而 Dalvik 虚拟机为 寄存器虚拟机。</p><p>从Android 5.0版起，Android Runtime（ART）取代Dalvik成为系统内默认虚拟机。</p><h3 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h3><p>ART，是一种在 Android 操作系统上的 <strong>运行环境</strong>， ART 能够把应用程序的字节码转换为机器码，是 Android 使用的一种新的虚拟机。与 Dalvik 不同的出 ART 使用的 AOT 技术，而 Dalvik 使用的为 JIT 技术。</p><p>ART 改善了性能、垃圾回收等方面。</p><p>ART引入了 AOT 技术，应用程序在安装时将所有的字节码编译成机器码，所以其在安装时花费的时间更长，同时也会占用更大的内部存储空间，用于存储编译后的代码。</p><h3 id="代码类型"><a href="#代码类型" class="headerlink" title="代码类型"></a>代码类型</h3><p><strong>源代码：</strong></p><p>指人类可读的计算机语言指令，如我们平时编程用到的 Java 、Py、PHP、C++ 等。</p><p><strong>目标代码：</strong></p><p>编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。存放目标代码的文件称为目标文件，常被称为 <strong>二进制文件</strong>。</p><p>目标文件中包含着机器代码以及代码运行中使用到的数据，以及其他信息。</p><p><strong>字节码：</strong></p><p><img src="/images/2019_04_02_2.jpg" alt="字节码"></p><p>字节码(ByteCode),通常指已经经过编译，但是与特定机器代码无关，需要解释器转译后才能成为机器的中间代码。字节码不能像源代码一样可以供人阅读，而是编译后的数值常量、引用、指令等构成的序列。</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机。编译器将源码编译成字节码，特定平台上的虚拟机将字节码转译为可以直接运行的指令。字节码的典型应用为Java bytecode。</p><p><strong>机器语言：</strong></p><p>机器语言是一种指令集体系，这种指令体系称为机器代码，是指计算机的 CPU 可直接解读的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h3&gt;&lt;p&gt;编译器(compiler) ,是一种 &lt;strong&gt;应用程序&lt;/strong&gt;，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。&lt;/p&gt;
&lt;p&gt;它的主要目的是将人编写、维护的高级计算机语言所写出的 &lt;strong&gt;源代码程序&lt;/strong&gt;，翻译为计算机能解读、运行的低价 &lt;strong&gt;机器语言&lt;/strong&gt; 的程序，也就是 &lt;strong&gt;可执行文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的编译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCC(GUN Compiler Collection)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译技术" scheme="/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>常用的 Gradle 命令</title>
    <link href="/2019/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84-Gradle-%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/28/常用的-Gradle-命令/</id>
    <published>2019-03-28T08:37:33.000Z</published>
    <updated>2019-03-29T10:55:03.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gradlew-q-app-dependencies"><a href="#gradlew-q-app-dependencies" class="headerlink" title="gradlew -q app:dependencies"></a>gradlew -q app:dependencies</h3><p>出现依赖库版本冲突，一般会包如下错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 28.0.0, 25.2.0. Examples include com.android.support:animated-vector-drawable:28.0.0 and com.android.support:support-media-compat:25.2.</span><br></pre></td></tr></table></figure><p>一般出现这种错的原因是自己依赖的库与其他依赖的库所依赖的库为同一个 group 的库，但是版本不同。</p><p>使用 <strong>./gradlew -q app:dependencies</strong> 可以看到自己项目依赖库的层级关系：</p><p>解决：使用 exclude 排除相应的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">api (&quot;com.alibaba:arouter-api:1.4.0&quot;)&#123;</span><br><span class="line">    exclude group: &apos;com.android.support&apos;,module:&apos;support-v4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;gradlew-q-app-dependencies&quot;&gt;&lt;a href=&quot;#gradlew-q-app-dependencies&quot; class=&quot;headerlink&quot; title=&quot;gradlew -q app:dependencies&quot;&gt;&lt;/a&gt;gradlew
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 jar 、aar</title>
    <link href="/2019/03/27/%E6%89%93%E5%8C%85-jar-%E3%80%81aar/"/>
    <id>/2019/03/27/打包-jar-、aar/</id>
    <published>2019-03-27T02:47:06.000Z</published>
    <updated>2019-03-28T10:06:15.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的 aar 文件包括：AndroidManifest.xml，classes.jar，res，R.txt。</p><p>jar：只包含了 class 文件和清单文件，不包含资源文件。</p><p>如果需要资源文件，那么以 aar 的形式引入到工程，反之使用 jar。</p><h3 id="打包-aar、jar"><a href="#打包-aar、jar" class="headerlink" title="打包 aar、jar"></a>打包 aar、jar</h3><p>如果将 Application 打包为 aar，做以下更改：</p><ol><li>将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为 <code>apply plugin: &#39;com.android.library&#39;</code></li><li>去掉 <code>applicationId</code></li><li>项目根目录执行 <code>./gradlew assembleRelease</code>,就可以在相应的目录(build/output/aar)下看到生成的 aar，在 <code>build/intermediates/packed-classes</code> 中看到相应的 jar 包。</li></ol><p>可以使用新建 gradle task 可以将生成的 jar 包直接复制到 libs 下，并完成构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    def name = project.name //Library名称</span><br><span class="line">    delete &apos;libs/&apos; + name + &apos;.jar&apos; //删除之前的旧jar包</span><br><span class="line">    from(&apos;build/intermediates/packaged-classes/release/&apos;) //从这个目录下取出默认jar包</span><br><span class="line">    into(&apos;libs/&apos;) //将jar包输出到指定目录下</span><br><span class="line">    include(&apos;classes.jar&apos;)</span><br><span class="line">    rename(&apos;classes.jar&apos;, name + &apos;.jar&apos;) //自定义jar包的名字</span><br><span class="line">&#125;</span><br><span class="line">copyJar.dependsOn(build)</span><br></pre></td></tr></table></figure><h3 id="自定义-jar"><a href="#自定义-jar" class="headerlink" title="自定义 jar"></a>自定义 jar</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>adb 运行原理和常用命令</title>
    <link href="/2019/03/26/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/26/adb-常用命令/</id>
    <published>2019-03-26T03:32:49.000Z</published>
    <updated>2019-07-31T11:02:14.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：</p><ol><li>客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。</li><li>后台程序。在相应的设备(模拟器、真机)上运行命令，作为<code>后台进程</code> 在 <code>设备</code>上运行。</li><li>服务器。管理客户端和后台程序之间的通信，在 <code>开发计算机</code> 上作为 <code>后台进程</code> 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。</li></ol><p>android_sdk/platform-tools/ 中找到 adb 工具。</p><h3 id="adb-工作方式"><a href="#adb-工作方式" class="headerlink" title="adb 工作方式"></a>adb 工作方式</h3><ol><li>启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。</li><li>服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。</li><li>当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。</li></ol><a id="more"></a><h3 id="通过-WLAN-连接设备"><a href="#通过-WLAN-连接设备" class="headerlink" title="通过 WLAN 连接设备"></a>通过 WLAN 连接设备</h3><p><strong>adb tcpip 5555:</strong> 设置设备监听 5555 端口上的 TCP/IP 的连接。</p><p><strong>adb connect xxx:</strong>  通过目标设备的 IP 连接设备。</p><p><strong>adb disconnect ip:</strong> 断开指定 IP 的设备 </p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>adb devices:</strong> 查找设备</p><p><strong>adb -s serialNum commond:</strong> 指定设备执行命令</p><p><strong>adb install apk:</strong> 安装 apk</p><p><strong>adb -s xxxx install apk:</strong> 指定设备上安装 apk</p><p><strong>adb install -r apk:</strong> 覆盖安装</p><p><strong>adb -d install apk:</strong> 唯一 USB 连接设备安装 apk</p><p><strong>adb -e install apk:</strong> 唯一模拟器设备安装 apk</p><p><strong>adb uninstall packageName:</strong> 卸载 apk</p><p><strong>adb uninsatll -k packageName:</strong> 卸载 apk,但是保留其配置和缓存文件</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>adb push localFile remoteDictory:</strong> 将本地的文件 push 远端指定的目录下</p><p><strong>adb pull file remoteDictory:</strong> 从 remoteDictory 中复制指定的 file 到当前目录下</p><h3 id="adb-服务器"><a href="#adb-服务器" class="headerlink" title="adb 服务器"></a>adb 服务器</h3><p>adb kill-server： 停止 adb 服务器</p><p>adb start-server：开启 adb 服务</p><h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h3><p>在目标设备启动远程 shell </p><h3 id="adb-shell-am"><a href="#adb-shell-am" class="headerlink" title="adb shell am"></a>adb shell am</h3><p>使用 adb shell am 与应用交互。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>start [option] <intent></intent></td><td>启动 <intent> 指定的 Activity</intent></td></tr><tr><td>startservice [options] <intent></intent></td><td>启动 <intent> 指定的 Service</intent></td></tr><tr><td>broadcast [options] <intent></intent></td><td>发送 <intent> 指定的广播</intent></td></tr><tr><td>force-stop <packagename></packagename></td><td>停止 <packagename> 相关的进程</packagename></td></tr></tbody></table><p><intent> 有关的选项<br>参数|含义<br>–|–<br>-a | <action>    指定 action，比如 android.intent.action.VIEW<br>-c | <category>    指定 category，比如 android.intent.category.APP_CONTACTS<br>-n | <component>    指定完整 component 名，用于明确指定启动哪个 Activity，如 com.gy/.MainActivity</component></category></action></intent></p><p><intent> 可以传参</intent></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell start -n com.gy/.MainActivity //启动指定的 Activity</span><br><span class="line"></span><br><span class="line">adb shell startService -n com.gy/.TestService //启动指定的 Service</span><br><span class="line"></span><br><span class="line">adb shell broadcast  -a android.intent.action.BOOT_COMPLETED -n com.gy/.TestBroadcast //向指定的 BroadCast 发送广播</span><br><span class="line"></span><br><span class="line">adb shell am force-stop com.gy // 关闭指定 app 的一切进程与服务</span><br></pre></td></tr></table></figure><h3 id="adb-shell-pm"><a href="#adb-shell-pm" class="headerlink" title="adb shell pm"></a>adb shell pm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br><span class="line"></span><br><span class="line">adb shell pm clear &lt;packagename&gt;:清除数据与缓存</span><br><span class="line"></span><br><span class="line">adb shell pm path &lt;packagename&gt;:应用安装路径</span><br></pre></td></tr></table></figure><h3 id="adb-shell-wm"><a href="#adb-shell-wm" class="headerlink" title="adb shell wm"></a>adb shell wm</h3><p>屏幕相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size: 屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm size 480x1024: 屏幕分辨率修改为 480x1024</span><br><span class="line"></span><br><span class="line">adb shell wm size reset: 恢复屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm density: 屏幕密度</span><br><span class="line"></span><br><span class="line">adb shell wm density 160 : 屏幕密度设置为 160dpi</span><br><span class="line"></span><br><span class="line">adb shell wm density reset: 恢复屏幕密度</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys"><a href="#adb-shell-dumpsys" class="headerlink" title="adb shell dumpsys"></a>adb shell dumpsys</h3><p>查看运行状态,打印出当前系统的系统信息，默认打印出设备中所有的 service 的信息。</p><p>查看 Service List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys</span><br><span class="line">adb shell service list</span><br></pre></td></tr></table></figure><p>查看屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br><span class="line">db shell dumpsys window | grep init</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys-activity-内容组成"><a href="#adb-shell-dumpsys-activity-内容组成" class="headerlink" title="adb shell dumpsys activity 内容组成"></a>adb shell dumpsys activity 内容组成</h3><ol><li>ACTIVITY MANAGER SETTINGS(dumpsys activity settings)</li><li>ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)</li><li>ACTIVITY MANAGER BROADCAST STATE(dumpsys activity broadcasts)</li><li>ACTIVITY MANAGER CONTENT PROVIDERS(dumpsys activity providers)</li><li>ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)</li><li>ACTIVITY MANAGER SERVICES (dumpsys activity services)</li><li>ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)</li><li>ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)</li><li>ACTIVITY MANAGER STARTER (dumpsys activity starter)</li><li>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</li><li>ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)</li></ol><p>使用 <code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code> 限制仅输出 “Running activities” 列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。&lt;/li&gt;
&lt;li&gt;后台程序。在相应的设备(模拟器、真机)上运行命令，作为&lt;code&gt;后台进程&lt;/code&gt; 在 &lt;code&gt;设备&lt;/code&gt;上运行。&lt;/li&gt;
&lt;li&gt;服务器。管理客户端和后台程序之间的通信，在 &lt;code&gt;开发计算机&lt;/code&gt; 上作为 &lt;code&gt;后台进程&lt;/code&gt; 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;android_sdk/platform-tools/ 中找到 adb 工具。&lt;/p&gt;
&lt;h3 id=&quot;adb-工作方式&quot;&gt;&lt;a href=&quot;#adb-工作方式&quot; class=&quot;headerlink&quot; title=&quot;adb 工作方式&quot;&gt;&lt;/a&gt;adb 工作方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。&lt;/li&gt;
&lt;li&gt;服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。&lt;/li&gt;
&lt;li&gt;当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="adb" scheme="/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Java IO 流</title>
    <link href="/2019/03/25/%E6%B5%81/"/>
    <id>/2019/03/25/流/</id>
    <published>2019-03-25T09:03:45.000Z</published>
    <updated>2019-04-09T07:40:35.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 为文件和目录路径名的抽象表示方式。<br>一个 File 对象可以代表一个文件或目录的抽象。<br>建立 File 对象不会对文件系统产生影响。</p><p>File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。</p><p>File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。</p><h3 id="File-的基本操作"><a href="#File-的基本操作" class="headerlink" title="File 的基本操作"></a>File 的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getName():获得文件的名字、路径名</span><br><span class="line">getPath():路径名</span><br><span class="line">getAbsoluteFile():绝对路径名</span><br><span class="line">getParentFile():父路径，没有为 null</span><br><span class="line">file 的绝对路径和相对路径</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建文件和删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createNewFile():</span><br><span class="line">createTempFile():创建临时文件，调用 deleteOnExit 会在程序退出后删除。</span><br></pre></td></tr></table></figure><p>文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir():新建文件夹，父路径不存在创建失败,文件夹存在不创建</span><br><span class="line">mkdirs():新建文件夹链，父路径不存在创建父目录</span><br></pre></td></tr></table></figure><h3 id="IO-流原理"><a href="#IO-流原理" class="headerlink" title="IO 流原理"></a>IO 流原理</h3><p>程序与文件、数组、网络连接数据库之间进行进行数据交换。</p><p><strong>IO 流的操作以程序为中心，什么是以程序为中心？</strong></p><p>就是如果要读度文件数据的话，对于文件来说为输出流，而对于程序来说为输入流，那么就以输入流来命名该文件流。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按流向分类</strong>：</p><ol><li>输入流</li><li>输出流</li></ol><p><strong>按处理的数据分类：</strong></p><ol><li>字节流：二进制，可以处理一切文件</li><li>字符流：文本文件 ，只能处理纯文本</li></ol><p><strong>按功能分类：</strong></p><ol><li>节点流：离源头近，包裹源头</li><li>处理流：增强功能，提高效率</li></ol><h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p><strong>两种流均为节点流，节点流为直接和源文件相连的流。</strong></p><p>InputStream(输入字节流)、OutputStream(输出字节流)</p><table><thead><tr><th>–</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p><strong>字节流可以处理一切格式的文件</strong>。</p><p><strong>字节流常用 API</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileInputStream</span><br><span class="line">read(byte[] b)、read(byte[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileOutoutStream</span><br><span class="line">writer(byte[] b)、write(byte[],int off,int len)、flush()、close()</span><br></pre></td></tr></table></figure><p>// 读取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileInputStream inputStream = null;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // 缓存数组</span><br><span class="line">        byte[] array = new byte[10];</span><br><span class="line">        int len = 0;//实际读取的大小</span><br><span class="line">        while ((len = inputStream.read(array)) != -1) &#123;</span><br><span class="line">            String info = new String(array, 0, len);</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 写出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileOutputStream outputStream = null;</span><br><span class="line">try &#123;</span><br><span class="line">    outputStream = new FileOutputStream(file, true);</span><br><span class="line">    String inrfo = &quot;wojwoo我们&quot;;</span><br><span class="line">    byte[] data = inrfo.getBytes();</span><br><span class="line">    outputStream.write(data);</span><br><span class="line">    outputStream.flush();//强制刷新，使在数组中的数据强制写出</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符流常用API</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileReader</span><br><span class="line">read(char[] b)、read(char[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileWriter</span><br><span class="line">writer(char[] b)、write(char[],int off,int len)、flush()、close</span><br></pre></td></tr></table></figure><p><strong>流的基本操作：</strong></p><ol><li>建立联系。 File 为程序与文件之间的联系,即 建立 File 对象。</li><li>选择合适的流。 </li><li>操作：流的读取，关键：缓存数组。</li><li>关闭流。</li></ol><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>只可处理纯文本文件，如 .txt、 .html 。</strong>  </p><p>Reader、Writer、FileReader、FileWriter</p><p>纯文本的读取、纯文本的写出</p><p>数组为 char[] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File src = new File(allPath, &quot;a&quot;);</span><br><span class="line">Reader reader = null;</span><br><span class="line">if (src.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = new FileReader(src);</span><br><span class="line">        char[] buffer = new char[512];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">            String str = new String(buffer, 0, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;file not exist&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p><img src="/images/2019_04_02_4.jpg" alt="字节流"></p><p><img src="/images/2019_04_02_3.jpg" alt="处理流"></p><p>增强功能，提高性能。</p><p><strong>节点流和处理流的关系：</strong></p><ol><li><p>节点流：可以直接从数据源读取或写出数据。</p></li><li><p>处理流：不直接连接到数据源或目的地，是处理流的流，通过对其他流的处理提高程序的性能。 </p></li><li><p>节点流处于 IO 操作的第一线，所有的操作必须通过它们，处理流可以对其他流进行处理。</p></li><li><p>处理流在节点流之上。</p></li></ol><p><strong>字节流的处理流</strong>：</p><p>BufferredInputStream、BufferendOutoutStream</p><p><strong>为字节流添加处理流</strong>：</p><p>new BufferredInputStream(new FileInputStream(xx,xx));</p><p>new BufferendOutoutStream(new FileOutputStream(xx,xx));</p><p><strong>字符流的处理流</strong>：</p><p>BufferendReader: readLine()</p><p>BufferendWrinter: newLine()</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>将字节流转换为字符流，可以指定编码格式将字节流转换为字符流，处理乱码(编码器、解码集)。</p><p>以程序为中心：</p><p>解码：二进制   –(解码字符集)–&gt;    字符</p><p>编码：字符  –(编码字符集)–&gt; 二进制</p><p>乱码原因：</p><ol><li>编码与解码字符集不同。</li><li>字节数目不完整。</li></ol><p> 字节流转换为字符流：</p><ol><li>输入流：InputStreamReader  解码（读取二进制文件，显示为人类可识别的字符）</li><li>输出流：OutputStreamWriter   编码 （将人类识别的字符转换为字节，写入文件）</li></ol><p>编码要求：使用字符流用指定的解码格式读取文本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初步实现如下，但是不能指定解码格式</span><br><span class="line">BufferendReader reader = new BufferendReader(new FileReader(xxx));</span><br><span class="line"></span><br><span class="line">//现在就是转换流出场的时候了，可以使用转换流以指定的解码方式将字节流转换为字符流</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;&quot;),&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;File&quot;&gt;&lt;a href=&quot;#File&quot; class=&quot;headerlink&quot; title=&quot;File&quot;&gt;&lt;/a&gt;File&lt;/h3&gt;&lt;p&gt;File 为文件和目录路径名的抽象表示方式。&lt;br&gt;一个 File 对象可以代表一个文件或目录的抽象。&lt;br&gt;建立 File 对象不会对文件系统产生影响。&lt;/p&gt;
&lt;p&gt;File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。&lt;/p&gt;
&lt;p&gt;File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。&lt;/p&gt;
&lt;h3 id=&quot;File-的基本操作&quot;&gt;&lt;a href=&quot;#File-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;File 的基本操作&quot;&gt;&lt;/a&gt;File 的基本操作&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getName():获得文件的名字、路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getPath():路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getAbsoluteFile():绝对路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getParentFile():父路径，没有为 null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file 的绝对路径和相对路径&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="IO 流" scheme="/tags/IO-%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>设计六大准则(设计模式之禅)</title>
    <link href="/2019/03/19/%E8%AE%BE%E8%AE%A1%E5%85%AD%E5%A4%A7%E5%87%86%E5%88%99/"/>
    <id>/2019/03/19/设计六大准则/</id>
    <published>2019-03-19T04:58:37.000Z</published>
    <updated>2019-03-25T07:11:28.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则 (Single Responsibility Principle)(SRP)"></a>单一职责原则 (Single Responsibility Principle)(SRP)</h3><p><strong>定义：</strong> 应该有且仅有一个原因引起类的变更。</p><p><strong>操作：</strong></p><ol><li>当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。</li><li>SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。</li></ol><p><strong>好处：</strong></p><ol><li>降低类的复杂度，实现什么职责都有明显的定义</li><li>可读性提高、可维护性强</li><li>变更风险低</li></ol><p><strong>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。</strong></p><a id="more"></a><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)(LSP)"></a>里氏替换原则(Liskov Substitution Principle)(LSP)</h3><p><strong>继承的优点</strong>：</p><ol><li>代码共享，每个子类拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>提高代码的扩展性，可 “随意” 重写父类方法；</li></ol><p><strong>继承的缺点：</strong></p><ol><li>继承具有入侵性，实现父类就必须拥有父类的方法和属性；</li><li>降低代码的灵活性，原因同上；</li><li>增强了耦合性。父类中的常量、变量、方法修改后，影响子类。</li></ol><p><strong>定义：</strong></p><p>凡是引用父类的地方都可以透明的使用其子类对象，反之，不成立。</p><p><strong>引申义：</strong></p><ol><li>子类必须完全实现父类的方法</li></ol><p><em>在类中调用其他类时 <code>务必使用父类或接口</code>，如果不能使用父类或接口，说明类的设计已经违反了 LSP 原则。</em></p><p>如果子类不能完整的实现父类中的方法或者父类中的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承。</p><ol start="2"><li><p>子类可以有自己的方法。这也就是 LSP 原则不能反过来用的原因。</p></li><li><p>覆盖或实现父类方法时，输入参数可以被放大。 </p></li><li><p>覆盖或实现父类方法时，输出结果可以被缩小。</p></li></ol><p><strong>优点：</strong></p><p>里氏替换原则的目的是增强程序的健壮性，即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对于不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h3 id="依赖倒置-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置(Dependence Inversion Principle)(DIP)"></a>依赖倒置(Dependence Inversion Principle)(DIP)</h3><p><strong>依赖倒置含义：</strong></p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖抽象。</li><li>抽象不应该依赖细节。</li><li>细节应该依赖抽象。</li></ol><p><strong>具体含义：</strong></p><p>低层模块：基本逻辑</p><p>高层模块：基本逻辑的组合</p><p>抽象：接口或抽象类</p><p>细节：实现类、继承子类</p><p><strong><em>模块之间的关系通过抽象产生</em></strong>，实现类之间不能直接发生依赖关系，其依赖关系通过上层的接口或者抽象类产生。</p><p>接口或抽象类不依赖实现类，实现类依赖接口或抽象类。</p><p><strong>优点：</strong></p><p>采用依赖倒置原则可以减少类间的耦合关系(更准确的说是(通过抽象类之间的关系)降低实现类之间的关系)，提高系统的稳定性，降低开发风险，提高代码的可读性和维护性。</p><p>抽象是对实现的约束，对依赖者而言，也是一种契约，不仅约束自己，同时还约束自己与外界的关系，其目的是保证所有的而细节不脱离契约的范畴，确保约束的双方按照既定的契约(抽象)共同发展，只要抽象这根基线存在，细节就不会超出范围。</p><p><strong>依赖关系</strong></p><p>依赖关系的概、具体表现、UML 图例表示可以参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/81531727" target="_blank" rel="noopener">Java 对象间关系以及 UML 类图表示方法</a> 下面简写如下：</p><ol><li>构造器函数传递依赖对象</li><li>方法中参数传递对象</li><li>接口声明中声明依赖对象。</li></ol><p><strong>最佳实践：</strong></p><p>依赖倒置原则的本质是 <code>通过抽象(抽象类或接口类)使各个类或模块的实现彼此独立</code>，不互相影响，实现模块间的松耦合，如何做：</p><ol><li>每个类尽量都有接口或抽象类，这是依赖倒置原则的基本要求，<strong>有了抽象才有可能倒置</strong>。</li><li>变量的表面类型(编译类型)尽量是接口或抽象类。</li><li>任何类都不应该从具体类派生出来。</li><li>尽量不要覆盖基类的方法(该方法已经在基类中实现)。如果说基类是一个抽象类，而且这个方法已经被实现了，子类尽量不要覆写。类间的依赖是抽象，覆写类抽象方法，对依赖的稳定性有所影响。</li><li>集合里氏替换原则。</li></ol><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>再此层面上 接口分为：</p><ol><li>实例接口 (类也是一种接口)</li><li>类接口(interface)</li></ol><p>隔离：即把一个接口中的多种职责进一步拆分出来，作为两个颗粒度更小的接口，此刻两个职责被单独隔离处理。</p><p><strong>定义：</strong></p><p>接口尽量细化，同时接口中的方法尽量少。</p><p><strong>如何对接口进行约束：</strong></p><ol><li>接口尽量小，满足单一职责原则。</li><li>接口高内聚。</li></ol><p>针对于接口高内聚就是要在接口中尽量少公布 public 方法，接口是对外的承诺，对外承诺越少越有利于系统的开发，这样变更的风险越低。</p><h3 id="迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP"><a href="#迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP" class="headerlink" title="迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)"></a>迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)</h3><p>一个对象应该对其他对象有最少的了解，换句话说，一个类应该对自己需要耦合或调用的类知道的最少，被耦合的类或这被调用的类内部如何复杂都和该类没有关系，我只需知道它们提供的 public 方法。</p><p><strong>只需要和朋友类联系：</strong></p><p>朋友类：出现在成员变量、方法的输入和输出参数的类为朋友类。<br>其实朋友类就是产生 <code>依赖关系的类</code>。</p><p><strong>朋友类中不应该向对方暴露的过多</strong></p><p>如果可能的话，尽量向其他类暴露尽量少的方法。</p><p><strong>自己的自己拥有</strong><br>如果一个类可以放在本类中，既不会增加类间关系，也不会对本类产生负面影响，那就放在本类中。</p><p><strong>尽量少的使用 Serializable</strong></p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体如类、模块、函数应该对扩展开发，对修改关闭。</p><p>开闭原则是最基础的一个原则，前面介绍的 5 个原则都是在开闭原则的具体形态，它们为指导设计的工具和方法，而开闭原则才是精神领袖。</p><p><strong>原则细节</strong></p><p>应该尽量通过扩展实体行为的方式来实现变化，而不是通过修改已有的代码来实现变化。</p><p>在软件开发中，尽可能减少代码粒度，代码粒度越小，被复用的可能越大。</p><p><strong>如何使用</strong></p><ol><li>抽象约束。</li></ol><p>具体表现为：</p><pre><code>1. 在对接口或抽象类进行扩展时，不允许出现接口或抽象类中不存在的 public 方法。2. 参数类型、引用对象尽量使用接口或抽象类，而不是实现类。3. 抽象应保持稳定，一旦确定不允许更改。</code></pre><ol start="2"><li>封装变化</li></ol><p>含义：<br>        1. 将相同的变化封装到接口或抽象类中<br>        2. 将不同的变化封装到不同的接口或抽象类中，不应该两个变化出现在同一个接口或抽象中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单一职责原则-Single-Responsibility-Principle-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-Single-Responsibility-Principle-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 (Single Responsibility Principle)(SRP)&quot;&gt;&lt;/a&gt;单一职责原则 (Single Responsibility Principle)(SRP)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 应该有且仅有一个原因引起类的变更。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。&lt;/li&gt;
&lt;li&gt;SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低类的复杂度，实现什么职责都有明显的定义&lt;/li&gt;
&lt;li&gt;可读性提高、可维护性强&lt;/li&gt;
&lt;li&gt;变更风险低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式六大原则" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Three</title>
    <link href="/2019/03/15/Java-Basic-%E4%B8%89/"/>
    <id>/2019/03/15/Java-Basic-三/</id>
    <published>2019-03-15T09:08:48.000Z</published>
    <updated>2019-05-29T10:11:56.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在只定义了方法的签名，没有方法的类称为抽象类。</p><ul><li>抽象类和抽象方法使用 abstract 修饰</li><li>抽象类不能实例化</li><li>抽象类可以没有抽象方法，可以有非抽象方法</li><li>抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)</li><li>含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类</li></ul><p>abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。</p><a id="more"></a><h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><p>抽象类是将多个子类向高层抽象，为子类提供行为模板,定义了子类中存在的共有行为。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口进一步将抽象类抽象。</p><p>接口定义了多个类共同的公共行为规范。</p><p>接口中不能含有</p><ol><li>构造器</li><li>初始化块</li></ol><p>但是接口中包含：</p><ol><li>成员变量(只能是静态)</li><li>方法(抽象实例方法、类方法、默认方法)</li><li>内部类(内部接口、枚举)</li></ol><h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><p>接口中的所有成员的访问权限为 <code>public</code> 。<br>对于接口中的静态常量而言，它们是接口相关的，系统会自动为这些成员变量增加 static 和 final 两个修饰符，必须在定义时进行初始化。</p><h3 id="接口中的默认方法、静态方法"><a href="#接口中的默认方法、静态方法" class="headerlink" title="接口中的默认方法、静态方法"></a>接口中的默认方法、静态方法</h3><p>接口中的默认方法和静态方法都可以实现，拥有方法体。</p><p>在 Java8 之前接口中的所有方法均为抽象方法，但是在 Java8 后系统为接口增加了默认方法，此方法增加了接口的可扩展性，如果需要在已有业务上需要为接口增加新的方法来实现增加业务的目的。那么 Java8 之前如果为接口增加方法，那么所有实现类均需要更改。在 Java8 后增加而 <code>默认方法</code>，实现类不是必须要实现该方法，如果实现了没有显示实现该方法，那么调用时使用默认实现。</p><p>而接口中的静态方法，需要通过接口名实现调用，在默认方法中可以调用本类的默认方法。</p><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p><em>一个类实现了一个接口后，这个类需要实现这个接口中的所有抽象方法，否则，这个类将保留从接口继承的抽象方法，则这个类必须定义为抽象类</em>。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>同：</strong></p><ol><li>不能被实例化，只能被其他类继承或实现。</li><li>都可以包含抽象方法，实现或继承的子类需要实现这些抽象方法。</li></ol><p><strong>异：</strong></p><p>接口作为系统与外界交互的窗口，接口体现的是一种规范,对于接口的实现者来说，接口规定了实现者必须向外提供哪些服务(以方法的形式)；对于接口的调用者来说，接口规定了可以调用哪些服务，以及如何调用服务(如何调用方法)。</p><p>抽象作为系统中多个子类的共同父类，它体现的是一种模板式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;存在只定义了方法的签名，没有方法的类称为抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法使用 abstract 修饰&lt;/li&gt;
&lt;li&gt;抽象类不能实例化&lt;/li&gt;
&lt;li&gt;抽象类可以没有抽象方法，可以有非抽象方法&lt;/li&gt;
&lt;li&gt;抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)&lt;/li&gt;
&lt;li&gt;含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>requestDisallowInterceptTouchEvent</title>
    <link href="/2019/03/14/requestDisallowInterceptTouchEvent/"/>
    <id>/2019/03/14/requestDisallowInterceptTouchEvent/</id>
    <published>2019-03-14T03:54:33.000Z</published>
    <updated>2019-03-14T11:15:50.581Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p>调用 <code>requestDisallowInterceptTouchEvent</code> 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于 ViewGroup 为什么还是会拦截 ACTION_DOWN 事件，是因为 ViewGruop 在 ACTION_DOWN 事件时会重新置位 FLAG_DISALLOW_INTERCEPTER 标志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;requestDisallowInterceptTouchEvent&lt;/code&gt; 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于
      
    
    </summary>
    
    
      <category term="View" scheme="/tags/View/"/>
    
      <category term="事件分发机制" scheme="/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>拖动百度地图出现黑影的解决方法</title>
    <link href="/2019/03/13/%E6%8B%96%E5%8A%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%87%BA%E7%8E%B0%E9%BB%91%E5%BD%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>/2019/03/13/拖动百度地图出现黑影的解决方法/</id>
    <published>2019-03-13T08:29:09.000Z</published>
    <updated>2019-03-14T02:12:43.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述及解决方案"><a href="#问题描述及解决方案" class="headerlink" title="问题描述及解决方案"></a>问题描述及解决方案</h3><p><code>NestScrollView</code> 嵌套 <code>MapView</code> 在滑动整个布局时，<code>MapView</code> 的上下边界出现黑影。</p><p>问题解决：</p><p>使用 <code>TextureMapView</code> 替换布局中的 <code>MapView</code> 并开启硬件加速，如果只在当前 Activity 中开启硬件加速，执行在清单文件中该 Activity 注册信息中添加标签：<code>android:hardwareAccelerated=&quot;true&quot;</code> 。</p><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述及解决方案&quot;&gt;&lt;a href=&quot;#问题描述及解决方案&quot; class=&quot;headerlink&quot; title=&quot;问题描述及解决方案&quot;&gt;&lt;/a&gt;问题描述及解决方案&lt;/h3&gt;&lt;p&gt;&lt;code&gt;NestScrollView&lt;/code&gt; 嵌套 &lt;code&gt;MapVi
      
    
    </summary>
    
    
      <category term="百度地图黑影" scheme="/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%BB%91%E5%BD%B1/"/>
    
      <category term="硬件加速" scheme="/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 单例的几种写法</title>
    <link href="/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>/2019/03/13/单例的几种写法/</id>
    <published>2019-03-13T03:37:05.000Z</published>
    <updated>2019-05-24T10:08:53.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何实现单例类"><a href="#如何实现单例类" class="headerlink" title="如何实现单例类"></a>如何实现单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式()"></a>饿汉式()</h3><p><strong>方式一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private final static Singleton INSTANCE = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方式二:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种实现方法基本一致，均是利用 <strong>类变量会在加载类时完成初始化</strong> 这一特性，实现了 <strong>线程安全</strong>，在加载类的同时就会完成该类单例的创建，即使在多线程情况下访问到的也是同一个对象，当然实现了单例模式。</p><p><strong>饿汉式的 “饿”具体体现在：不管你是否使用，都会实例化该类的单例对象</strong>，正是这个特点造成了如下缺点：</p><pre><code>饿汉式在类加载时就实现了类的单例，但是存在压根就用不到该单例的情况，此时就浪费了内存。</code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>方式一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式的 “懒” 具体体现在:你用的话我就会初始化，你不用我我就不会初始化</strong>,但是也造成了已些缺陷：</p><pre><code>在多线程情况下，有可能一个线程 A 进入了 `getInstance` 方法中但是未完成对象的初始化，但是此时另外的一个线程 B 进入该方法完成初始化初始化一个对象，A 之后重新执行生成一个对象，那么此刻就违背了单例模式的初衷。</code></pre><p><strong>方式二：(改进)</strong></p><p>上面方式一谈到懒汉式存在线程安全的问题，那么改进该问题如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static synchronized Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>synchronized</code> 进行线程同步。</p><p>但是同时也需要面临的一个缺点就是每次获得该单例时都需要进行线程同步操作，效率大打折扣。</p><p><strong>方式三</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                INSTANCE = new Singleton(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写虽然杜绝了每次获得实例的线程同步而引起的问题，但是这种方式是有明显的缺点的：一个线程执行 <code>if(INSTANCE == null)</code> 方法时，其他多个线程可能会同时执行该方法，并且执行至 <code>if(INSTANCE == null)</code>代码后 后，虽然多个线程在此排队获得 <code>Singleton</code> 类的锁，但是这样每个运行至此的线程都会实例化对象，造成程序中出现多个实例对象。</p><h3 id="多重检查-饿汉式终极形态"><a href="#多重检查-饿汉式终极形态" class="headerlink" title="多重检查(饿汉式终极形态)"></a>多重检查(饿汉式终极形态)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(INSTANCE == null)&#123;</span><br><span class="line">                    INSTANCE = new Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的 饿汉方式三 做出改进，即在同步代码块中再做一次空判断，杜绝了以上方式的明显缺陷。</p><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonInstance&#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不会再外部类完成类加载的时候进行初始化加载，只会在调用时进行相关的类加载，实现了 <strong>懒加载</strong> 的功能，由于类加载只有在程序中出现一次，其享相应的属性也只会存在一份，实现了单例。</p><h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Effective Java 推荐使用，避免线程安全问题，支持自动序列化，注意枚举特性为 JDK 1.5 后添加。</p><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>一般情况下，推荐使用 <code>饿汉方式</code>，如果项目需求实现懒加载，推荐使用 <code>静态内部类方式</code>，涉及反序列试一下 <code>枚举方式</code>,特殊需求使用 <code>多重检查</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何实现单例类&quot;&gt;&lt;a href=&quot;#如何实现单例类&quot; class=&quot;headerlink&quot; title=&quot;如何实现单例类&quot;&gt;&lt;/a&gt;如何实现单例类&lt;/h3&gt;&lt;p&gt;如果一个类只能创建一个实例，那么这个类称为 &lt;strong&gt;单例类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据良好性封装原则，我们需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把类构造器函数隐藏&lt;/li&gt;
&lt;li&gt;提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot; title=&quot;饿汉式()&quot;&gt;&lt;/a&gt;饿汉式()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private final static Singleton INSTANCE = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getInstance&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return INSTANCE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Singleton" scheme="/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Android 焦点机制</title>
    <link href="/2019/03/11/Android-%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    <id>/2019/03/11/Android-焦点机制/</id>
    <published>2019-03-11T03:08:29.000Z</published>
    <updated>2019-03-13T02:44:51.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式"><a href="#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式" class="headerlink" title="No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)"></a>No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)</h3><p>Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 <code>触摸模式</code>，而像 Andorid TV、键盘、轨迹球一般为 <code>非触摸模式</code>。</p><h3 id="Focus-焦点-、Focusable-可聚焦"><a href="#Focus-焦点-、Focusable-可聚焦" class="headerlink" title="Focus(焦点)、Focusable(可聚焦)"></a>Focus(焦点)、Focusable(可聚焦)</h3><p>在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。<br>根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。</p><a id="more"></a><p>根据用户的不同行为,两种模式可以不断切换：<br>在用户点击屏幕时，设备会进入触摸模式，而当用户点击轨迹球时，App 会立即退出触摸模式进入非触摸模式，并寻找一个控件获得焦点。</p><h3 id="触摸模式与-Focusable"><a href="#触摸模式与-Focusable" class="headerlink" title="触摸模式与 Focusable"></a>触摸模式与 Focusable</h3><p>Focusable 此特殊模式是为接收文本输入的控件创建的，如 EditText。在触摸模式中，如果控件是可聚焦的(Focusable),只要用户点击该控件，该控件就会得到焦点，反之控件是不会获得焦点的。</p><p>Foucusable 其实为控件的一个属性，可以通过代码 <code>setFocusableInTouchMode</code> 或 xml中<code>android:focusableInTouchMode</code>设置控件是否可聚焦。</p><h3 id="setFocusableInTouchMode-和-setFocusable"><a href="#setFocusableInTouchMode-和-setFocusable" class="headerlink" title="setFocusableInTouchMode 和 setFocusable"></a>setFocusableInTouchMode 和 setFocusable</h3><ul><li>setFocusable:设置控件是否可以获得焦点，可以通过 isFocusable() 获得状态。</li><li>setFocusableInTouchMode: 在触摸模式下，可以通过setFocusableInTouchMode 来设置控件是否可聚焦，可以通过isFocusableInTouchMode() 获得状态。</li></ul><p>大部分控件的 <code>setFocusableInTouchMode</code> 属性均为 false ，至于 EditText 的 <code>setFocusableInTouchMode</code> 的属性为 true，这也就是为什么 EditText 会率先获得屏幕焦点的原因。</p><h3 id="焦点监听与事件监听"><a href="#焦点监听与事件监听" class="headerlink" title="焦点监听与事件监听"></a>焦点监听与事件监听</h3><p>当为控件设置可聚焦属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">      android:id=&quot;@+id/btnOne&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:text=&quot;one&quot;</span><br><span class="line">      android:focusableInTouchMode=&quot;true&quot;   </span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><p>同时，为该控件设置了点击事件、焦点监听，此时是需要特别注意的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnOne.setOnclickListener&#123;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;click&quot;)</span><br><span class="line">&#125;</span><br><span class="line">btnOne.setOnFocusChangeListener&#123; v, hasFocus -&gt;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;focus change&quot; + hasFocus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们点击 Button 时，此时 Log 日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG focus change true</span><br></pre></td></tr></table></figure><p>而不会响应点击事件，想要 Button 响应点击事件，需要再次点击该按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG click</span><br></pre></td></tr></table></figure><p>在这种情况下，需要点击两次才能让 Button 响应点击事件：</p><ol><li>Button 获得焦点</li><li>Button 响应点击事件</li></ol><p>所以 Google 建议使用 <code>focusableInTouchMode</code> 之前，需要三思后行。</p><h3 id="descendantFocusability"><a href="#descendantFocusability" class="headerlink" title="descendantFocusability"></a>descendantFocusability</h3><p><code>Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.</code></p><p>该属性的字面意思: 子代获取焦点的能力。该属性定义的是当一个 子View 获取焦点时， ViewGroup 与 子View 之间的关系。</p><ul><li><strong>beforeDescendants</strong>：Viewgroup 会优先其子类控件而获取到焦点</li><li><strong>afterDescendants</strong>：Viewgroup 只有当其子类控件不需要获取焦点时才获取焦点</li><li><strong>blocksDescendants</strong>：Viewgroup 会覆盖子类控件而直接获得焦点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot;&gt;&lt;a href=&quot;#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot; class=&quot;headerlink&quot; title=&quot;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&quot;&gt;&lt;/a&gt;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&lt;/h3&gt;&lt;p&gt;Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 &lt;code&gt;触摸模式&lt;/code&gt;，而像 Andorid TV、键盘、轨迹球一般为 &lt;code&gt;非触摸模式&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Focus-焦点-、Focusable-可聚焦&quot;&gt;&lt;a href=&quot;#Focus-焦点-、Focusable-可聚焦&quot; class=&quot;headerlink&quot; title=&quot;Focus(焦点)、Focusable(可聚焦)&quot;&gt;&lt;/a&gt;Focus(焦点)、Focusable(可聚焦)&lt;/h3&gt;&lt;p&gt;在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。&lt;br&gt;根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。&lt;/p&gt;
    
    </summary>
    
    
      <category term="焦点机制" scheme="/tags/%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java Baseic Two</title>
    <link href="/2019/03/07/Java-Basic-%E4%BA%8C/"/>
    <id>/2019/03/07/Java-Basic-二/</id>
    <published>2019-03-07T04:56:36.000Z</published>
    <updated>2019-05-29T10:11:57.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equal-方法"><a href="#与-equal-方法" class="headerlink" title="== 与 equal 方法"></a>== 与 equal 方法</h3><p>Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。</p><p>当使用 <code>==</code> 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 <strong><code>==</code> 不可用于比较类型上没有父子关系的两个对象</strong>。</p><p>equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。</p><p>在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。</p><p>所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。</p><a id="more"></a><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">String c = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>此时堆内存中只会分配一份存储 “abc” 的内存, 变量 a、b、c 的引用地址都指向该内存地址。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池，主要是用来管理编译时被确定并且保存在 .class 文件中的数据，包括类、方法、接口中的常量以及字符串常量。</p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>被 static 修饰的变量、方法、初始化块、内部类等称为类变量。类变量属于类，在第一加载类的时候，系统会为类变量分配内存空间并进行初始化，直到该类被卸载，类变量占用的内存从会被标记成垃圾。</p><p>类变量中不能访问非 static 变量成员(变量、方法等),因为 类成员的作用域比非 static 变量成员的作用域大，存在类变量已经被初始化但是实例变量为被初始化的情况，此时程序就会出现异常。</p><h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>final 修饰的变量不可重复赋值</strong>。</p><p><strong>final 修饰成员变量</strong></p><p>初始化位置：</p><ul><li>初始化块</li><li>构造器</li><li>声明处</li></ul><p><strong>final 修饰类变量</strong><br>初始化位置：</p><ul><li>初始化块</li><li>声明处</li></ul><p>与普通实例变量不同，final 修饰的变量(实例变量和类变量)必须显式的初始化，系统不会为 final 修饰的变量的执行默认初始化。</p><ul><li>final 修饰局部变量</li></ul><p>必须显式的初始化初始值。</p><h3 id="final-修饰基本数据类型和引用数据类型"><a href="#final-修饰基本数据类型和引用数据类型" class="headerlink" title="final 修饰基本数据类型和引用数据类型"></a>final 修饰基本数据类型和引用数据类型</h3><p>final 修饰基本数据变量，则该变量不能被改变。<br>final 修饰引用数据类型变量，说明这个变量指向的内存地址不可更改，但是并不是此对象的各个属性不可变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Person person = new Person(20,&quot;Mike&quot;);</span><br><span class="line">person.setName(&quot;Jim&quot;);</span><br><span class="line">person.age = 21;</span><br></pre></td></tr></table></figure><h3 id="final-、宏变量与宏替换"><a href="#final-、宏变量与宏替换" class="headerlink" title="final 、宏变量与宏替换"></a>final 、宏变量与宏替换</h3><p>只要满足三个条件，这个 final 变量就不再是一个变量，而相当于一个直接量：</p><ol><li>使用 final 修饰</li><li>定义该 final 变量时指定初始值</li><li>该初始值在编译器时被确定下来。</li></ol><p>那么这个变量称为 <strong>宏变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int a =  5;</span><br></pre></td></tr></table></figure><p>那么对于这个程序来说，根本不存在变量 a，出现变量a 的地方全部被 5 替换。</p><p>为了说明宏变量的不同之处，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ab&quot;;</span><br><span class="line">String str2 = &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">sout(str1==str2);// true</span><br><span class="line"></span><br><span class="line">String str3 = &quot;a&quot;;</span><br><span class="line">String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><p>至于第一个日志结果为 true ,应该十分容易理解：str1 在编译时确定值，会被存储在常量池中，str2 通过显示的 <strong>拼装后(不是分别创建“a”和“b”)</strong> 存入 <strong>常量池</strong>，但是常量池中已经存在相同的值，就不会重新创建，直接将该值的内存地址指向 str2，所以结果为 true。</p><p>而第二条日志中，str5 在编译期不会初始化，需要在运行期通过计算获得，其值会被分配在 <code>堆内存</code>去中，所以 str1 和 str5 的引用的地址不同，其打印结果为 false。</p><p>同理有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str6 = new String(&quot;ab&quot;); </span><br><span class="line">sout(str1 == str6);//false</span><br></pre></td></tr></table></figure><p>但是如果 str3 和 str4 被 final 修饰，两者就会变成宏变量，两变量出现的位置会直接被值替换，此时 str5 在编译期就会确定初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final String str3 = &quot;a&quot;;</span><br><span class="line">final String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>final 方法不可被重写，但是可以被重载。</p><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>final 类不能拥有子类。</p><h3 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h3><p>不可变类为创建该类的实例后，该实例的实例变量不可变。</p><p>Java 提供的 8 个包装类和 String 为不可变类。</p><p>自定义不可变类需要遵循以下规则：</p><ol><li>使用 private final 修饰成员变量</li><li>提供构造器，传入初始值</li><li>仅提供 getter 方法</li><li>如果有必要，重新 equal() 和 hashcode() 方法自定义相等的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equal-方法&quot;&gt;&lt;a href=&quot;#与-equal-方法&quot; class=&quot;headerlink&quot; title=&quot;== 与 equal 方法&quot;&gt;&lt;/a&gt;== 与 equal 方法&lt;/h3&gt;&lt;p&gt;Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;==&lt;/code&gt; 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 不可用于比较类型上没有父子关系的两个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。&lt;/p&gt;
&lt;p&gt;在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。&lt;/p&gt;
&lt;p&gt;所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic One</title>
    <link href="/2019/03/06/Java-Basic-%E4%B8%80/"/>
    <id>/2019/03/06/Java-Basic-一/</id>
    <published>2019-03-06T06:31:33.000Z</published>
    <updated>2019-05-29T10:11:58.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的三大特征"><a href="#对象的三大特征" class="headerlink" title="对象的三大特征"></a>对象的三大特征</h3><p>对象的三种基本特征:继承、封装、多态。</p><p>Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。</p><p><strong>封装</strong>： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。</p><p><strong>继承</strong>：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。</p><p><strong>多态</strong>：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// B 继承 A</span><br><span class="line">A a;</span><br><span class="line">a = new A();</span><br><span class="line">a.testMethod();// 执行 A 中方法</span><br><span class="line">a = new B();</span><br><span class="line">a.testMethod();// 执行 B 中方法</span><br><span class="line"></span><br><span class="line">//在此例中，同一个类型引用执行同一个方法，可能表现多种行为特征：类型为 A ，该类的对象 a 执行 testMethod() 方法会根据其引用对象的具体类型表现出不同的行为特征 -- A#testMethod()或B#testMethod()。</span><br></pre></td></tr></table></figure><h4 id="Java-是静态的强类型的语言"><a href="#Java-是静态的强类型的语言" class="headerlink" title="Java 是静态的强类型的语言"></a>Java 是静态的强类型的语言</h4><p>Java 是静态的，一旦一个类被定义，如果对这个类有所更改，只要不重新编译这个类，那么这个类以及这个类拥有的成员变量就不会发生改变。</p><p>Java 的强类型主要表现在两方面：</p><ol><li>所有的变量必须先声明后使用；</li><li>指定类型的变量只能赋相同类型的值；</li></ol><p>基于上面，Java 在编译期就会确定成员变量的类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>编程的本质就是对内存中的数据访问和修改</strong>，程序所用到的数据都会保存在内存中，程序员需要通过一种机制来访问和修改内存中的数据，这种机制就是 <strong>变量</strong> ，每个变量代表某一小块内存。变量是有名字的，程序对变量 <strong>赋值</strong>，就是把数据装入该变量所代表的内存区的过程；程序 <strong>读取变量</strong>，就是从变量代表的内存区取值的过程。可以简单的理解：变量相当于一个有名称的容器，该容器用于装各种不同类型的数据。</p><h3 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h3><p><img src="/images/19_03_06.jpg" alt="对象与引用"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person(&quot;Mike&quot;,20)</span><br></pre></td></tr></table></figure><p>由上文中变量是需要是需要内存存储数据的，此语句中 <code>new Person(&quot;Mike&quot;,20)</code> 只是在堆内存中开辟出一块内存去存储这个对象，而 <code>Person p</code> 则需要在栈内存中开辟一块内存来存储变量以及相关内容，至于在此区域存储的到底是什么,需要在赋值后才会具体化。在此例中，赋值语句后，变量 p 对应的栈内存存储的为新建对象 – new Person 的内存地址。</p><h3 id="this-引用"><a href="#this-引用" class="headerlink" title="this 引用"></a>this 引用</h3><p>首先 this 代表一定是个对象，其次 this 出现在不同位置含义有所不同：</p><ul><li>在构造器中代表正在初始化的对象</li><li>在方法中代码调用该方法的对象</li></ul><p>因此 static 方法中不能出现 this，因为 static 的方法属于类，是通过类去调用，此时 this 代表了类，违背了 this 代表的为一个对象的前提。</p><p>同时 static 方法不可调用非 static 变量和方法也是基于这个原因，因为类中的变量和方法存在隐式的 this 引用，即为 this 作为调用者必须是一个对象。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法名相同，而参数列表不同的现象称为方法重载。</p><ul><li>为什么返回值不作为方法重载的区分标准？</li></ul><p><strong>Java 调用方法时可以忽略返回值</strong>，如果将返回值作为重载的标准，那么存在以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int method();</span><br><span class="line">void method()</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 Java 系统将不能分辨出 test 方法中调用的 method() 是具体哪一个方法。</p><h3 id="变量及其运行机制"><a href="#变量及其运行机制" class="headerlink" title="变量及其运行机制"></a>变量及其运行机制</h3><p>成员变量：</p><ol><li>类变量：从类的准备阶段开始存在，到系统完全销毁这个类。</li><li>实例变量：从实例的创建始存在，到系统完全销毁这个实例。</li></ol><p>局部变量：</p><ol><li>形参</li><li>方法内局部变量</li><li>代码块中局部变量</li></ol><p>局部变量只要离开了相应的代码块(方法、代码块)，局部变量就会被销毁。</p><h3 id="成员变量的初始化和内存中的运行机制"><a href="#成员变量的初始化和内存中的运行机制" class="headerlink" title="成员变量的初始化和内存中的运行机制"></a>成员变量的初始化和内存中的运行机制</h3><p>JVM 加载类经历以下几个阶段：</p><ol><li>类加载</li><li>类验证</li><li>类准备</li><li>类解析</li><li>类初始化</li></ol><p>当系统加载类或创建类实例时，系统会自动为成员变量分配内存，并赋初值。<br>Person 类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private static int phone;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person 类使用</span><br><span class="line">Person a = new Person();</span><br><span class="line">a.phone = 110;</span><br><span class="line">a.name = &quot;mike&quot;;</span><br></pre></td></tr></table></figure><p>当执行 <code>Person a = new Person();</code> 时，如果程序中第一次使用 Person 类， JVM 将会加载 Person 类，并初始化这个类。在类的准备阶段，<strong>JVM 将会该类的类变量分配内存空间并初始化</strong>。当 Person 类初始化完成后，系统中的内存情况如下图：</p><p><img src="/images/2019_03_06_1.jpg" alt="类初始化"></p><p>当类完成初始化后，JVM 将在 堆内存 中为 Person 类分配一块内存(JVM 会为Person类创建一个对象)，这块内存区包含了类变量 phone 的内存，并初始化它的初值。</p><p>接着，系统创建一个 Person 对象，并把这个对象赋值给 p 变量， Person 对象中包含了实例变量–name，<strong>实例变量在创建实例时分配内存空间并赋初值</strong>。JVM 创建了第一个 Person 对象后，内存分配情况如下：</p><p><img src="/images/2019_03_06_2.jpg" alt="实例变量初始化"></p><p>当再次创建 Person 对象时，不需要再对 Person 类初始化。</p><p>对类变量和实例变量赋值时,内存分配情况如下：</p><p><img src="/images/2019_03_06_3.jpg" alt="赋值"></p><p>其中，类变量为所有实例共有，每个实例都有权对其进行更改。</p><h3 id="局部变量的初始化和内存中的运行机制"><a href="#局部变量的初始化和内存中的运行机制" class="headerlink" title="局部变量的初始化和内存中的运行机制"></a>局部变量的初始化和内存中的运行机制</h3><p>系统不会为局部变量进行初始化，所以局部变量必须手动初始化。</p><p>与成员变量不同，<code>局部变量的分配内存为所在的方法栈区</code>，如果局部变量时基本数据类型，会直接存在方法栈中;如果为引用变量，则存放引用地址，通过该引用地址指向实际引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test(int a,Person p)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 方法栈中内存分配情况如下：</p><p><img src="/images/2019_03_06_4.jpg" alt="局部变量"></p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>private:类私有</li><li>default:同包可访问</li><li>protected:同包及子类可访问</li><li>public:所有类可访问</li></ul><h3 id="构造器与成员变量初始化"><a href="#构造器与成员变量初始化" class="headerlink" title="构造器与成员变量初始化"></a>构造器与成员变量初始化</h3><p>我们知道在创建一个对象时，系统会为这个对象的实例变量进行默认初始化，根据数据类型的不同初始值为：0、falase、null。如果想要改变默认初始化，想让系统创建对象时就位对象的实例变量显示指定初始值，可以通过构造器来实现。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系中，子类和父类拥有相同的实例变量时的内存模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    public String tag = &quot;parent&quot;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Parent&#123;</span><br><span class="line">    private String tag = &quot;son&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Son son = new Son();</span><br><span class="line">// sout(son.tag); 编译错误，不可访问私有变量</span><br><span class="line">sout(((Parent)son).tag); // 打印日志为： parent</span><br></pre></td></tr></table></figure><p><img src="/images/2019_04_02_1.jpg" alt="图"></p><p>子类的实例变量隐藏父类实例变量</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java 引用变量有两个类型：<strong>编译时类型</strong> 和 <strong>运行时类型</strong>。编译时类型是由声明该变量时使用的类型决定，运行时类型是由实际赋给该变量的对象决定。</p><p>当编译时类型和运行时类型不一致，就可能发生所谓的 <strong>多态</strong>。</p><p>引用变量在编译时只能调用编译时类型所拥有的方法，运行时在可以执行其运行时类型所具有的方法。因此，在编写 Java 代码是，引用变量只能调用声明该变量时所用的类(编译时类型)中的方法，例如 <code>Object person = new Person();</code> ,<code>person</code> 只能调用 <code>Object</code> 类中的方法,不能调用 Person 中的方法。</p><p>如果想要编译时类型调用运行时类型的方法，可以对引用变量进行强转型。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>继承是实现类复用的重要手段，但是继承带来了一个坏处：破坏了封装性，即子类可以任意的访问父类的实例变量、重新父类的方法。</p><p>为了保证父类良好的封装性不被子类任意更改，设计父类应遵循如下规则：</p><ol><li>尽量隐藏父类的内部数据，使用 private 修饰;</li><li>不要让子类任意访问和修改方法。辅助方法使用 private 修饰；父类中可以被外界访问但是不可以被子类重新的方法使用 public final 修饰；希望被子类重写的方法使用 protected 修饰。</li><li>尽量不要在父构造器中调用被子类重写的方法。</li></ol><p>针对第 3 条，特殊说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    private String des;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;B&quot; + des.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">B b = new B();</span><br></pre></td></tr></table></figure><p>系统在创建 B 实例时，会首先执行父类的构造器，在父构造器中调用了被父类重写的方法，此时执行的方法为子类的重写后的方法。此时 B 的实例变量 des 还没有初始化为 null，调用会发生空指针异常。</p><p>产生此现象的原因我猜大致是因为这样：</p><blockquote><p>这个问题又牵涉到 this 引用的问题，在这个问题中我们很明确的表明当 this 出现在构造器中表示正在实例化的对象, A 构造器中 test() 方法的调用中隐藏了默认的 this 引用，所以此时 this 代表被实例化的 B 的对象，所以 A 中 test() 执行 B 中的 test() 方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象的三大特征&quot;&gt;&lt;a href=&quot;#对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;对象的三大特征&quot;&gt;&lt;/a&gt;对象的三大特征&lt;/h3&gt;&lt;p&gt;对象的三种基本特征:继承、封装、多态。&lt;/p&gt;
&lt;p&gt;Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java 继承，对象，类初始化" scheme="/tags/Java-%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于 Java 异常机制的补充</title>
    <link href="/2019/01/26/%E5%85%B3%E4%BA%8E-Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>/2019/01/26/关于-Java-异常机制的补充/</id>
    <published>2019-01-26T10:44:41.000Z</published>
    <updated>2019-01-26T10:51:14.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"><a href="#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？" class="headerlink" title="为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"></a>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</h3><p>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</p><h3 id="如何正确的关闭资源？"><a href="#如何正确的关闭资源？" class="headerlink" title="如何正确的关闭资源？"></a>如何正确的关闭资源？</h3><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="finally-与-return-的关系"><a href="#finally-与-return-的关系" class="headerlink" title="finally 与 return 的关系"></a>finally 与 return 的关系</h3><p>阐述两者的关系，我们主要关注 return 关键字的位置，为了表达的更形象，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int count = 5;</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot;);</span><br><span class="line">            System.out.println(&quot;finally 语句执行 &quot; + count);</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally 语句执行</span><br><span class="line">finally 语句执行 6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当 Java 程序执行 try/catch 中有 return 语句，return 语句会导致方法立即结束。但是系统执行完 return 语句不会马上结束该方法，而是查看在这个异常处理的流程中是否存在 finally 语句，如果存在 finally 语句，那么需要执行 finally 语句。如果 finally 语句中有 return 语句，那么会更新 try/catch 语句 return 返回的值，但是需要注意的是因为该方法已经结束，此处的 return 不会像无法返回到 try/catch 中执行代码(因为 try/catch 之后才会来到 finally 语句)。具体可以参看上例自行揣摩其中含义。</p><p>在举一个例子，我们在 catch 中执行 return 语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int[] counts = new int[]&#123;5,3&#125;;</span><br><span class="line">        int count = counts[0];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int error = counts[2];</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(&quot;catch 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch 语句执行5</span><br><span class="line">finally 语句执行6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>针对该例不做阐述。</p><h3 id="关于异常的捕获"><a href="#关于异常的捕获" class="headerlink" title="关于异常的捕获"></a>关于异常的捕获</h3><p>当 Java 运行时环境接收到异常对象时，系统会根据catch(TypeException e) 来决定使用哪一个异常分支来处理程序引发的异常。程序进入负责异常处理的 catch 块时，系统生成的异常对象 ex 将会被传给 cathc(TypeException ex) 的异常形参，从而可以在 catch 块中访问异常信息。</p><h3 id="关于异常捕获的顺序"><a href="#关于异常捕获的顺序" class="headerlink" title="关于异常捕获的顺序"></a>关于异常捕获的顺序</h3><p>捕获父类异常的 catch 块在捕获子类异常的 catch 块后，即先处理小异常，再处理大异常。</p><h3 id="使用异常机制的注意点"><a href="#使用异常机制的注意点" class="headerlink" title="使用异常机制的注意点"></a>使用异常机制的注意点</h3><ol><li>不要使用 try/catch 来控制流向。</li><li>精准捕获可能抛出的异常，不要乱抛异常，不要放大异常的范围。</li><li>不要在 finally语句中递归调用可能引起异常的方法，因为这将导致该方法的议程不能被正常抛出，甚至StackOverflowError 也不能终止程序，只能强制终止 java 进程才可以终止程序运行。</li><li>在子类复写时，子类方法只能抛出父类方法声明抛出的异常的子类。</li></ol><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/22581959.html" target="_blank" rel="noopener">疯狂 Java 系列书籍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;a href=&quot;#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot; class=&quot;headerlink&quot; title=&quot;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;/a&gt;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&lt;/h3&gt;&lt;p&gt;JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。&lt;/p&gt;
&lt;h3 id=&quot;如何正确的关闭资源？&quot;&gt;&lt;a href=&quot;#如何正确的关闭资源？&quot; class=&quot;headerlink&quot; title=&quot;如何正确的关闭资源？&quot;&gt;&lt;/a&gt;如何正确的关闭资源？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 finall 中执行资源关闭操作。&lt;/li&gt;
&lt;li&gt;保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。&lt;/li&gt;
&lt;li&gt;为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Exception" scheme="/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常机制浅析</title>
    <link href="/2019/01/26/Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>/2019/01/26/Java-异常机制浅析/</id>
    <published>2019-01-26T10:23:46.000Z</published>
    <updated>2019-05-29T10:12:08.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>所有的异常都是继承于 Throwable</p><p><img src="/images/2019_01_26.jpg" alt="运行时内存区域"></p><p> Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。</p><a id="more"></a><p>关于 Exception 派生的两个分支的依据：</p><ul><li><p><strong>RuntimeException: 由程序错误导致导致的异常。</strong></p></li><li><p><strong>其他 Exception： 程序本身没问题，但是由于像 IO 错误这类问题导致的异常属于其他异常。</strong></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RuntimeException 的几种异常：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>ClassCastException:</strong> 类变换异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IllegalArgumentException:</strong> 传递非法参数异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IndexOutOfBoundsException:</strong> 索引越界异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NoSuchElementException:</strong>  表明枚举中没有更多的元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NullPointerException:</strong> 空指针异常</p><p>对于这些异常，我们可以选择进行处理(捕获、抛出)，也可以选择不处理。如果我们不处理的话，那么异常会交给 Java 虚拟机，不断的向上层传递，那么在不同条件下导致的情况是  <strong>当前运行的线程中断或程序中断</strong>。</p><p>一般情况下我们对这类情况是不作处理的，如上文所说 <strong>“RuntimeException: 由程序错误导致导致的异常”</strong>，我们在写代码时应该尽力避免这种异常，而不应该通过 try/catch 、抛出等操作来隐藏异常。</p><p><strong>如果出现了 RuntimeException 异常，那么就一定是你的问题。</strong></p><p><strong>不是派生于 RuntimeException 的异常：</strong></p><ol><li>在文件后面读取数据</li><li>打开一个不存在的文件</li><li>根据给定的字符串去查找 Class 对象，但是这个对象表示的类不存在</li></ol><p><strong>对于这种异常，Java 编译器强制要求对这类异常进行 try/catch 并处理 或将异常抛出，否则程序就不能编译通过。</strong></p><h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>派生于 Error 或 RuntimeException 类所有的异常称为 <strong>非受查异常</strong>，其他所有的异常称为 <strong>受查异常</strong>。</p><p><strong>编译器将检查是否为所有的受查异常提供了异常处理器。</strong></p><p><strong>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什错误</strong>,我们需要在声明方法的时候同时声明该方法可能会抛出的异常。<br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public FileIputStream(String name) throw FileNotFoundException;</span><br></pre></td></tr></table></figure><p>自己在编写方法时，不可能将所有可能抛出的异常声明，下面的 4 种情况应该抛出异常：</p><ol><li>调用一个抛出异常的方法</li><li>程序运行中发现错误，并且利用 throw 语句抛出一个受查异常</li><li>程序出现错误，例如一个数据越界的非受查异常</li><li>Java 虚拟机或运行时库出现内部错误</li></ol><p>如果是前两种异常，则必须告诉调用这个方法的程序员有可能抛出的异常，因为一个抛出异常的方法都有可能是死亡陷阱。</p><p>对于一个有可能被其他人使用的 Java 方法，要根据 Java 异常规范，在方法的首部声明可能会抛出的异常。</p><p>我们不需要声明从 Error 继承的错误，不声明继承于 RuntimeException 的非受查异常。因为这些运行时错误是在我们的控制范围内，我们应该尽力避免这些错误，而不是在可能异常的位置抛出异常。</p><p> 对于一个方法必须声明所有可能抛出的受查异常，而非受查异常要么是不可控制的，要么就必须避免发生。如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。</p><h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p><strong>首先要决定抛出什么类型的异常</strong>。</p><p>对于一个已经存在的异常类，抛出异常有一下几个步骤：</p><ol><li>找到一个合适的类。</li><li>创建这个类的一个对象。</li><li>将对象抛出。</li></ol><p>以下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String readDate(Scanner in) throw EOFException&#123;//声明这个方法可能会抛出的异常</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    if(..)&#123;</span><br><span class="line">        throw new EOFException();//抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一旦方法抛出了异常，这个方法就不可能返回到调用者中，不必为返回的默认值或错误代码担忧。</strong></p><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>定义一个继承于 Exception 的子类，习惯上，这个类应该包含两个构造器，一个默认构造器，另一个带有详细描述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomException extends IOException&#123;</span><br><span class="line">    public CustomException()&#123;&#125;</span><br><span class="line">    public CustomException(String description)&#123;</span><br><span class="line">        super(description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>上面的抛出异常中，我们只需将异常抛出不用理睬了，同时有些异常是需要我们捕获的。</p><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>在异常发生的位置如果没有进行捕获操作，那么程序就会终止执行，并且在控制台打印出异常信息和堆栈内容。</p><p>捕获异常的方法：</p><ol><li>try/catch 语句</li><li>方法首部声明异常，抛给方法调用处理</li></ol><ul><li>try/catch</li></ul><p>我们使用 try/catch 语句，具体语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;catch(ExceptionType e)&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 语句中出现 catch 中出现的异常，那么程序将执行 catch 子句中的代码。</p><ul><li>抛出异常给调用者</li></ul><p>除了自己通过 try/catch 来处理异常，我们有没有更好的处理方式？答案是抛给调用者，很明显嘛，谁使用谁负责，让该方法的调用者去处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void read(String filename) throw IOException&#123;</span><br><span class="line">    InputStream in = new InputStream(filename);</span><br><span class="line">    int b;</span><br><span class="line">    while((in.read()) != -1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器严格执行 throw 说明符，如果调用了一个受查异常的方法，就必须对它进行处理，或者继续传递。</p><ul><li>如果选择 try/catch 处理还是继续传递呢？</li></ul><p><strong>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎么处理的异常继续传递。</strong></p><p>为具体说明，看一个例子：</p><p><strong>抛出异常</strong></p><p>如果传递一个异常，那么应该在方法的首部使用 throw 声明抛出的异常，告诉方法的调用者这个方法可能会抛出的一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename) throws FileNotFoundException &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在定义 read() 方法时，针对方法体中的 FileNotFoundException 异常我们不知道该怎么处理，怎么办？秉持着谁调用谁处理的原则 ，将该异常抛出，即如代码所示在方法头中 throws FileNotFoundException。在调用该方法时对异常进行处理，则有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile.read(&quot;&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样，如果我们还是不知道该如何处理该异常，也可以将异常继续抛出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() throws FileNotFoundException &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>处理异常</strong></p><p>如果我们在定义时方法体知道如何处理该异常，那么我们可以在定义方法处对异常进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename)  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们正常调用该方法就可以了， 不再需要对该方法中的异常进行任何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在类继承关系中，如果超类中的方法没有抛出异常，而子类重写了这个方法，那么这个方法必须捕获方法代码出现的每一个受查异常。在子类中不允许出现 throw 说明符中出现超过超类方法声明的异常范围。</p><h4 id="再次抛出异常和异常链"><a href="#再次抛出异常和异常链" class="headerlink" title="再次抛出异常和异常链"></a>再次抛出异常和异常链</h4><p><strong>可以在 catch 字句中抛出一个异常，这样的目的是改变异常的类型。</strong> 原来抛出的异常为 catch(异常) 中的异常，现在在 catch 语句中抛出了一个新的异常，那么最终异常类型为新异常。</p><p>场景描述：</p><p>如果开发一个供其他程序员使用的子系统，那么用于表示子系统故障的异常类型可能有多种。 ServletException 就是这样一个异常的例子，执行servlet 的代码可能不想知道发生错误的细节原因，但是希望知道 servlet 是否有问题。</p><p>下面是一个捕获异常将它再次抛出的基本方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    throw new ServletException(&quot;database error: &quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还是强烈推荐通过包装技术，<strong>将原始异常设置为新异常的原因</strong>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    Throwable se = new ServletException(&quot;database error&quot;);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们捕获异常时，可以重新获取原始异常，不会丢弃原始异常的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable e = se.getCause();</span><br></pre></td></tr></table></figure><p>一个完整的例子，帮助理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## Main.java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    showTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void showTest() &#123;</span><br><span class="line">    ReadFile readFile = new ReadFile();</span><br><span class="line">    try &#123;</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## ReadFile.java    </span><br><span class="line">public void read(String filename) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        Throwable throwable = new CustomFileExpection(&quot;在 catch中再次抛出了异常&quot;);</span><br><span class="line">        throwable.initCause(e);</span><br><span class="line">        throw throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally-字句"><a href="#finally-字句" class="headerlink" title="finally 字句"></a>finally 字句</h4><p>应用场景：<br>在 finally 语句中释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new InputStream(...);</span><br><span class="line">try&#123;</span><br><span class="line">    // 1</span><br><span class="line">    // code that migth throw exception</span><br><span class="line">    //2</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    //3</span><br><span class="line">    show error message</span><br><span class="line">    //4</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    //5</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line">//6</span><br></pre></td></tr></table></figure><ol><li>代码没有抛出异常。代码会执行 1、2、5、6</li><li>抛出一个在 catch 子句中捕获的异常。try 语句中，程序发生异常，跳过剩余代码，执行 catch 子句中代码。<ol><li>如果 catch 中子句没有抛出异常，那么执行 1、3、4、5、6。</li><li>如果 catch 中子句抛出一个异常，异常将被抛回给这个方法的调用者，执行 1、3、5.</li></ol></li><li>代码抛出了一个不是 catch 捕获的异常，这种情况下，程序执行 try 语句中所有的语句，直到有异常被抛出为止，代码执行 1、5。</li></ol><p>在日常代码中，<strong>强烈建议解耦 try/catch 和 try/finally</strong>，这样可以提高代码的清晰度，上面的代码可以这样书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in ...;</span><br><span class="line">try&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        code that might throw exception</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存 try 代码的职责是关闭输入流，外层的 try 语句的职责就是报告出现的错误。</p><p>面临的问题：<br><strong>finally 语句也可能抛出异常，这时会覆盖原来的异常。</strong></p><h4 id="带资源的-try-语句"><a href="#带资源的-try-语句" class="headerlink" title="带资源的 try 语句"></a>带资源的 try 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open a resource</span><br><span class="line">try&#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如资源属于一个实现了 AutoCloseable/Closeable 的类，Java 7 提供了一个有用的快捷方式，AutoCloseable 与一个接口方法：</p><p><code>void close() throw Exception</code></p><p>Closeable 接口的 close() 方法是一个 抛出 IOException 的方法。</p><p>带资源的 try 语句的最简形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try(Resource res = ...;)&#123;</span><br><span class="line">    work with resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 块退出时或者存在一个异常时，<strong>会自动调用 res.close()</strong>，就好像使用了 finally 块一样。 </p><p>可以指定多个资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try(Scanner in = new Scanner(new InputStream(&quot;/usr/share/dict/words&quot;),&quot;UTF-8&quot;);</span><br><span class="line">PrintWriter out = new PrintWrite(&quot;out.txt&quot;);)&#123;</span><br><span class="line">    while(in.hasNext())&#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论这个块怎么退出， in 和 out 都会关闭。</p><p>这种处理异常的方式，就避免了上文所说的在 finally 语句中抛出的异常会覆盖 try 语句抛出异常的情况。</p><p>如果此时在 finally 中 close() 也会抛出异常，那么原来在 try 子句中的异常会被重新抛出，而 close 方法抛出的异常会被抑制，这些异常会被抑制，并由 addSuppressed() 方法增加到原来的异常，可以通过 getSuppressed() 获取这个被抑制的异常。</p><p><strong>在我们查看一些开源库代码时，这种实现 Closeable 接口的方案随处可见，其目的就是在相应的代码执行完毕后，关闭资源。</strong></p><h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，这个列表就会显示出来。</p><ol><li><p>可以调用 Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StringWriter out = new StringWriter();</span><br><span class="line">t.printStackTrace(new PrintWriter(out));</span><br><span class="line">String des = out.toString();</span><br></pre></td></tr></table></figure></li><li><p>一种更为灵活的方法是使用 getStackTrace 方法，他会得到 StackTraceElement 对象的一个数组，可以在你的程序中分析这个对象数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStaceTrace();</span><br><span class="line">for(StackTraceElement frame: frames)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法，同时还含有获得类名和方法名的方法。</p><p>静态的Thread.getAllStackTrace() 方法，它可以产生所有线程的堆栈轨迹，下面给出这个方法的绝唱方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread,StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line">for(Thread t : map.keySet())&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以上方法我们可以自定义 Android 的 LogCat 的打印信息，具体代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static String generateTag() &#123;</span><br><span class="line">       StackTraceElement caller = new Throwable().getStackTrace()[2];</span><br><span class="line">       String tag = &quot;%s.%s(L:%d)&quot;;</span><br><span class="line">       String callerClazzName = caller.getClassName();</span><br><span class="line">       callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(&quot;.&quot;) + 1);</span><br><span class="line">       tag = String.format(Locale.CHINA, tag, callerClazzName, caller.getMethodName(),</span><br><span class="line">               caller.getLineNumber());</span><br><span class="line">       String customTagPrefix = &quot;h_log&quot;;</span><br><span class="line">       tag = TextUtils.isEmpty(customTagPrefix) ? tag : customTagPrefix + &quot;:&quot; + tag;</span><br><span class="line">       return tag;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void d(Object content) &#123;</span><br><span class="line">       if (!isDebug||content==null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       String tag = generateTag();</span><br><span class="line">       Log.d(tag, content.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ul><li>异常处理不能代替简单的测试</li></ul><p>捕获异常的时间较代码此时花的时间较长，只有在异常情况下使用异常机制。</p><ul><li><p>不过过分细化异常</p></li><li><p>利用异常层次结构</p></li></ul><p>根据具体代码寻找更适合的子类或创建自己的异常子类。</p><ul><li>不要压制异常</li></ul><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>在执行以下代码时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int = a/b;</span><br></pre></td></tr></table></figure><p>那么我们需要确认的是，a、b 为数值，并且 b 的值不为 0，我们可以做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(b=0) throw new IllegalAraumentException(&quot;b=0&quot;);</span><br></pre></td></tr></table></figure><p>但是以上代码会一直保存在代码中，测试工作完毕后也不会自动删除，如果代码中含有大量的这种检查，程序运行起来就会变慢。</p><p><strong>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会自动的移走。</strong></p><p>Java 引入了关键字 assert，有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：表达式;</span><br></pre></td></tr></table></figure><p>这两种形式都会对条件进行检测，如果结果为 false，则抛出一个 AssertionError 异常。在第二种形式中，表达式将会被传入 AssertionError 的构造器，并转换成一个消息字符串。</p><h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>启动或禁用断言是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码。</p><ul><li>启用断言</li></ul><p><code>java -enablessertions(-ea) MyApp</code></p><p>在某个类或整个包下使用断言：</p><p><code>java -ea:MyClass -ea:com.xx.xxx MyApp</code></p><ul><li>禁用断言</li></ul><p><code>java -disablessertions(-da) MyApp</code></p><p>有些类不是由类加载器加载，而是有直接虚拟机加载。对于不是由类加载器的系统类可是使用 -enablesystemssertions/-esa 启用断言。</p><h4 id="使用断言完成代码检查"><a href="#使用断言完成代码检查" class="headerlink" title="使用断言完成代码检查"></a>使用断言完成代码检查</h4><p>Java 中有 3 种处理系统错误的机制：</p><ol><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ol><p>选择断言记住以下几点：</p><ul><li>断言失败是致命的、不可恢复的错误</li><li>断言只用于开发和测试阶段</li></ul><p>所以不应该使用断言向程序的其他部分通告发生了可恢复性的错误，断言只应该用于在测试阶段确定程序内部的错误位置。</p><p><strong>前置条件</strong></p><p>在声明一些方法时，往往针对该方法的使用有一定的说明，有些方法往往定义一些 <strong>前置条件</strong> 来进一步指导方法的使用，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param a array to be sorted (must not be null)</span><br><span class="line">*/</span><br><span class="line">static void sort(int[] a, int fromIndex, int toIndex)</span><br></pre></td></tr></table></figure><p>那么 对数组的限制就是定义了一个前置条件，在使用这个方法时就不允许用 null 数组调用这个方法，并在这个方法的开头使用以下断言：<br><code>assert a != null;</code></p><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>我们在代码添加 <code>System.out.println()</code> 方法来调用程序员观察具体的运行过程和结果，记录日志 API 就是为了这种情况下而设计的。记录日志 API 的有点：<br>1.可以轻易的取消全部日志记录。</p><ol start="2"><li>可以很简单的禁止日志的输出。</li><li>可进行条件过滤。</li><li>日志记录可以被定向到不同的处理器，用于控制台输出，用于存储在文件中等。</li><li></li></ol><h4 id="关于异常的补充"><a href="#关于异常的补充" class="headerlink" title="关于异常的补充"></a>关于异常的补充</h4><ul><li>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</li></ul><p><strong>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</strong></p><ul><li>如何正确的关闭资源？</li></ul><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/24035306.html" target="_blank" rel="noopener">Java 核心知识 卷1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;处理错误&quot;&gt;&lt;a href=&quot;#处理错误&quot; class=&quot;headerlink&quot; title=&quot;处理错误&quot;&gt;&lt;/a&gt;处理错误&lt;/h3&gt;&lt;h4 id=&quot;异常分类&quot;&gt;&lt;a href=&quot;#异常分类&quot; class=&quot;headerlink&quot; title=&quot;异常分类&quot;&gt;&lt;/a&gt;异常分类&lt;/h4&gt;&lt;p&gt;所有的异常都是继承于 Throwable&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_26.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;p&gt; Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Exception" scheme="/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>RxJava Transformer</title>
    <link href="/2019/01/17/RxJava%20%E4%BD%BF%E7%94%A8%20Transformer%20%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2/"/>
    <id>/2019/01/17/RxJava 使用 Transformer 进行变换/</id>
    <published>2019-01-17T09:26:13.000Z</published>
    <updated>2019-01-17T10:51:43.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Observable、Observer-线程切换"><a href="#0x81-Observable、Observer-线程切换" class="headerlink" title="0x81 Observable、Observer 线程切换"></a>0x81 Observable、Observer 线程切换</h3><p>在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。</p><h3 id="0x82-Transformer-实现对调用链的处理"><a href="#0x82-Transformer-实现对调用链的处理" class="headerlink" title="0x82 Transformer 实现对调用链的处理"></a>0x82 Transformer 实现对调用链的处理</h3><p>我们可能有以下实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">abstract class SchedulerTransformer&lt;T&gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), </span><br><span class="line">                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&lt;T, T&gt;,</span><br><span class="line">        SingleTransformer&lt;T, T&gt;,</span><br><span class="line">        MaybeTransformer&lt;T, T&gt;,</span><br><span class="line">        CompletableTransformer,</span><br><span class="line">        FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Completable): CompletableSource &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Flowable&lt;T&gt;): Publisher&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Maybe&lt;T&gt;): MaybeSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Observable&lt;T&gt;): ObservableSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Single&lt;T&gt;): SingleSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在具体业务中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(ObservableOnSubscribe&lt;Int&gt; &#123; emitter -&gt; emitter.onNext(1) &#125;).compose(SchedulerTransformer(Schedulers.io(),AndroidSchedulers.mainThread())).subscribe(...);</span><br></pre></td></tr></table></figure><p></p><h3 id="0x83-RxLifeCycle2-中的实现"><a href="#0x83-RxLifeCycle2-中的实现" class="headerlink" title="0x83 RxLifeCycle2 中的实现"></a>0x83 RxLifeCycle2 中的实现</h3><p>RxLifeCycle2 中使用相同的机制，在事件处理过程中对针对生命周期做出处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(ActivityEvent.DESTROY));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity, ActivityEvent event) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(event));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在Fragment的destroy中取消订阅，防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; fragmentLifecycle(RxFragment fragment) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(fragment.bindUntilEvent(FragmentEvent.DESTROY));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x84-在-Kotlin-中的实现"><a href="#0x84-在-Kotlin-中的实现" class="headerlink" title="0x84 在 Kotlin 中的实现"></a>0x84 在 Kotlin 中的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SchedulersApply.kt</span><br><span class="line">fun &lt;T&gt; transformerSchedluer(): ObservableTransformer&lt;T, T&gt; =</span><br><span class="line">        ObservableTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) &#125;</span><br></pre></td></tr></table></figure><p>直接在调用链中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obserable..compose(transformerSchedluer2()).subscribe(....);</span><br></pre></td></tr></table></figure><h3 id="0x85-compose-操作符的功能"><a href="#0x85-compose-操作符的功能" class="headerlink" title="0x85 compose 操作符的功能"></a>0x85 compose 操作符的功能</h3><p>以上对 Observable 的变换最终插入调用链中，主要是因为 compose() 的作用。compose 操作符可以对调用链的原始 Observable 产生作用。</p><p>compose() 除了 实现上述对 Observable 进行变换外我们可以做一些其他处理，如 网络请求过程中 Dialog 的显示和隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity, String message) &#123;</span><br><span class="line">      SpotsDialog dialog = DialogUtil.showLoadingDialog(activity, message);</span><br><span class="line">      return observable -&gt; observable</span><br><span class="line">              .doOnSubscribe(disposable -&gt; &#123;</span><br><span class="line">                  if (dialog != null) &#123;</span><br><span class="line">                      dialog.show();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .doOnComplete(() -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnError(throwable -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnNext(t -&gt; DialogUtil.dismiss(dialog));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity) &#123;</span><br><span class="line">      return loadingDialog(activity, &quot;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Observable、Observer-线程切换&quot;&gt;&lt;a href=&quot;#0x81-Observable、Observer-线程切换&quot; class=&quot;headerlink&quot; title=&quot;0x81 Observable、Observer 线程切换&quot;&gt;&lt;/a&gt;0x81 Observable、Observer 线程切换&lt;/h3&gt;&lt;p&gt;在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。&lt;/p&gt;
&lt;h3 id=&quot;0x82-Transformer-实现对调用链的处理&quot;&gt;&lt;a href=&quot;#0x82-Transformer-实现对调用链的处理&quot; class=&quot;headerlink&quot; title=&quot;0x82 Transformer 实现对调用链的处理&quot;&gt;&lt;/a&gt;0x82 Transformer 实现对调用链的处理&lt;/h3&gt;&lt;p&gt;我们可能有以下实现方式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class SchedulerTransformer&amp;lt;T&amp;gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SingleTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MaybeTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CompletableTransformer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FlowableTransformer&amp;lt;T, T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Completable): CompletableSource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Flowable&amp;lt;T&amp;gt;): Publisher&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Maybe&amp;lt;T&amp;gt;): MaybeSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Observable&amp;lt;T&amp;gt;): ObservableSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Single&amp;lt;T&amp;gt;): SingleSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="/tags/RxJava/"/>
    
      <category term="Transformer" scheme="/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 前奏篇:依赖注入概念</title>
    <link href="/2019/01/17/Dagger2%20%E5%89%8D%E5%A5%8F%E7%AF%87%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/01/17/Dagger2 前奏篇：依赖注入概念/</id>
    <published>2019-01-17T06:57:56.000Z</published>
    <updated>2019-01-26T11:10:20.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、What-is-Dagger2"><a href="#一、What-is-Dagger2" class="headerlink" title="一、What is Dagger2 ?"></a>一、What is Dagger2 ?</h2><p> <a href="https://github.com/google/dagger" target="_blank" rel="noopener">Dagger2</a> 是一个谷歌开源的依赖注入(<code>Dependency Injection</code>)框架，简称<code>DI</code>。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 <strong>2</strong> 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。<br> 那么 <strong>什么是 <code>依赖注入</code></strong> 呢？</p><h3 id="1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））"><a href="#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））" class="headerlink" title="1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））"></a>1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））</h3><p>我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：</p><a id="more"></a><ol><li>在一个类的具体业务逻辑中，需要另一个类的实例进行相应的操作时，在传统的设计中，通常由调用者来创建被调用者的实例（一般的，我们通过 new 的方式创建），然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由 <code>IOC 容器</code> 来完成，然后<code>注入</code>到调用者。因此也被称为 <strong><code>依赖注入</code></strong>。</li><li><strong><code>依赖注入</code></strong> 就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。那么这个外部，到底指的是哪里，如果指的是另一个类，那么，另一个类内部就耦合了,这种拆东墙补西墙的做法我们是不推荐的。能不能有一种方式，将这些构造的对象放到一个容器中，具体需要哪个实例时，就从这个容器中取就行了。那么，类的实例和使用就不在有联系了，而是通过一个容器将他们联系起来。实现了解耦。</li></ol><p>个人理解：<strong>控制反转</strong> ,把自己新建实例对象的权利由交给了第三方工具或容器。<br>目标类将创建其他实例类的权利交给了第三方工具，也就是说，原来需要程序员把自主在目标类通过 new 的方式创建相关类的实例的权利，交给具体的业务（所谓的 IOC 容器） ，该容器在需要的时候通过它自己的方式创建该类的实例，即：<code>创建类实例权利的移交</code>。</p><h2 id="1-2-依赖注入的好处"><a href="#1-2-依赖注入的好处" class="headerlink" title="1.2 依赖注入的好处"></a>1.2 依赖注入的好处</h2><p><code>依赖注入</code>就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。</p><p>通俗一点讲：将该对象的实例化交给其调用者，通过某种方式传入进来，这种模式就是依赖注入。常见的降低耦合的方式： </p><ul><li>构造方法注入。 </li><li>Setter方式注入。 </li><li>接口注入。</li></ul><h2 id="二、Why-Dagger2"><a href="#二、Why-Dagger2" class="headerlink" title="二、Why Dagger2"></a>二、Why Dagger2</h2><p>Dagger2 的原理是在<code>编译期生成相应的依赖注入代码</code>。这也是和其他依赖注入框架不同的地方，其他框架是在运行时期反射获取注解内容，影响了运行效率。</p><p><strong>栗子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MainClass &#123;</span><br><span class="line">    private  void main(String [] args)&#123;</span><br><span class="line">        John john = new John(&quot;john&quot;,12);</span><br><span class="line">        john.introduceSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子面临着一个问题，一旦 <code>John</code> 的创建方式（如构造参数）发生改变，那么你不但需要修改 <code>MainClass</code> 中创建<code>John</code>的代码，还要修改其他所有地方创建 <code>John</code> 的代码。如果我们使用了<code>Dagger2</code> 的话，就不需要管这些了，只需要在需要<code>John</code>的地方写下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">John john;</span><br></pre></td></tr></table></figure><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="https://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger 详解</a>、<a href="http://www.qingpingshan.com/rjbc/az/170191.html" target="_blank" rel="noopener">这就是Dagger2</a>、<a href="https://juejin.im/entry/589bd2cf8d6d8100585fd86c" target="_blank" rel="noopener">Dagger2 入门实践</a>、<a href="https://blog.csdn.net/lisdye2/article/details/51942511" target="_blank" rel="noopener">最简单的Dagger2入门教程</a>、<a href="https://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、What-is-Dagger2&quot;&gt;&lt;a href=&quot;#一、What-is-Dagger2&quot; class=&quot;headerlink&quot; title=&quot;一、What is Dagger2 ?&quot;&gt;&lt;/a&gt;一、What is Dagger2 ?&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/google/dagger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dagger2&lt;/a&gt; 是一个谷歌开源的依赖注入(&lt;code&gt;Dependency Injection&lt;/code&gt;)框架，简称&lt;code&gt;DI&lt;/code&gt;。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 &lt;strong&gt;2&lt;/strong&gt; 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。&lt;br&gt; 那么 &lt;strong&gt;什么是 &lt;code&gt;依赖注入&lt;/code&gt;&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;h3 id=&quot;1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot;&gt;&lt;a href=&quot;#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot; class=&quot;headerlink&quot; title=&quot;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&quot;&gt;&lt;/a&gt;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&lt;/h3&gt;&lt;p&gt;我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dagger2" scheme="/tags/Dagger2/"/>
    
      <category term="DI" scheme="/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>OKhttp3 拦截器</title>
    <link href="/2019/01/17/OKhttp3%20%E7%B3%BB%E7%BB%9F%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>/2019/01/17/OKhttp3 系统拦截器简介/</id>
    <published>2019-01-17T06:31:26.000Z</published>
    <updated>2019-05-16T07:53:37.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>功能：实现重试、跟踪</p><p>实现原理： </p><p>while(true) 死循环的实现。</p><p>检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 <code>return Response</code>, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。</p><p>检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。</p><a id="more"></a><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>将用户构建的 Request 请求转换为能够进行网络访问的请求。</li></ul><p>在用户构建的 Request 的基础上 <strong>添加了许多的请求头</strong>，具体内容参看代码。</p><ul><li>将符合网络请求的 Request 进行网络请求。</li></ul><p>在责任链模式的过程中，在此拦截器的到响应 Response。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br></pre></td></tr></table></figure><ul><li>将请求回来的响应 Response 转化为用户可用的 Response。</li></ul><p>主要是根据响应是否对 Response 进行 gzip 压缩，具体是使用 Okio 的库对 Response 进行压缩，并返回 Response。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>功能： 实现缓存功能的拦截器</p><h4 id="设置启用缓存功能"><a href="#设置启用缓存功能" class="headerlink" title="设置启用缓存功能"></a>设置启用缓存功能</h4><p>在新建 OkhttpClient.Builder 的时候进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File sdcache = getExternalCacheDir();</span><br><span class="line">int cacheSize = 10 * 1024 * 1024;</span><br><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">    .cache(new Cache(sdcache.getAbsoluteFile(), cacheSize));</span><br><span class="line">mOkHttpClient = builder.build();</span><br></pre></td></tr></table></figure><p>其底层实现还是 大神 的 开源库 DiskLruCache，如下可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache(File directory, long maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存策略的基本流程"><a href="#缓存策略的基本流程" class="headerlink" title="缓存策略的基本流程"></a>缓存策略的基本流程</h4><h5 id="1-获取缓存响应"><a href="#1-获取缓存响应" class="headerlink" title="1. 获取缓存响应"></a>1. 获取缓存响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h5 id="2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略"><a href="#2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略" class="headerlink" title="2. 根据 request 和 缓存响应 cacheCandidate 获取缓存策略"></a>2. 根据 <strong>request</strong> 和 <strong>缓存响应 cacheCandidate</strong> 获取缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><h5 id="3-获取响应缓存策略下的-request-和-response"><a href="#3-获取响应缓存策略下的-request-和-response" class="headerlink" title="3. 获取响应缓存策略下的 request 和 response"></a>3. 获取响应缓存策略下的 request 和 response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//缓存策略中的请求</span><br><span class="line">Request networkRequest = strategy.networkRequest;</span><br><span class="line">//缓存策略中的响应</span><br><span class="line">Response cacheResponse = strategy.cacheResponse;</span><br></pre></td></tr></table></figure><h5 id="4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。"><a href="#4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。" class="headerlink" title="4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。"></a>4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。</h5><h6 id="1-缓存响应不为空但是策略的响应为空，关闭缓存响应流"><a href="#1-缓存响应不为空但是策略的响应为空，关闭缓存响应流" class="headerlink" title="1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流"></a>1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。"><a href="#2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。" class="headerlink" title="2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。"></a>2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(504)</span><br><span class="line">            .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-1L)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-networkRequest-为空，直接使用缓存，-返回缓存响应-。"><a href="#3-networkRequest-为空，直接使用缓存，-返回缓存响应-。" class="headerlink" title="3. networkRequest 为空，直接使用缓存，==返回缓存响应==。"></a>3. networkRequest 为空，直接使用缓存，==返回缓存响应==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-获取网络请求的响应后，进行操作，此时也要分情况讨论。"><a href="#4-获取网络请求的响应后，进行操作，此时也要分情况讨论。" class="headerlink" title="4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。"></a>4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = null;</span><br><span class="line">networkResponse = chain.proceed(networkRequest);</span><br></pre></td></tr></table></figure><ol><li>networkResponse 的响应码为 304，说明请求的资源未过期，构建 Response 对象，==直接反正该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (cacheResponse != null) &#123;</span><br><span class="line">    // 304 304 的标准解释是：Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（</span><br><span class="line">    // 一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">    // 服务器告诉客户，原来缓冲的文档还可以继续使用。</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">     // Update the cache after combining headers but before stripping the</span><br><span class="line">    // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">    cache.trackConditionalCacheHit();</span><br><span class="line">    cache.update(cacheResponse, response);</span><br><span class="line">    return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 构建 Response，==并直接返回该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Response response = networkResponse.newBuilder()</span><br><span class="line">    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">    .networkResponse(stripBody(networkResponse))</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure><h5 id="5-将-Response-写入缓存"><a href="#5-将-Response-写入缓存" class="headerlink" title="5. 将 Response 写入缓存"></a>5. 将 Response 写入缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上被标注为 ==== 的字样，说明执行 <code>return Response</code> 操作,直接返回响应，进入下一个拦截器的相关处理。</p></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>功能： Opens a connection to the target server and proceeds to the next interceptor。</p><p>打开一个面向指定服务器的连接，并且执行下一个拦截器。</p><h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>在这个拦截器中 HttpCodec 的作用是编码 Http 请求和解码 Http 响应。根据 HTTP版本不同分为 </p><ul><li>Http1Codec(HTTP/1.1) </li><li>Http2Codec(HTTP/2)</li></ul><p>打开连接的关键代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure><p>以下为具体代码调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamAllocation#newStream() </span><br><span class="line">--&gt; this#findHealthyConnection(..) </span><br><span class="line">--&gt;this#findHealthyConnection(..)//获得连接的顺序：存在的链接 、 连接池、新建一个连接</span><br><span class="line">--&gt;this#findConnection(...)</span><br><span class="line">--&gt;RealConnection#connect(...)// 连接并握手</span><br><span class="line">--&gt;RealConnection#connectTunnel(...)或</span><br><span class="line">   RealConnection#connectSocket(..)(最终都会调用connectSocket(...))</span><br><span class="line">--&gt;Platform.get()#connectSocket(...)</span><br><span class="line">--&gt;socket.connect(address, connectTimeout);//最终可以获得建立连接后的 Socket</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;RealConnection#newCodec(..)// 返回 HttpCode</span><br></pre></td></tr></table></figure><p>在 findHealthyConnection() 中有以下代码进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br></pre></td></tr></table></figure><p>至此连接指定服务器的 connection 已经建立。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>这是 Okhttp 库中拦截器链的最后一个拦截器，也是这个拦截器区具体发起请求和获取响应。</p><p>大致分为以下几个步骤：</p><ol><li>写入请求头</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据具体情况判断是否读取</p></li><li><p>根据具体情况判断是否写入相应请求头</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (responseBuilder == null) &#123;</span><br><span class="line">                // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection from</span><br><span class="line">                // being reused. Otherwise we&apos;re still obligated to transmit the request body to leave the</span><br><span class="line">                // connection in a consistent state.</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>构建 Response </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response = responseBuilder</span><br><span class="line">               .request(request)</span><br><span class="line">               .handshake(streamAllocation.connection().handshake())</span><br><span class="line">               .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">               .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></li><li><p>写入 Response 的 body</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>至此，网络请求经过拦截器链获得 Response ，那么再按照拦截器链逆向返回 Response，在此过程中对 Response 进行相应的处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对开源库的研读中，我们首先需要做的是对大致流程有个清晰的认识，但是不能深陷细节、具体实现上在后期对相关功能的具体使用时在进行相关研究。而自己在此过程中，就深陷入细节，针对具体的实现真是绞尽脑汁，最后还是 “一败涂地”。此处再次告诫自己和后来人：对开源库的研读不要纠结于细节、不要纠结于细节、不要纠结于细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;a href=&quot;#RetryAndFollowUpInterceptor&quot; class=&quot;headerlink&quot; title=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;/a&gt;RetryAndFollowUpInterceptor&lt;/h3&gt;&lt;p&gt;功能：实现重试、跟踪&lt;/p&gt;
&lt;p&gt;实现原理： &lt;/p&gt;
&lt;p&gt;while(true) 死循环的实现。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 &lt;code&gt;return Response&lt;/code&gt;, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Okhttp3" scheme="/tags/Okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客维护</title>
    <link href="/2019/01/17/Hexo%20%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    <id>/2019/01/17/Hexo 博客维护/</id>
    <published>2019-01-17T02:26:43.000Z</published>
    <updated>2019-01-17T07:13:41.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Hexo-博客建站"><a href="#关于-Hexo-博客建站" class="headerlink" title="关于 Hexo 博客建站"></a>关于 Hexo 博客建站</h3><p>自己在 2016 基于 Hexo + GitPage 搭建个人博客，但是看到推到 Github 上的代码是 hexo g 生成的 public 文件夹下文件，那我日后怎么维护。自己看到别人上传的代码却是真正的 source 文件。</p><p>今日自己才知道，需要维护两套代码，一套真正的 source 文件，一套部署到 github 的代码，真是废柴。</p><h3 id="关于-Hexo-主题"><a href="#关于-Hexo-主题" class="headerlink" title="关于 Hexo 主题"></a>关于 Hexo 主题</h3><p>自己在网上搜索了一部分主题，有的页面概念过于繁杂，有的页面过于花哨，自己的主要目的是博客记录，搭建时默认的 Hexo 主题已经满足要求，就不再更换主题(于今日有效，万一哪天遇到称心得主题)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于-Hexo-博客建站&quot;&gt;&lt;a href=&quot;#关于-Hexo-博客建站&quot; class=&quot;headerlink&quot; title=&quot;关于 Hexo 博客建站&quot;&gt;&lt;/a&gt;关于 Hexo 博客建站&lt;/h3&gt;&lt;p&gt;自己在 2016 基于 Hexo + GitPage 搭建个
      
    
    </summary>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存空间类别</title>
    <link href="/2019/01/16/Java%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%88%AB/"/>
    <id>/2019/01/16/Java 内存空间类别/</id>
    <published>2019-01-16T07:23:17.000Z</published>
    <updated>2019-08-05T06:12:35.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h2><p>JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。</p><p><img src="/images/2019_01_16.jpg" alt="运行时内存区域"></p><!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存，它可以看作 <strong>当前线程</strong> 所执行的 <strong>字节码的行号指示器</strong>。<strong>在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值</strong> 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成**。</p><p>如上图所示，程序计数器是线程私有的。</p><p><strong>如何执行工作</strong></p><p>如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。</p><a id="more"></a><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>Java 虚拟机栈是线程私有的，其生命周期与线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的内存模型： 每个 Java 方法执行的同时都会创建一个 <strong>栈帧(stack frame)</strong>,栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>平时的把 Java 内存分为 堆内存(heap) 和 栈内存(stack) 的分类方法是比较粗糙的，实际分类方法十分复杂。这种分类方法中栈即为虚拟机栈，或为虚拟机中的局部变量表。</p><p>局部变量表存放了编译期可知的各种数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress(指向一条字节码指令的地址)。</p><p>局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多的的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量表的大小。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>本地方方法栈与虚拟机栈发挥的作用相似，不同的是该栈为 Native 方法服务。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java 堆对于大部分应用来说都是 JVM 所管理的内存中最大的一块。Java 堆是 <strong>所有线程共享</strong> 的一块内存区域,<strong>在虚拟机启动时创建</strong>。</p><p>Java 堆的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存 – <strong>所有的对象实例以及数组都要在堆上分配</strong>。</p><p>Java 堆的分配可以在物理上不连续的内存空间，只要逻辑上连续就可以，可以固定大小，也可以扩展空间。</p><p>Java 堆是 GC 发生的主要区域。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样是所有线程共享的内存空间，<strong>它用于储存已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据</strong>。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它还有一个别名 – Non-Heap(非堆)，目的应该是与 Java 堆区分。</p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行区常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong>常量池</strong> ，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字面量和符号引用--&gt;常量池--&gt;运行时常量池</span><br></pre></td></tr></table></figure><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><blockquote><p>没有接触过相关概念。</p></blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><table><thead><tr><th>数据区域</th><th>功能</th><th>线程相关</th><th align="center">备注</th></tr></thead><tbody><tr><td>程序计数器</td><td>字节码执行指示器</td><td>线程私有</td><td align="center"></td></tr><tr><td>Java 虚拟机栈</td><td>为 Java方法服务、存放编译期基本数据类型以及对象引用</td><td>线程私有</td><td align="center">平常被称为的 “栈”、空间较小</td></tr><tr><td></td><td>本地方法栈</td><td>与 Java 虚拟机栈类似，为 Native 方法服务</td><td align="center">线程私有</td></tr><tr><td></td><td>Java 堆</td><td>存放对象(对象实例以及数组)</td><td align="center">线程共享</td></tr><tr><td></td><td>方法区</td><td>存储类信息、常量、静态变量、即时编译器编译后等数据</td><td align="center">线程共享</td></tr><tr><td></td><td>运行时常量池</td><td>常量池存放编译期生成的各种字面量和符号引用、常量池在类加载后存储在运行时常量池</td><td align="center">线程共享</td></tr><tr><td></td><td>直接内存</td><td></td><td align="center"></td></tr></tbody></table><hr><p><strong>知识链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://product.dangdang.com/23259731.html" target="_blank" rel="noopener">深入理解Java虚拟机：JVM高级特性与最佳实践</a></p><p><strong>发现好的博文</strong></p><p><a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener">这一次，彻底解决Java的值传递和引用传递</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。&lt;/p&gt;
&lt;h2 id=&quot;2-运行时数据区域&quot;&gt;&lt;a href=&quot;#2-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;2. 运行时数据区域&quot;&gt;&lt;/a&gt;2. 运行时数据区域&lt;/h2&gt;&lt;p&gt;JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_16.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --&gt;

&lt;h3 id=&quot;2-1-程序计数器&quot;&gt;&lt;a href=&quot;#2-1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;2.1 程序计数器&quot;&gt;&lt;/a&gt;2.1 程序计数器&lt;/h3&gt;&lt;p&gt;程序计数器是一块较小的内存，它可以看作 &lt;strong&gt;当前线程&lt;/strong&gt; 所执行的 &lt;strong&gt;字节码的行号指示器&lt;/strong&gt;。&lt;strong&gt;在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值&lt;/strong&gt; 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成**。&lt;/p&gt;
&lt;p&gt;如上图所示，程序计数器是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何执行工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
      <category term="内存分区" scheme="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建 GitPage 静态博客</title>
    <link href="/2019/01/16/%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%20GitPage%20%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>/2019/01/16/使用 Hexo 搭建 GitPage 静态博客/</id>
    <published>2019-01-16T06:08:29.821Z</published>
    <updated>2019-01-17T07:13:32.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必要工具的安装-Mac"><a href="#必要工具的安装-Mac" class="headerlink" title="必要工具的安装(Mac)"></a>必要工具的安装(Mac)</h2><h3 id="nmp"><a href="#nmp" class="headerlink" title="nmp"></a>nmp</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 官方网站</a>下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。</p><p>或使用相关命令行进行安装，具体步骤自行搜索。</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>具体参见 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo 建站"></a>Hexo 建站</h2><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>编辑 <code>_config.yml</code> 文件，进行相关配置。</p><a id="more"></a><h2 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览</p><h2 id="博文部署"><a href="#博文部署" class="headerlink" title="博文部署"></a>博文部署</h2><p><code>_congfig.yml</code> 有关文件编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><p>在每次编辑文章后执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean //清理 public 文件夹和 database 文件</span><br><span class="line">$ hexo generate // 重新生成 public 文件夹和 database 文件</span><br><span class="line">$ hexo deploy // 部署到 github page 上</span><br></pre></td></tr></table></figure><p>观察了以下目录文件夹，部署到 GitPage 上应该为 <code>hexo g</code> 生成的 public 文件夹下的内容。</p><hr><p><strong>知识链接：</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cherryblog.site/categories/Hexo%E5%BB%BA%E7%AB%99/" target="_blank" rel="noopener">Hexo建站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;必要工具的安装-Mac&quot;&gt;&lt;a href=&quot;#必要工具的安装-Mac&quot; class=&quot;headerlink&quot; title=&quot;必要工具的安装(Mac)&quot;&gt;&lt;/a&gt;必要工具的安装(Mac)&lt;/h2&gt;&lt;h3 id=&quot;nmp&quot;&gt;&lt;a href=&quot;#nmp&quot; class=&quot;headerlink&quot; title=&quot;nmp&quot;&gt;&lt;/a&gt;nmp&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node 官方网站&lt;/a&gt;下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。&lt;/p&gt;
&lt;p&gt;或使用相关命令行进行安装，具体步骤自行搜索。&lt;/p&gt;
&lt;h3 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;具体参见 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hexo-建站&quot;&gt;&lt;a href=&quot;#Hexo-建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo 建站&quot;&gt;&lt;/a&gt;Hexo 建站&lt;/h2&gt;&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编辑 &lt;code&gt;_config.yml&lt;/code&gt; 文件，进行相关配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
      <category term="GitPage" scheme="/tags/GitPage/"/>
    
  </entry>
  
</feed>
