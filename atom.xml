<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enjoy</title>
  
  <subtitle>Enjoy the technology，Enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mllgy.github.io/"/>
  <updated>2019-04-04T08:48:38.972Z</updated>
  <id>https://mllgy.github.io/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Basic (四) -- 内部类</title>
    <link href="https://mllgy.github.io/2019/04/04/Java-Basic-%E5%9B%9B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://mllgy.github.io/2019/04/04/Java-Basic-四内部类/</id>
    <published>2019-04-04T06:47:26.000Z</published>
    <updated>2019-04-04T08:48:38.972Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-提问"><a href="#1-提问" class="headerlink" title="1. 提问"></a>1. 提问</h3><ol><li>内部类为什么会出现</li><li>内部类的调用</li><li>内部类与外部类访问成员变量的不同</li><li>静态内部类和非静态内部类</li></ol><h4 id="为什么使用内部类"><a href="#为什么使用内部类" class="headerlink" title="为什么使用内部类"></a>为什么使用内部类</h4><ol><li>内部类提供了 <strong>更好的封装</strong>，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。</li><li><strong>内部类可以访问外部类的私有数据</strong>。因为内部类为外部类的成员，成员之间可以互相访问,外部类不可以访问内部类的私有数据。</li><li><strong>可以使用匿名内部类创建访问一次的类</strong>，十分方便。</li></ol><h3 id="2-非静态内部类"><a href="#2-非静态内部类" class="headerlink" title="2. 非静态内部类"></a>2. 非静态内部类</h3><p>例子 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private int num2 = 3;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        private int num = 2;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            System.out.println(&quot;innerclass method&quot;);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + num);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num &quot; + OutClass.this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num2 &quot; + num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass outclass = new OutClass();</span><br><span class="line">        System.out.println(&quot;main &quot;+ outclass.num);</span><br><span class="line">        outclass.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass();</span><br><span class="line">        inner.method();</span><br><span class="line">        System.out.println(&quot;outclass test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印日志：</span><br><span class="line">main 1</span><br><span class="line">innerclass method</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method out num 1</span><br><span class="line">innerclass method out num2 3</span><br><span class="line">outclass test</span><br></pre></td></tr></table></figure></p><h4 id="2-1-内部类可以访问外部类的成员变量-包括私有变量"><a href="#2-1-内部类可以访问外部类的成员变量-包括私有变量" class="headerlink" title="2.1 内部类可以访问外部类的成员变量(包括私有变量)"></a>2.1 内部类可以访问外部类的成员变量(包括私有变量)</h4><p>原因：</p><p>在非静态内部类对象里，保存了外部类对象的引用。</p><p>内存模型：<br><img src="/images/2019_04_04_1.jpg" alt="内存模型图"></p><p>但是当外部类与内部类有相同名字的变量时，引用外部类变量需要指定外部类对象 –  <code>Outclass.this</code> </p><h4 id="2-2-编译后的-Class-文件"><a href="#2-2-编译后的-Class-文件" class="headerlink" title="2.2 编译后的 Class 文件"></a>2.2 编译后的 Class 文件</h4><p>在 JVM 中没有内部类这个概念，所有的类都是普通类（POJO），内部类也会被编译成带有前缀的类。</p><p>编译后，得到两个 class 文件:</p><ol><li><code>OutClass.java</code> </li><li><code>OutClass$InnerClass.class</code></li></ol><h4 id="2-3-内部类方法中的变量的访问顺序"><a href="#2-3-内部类方法中的变量的访问顺序" class="headerlink" title="2.3 内部类方法中的变量的访问顺序"></a>2.3 内部类方法中的变量的访问顺序</h4><p><strong>内部类方法内部中 –&gt; 内部类中的成员变量 –&gt; 外部类中的成员变量 –&gt; 不存在，编译异常</strong></p><h4 id="2-4-内、外部类变量名相同"><a href="#2-4-内、外部类变量名相同" class="headerlink" title="2.4 内、外部类变量名相同"></a>2.4 内、外部类变量名相同</h4><p>访问使用如下格式：</p><p><code>this.field</code> : 内部类变量</p><p><code>OutClass.this.field</code> : 外部类变量</p><h4 id="2-5-外部类不可直接访问内部类成员"><a href="#2-5-外部类不可直接访问内部类成员" class="headerlink" title="2.5 外部类不可直接访问内部类成员"></a>2.5 外部类不可直接访问内部类成员</h4><p>非静态内部类成员只在非静态内部类范围内是可知的，外部类不能直接访问。</p><p>通过 <strong>内部类实例对象来访问</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InnerClass().method();</span><br><span class="line">new InnerClass().num++;</span><br></pre></td></tr></table></figure></p><h4 id="2-6-外部类中静态成员中不允许直接使用非静态内部类"><a href="#2-6-外部类中静态成员中不允许直接使用非静态内部类" class="headerlink" title="2.6 外部类中静态成员中不允许直接使用非静态内部类"></a>2.6 外部类中静态成员中不允许直接使用非静态内部类</h4><p>静态成员为类成员，在编译期对其初始化，如果直接使用非静态成员(如非静态内部类)，则会发生错误。</p><h4 id="2-7-内、外部类关系"><a href="#2-7-内、外部类关系" class="headerlink" title="2.7 内、外部类关系"></a>2.7 内、外部类关系</h4><p>非静态内部类对象寄生在外部类对象里，有非静态内部类对象一定存在外部类对象，反之不成立。</p><h4 id="2-8-非静态内部类中的静态成员-重点理解"><a href="#2-8-非静态内部类中的静态成员-重点理解" class="headerlink" title="2.8 非静态内部类中的静态成员(重点理解)"></a>2.8 非静态内部类中的静态成员(重点理解)</h4><p><strong>如果内部了声明静态成员变量，那么必须使用 <code>final</code> 修饰</strong>。</p><p>因为一个静态变量只有一个实例，而对于每一个外部对象，分别有一个单独的内部类实例，如果这个变量不是 final 的，那么他就不是唯一的，这与 static 的含义相互冲突。</p><p><strong>非静态内部类中不能含有静态方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OutterClass &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private void outMethod()&#123;&#125;</span><br><span class="line">     class InnerClass &#123;</span><br><span class="line">        private final static String name = &quot;&quot;;</span><br><span class="line">        private /*static*/ void innerMethod() &#123;</span><br><span class="line">            age++;</span><br><span class="line">            outMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private static int age = 2;</span><br><span class="line"></span><br><span class="line">    private void doSomething()&#123;</span><br><span class="line">        StaticInnerClass.staticNum++;</span><br><span class="line">        StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">        staticInnerClass.method();</span><br><span class="line">        staticInnerClass.num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static class StaticInnerClass &#123;</span><br><span class="line">        private static int staticNum = 10;</span><br><span class="line">        private int num = 100;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            num++;</span><br><span class="line">            staticNum++;</span><br><span class="line">            age++;</span><br><span class="line">            // &apos;four.OutClass.this&apos; cannot be referenced from a static context</span><br><span class="line">            // -- four.OutClass.this 不能再 static 环境下被引用</span><br><span class="line">            // OutClass.this.num++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-静态内部类不可以访问外部类实例成员，可以访问类成员"><a href="#3-1-静态内部类不可以访问外部类实例成员，可以访问类成员" class="headerlink" title="3.1 静态内部类不可以访问外部类实例成员，可以访问类成员"></a>3.1 静态内部类不可以访问外部类实例成员，可以访问类成员</h4><p>静态内部类为外部类的类成员，只能访问外部类的静态变量，不可以访问非静态变量。</p><h4 id="3-2-编译后的-Class-文件"><a href="#3-2-编译后的-Class-文件" class="headerlink" title="3.2  编译后的 Class 文件"></a>3.2  编译后的 Class 文件</h4><p>与非静态内部类相同，编译后得到两个 class 文件 – OutClass.class 、StaticInnerClass.class</p><h4 id="3-3-外部类不可直接访问内部类成员"><a href="#3-3-外部类不可直接访问内部类成员" class="headerlink" title="3.3 外部类不可直接访问内部类成员"></a>3.3 外部类不可直接访问内部类成员</h4><p>静态内部类成员、实例成员只在静态内部类范围内是可知的，外部类不能直接访问。</p><ul><li><p>通过 内部类名 来访问静态内部类类成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass.staticNum++;</span><br></pre></td></tr></table></figure></li><li><p>通过内部类实例对象访问静态内部类实例成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">staticInnerClass.method();</span><br><span class="line">staticInnerClass.num++;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-内部类使用"><a href="#4-内部类使用" class="headerlink" title="4. 内部类使用"></a>4. 内部类使用</h3><h4 id="4-1-外部类使用内部类"><a href="#4-1-外部类使用内部类" class="headerlink" title="4.1 外部类使用内部类"></a>4.1 外部类使用内部类</h4><ul><li>基本的使用</li><li>外部类使用内部类的子类</li></ul><p>外部类中的静态代码块、静态方法中不可使用非静态内部类，因为静态成员不能使用非静态成员。</p><h4 id="4-2-外部类以外使用非静态内部类"><a href="#4-2-外部类以外使用非静态内部类" class="headerlink" title="4.2 外部类以外使用非静态内部类"></a>4.2 外部类以外使用非静态内部类</h4><p>根据内部类的访问权限修饰符，内部类对其他类的可见性不同。</p><p>外部类以外建立非静态内部类实例必须外部类实例和 new 来调用非静态内部类的构造器。</p><ul><li>非静态内部类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass innerclass = new OutClass().new InnerClass();</span><br><span class="line">innerclass.num++;</span><br><span class="line">innerclass.method();</span><br></pre></td></tr></table></figure></p><ul><li>非静态内部类子类</li><li></li></ul><h4 id="4-2-外部类以外使用非静态内部类-1"><a href="#4-2-外部类以外使用非静态内部类-1" class="headerlink" title="4.2 外部类以外使用非静态内部类"></a>4.2 外部类以外使用非静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected static InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass staticInnerClass = new OutClass.InnerClass();</span><br><span class="line">staticInnerClass.</span><br></pre></td></tr></table></figure><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5. 局部内部类"></a>5. 局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        class InnerBase&#123;</span><br><span class="line">            int a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class SubInnerClass extends InnerBase&#123;</span><br><span class="line">            int b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubInnerClass subInnerClass = new SubInnerClass();</span><br><span class="line">        subInnerClass.a = 1;</span><br><span class="line">        subInnerClass.b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类，顾名思义内部类定义在 方法内部，其有效范围也在方法内部，方法外部无法访问,即：对外部世界完全的隐藏起来。</p><p>通过 <code>javac Test.java</code> 对该类进行编译，生成的 class 有 3 个，分别为： <code>Test.class</code>、<code>Test$1InnerBase.class</code>、<code>Test$1SubInnerClass.class</code>。</p><p>局部内部类遵循如下命名格式：<br><strong>OutClassName$NInnerClassName 其中 N 表示第 N 个内部类。</strong></p><h3 id="6-匿名内部类-Anonymous-Inner-Class"><a href="#6-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="6. 匿名内部类(Anonymous Inner Class)"></a>6. 匿名内部类(Anonymous Inner Class)</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>匿名内部类适合创建只需要一次使用的类。</p><p>定义内部类的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 实现接口 或 父类构造器(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    类的主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由其格式可知，<strong>匿名内部类必须且只能继承一个父类，或实现且最多一个接口</strong>。</p><p>由于构造器必须与类名相同，而匿名内部类不能有类名，所以匿名类不能有构造器。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IClick &#123;</span><br><span class="line">    void change();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public  void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final String  name = &quot;name&quot;;</span><br><span class="line">        show(new IClick() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void change() &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  void show(IClick click)&#123;</span><br><span class="line">        click.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，main 方法中的调用 show 的方法中定义了一个匿名内部类，这个匿名内部类实现了 IClick 接口。</p><p><strong>不仅在 匿名内部类中，就是在普通的内部类中访问内部类外部的变量也需要添加 final 修饰符。</strong></p><p>原因：</p><p>对于普通局部变量而言，它的作用域停留在方法内，当方法执行完毕，该局部变量也随之消失。但内部类则可能产生隐式的 “闭包”，闭包使得局部变量脱离它所在的方法继续存在。</p><p>个人理解，匿名内部类是一个实现了接口或继承类的</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>由于系统在创建匿名内部类时，会创建匿名内部类的对象，所以匿名内部类不能定义为抽象类。</li><li>由于匿名内部类没有类名，所以匿名内部类无法定义构造器，但可以使用初始化块进行初始化。</li></ul><p>方法的返回值的生成和表示这个返回值的类的定义结合在一起。</p><hr><p>为什么需要内部类？</p><p>答:   如果你想实现一个接口，但是这个接口中的一个方法和你构想的这个类中的一个方法的名称，参数相同，你应该怎么办？这时候，你可以建一个内部类实现这个接口。由于内部类对外部类的所有内容都是可访问的，所以这样做可以完成所有你直接实现这个接口的功能。</p><p>真正的原因，java中的内部类和接口加在一起，可以很好的实现多继承的效果</p><p>内部类是否有用、必要和安全</p><p>内部类是一种编译器现象，与虚拟机无关。编译器会把内部了翻译成用 $ 分割外部类名与内部类名的常规文件，而虚拟机对此一无所知。</p><hr><p><a href="https://www.zhihu.com/question/21395848" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-提问&quot;&gt;&lt;a href=&quot;#1-提问&quot; class=&quot;headerlink&quot; title=&quot;1. 提问&quot;&gt;&lt;/a&gt;1. 提问&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内部类为什么会出现&lt;/li&gt;
&lt;li&gt;内部类的调用&lt;/li&gt;
&lt;li&gt;内部类与外部类访问成员变量的不同&lt;/l
      
    
    </summary>
    
    
      <category term="内部类" scheme="https://mllgy.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vim</title>
    <link href="https://mllgy.github.io/2019/04/02/Vim/"/>
    <id>https://mllgy.github.io/2019/04/02/Vim/</id>
    <published>2019-04-02T03:33:55.000Z</published>
    <updated>2019-04-02T03:34:51.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插入命令"><a href="#1、插入命令" class="headerlink" title="1、插入命令"></a>1、插入命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">在光标所在字符<code>后</code>插入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在光标所在<code>行尾</code>插入</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">在光标所在字符<code>前</code>插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在光标所在<code>行首</code>插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在光标<code>下</code>插入行</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在光标<code>上</code>插入行</td></tr></tbody></table><h3 id="2、定位命令"><a href="#2、定位命令" class="headerlink" title="2、定位命令"></a>2、定位命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:set nu</td><td style="text-align:center">设置行号</td></tr><tr><td style="text-align:center">:set nonu</td><td style="text-align:center">取消行号</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">到第一行</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">到最后一行</td></tr><tr><td style="text-align:center">nG</td><td style="text-align:center">到第n行</td></tr><tr><td style="text-align:center">:n</td><td style="text-align:center">到第n行</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">移至行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">移至行首</td></tr></tbody></table><h3 id="3、删除命令"><a href="#3、删除命令" class="headerlink" title="3、删除命令"></a>3、删除命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除光标所在处字符</td></tr><tr><td style="text-align:center">nx</td><td style="text-align:center">删除光标所在处后 n 个字符</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行</td></tr><tr><td style="text-align:center">ndd</td><td style="text-align:center">删除n行</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到<code>文件末尾</code>的内容</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">删除光标所在处到<code>行尾</code>的内容</td></tr><tr><td style="text-align:center">:n1,n2d</td><td style="text-align:center">删除指定范围的行</td></tr></tbody></table><h3 id="4、复制和剪切命令"><a href="#4、复制和剪切命令" class="headerlink" title="4、复制和剪切命令"></a>4、复制和剪切命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">yy</td><td style="text-align:center">复制当前行</td></tr><tr><td style="text-align:center">nyy</td><td style="text-align:center">复制当前行以下 n 行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">剪切当前行</td></tr><tr><td style="text-align:center">ndd</td><td style="text-align:center">剪切当前行以下 n 行</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">粘贴在当前光标所在行下</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">粘贴在当前光标所在行上</td></tr></tbody></table><h3 id="5、替换和取消命令"><a href="#5、替换和取消命令" class="headerlink" title="5、替换和取消命令"></a>5、替换和取消命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">取代光标所在处字符</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">从光标所在处开始替换字符，按 Esc 结束</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">取消上一步操作</td></tr></tbody></table><h3 id="6、搜索和搜索替换命令"><a href="#6、搜索和搜索替换命令" class="headerlink" title="6、搜索和搜索替换命令"></a>6、搜索和搜索替换命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>/string|搜索指定字符串 、搜索时忽略大小写 <code>:set ic</code><br>n|搜索指定字符串的下一个出现位置<br>：%s/old/new/g|全文替换指定字符串<br>：n1，n2/old/new/g|在一定范围内替换指定字符串</p><h3 id="7、保存和退出命令"><a href="#7、保存和退出命令" class="headerlink" title="7、保存和退出命令"></a>7、保存和退出命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>:w|保存修改<br>:w new_filename|另存为指定文件<br>：wq|保存修改并退出<br>ZZ|快捷键，保存修改并退出<br>:q!|不保存修改退出<br>：wq!|保存修改并退出（文件所有者及root 用户可使用）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、插入命令&quot;&gt;&lt;a href=&quot;#1、插入命令&quot; class=&quot;headerlink&quot; title=&quot;1、插入命令&quot;&gt;&lt;/a&gt;1、插入命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;命令&lt;/th
      
    
    </summary>
    
    
      <category term="VIM" scheme="https://mllgy.github.io/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>IntentFilter匹配规则</title>
    <link href="https://mllgy.github.io/2019/04/02/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>https://mllgy.github.io/2019/04/02/IntentFilter匹配规则/</id>
    <published>2019-04-02T02:28:45.000Z</published>
    <updated>2019-04-02T02:28:45.780Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android编程中的一些概念(Wiki)</title>
    <link href="https://mllgy.github.io/2019/04/01/Android%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
    <id>https://mllgy.github.io/2019/04/01/Android编程中的一些概念/</id>
    <published>2019-04-01T02:38:59.000Z</published>
    <updated>2019-04-02T08:50:44.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器(compiler) ,是一种 <strong>应用程序</strong>，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。</p><p>它的主要目的是将人编写、维护的高级计算机语言所写出的 <strong>源代码程序</strong>，翻译为计算机能解读、运行的低价 <strong>机器语言</strong> 的程序，也就是 <strong>可执行文件</strong>。</p><p>常见的编译器：</p><ol><li>GCC(GUN Compiler Collection)</li></ol><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><ol start="2"><li>LLVM</li></ol><p>LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。<br><a id="more"></a></p><h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><ol><li>即时编译(JIT,Just In Time)</li></ol><p>动态编译的一种形式，提高程序运行效率的方法。程序运行有两种方式：</p><pre><code>1. 静态编译。执行程序前程序全部被翻译为机器码。2. 动态解释。解释执行则是边执行边翻译。</code></pre><p>即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p><p>即时编译器有两种类型：</p><pre><code>1. 字节码翻译。2. 动态编译翻译。</code></pre><ol start="2"><li>提前编译(AOT,Ahead Of Time)</li></ol><h3 id="运行时系统"><a href="#运行时系统" class="headerlink" title="运行时系统"></a>运行时系统</h3><p>运行环境有称运行时系统，是指把半编译的运行码在目标机器上运行的环境，如 Java<br> 的 JRE。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p> 可执行文件，是指 <strong>内容可被计算机解释为程序</strong> 的文件，通常可执行文件内含有二进制编码的微处理器指令，所以可执行文件也可被称为 二进制文件。<br> <strong>扩展名：</strong></p><ul><li>.exe</li><li>.com</li><li><p>.run</p><p><strong>脚本：</strong></p><p>不是所有的可执行文件都只存在计算机识别的数据，脚本中也是可执行文件，但是内含人类识别的数据，原因：<strong>脚本语言无需经过编译器先编译，就可经过解释器运行(Perl、Python、Shell)</strong>。</p></li></ul><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释器(interpreter),是一种 <strong>计算机程序</strong>，能够把高级编程语言一行一行解释运行，每次运行程序都需要将先转成另外一种语言再作运行，因此解释器的程序运行速度比较慢，运行程序只能将程序一行一行的翻译。</p><p>解释器的好处是它消除了编译整个程序的负担，程序可以拆分成多个部分来模块化，但这会让运行时的效率打了折扣。相对地，编译器已一次将所有源代码翻译成另一种语言，如机器代码，运行时便无需再依赖编译器或额外的程序，故而其运行速度比较快。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>在计算机科学体系结构中，虚拟机指一种 <strong>特殊的软件</strong>，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是 <strong>基于这个软件所创建的环境来操作的软件</strong>。</p><h3 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h3><p>为 Google 开发的 Android 移动设备平台的核心组成部分之一，它支持 .dex(Dalvik Executable) 格式的 Java 应用程序的运行，.dex 格式为专门为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。</p><p>Java 虚拟机和大部分虚拟机包括 JVM 都是基于堆栈的虚拟机，而 Dalvik 虚拟机为 寄存器虚拟机。</p><p>从Android 5.0版起，Android Runtime（ART）取代Dalvik成为系统内默认虚拟机。</p><h3 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h3><p>ART，是一种在 Android 操作系统上的 <strong>运行环境</strong>， ART 能够把应用程序的字节码转换为机器码，是 Android 使用的一种新的虚拟机。与 Dalvik 不同的出 ART 使用的 AOT 技术，而 Dalvik 使用的为 JIT 技术。</p><p>ART 改善了性能、垃圾回收等方面。</p><p>ART引入了 AOT 技术，应用程序在安装时将所有的字节码编译成机器码，所以其在安装时花费的时间更长，同时也会占用更大的内部存储空间，用于存储编译后的代码。</p><h3 id="代码类型"><a href="#代码类型" class="headerlink" title="代码类型"></a>代码类型</h3><p><strong>源代码：</strong></p><p>指人类可读的计算机语言指令，如我们平时编程用到的 Java 、Py、PHP、C++ 等。</p><p><strong>目标代码：</strong></p><p>编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。存放目标代码的文件称为目标文件，常被称为 <strong>二进制文件</strong>。</p><p>目标文件中包含着机器代码以及代码运行中使用到的数据，以及其他信息。</p><p><strong>字节码：</strong></p><p><img src="/images/2019_04_02_2.jpg" alt="字节码"></p><p>字节码(ByteCode),通常指已经经过编译，但是与特定机器代码无关，需要解释器转译后才能成为机器的中间代码。字节码不能像源代码一样可以供人阅读，而是编译后的数值常量、引用、指令等构成的序列。</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机。编译器将源码编译成字节码，特定平台上的虚拟机将字节码转译为可以直接运行的指令。字节码的典型应用为Java bytecode。</p><p><strong>机器语言：</strong></p><p>机器语言是一种指令集体系，这种指令体系称为机器代码，是指计算机的 CPU 可直接解读的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h3&gt;&lt;p&gt;编译器(compiler) ,是一种 &lt;strong&gt;应用程序&lt;/strong&gt;，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。&lt;/p&gt;
&lt;p&gt;它的主要目的是将人编写、维护的高级计算机语言所写出的 &lt;strong&gt;源代码程序&lt;/strong&gt;，翻译为计算机能解读、运行的低价 &lt;strong&gt;机器语言&lt;/strong&gt; 的程序，也就是 &lt;strong&gt;可执行文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的编译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCC(GUN Compiler Collection)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="编译技术" scheme="https://mllgy.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Gradle 常用命令(Android)</title>
    <link href="https://mllgy.github.io/2019/03/29/Gradle-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-Android/"/>
    <id>https://mllgy.github.io/2019/03/29/Gradle-常用命令-Android/</id>
    <published>2019-03-29T08:31:19.000Z</published>
    <updated>2019-03-29T08:31:19.831Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用的 Gradle 命令</title>
    <link href="https://mllgy.github.io/2019/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84-Gradle-%E5%91%BD%E4%BB%A4/"/>
    <id>https://mllgy.github.io/2019/03/28/常用的-Gradle-命令/</id>
    <published>2019-03-28T08:37:33.000Z</published>
    <updated>2019-03-29T10:55:03.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gradlew-q-app-dependencies"><a href="#gradlew-q-app-dependencies" class="headerlink" title="gradlew -q app:dependencies"></a>gradlew -q app:dependencies</h3><p>出现依赖库版本冲突，一般会包如下错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 28.0.0, 25.2.0. Examples include com.android.support:animated-vector-drawable:28.0.0 and com.android.support:support-media-compat:25.2.</span><br></pre></td></tr></table></figure></p><p>一般出现这种错的原因是自己依赖的库与其他依赖的库所依赖的库为同一个 group 的库，但是版本不同。</p><p>使用 <strong>./gradlew -q app:dependencies</strong> 可以看到自己项目依赖库的层级关系：</p><p>解决：使用 exclude 排除相应的库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">api (&quot;com.alibaba:arouter-api:1.4.0&quot;)&#123;</span><br><span class="line">    exclude group: &apos;com.android.support&apos;,module:&apos;support-v4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;gradlew-q-app-dependencies&quot;&gt;&lt;a href=&quot;#gradlew-q-app-dependencies&quot; class=&quot;headerlink&quot; title=&quot;gradlew -q app:dependencies&quot;&gt;&lt;/a&gt;gradlew
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 jar 、aar</title>
    <link href="https://mllgy.github.io/2019/03/27/%E6%89%93%E5%8C%85-jar-%E3%80%81aar/"/>
    <id>https://mllgy.github.io/2019/03/27/打包-jar-、aar/</id>
    <published>2019-03-27T02:47:06.000Z</published>
    <updated>2019-03-28T10:06:15.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的 aar 文件包括：AndroidManifest.xml，classes.jar，res，R.txt。</p><p>jar：只包含了 class 文件和清单文件，不包含资源文件。</p><p>如果需要资源文件，那么以 aar 的形式引入到工程，反之使用 jar。</p><h3 id="打包-aar、jar"><a href="#打包-aar、jar" class="headerlink" title="打包 aar、jar"></a>打包 aar、jar</h3><p>如果将 Application 打包为 aar，做以下更改：</p><ol><li>将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为 <code>apply plugin: &#39;com.android.library&#39;</code></li><li>去掉 <code>applicationId</code></li><li>项目根目录执行 <code>./gradlew assembleRelease</code>,就可以在相应的目录(build/output/aar)下看到生成的 aar，在 <code>build/intermediates/packed-classes</code> 中看到相应的 jar 包。</li></ol><p>可以使用新建 gradle task 可以将生成的 jar 包直接复制到 libs 下，并完成构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    def name = project.name //Library名称</span><br><span class="line">    delete &apos;libs/&apos; + name + &apos;.jar&apos; //删除之前的旧jar包</span><br><span class="line">    from(&apos;build/intermediates/packaged-classes/release/&apos;) //从这个目录下取出默认jar包</span><br><span class="line">    into(&apos;libs/&apos;) //将jar包输出到指定目录下</span><br><span class="line">    include(&apos;classes.jar&apos;)</span><br><span class="line">    rename(&apos;classes.jar&apos;, name + &apos;.jar&apos;) //自定义jar包的名字</span><br><span class="line">&#125;</span><br><span class="line">copyJar.dependsOn(build)</span><br></pre></td></tr></table></figure></p><h3 id="自定义-jar"><a href="#自定义-jar" class="headerlink" title="自定义 jar"></a>自定义 jar</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter 介绍</title>
    <link href="https://mllgy.github.io/2019/03/27/Flutter-%E4%BB%8B%E7%BB%8D/"/>
    <id>https://mllgy.github.io/2019/03/27/Flutter-介绍/</id>
    <published>2019-03-27T02:25:00.000Z</published>
    <updated>2019-03-27T07:40:16.831Z</updated>
    
    <content type="html"><![CDATA[<ul><li>main函数使用了(=&gt;)符号, 这是Dart中单行函数或方法的简写</li><li>在 Flutter 中大部分都是 widget，包括对齐(alignment)、填充(padding)、布局(layout)。</li><li>Scaffold(脚手架) 是Material library 中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。</li><li>widget 的主要工作是提供一个build()方法来描述如何根据其他较低级别的widget来显示自己。</li><li>变量以下划线(_) 为前缀时，在 Dart 会被强制将其变为私有的。</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>在 Flutter 中页面称为路由(Router)。</li><li>在 Flutter 中，<strong>导航器</strong> 管理应用程序的 <strong>路由栈</strong>，将路由推入 (push) 到导航器的栈中，将会显示该路由界面，从导航器中弹出 (pop) 路由，将返回到前一个路由(页面)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;main函数使用了(=&amp;gt;)符号, 这是Dart中单行函数或方法的简写&lt;/li&gt;
&lt;li&gt;在 Flutter 中大部分都是 widget，包括对齐(alignment)、填充(padding)、布局(layout)。&lt;/li&gt;
&lt;li&gt;Scaffold(脚手
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>adb 常用命令</title>
    <link href="https://mllgy.github.io/2019/03/26/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://mllgy.github.io/2019/03/26/adb-常用命令/</id>
    <published>2019-03-26T03:32:49.000Z</published>
    <updated>2019-04-02T07:41:02.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：</p><ol><li>客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。</li><li>后台程序。在相应的设备(模拟器、真机)上运行命令，作为<code>后台进程</code> 在 <code>设备</code>上运行。</li><li>服务器。管理客户端和后台程序之间的通信，在 <code>开发计算机</code> 上作为 <code>后台进程</code> 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。</li></ol><p>android_sdk/platform-tools/ 中找到 adb 工具。</p><h3 id="adb-工作方式"><a href="#adb-工作方式" class="headerlink" title="adb 工作方式"></a>adb 工作方式</h3><ol><li>启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。</li><li>服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。</li><li>当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。</li></ol><a id="more"></a><h3 id="通过-WLAN-连接设备"><a href="#通过-WLAN-连接设备" class="headerlink" title="通过 WLAN 连接设备"></a>通过 WLAN 连接设备</h3><p><strong>adb tcpip 5555:</strong> 设置设备监听 5555 端口上的 TCP/IP 的连接。</p><p><strong>adb connect xxx:</strong>  通过目标设备的 IP 连接设备。</p><p><strong>adb disconnect ip:</strong> 断开指定 IP 的设备 </p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>adb devices:</strong> 查找设备</p><p><strong>adb -s serialNum commond:</strong> 指定设备执行命令</p><p><strong>adb install apk:</strong> 安装 apk</p><p><strong>adb -s xxxx install apk:</strong> 指定设备上安装 apk</p><p><strong>adb install -r apk:</strong> 覆盖安装</p><p><strong>adb -d install apk:</strong> 唯一 USB 连接设备安装 apk</p><p><strong>adb -e install apk:</strong> 唯一模拟器设备安装 apk</p><p><strong>adb uninstall packageName:</strong> 卸载 apk</p><p><strong>adb uninsatll -k packageName:</strong> 卸载 apk,但是保留其配置和缓存文件</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>adb push localFile remoteDictory:</strong> 将本地的文件 push 远端指定的目录下</p><p><strong>adb pull file remoteDictory:</strong> 从 remoteDictory 中复制指定的 file 到当前目录下</p><h3 id="adb-服务器"><a href="#adb-服务器" class="headerlink" title="adb 服务器"></a>adb 服务器</h3><p>adb kill-server： 停止 adb 服务器</p><p>adb start-server：开启 adb 服务</p><h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h3><p>在目标设备启动远程 shell </p><h3 id="adb-shell-am"><a href="#adb-shell-am" class="headerlink" title="adb shell am"></a>adb shell am</h3><p>使用 adb shell am 与应用交互。</p><table><thead><tr><th></th><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>start [option] <intent></intent></td><td>启动 <intent> 指定的 Activity</intent></td></tr><tr><td>startservice [options] <intent></intent></td><td>启动 <intent> 指定的 Service</intent></td></tr><tr><td>broadcast [options] <intent></intent></td><td>发送 <intent> 指定的广播</intent></td></tr><tr><td>force-stop <packagename></packagename></td><td>停止 <packagename> 相关的进程</packagename></td></tr></tbody></table><p><intent> 有关的选项<br>参数|含义<br>–|–<br>-a | <action>    指定 action，比如 android.intent.action.VIEW<br>-c | <category>    指定 category，比如 android.intent.category.APP_CONTACTS<br>-n | <component>    指定完整 component 名，用于明确指定启动哪个 Activity，如 com.gy/.MainActivity</component></category></action></intent></p><p><intent> 可以传参</intent></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell start -n com.gy/.MainActivity //启动指定的 Activity</span><br><span class="line"></span><br><span class="line">adb shell startService -n com.gy/.TestService //启动指定的 Service</span><br><span class="line"></span><br><span class="line">adb shell broadcast  -a android.intent.action.BOOT_COMPLETED -n com.gy/.TestBroadcast //向指定的 BroadCast 发送广播</span><br><span class="line"></span><br><span class="line">adb shell am force-stop com.gy // 关闭指定 app 的一切进程与服务</span><br></pre></td></tr></table></figure><h3 id="adb-shell-pm"><a href="#adb-shell-pm" class="headerlink" title="adb shell pm"></a>adb shell pm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br><span class="line"></span><br><span class="line">adb shell pm clear &lt;packagename&gt;:清除数据与缓存</span><br><span class="line"></span><br><span class="line">adb shell pm path &lt;packagename&gt;:应用安装路径</span><br></pre></td></tr></table></figure><h3 id="adb-shell-wm"><a href="#adb-shell-wm" class="headerlink" title="adb shell wm"></a>adb shell wm</h3><p>屏幕相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size: 屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm size 480x1024: 屏幕分辨率修改为 480x1024</span><br><span class="line"></span><br><span class="line">adb shell wm size reset: 恢复屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm density: 屏幕密度</span><br><span class="line"></span><br><span class="line">adb shell wm density 160 : 屏幕密度设置为 160dpi</span><br><span class="line"></span><br><span class="line">adb shell wm density reset: 恢复屏幕密度</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys"><a href="#adb-shell-dumpsys" class="headerlink" title="adb shell dumpsys"></a>adb shell dumpsys</h3><p>查看运行状态,打印出当前系统的系统信息，默认打印出设备中所有的 service 的信息。</p><p>查看 Service List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys</span><br><span class="line">adb shell service list</span><br></pre></td></tr></table></figure><p>查看屏幕分辨率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br><span class="line">db shell dumpsys window | grep init</span><br></pre></td></tr></table></figure></p><h3 id="adb-shell-dumpsys-activity-内容组成"><a href="#adb-shell-dumpsys-activity-内容组成" class="headerlink" title="adb shell dumpsys activity 内容组成"></a>adb shell dumpsys activity 内容组成</h3><ol><li>ACTIVITY MANAGER SETTINGS(dumpsys activity settings)</li><li>ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)</li><li>ACTIVITY MANAGER BROADCAST STATE(dumpsys activity broadcasts)</li><li>ACTIVITY MANAGER CONTENT PROVIDERS(dumpsys activity providers)</li><li>ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)</li><li>ACTIVITY MANAGER SERVICES (dumpsys activity services)</li><li>ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)</li><li>ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)</li><li>ACTIVITY MANAGER STARTER (dumpsys activity starter)</li><li>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</li><li>ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)</li></ol><p>使用 <code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code> 限制仅输出 “Running activities” 列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。&lt;/li&gt;
&lt;li&gt;后台程序。在相应的设备(模拟器、真机)上运行命令，作为&lt;code&gt;后台进程&lt;/code&gt; 在 &lt;code&gt;设备&lt;/code&gt;上运行。&lt;/li&gt;
&lt;li&gt;服务器。管理客户端和后台程序之间的通信，在 &lt;code&gt;开发计算机&lt;/code&gt; 上作为 &lt;code&gt;后台进程&lt;/code&gt; 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;android_sdk/platform-tools/ 中找到 adb 工具。&lt;/p&gt;
&lt;h3 id=&quot;adb-工作方式&quot;&gt;&lt;a href=&quot;#adb-工作方式&quot; class=&quot;headerlink&quot; title=&quot;adb 工作方式&quot;&gt;&lt;/a&gt;adb 工作方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。&lt;/li&gt;
&lt;li&gt;服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。&lt;/li&gt;
&lt;li&gt;当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="adb" scheme="https://mllgy.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://mllgy.github.io/2019/03/25/%E6%B5%81/"/>
    <id>https://mllgy.github.io/2019/03/25/流/</id>
    <published>2019-03-25T09:03:45.000Z</published>
    <updated>2019-04-02T08:50:44.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 为文件和目录路径名的抽象表示方式。<br>一个 File 对象可以代表一个文件或目录的抽象。<br>建立 File 对象不会对文件系统产生影响。</p><p>File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。</p><p>File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。</p><h3 id="File-的基本操作"><a href="#File-的基本操作" class="headerlink" title="File 的基本操作"></a>File 的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getName():获得文件的名字、路径名</span><br><span class="line">getPath():路径名</span><br><span class="line">getAbsoluteFile():绝对路径名</span><br><span class="line">getParentFile():父路径，没有为 null</span><br><span class="line">file 的绝对路径和相对路径</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建文件和删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createNewFile():</span><br><span class="line">createTempFile():创建临时文件，调用 deleteOnExit 会在程序退出后删除。</span><br></pre></td></tr></table></figure><p>文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir():新建文件夹，父路径不存在创建失败,文件夹存在不创建</span><br><span class="line">mkdirs():新建文件夹链，父路径不存在创建父目录</span><br></pre></td></tr></table></figure><h3 id="IO-流原理"><a href="#IO-流原理" class="headerlink" title="IO 流原理"></a>IO 流原理</h3><p>程序与文件、数组、网络连接数据库之间进行进行数据交换。</p><p><strong>IO 流的操作以程序为中心，什么是以程序为中心？</strong></p><p>就是如果要读度文件数据的话，对于文件来说为输出流，而对于程序来说为输入流，那么就以输入流来命名该文件流。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按流向分类</strong>：</p><ol><li>输入流</li><li>输出流</li></ol><p><strong>按处理的数据分类：</strong></p><ol><li>字节流：二进制，可以处理一切文件</li><li>字符流：文本文件 ，只能处理纯文本</li></ol><p><strong>按功能分类：</strong></p><ol><li>节点流：离源头近，包裹源头</li><li>处理流：增强功能，提高效率</li></ol><h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p><strong>两种流均为节点流，节点流为直接和源文件相连的流。</strong></p><p>InputStream(输入字节流)、OutputStream(输出字节流)</p><table><thead><tr><th></th><th>–</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p><strong>字节流可以处理一切格式的文件</strong>。</p><p><strong>字节流常用 API</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileInputStream</span><br><span class="line">read(byte[] b)、read(byte[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileOutoutStream</span><br><span class="line">writer(byte[] b)、write(byte[],int off,int len)、flush()、close()</span><br></pre></td></tr></table></figure></p><p><strong>字符流常用API</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileReader</span><br><span class="line">read(char[] b)、read(char[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileWriter</span><br><span class="line">writer(char[] b)、write(char[],int off,int len)、flush()、close</span><br></pre></td></tr></table></figure></p><p><strong>流的基本操作：</strong></p><ol><li>建立联系。 File 为程序与文件之间的联系,即 建立 File 对象。</li><li>选择合适的流。 </li><li>操作：流的读取，关键：缓存数组。</li><li>关闭流。</li></ol><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>只可处理纯文本文件，如 .txt、 .html 。</strong>  </p><p>Reader、Writer、FileReader、FileWriter</p><p>纯文本的读取、纯文本的写出</p><p>数组为 char[] </p><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p><img src="/images/2019_04_02_4.jpg" alt="字节流"></p><p><img src="/images/2019_04_02_3.jpg" alt="处理流"></p><p>增强功能，提高性能。</p><p><strong>节点流和处理流的关系：</strong></p><ol><li><p>节点流：可以直接从数据源读取或写出数据。</p></li><li><p>处理流：不直接连接到数据源或目的地，是处理流的流，通过对其他流的处理提高程序的性能。 </p></li><li><p>节点流处于 IO 操作的第一线，所有的操作必须通过它们，处理流可以对其他流进行处理。</p></li><li><p>处理流在节点流之上。</p></li></ol><p><strong>字节流的处理流</strong>：</p><p>BufferredInputStream、BufferendOutoutStream</p><p><strong>为字节流添加处理流</strong>：</p><p>new BufferredInputStream(new FileInputStream(xx,xx));</p><p>new BufferendOutoutStream(new FileOutputStream(xx,xx));</p><p><strong>字符流的处理流</strong>：</p><p>BufferendReader: readLine()</p><p>BufferendWrinter: newLine()</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>将字节流转换为字符流，可以指定编码格式将字节流转换为字符流，处理乱码(编码器、解码集)。</p><p>以程序为中心：</p><p>解码：二进制   –(解码字符集)–&gt;    字符</p><p>编码：字符  –(编码字符集)–&gt; 二进制</p><p>乱码原因：</p><ol><li>编码与解码字符集不同。</li><li>字节数目不完整。</li></ol><p> 字节流转换为字符流：</p><ol><li>输入流：InputStreamReader  解码（读取二进制文件，显示为人类可识别的字符）</li><li>输出流：OutputStreamWriter   编码 （将人类识别的字符转换为字节，写入文件）</li></ol><p>编码要求：使用字符流用指定的解码格式读取文本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初步实现如下，但是不能指定解码格式</span><br><span class="line">BufferendReader reader = new BufferendReader(new FileReader(xxx));</span><br><span class="line"></span><br><span class="line">//现在就是转换流出场的时候了，可以使用转换流以指定的解码方式将字节流转换为字符流</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;&quot;),&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;File&quot;&gt;&lt;a href=&quot;#File&quot; class=&quot;headerlink&quot; title=&quot;File&quot;&gt;&lt;/a&gt;File&lt;/h3&gt;&lt;p&gt;File 为文件和目录路径名的抽象表示方式。&lt;br&gt;一个 File 对象可以代表一个文件或目录的抽象。&lt;br&gt;建立 File 对象不会对文件系统产生影响。&lt;/p&gt;
&lt;p&gt;File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。&lt;/p&gt;
&lt;p&gt;File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。&lt;/p&gt;
&lt;h3 id=&quot;File-的基本操作&quot;&gt;&lt;a href=&quot;#File-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;File 的基本操作&quot;&gt;&lt;/a&gt;File 的基本操作&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getName():获得文件的名字、路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getPath():路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getAbsoluteFile():绝对路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getParentFile():父路径，没有为 null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file 的绝对路径和相对路径&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="IO" scheme="https://mllgy.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>设计六大准则(设计模式之禅)</title>
    <link href="https://mllgy.github.io/2019/03/19/%E8%AE%BE%E8%AE%A1%E5%85%AD%E5%A4%A7%E5%87%86%E5%88%99/"/>
    <id>https://mllgy.github.io/2019/03/19/设计六大准则/</id>
    <published>2019-03-19T04:58:37.000Z</published>
    <updated>2019-03-25T07:11:28.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则 (Single Responsibility Principle)(SRP)"></a>单一职责原则 (Single Responsibility Principle)(SRP)</h3><p><strong>定义：</strong> 应该有且仅有一个原因引起类的变更。</p><p><strong>操作：</strong></p><ol><li>当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。</li><li>SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。</li></ol><p><strong>好处：</strong></p><ol><li>降低类的复杂度，实现什么职责都有明显的定义</li><li>可读性提高、可维护性强</li><li>变更风险低</li></ol><p><strong>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。</strong></p><a id="more"></a><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)(LSP)"></a>里氏替换原则(Liskov Substitution Principle)(LSP)</h3><p><strong>继承的优点</strong>：</p><ol><li>代码共享，每个子类拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>提高代码的扩展性，可 “随意” 重写父类方法；</li></ol><p><strong>继承的缺点：</strong></p><ol><li>继承具有入侵性，实现父类就必须拥有父类的方法和属性；</li><li>降低代码的灵活性，原因同上；</li><li>增强了耦合性。父类中的常量、变量、方法修改后，影响子类。</li></ol><p><strong>定义：</strong></p><p>凡是引用父类的地方都可以透明的使用其子类对象，反之，不成立。</p><p><strong>引申义：</strong></p><ol><li>子类必须完全实现父类的方法</li></ol><p><em>在类中调用其他类时 <code>务必使用父类或接口</code>，如果不能使用父类或接口，说明类的设计已经违反了 LSP 原则。</em></p><p>如果子类不能完整的实现父类中的方法或者父类中的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承。</p><ol start="2"><li><p>子类可以有自己的方法。这也就是 LSP 原则不能反过来用的原因。</p></li><li><p>覆盖或实现父类方法时，输入参数可以被放大。 </p></li><li><p>覆盖或实现父类方法时，输出结果可以被缩小。</p></li></ol><p><strong>优点：</strong></p><p>里氏替换原则的目的是增强程序的健壮性，即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对于不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h3 id="依赖倒置-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置(Dependence Inversion Principle)(DIP)"></a>依赖倒置(Dependence Inversion Principle)(DIP)</h3><p><strong>依赖倒置含义：</strong></p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖抽象。</li><li>抽象不应该依赖细节。</li><li>细节应该依赖抽象。</li></ol><p><strong>具体含义：</strong></p><p>低层模块：基本逻辑</p><p>高层模块：基本逻辑的组合</p><p>抽象：接口或抽象类</p><p>细节：实现类、继承子类</p><p><strong><em>模块之间的关系通过抽象产生</em></strong>，实现类之间不能直接发生依赖关系，其依赖关系通过上层的接口或者抽象类产生。</p><p>接口或抽象类不依赖实现类，实现类依赖接口或抽象类。</p><p><strong>优点：</strong></p><p>采用依赖倒置原则可以减少类间的耦合关系(更准确的说是(通过抽象类之间的关系)降低实现类之间的关系)，提高系统的稳定性，降低开发风险，提高代码的可读性和维护性。</p><p>抽象是对实现的约束，对依赖者而言，也是一种契约，不仅约束自己，同时还约束自己与外界的关系，其目的是保证所有的而细节不脱离契约的范畴，确保约束的双方按照既定的契约(抽象)共同发展，只要抽象这根基线存在，细节就不会超出范围。</p><p><strong>依赖关系</strong></p><p>依赖关系的概、具体表现、UML 图例表示可以参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/81531727" target="_blank" rel="noopener">Java 对象间关系以及 UML 类图表示方法</a> 下面简写如下：</p><ol><li>构造器函数传递依赖对象</li><li>方法中参数传递对象</li><li>接口声明中声明依赖对象。</li></ol><p><strong>最佳实践：</strong></p><p>依赖倒置原则的本质是 <code>通过抽象(抽象类或接口类)使各个类或模块的实现彼此独立</code>，不互相影响，实现模块间的松耦合，如何做：</p><ol><li>每个类尽量都有接口或抽象类，这是依赖倒置原则的基本要求，<strong>有了抽象才有可能倒置</strong>。</li><li>变量的表面类型(编译类型)尽量是接口或抽象类。</li><li>任何类都不应该从具体类派生出来。</li><li>尽量不要覆盖基类的方法(该方法已经在基类中实现)。如果说基类是一个抽象类，而且这个方法已经被实现了，子类尽量不要覆写。类间的依赖是抽象，覆写类抽象方法，对依赖的稳定性有所影响。</li><li>集合里氏替换原则。</li></ol><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>再此层面上 接口分为：</p><ol><li>实例接口 (类也是一种接口)</li><li>类接口(interface)</li></ol><p>隔离：即把一个接口中的多种职责进一步拆分出来，作为两个颗粒度更小的接口，此刻两个职责被单独隔离处理。</p><p><strong>定义：</strong></p><p>接口尽量细化，同时接口中的方法尽量少。</p><p><strong>如何对接口进行约束：</strong></p><ol><li>接口尽量小，满足单一职责原则。</li><li>接口高内聚。</li></ol><p>针对于接口高内聚就是要在接口中尽量少公布 public 方法，接口是对外的承诺，对外承诺越少越有利于系统的开发，这样变更的风险越低。</p><h3 id="迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP"><a href="#迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP" class="headerlink" title="迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)"></a>迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)</h3><p>一个对象应该对其他对象有最少的了解，换句话说，一个类应该对自己需要耦合或调用的类知道的最少，被耦合的类或这被调用的类内部如何复杂都和该类没有关系，我只需知道它们提供的 public 方法。</p><p><strong>只需要和朋友类联系：</strong></p><p>朋友类：出现在成员变量、方法的输入和输出参数的类为朋友类。<br>其实朋友类就是产生 <code>依赖关系的类</code>。</p><p><strong>朋友类中不应该向对方暴露的过多</strong></p><p>如果可能的话，尽量向其他类暴露尽量少的方法。</p><p><strong>自己的自己拥有</strong><br>如果一个类可以放在本类中，既不会增加类间关系，也不会对本类产生负面影响，那就放在本类中。</p><p><strong>尽量少的使用 Serializable</strong></p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体如类、模块、函数应该对扩展开发，对修改关闭。</p><p>开闭原则是最基础的一个原则，前面介绍的 5 个原则都是在开闭原则的具体形态，它们为指导设计的工具和方法，而开闭原则才是精神领袖。</p><p><strong>原则细节</strong></p><p>应该尽量通过扩展实体行为的方式来实现变化，而不是通过修改已有的代码来实现变化。</p><p>在软件开发中，尽可能减少代码粒度，代码粒度越小，被复用的可能越大。</p><p><strong>如何使用</strong></p><ol><li>抽象约束。</li></ol><p>具体表现为：</p><pre><code>1. 在对接口或抽象类进行扩展时，不允许出现接口或抽象类中不存在的 public 方法。2. 参数类型、引用对象尽量使用接口或抽象类，而不是实现类。3. 抽象应保持稳定，一旦确定不允许更改。</code></pre><ol start="2"><li>封装变化</li></ol><p>含义：</p><pre><code>1. 将相同的变化封装到接口或抽象类中2. 将不同的变化封装到不同的接口或抽象类中，不应该两个变化出现在同一个接口或抽象中。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单一职责原则-Single-Responsibility-Principle-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-Single-Responsibility-Principle-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 (Single Responsibility Principle)(SRP)&quot;&gt;&lt;/a&gt;单一职责原则 (Single Responsibility Principle)(SRP)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 应该有且仅有一个原因引起类的变更。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。&lt;/li&gt;
&lt;li&gt;SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低类的复杂度，实现什么职责都有明显的定义&lt;/li&gt;
&lt;li&gt;可读性提高、可维护性强&lt;/li&gt;
&lt;li&gt;变更风险低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式六大原则" scheme="https://mllgy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>代码混淆</title>
    <link href="https://mllgy.github.io/2019/03/16/%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86/"/>
    <id>https://mllgy.github.io/2019/03/16/代码混淆/</id>
    <published>2019-03-16T01:08:36.000Z</published>
    <updated>2019-03-16T01:08:36.696Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Basic 三</title>
    <link href="https://mllgy.github.io/2019/03/15/Java-Basic-%E4%B8%89/"/>
    <id>https://mllgy.github.io/2019/03/15/Java-Basic-三/</id>
    <published>2019-03-15T09:08:48.000Z</published>
    <updated>2019-03-25T08:18:18.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在只定义了方法的签名，没有方法的类称为抽象类。</p><ul><li>抽象类和抽象方法使用 abstract 修饰</li><li>抽象类不能实例化</li><li>抽象类可以没有抽象方法，可以有非抽象方法</li><li>抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)</li><li>含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类</li></ul><p>abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。<br><a id="more"></a></p><h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><p>抽象类是将多个子类向高层抽象，为子类提供行为模板,定义了子类中存在的共有行为。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口进一步将抽象类抽象。</p><p>接口定义了多个类共同的公共行为规范。</p><p>接口中不能含有</p><ol><li>构造器</li><li>初始化块</li></ol><p>但是接口中包含：</p><ol><li>成员变量(只能是静态)</li><li>方法(抽象实例方法、类方法、默认方法)</li><li>内部类(内部接口、枚举)</li></ol><h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><p>接口中的所有成员的访问权限为 <code>public</code> 。<br>对于接口中的静态常量而言，它们是接口相关的，系统会自动为这些成员变量增加 static 和 final 两个修饰符，必须在定义时进行初始化。</p><h3 id="接口中的默认方法、静态方法"><a href="#接口中的默认方法、静态方法" class="headerlink" title="接口中的默认方法、静态方法"></a>接口中的默认方法、静态方法</h3><p>接口中的默认方法和静态方法都可以实现，拥有方法体。</p><p>在 Java8 之前接口中的所有方法均为抽象方法，但是在 Java8 后系统为接口增加了默认方法，此方法增加了接口的可扩展性，如果需要在已有业务上需要为接口增加新的方法来实现增加业务的目的。那么 Java8 之前如果为接口增加方法，那么所有实现类均需要更改。在 Java8 后增加而 <code>默认方法</code>，实现类不是必须要实现该方法，如果实现了没有显示实现该方法，那么调用时使用默认实现。</p><p>而接口中的静态方法，需要通过接口名实现调用，在默认方法中可以调用本类的默认方法。</p><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p><em>一个类实现了一个接口后，这个类需要实现这个接口中的所有抽象方法，否则，这个类将保留从接口继承的抽象方法，则这个类必须定义为抽象类</em>。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>同：</strong></p><ol><li>不能被实例化，只能被其他类继承或实现。</li><li>都可以包含抽象方法，实现或继承的子类需要实现这些抽象方法。</li></ol><p><strong>异：</strong></p><p>接口作为系统与外界交互的窗口，接口体现的是一种规范,对于接口的实现者来说，接口规定了实现者必须向外提供哪些服务(以方法的形式)；对于接口的调用者来说，接口规定了可以调用哪些服务，以及如何调用服务(如何调用方法)。</p><p>抽象作为系统中多个子类的共同父类，它体现的是一种模板式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;存在只定义了方法的签名，没有方法的类称为抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法使用 abstract 修饰&lt;/li&gt;
&lt;li&gt;抽象类不能实例化&lt;/li&gt;
&lt;li&gt;抽象类可以没有抽象方法，可以有非抽象方法&lt;/li&gt;
&lt;li&gt;抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)&lt;/li&gt;
&lt;li&gt;含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker基本使用</title>
    <link href="https://mllgy.github.io/2019/03/14/Docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://mllgy.github.io/2019/03/14/Docker基本使用/</id>
    <published>2019-03-14T13:49:55.000Z</published>
    <updated>2019-03-15T02:24:45.784Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p><strong>docker ps:</strong> 查看本机上正在运行的容器<br><strong>docker ps -l:</strong> 查看本机上所有的容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker ps:&lt;/strong&gt; 查看本机上正在运行的容器&lt;br&gt;&lt;strong&gt;docker ps -l:&lt;/strong&gt; 查看本机上所有的容器&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Docker" scheme="https://mllgy.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>homebrew</title>
    <link href="https://mllgy.github.io/2019/03/14/homebrew/"/>
    <id>https://mllgy.github.io/2019/03/14/homebrew/</id>
    <published>2019-03-14T07:29:58.000Z</published>
    <updated>2019-03-14T08:08:39.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HomeBrew 为 Mac OSX 上的 软件管理工具，在 Mac 中可以方便的安装、卸载、更新软件，类似于 Linux 下的 apt-get、yum、dnf 等。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>具体安装见 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">官网</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>brew search xx:</strong><br><strong>brew install xx:</strong><br><strong>brew remove xx: </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;HomeBrew 为 Mac OSX 上的 软件管理工具，在 Mac 中可以方便的安装、卸载、更新软件，类似于 Linux 下的 apt-g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>requestDisallowInterceptTouchEvent</title>
    <link href="https://mllgy.github.io/2019/03/14/requestDisallowInterceptTouchEvent/"/>
    <id>https://mllgy.github.io/2019/03/14/requestDisallowInterceptTouchEvent/</id>
    <published>2019-03-14T03:54:33.000Z</published>
    <updated>2019-03-14T11:15:50.581Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p>调用 <code>requestDisallowInterceptTouchEvent</code> 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于 ViewGroup 为什么还是会拦截 ACTION_DOWN 事件，是因为 ViewGruop 在 ACTION_DOWN 事件时会重新置位 FLAG_DISALLOW_INTERCEPTER 标志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;requestDisallowInterceptTouchEvent&lt;/code&gt; 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于
      
    
    </summary>
    
    
      <category term="View" scheme="https://mllgy.github.io/tags/View/"/>
    
      <category term="事件分发机制" scheme="https://mllgy.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>拖动百度地图出现黑影的解决方法</title>
    <link href="https://mllgy.github.io/2019/03/13/%E6%8B%96%E5%8A%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%87%BA%E7%8E%B0%E9%BB%91%E5%BD%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://mllgy.github.io/2019/03/13/拖动百度地图出现黑影的解决方法/</id>
    <published>2019-03-13T08:29:09.000Z</published>
    <updated>2019-03-14T02:12:43.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述及解决方案"><a href="#问题描述及解决方案" class="headerlink" title="问题描述及解决方案"></a>问题描述及解决方案</h3><p><code>NestScrollView</code> 嵌套 <code>MapView</code> 在滑动整个布局时，<code>MapView</code> 的上下边界出现黑影。</p><p>问题解决：</p><p>使用 <code>TextureMapView</code> 替换布局中的 <code>MapView</code> 并开启硬件加速，如果只在当前 Activity 中开启硬件加速，执行在清单文件中该 Activity 注册信息中添加标签：<code>android:hardwareAccelerated=&quot;true&quot;</code> 。</p><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述及解决方案&quot;&gt;&lt;a href=&quot;#问题描述及解决方案&quot; class=&quot;headerlink&quot; title=&quot;问题描述及解决方案&quot;&gt;&lt;/a&gt;问题描述及解决方案&lt;/h3&gt;&lt;p&gt;&lt;code&gt;NestScrollView&lt;/code&gt; 嵌套 &lt;code&gt;MapVi
      
    
    </summary>
    
    
      <category term="百度地图黑影" scheme="https://mllgy.github.io/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%BB%91%E5%BD%B1/"/>
    
      <category term="硬件加速" scheme="https://mllgy.github.io/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>单例的几种写法</title>
    <link href="https://mllgy.github.io/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>https://mllgy.github.io/2019/03/13/单例的几种写法/</id>
    <published>2019-03-13T03:37:05.000Z</published>
    <updated>2019-04-04T06:44:50.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何实现单例类"><a href="#如何实现单例类" class="headerlink" title="如何实现单例类"></a>如何实现单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式()"></a>饿汉式()</h3><p><strong>方式一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private final static Singleton INSTANCE = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>方式二:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上两种实现方法基本一致，均是利用 <strong>类变量会在加载类时完成初始化</strong> 这一特性，实现了 <strong>线程安全</strong>，在加载类的同时就会完成该类单例的创建，即使在多线程情况下访问到的也是同一个对象，当然实现了单例模式。</p><p>虽然饿汉式在类加载时就实现了类的单例，但是存在压根就用不到该单例的情况，此时就浪费了内存。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>方式一：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式的 “懒” 就体现在:你用的话我就会初始化，你不用我我就不会初始化。</p><p>但是一个很明显的 Bug 是：在多线程情况下，有可能一个线程 A 进入了 <code>getInstance</code> 方法中但是未完成对象的初始化，但是此时另外的一个线程 B 进入该方法完成初始化初始化一个对象，A 之后重新执行生成一个对象，那么此刻就违背了单例模式的初衷。</p><p><strong>方式二：(改进)</strong></p><p>上面方式一谈到懒汉式存在线程安全的问题，那么改进该问题如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static synchronized Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>synchronized</code> 进行线程同步。</p><p>但是同时也需要面临的一个缺点就是每次获得该单例时都需要进行线程同步操作，效率大打折扣。</p><p><strong>方式三</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                INSTANCE = new Singleton(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写虽然杜绝了每次获得实例的线程同步而引起的问题，但是这种方式是有明显的缺点的：一个线程执行 <code>if(INSTANCE == null)</code> 方法时，其他线程可能会同时执行方法，造成程序中出现多个实例。</p><h3 id="多重检查"><a href="#多重检查" class="headerlink" title="多重检查"></a>多重检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(INSTANCE == null)&#123;</span><br><span class="line">                    INSTANCE = new Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的 饿汉方式三 做出改进，即在同步代码块中再做一次空判断，杜绝了以上方式的明显缺陷。</p><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonInstance&#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不会再外部类完成类加载的时候进行初始化加载，只会在调用时进行相关的类加载，实现了 <strong>懒加载</strong> 的功能，由于类加载只有在程序中出现一次，其享相应的属性也只会存在一份，实现了单例。</p><h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><p>public enum Singleton{<br>    INSTANCE;<br>    public void whateverMethod() {<br>    }<br>}</p><p>Effective Java 推荐使用，避免线程安全问题，支持自动序列化，注意枚举特性为 JDK 1.5 后添加。</p><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>一般情况下，推荐使用 <code>饿汉方式</code>，如果项目需求实现懒加载，推荐使用 <code>静态内部类方式</code>，涉及反序列试一下 <code>枚举方式</code>,特殊需求使用 <code>多重检查</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何实现单例类&quot;&gt;&lt;a href=&quot;#如何实现单例类&quot; class=&quot;headerlink&quot; title=&quot;如何实现单例类&quot;&gt;&lt;/a&gt;如何实现单例类&lt;/h3&gt;&lt;p&gt;如果一个类只能创建一个实例，那么这个类称为 &lt;strong&gt;单例类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据良好性封装原则，我们需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把类构造器函数隐藏&lt;/li&gt;
&lt;li&gt;提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot; title=&quot;饿汉式()&quot;&gt;&lt;/a&gt;饿汉式()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private final static Singleton INSTANCE = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getInstance&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return INSTANCE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 焦点机制</title>
    <link href="https://mllgy.github.io/2019/03/11/Android-%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    <id>https://mllgy.github.io/2019/03/11/Android-焦点机制/</id>
    <published>2019-03-11T03:08:29.000Z</published>
    <updated>2019-03-13T02:44:51.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式"><a href="#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式" class="headerlink" title="No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)"></a>No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)</h3><p>Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 <code>触摸模式</code>，而像 Andorid TV、键盘、轨迹球一般为 <code>非触摸模式</code>。</p><h3 id="Focus-焦点-、Focusable-可聚焦"><a href="#Focus-焦点-、Focusable-可聚焦" class="headerlink" title="Focus(焦点)、Focusable(可聚焦)"></a>Focus(焦点)、Focusable(可聚焦)</h3><p>在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。<br>根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。<br><a id="more"></a><br>根据用户的不同行为,两种模式可以不断切换：<br>在用户点击屏幕时，设备会进入触摸模式，而当用户点击轨迹球时，App 会立即退出触摸模式进入非触摸模式，并寻找一个控件获得焦点。</p><h3 id="触摸模式与-Focusable"><a href="#触摸模式与-Focusable" class="headerlink" title="触摸模式与 Focusable"></a>触摸模式与 Focusable</h3><p>Focusable 此特殊模式是为接收文本输入的控件创建的，如 EditText。在触摸模式中，如果控件是可聚焦的(Focusable),只要用户点击该控件，该控件就会得到焦点，反之控件是不会获得焦点的。</p><p>Foucusable 其实为控件的一个属性，可以通过代码 <code>setFocusableInTouchMode</code> 或 xml中<code>android:focusableInTouchMode</code>设置控件是否可聚焦。</p><h3 id="setFocusableInTouchMode-和-setFocusable"><a href="#setFocusableInTouchMode-和-setFocusable" class="headerlink" title="setFocusableInTouchMode 和 setFocusable"></a>setFocusableInTouchMode 和 setFocusable</h3><ul><li>setFocusable:设置控件是否可以获得焦点，可以通过 isFocusable() 获得状态。</li><li>setFocusableInTouchMode: 在触摸模式下，可以通过setFocusableInTouchMode 来设置控件是否可聚焦，可以通过isFocusableInTouchMode() 获得状态。</li></ul><p>大部分控件的 <code>setFocusableInTouchMode</code> 属性均为 false ，至于 EditText 的 <code>setFocusableInTouchMode</code> 的属性为 true，这也就是为什么 EditText 会率先获得屏幕焦点的原因。</p><h3 id="焦点监听与事件监听"><a href="#焦点监听与事件监听" class="headerlink" title="焦点监听与事件监听"></a>焦点监听与事件监听</h3><p>当为控件设置可聚焦属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">      android:id=&quot;@+id/btnOne&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:text=&quot;one&quot;</span><br><span class="line">      android:focusableInTouchMode=&quot;true&quot;   </span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>同时，为该控件设置了点击事件、焦点监听，此时是需要特别注意的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnOne.setOnclickListener&#123;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;click&quot;)</span><br><span class="line">&#125;</span><br><span class="line">btnOne.setOnFocusChangeListener&#123; v, hasFocus -&gt;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;focus change&quot; + hasFocus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们点击 Button 时，此时 Log 日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG focus change true</span><br></pre></td></tr></table></figure></p><p>而不会响应点击事件，想要 Button 响应点击事件，需要再次点击该按钮。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG click</span><br></pre></td></tr></table></figure></p><p>在这种情况下，需要点击两次才能让 Button 响应点击事件：</p><ol><li>Button 获得焦点</li><li>Button 响应点击事件</li></ol><p>所以 Google 建议使用 <code>focusableInTouchMode</code> 之前，需要三思后行。</p><h3 id="descendantFocusability"><a href="#descendantFocusability" class="headerlink" title="descendantFocusability"></a>descendantFocusability</h3><p><code>Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.</code></p><p>该属性的字面意思: 子代获取焦点的能力。该属性定义的是当一个 子View 获取焦点时， ViewGroup 与 子View 之间的关系。</p><ul><li><strong>beforeDescendants</strong>：Viewgroup 会优先其子类控件而获取到焦点</li><li><strong>afterDescendants</strong>：Viewgroup 只有当其子类控件不需要获取焦点时才获取焦点</li><li><strong>blocksDescendants</strong>：Viewgroup 会覆盖子类控件而直接获得焦点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot;&gt;&lt;a href=&quot;#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot; class=&quot;headerlink&quot; title=&quot;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&quot;&gt;&lt;/a&gt;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&lt;/h3&gt;&lt;p&gt;Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 &lt;code&gt;触摸模式&lt;/code&gt;，而像 Andorid TV、键盘、轨迹球一般为 &lt;code&gt;非触摸模式&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Focus-焦点-、Focusable-可聚焦&quot;&gt;&lt;a href=&quot;#Focus-焦点-、Focusable-可聚焦&quot; class=&quot;headerlink&quot; title=&quot;Focus(焦点)、Focusable(可聚焦)&quot;&gt;&lt;/a&gt;Focus(焦点)、Focusable(可聚焦)&lt;/h3&gt;&lt;p&gt;在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。&lt;br&gt;根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。&lt;br&gt;
    
    </summary>
    
    
      <category term="焦点机制" scheme="https://mllgy.github.io/tags/%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java Baseic 二</title>
    <link href="https://mllgy.github.io/2019/03/07/Java-Basic-%E4%BA%8C/"/>
    <id>https://mllgy.github.io/2019/03/07/Java-Basic-二/</id>
    <published>2019-03-07T04:56:36.000Z</published>
    <updated>2019-03-12T06:47:07.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equal-方法"><a href="#与-equal-方法" class="headerlink" title="== 与 equal 方法"></a>== 与 equal 方法</h3><p>Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。</p><p>当使用 <code>==</code> 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 <strong><code>==</code> 不可用于比较类型上没有父子关系的两个对象</strong>。</p><p>equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。</p><p>在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。</p><p>所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。<br><a id="more"></a></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">String c = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>此时堆内存中只会分配一份存储 “abc” 的内存, 变量 a、b、c 的引用地址都指向该内存地址。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池，主要是用来管理编译时被确定并且保存在 .class 文件中的数据，包括类、方法、接口中的常量以及字符串常量。</p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>被 static 修饰的变量、方法、初始化块、内部类等称为类变量。类变量属于类，在第一加载类的时候，系统会为类变量分配内存空间并进行初始化，直到该类被卸载，类变量占用的内存从会被标记成垃圾。</p><p>类变量中不能访问非 static 变量成员(变量、方法等),因为 类成员的作用域比非 static 变量成员的作用域大，存在类变量已经被初始化但是实例变量为被初始化的情况，此时程序就会出现异常。</p><h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>final 修饰的变量不可重复赋值</strong>。</p><p><strong>final 修饰成员变量</strong></p><p>初始化位置：</p><ul><li>初始化块</li><li>构造器</li><li>声明处</li></ul><p><strong>final 修饰类变量</strong><br>初始化位置：</p><ul><li>初始化块</li><li>声明处</li></ul><p>与普通实例变量不同，final 修饰的变量(实例变量和类变量)必须显式的初始化，系统不会为 final 修饰的变量的执行默认初始化。</p><ul><li>final 修饰局部变量</li></ul><p>必须显式的初始化初始值。</p><h3 id="final-修饰基本数据类型和引用数据类型"><a href="#final-修饰基本数据类型和引用数据类型" class="headerlink" title="final 修饰基本数据类型和引用数据类型"></a>final 修饰基本数据类型和引用数据类型</h3><p>final 修饰基本数据变量，则该变量不能被改变。<br>final 修饰引用数据类型变量，说明这个变量指向的内存地址不可更改，但是并不是此对象的各个属性不可变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Person person = new Person(20,&quot;Mike&quot;);</span><br><span class="line">person.setName(&quot;Jim&quot;);</span><br><span class="line">person.age = 21;</span><br></pre></td></tr></table></figure><h3 id="final-、宏变量与宏替换"><a href="#final-、宏变量与宏替换" class="headerlink" title="final 、宏变量与宏替换"></a>final 、宏变量与宏替换</h3><p>只要满足三个条件，这个 final 变量就不再是一个变量，而相当于一个直接量：</p><ol><li>使用 final 修饰</li><li>定义该 final 变量时指定初始值</li><li>该初始值在编译器时被确定下来。</li></ol><p>那么这个变量称为 <strong>宏变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int a =  5;</span><br></pre></td></tr></table></figure><p>那么对于这个程序来说，根本不存在变量 a，出现变量a 的地方全部被 5 替换。</p><p>为了说明宏变量的不同之处，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ab&quot;;</span><br><span class="line">String str2 = &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">sout(str1==str2);// true</span><br><span class="line"></span><br><span class="line">String str3 = &quot;a&quot;;</span><br><span class="line">String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><p>至于第一个日志结果为 true ,应该十分容易理解：str1 在编译时确定值，会被存储在常量池中，str2 通过显示的 <strong>拼装后(不是分别创建“a”和“b”)</strong> 存入 <strong>常量池</strong>，但是常量池中已经存在相同的值，就不会重新创建，直接将该值的内存地址指向 str2，所以结果为 true。</p><p>而第二条日志中，str5 在编译期不会初始化，需要在运行期通过计算获得，其值会被分配在 <code>堆内存</code>去中，所以 str1 和 str5 的引用的地址不同，其打印结果为 false。</p><p>同理有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str6 = new String(&quot;ab&quot;); </span><br><span class="line">sout(str1 == str6);//false</span><br></pre></td></tr></table></figure></p><p>但是如果 str3 和 str4 被 final 修饰，两者就会变成宏变量，两变量出现的位置会直接被值替换，此时 str5 在编译期就会确定初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final String str3 = &quot;a&quot;;</span><br><span class="line">final String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>final 方法不可被重写，但是可以被重载。</p><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>final 类不能拥有子类。</p><h3 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h3><p>不可变类为创建该类的实例后，该实例的实例变量不可变。</p><p>Java 提供的 8 个包装类和 String 为不可变类。</p><p>自定义不可变类需要遵循以下规则：</p><ol><li>使用 private final 修饰成员变量</li><li>提供构造器，传入初始值</li><li>仅提供 getter 方法</li><li>如果有必要，重新 equal() 和 hashcode() 方法自定义相等的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equal-方法&quot;&gt;&lt;a href=&quot;#与-equal-方法&quot; class=&quot;headerlink&quot; title=&quot;== 与 equal 方法&quot;&gt;&lt;/a&gt;== 与 equal 方法&lt;/h3&gt;&lt;p&gt;Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;==&lt;/code&gt; 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 不可用于比较类型上没有父子关系的两个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。&lt;/p&gt;
&lt;p&gt;在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。&lt;/p&gt;
&lt;p&gt;所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
