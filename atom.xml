<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GY</title>
  
  <subtitle>Enjoy the life, enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-02-26T02:54:06.694Z</updated>
  <id>/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Logcat 基本信息细述</title>
    <link href="/2020/02/24/Android-Logcat-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%BB%86%E8%BF%B0/"/>
    <id>/2020/02/24/Android-Logcat-基本信息细述/</id>
    <published>2020-02-24T06:51:48.000Z</published>
    <updated>2020-02-26T02:54:06.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Logcat-信息格式"><a href="#Logcat-信息格式" class="headerlink" title="Logcat 信息格式"></a>Logcat 信息格式</h2><blockquote><p>date time PID-TID/package priority/tag: message</p></blockquote><p>具体为：</p><blockquote><p>12-10 13:02:50.071 1901-4229/com.google.android.gms V/AuthZen: Handling delegate intent.</p></blockquote><p>PID 代表进程标识符，TID 则为线程标识符；如果仅有一个线程，两者可以相同。</p><h2 id="读取垃圾回收消息"><a href="#读取垃圾回收消息" class="headerlink" title="读取垃圾回收消息"></a>读取垃圾回收消息</h2><h3 id="Dalvik-日志消息"><a href="#Dalvik-日志消息" class="headerlink" title="Dalvik 日志消息-"></a>Dalvik 日志消息-</h3><p>在 Dalvik（而不是 ART）中，每个 GC 都会将以下信息输出到 logcat：</p><blockquote><p>D/dalvikvm(PID): GC_Reason(GC 原因) Amount_freed(释放内存量), Heap_stats(堆统计数据), External_memory_stats(外部内存统计数据), Pause_time(暂停时间)</p></blockquote><p>实例：</p><blockquote><p>D/dalvikvm( 9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms</p></blockquote><p>常见的 GC 原因：</p><ul><li>GC_CONCURRENT</li></ul><p>在堆 <strong>开始占用内存时</strong> 释放内存的并发 GC。</p><ul><li>GC_FOR_MALLOC</li></ul><p>您的 <strong>堆已满</strong> 而系统不得不停止您的应用并回收内存时，应用 <strong>尝试分配内存</strong> 而引起的 GC。</p><ul><li>GC_HPROF_DUMP_HEAP</li></ul><p><strong>请求创建 HPROF 文件</strong>，来分析堆时发生的 GC。</p><ul><li>GC_EXPLICIT</li></ul><p><strong>显式 GC</strong>，例如当您调用 gc() 时（您应避免调用它，而应信任 GC 会根据需要运行）。</p><ul><li>GC_EXTERNAL_ALLOC</li></ul><p>这仅适用于 API 级别 10 及更低级别（更新的版本会在 Dalvik 堆中分配任何内存）。外部分配内存的 GC（例如存储在原生内存或 NIO 字节缓冲区中的像素数据）。</p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>堆越大，暂停时间越长。并发暂停时间显示两个暂停：一个出现在 <strong>回收开始时</strong>，另一个出现在 <strong>回收快要完成时</strong>。</p><p>在此类日志消息积聚时，请注意 <strong>堆统计数据</strong>（上面示例中的 3571K/9991K 值）的增大情况。如果此值继续增大，可能会出现内存泄露。</p><h3 id="ART-日志消息"><a href="#ART-日志消息" class="headerlink" title="ART 日志消息"></a>ART 日志消息</h3><p>ART 不会为未明确请求的 GC 记录消息。只有在系统认为 GC 速度较慢时才会输出 GC 消息。更确切地说，仅在 <strong>GC 暂停时间超过 5 毫秒</strong> 或 <strong>GC 持续时间超过 100 毫秒时</strong>，才会输出 GC 记录日志。</p><p>输出格式：</p><blockquote><p> I/art: GC_Reason GC_Name Objects_freed(Size_freed) AllocSpace Objects,<br>        Large_objects_freed(Large_object_size_freed) Heap_stats LOS objects, Pause_time(s)</p></blockquote><p>GC 原因查看官方链接<br><a href="https://developer.android.google.cn/studio/debug/am-logcat?hl=zh_cn#format" target="_blank" rel="noopener">使用 Logcat 写入和查看日志</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Logcat-信息格式&quot;&gt;&lt;a href=&quot;#Logcat-信息格式&quot; class=&quot;headerlink&quot; title=&quot;Logcat 信息格式&quot;&gt;&lt;/a&gt;Logcat 信息格式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;date time PID-TID/pac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 多线程五：线程池</title>
    <link href="/2020/02/12/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%94%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>/2020/02/12/Java-多线程-五：线程池/</id>
    <published>2020-02-12T06:56:44.000Z</published>
    <updated>2020-02-28T03:39:16.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>有了 Thread，可以凭此开启子线程，执行耗时操作，那么为什么还有 Java 还有线程池这种类存在呢？</p><p>这是因为当业务需要我们频繁创建多个线程并进行耗时操作时，每次通过 <code>new Thread</code> 的方式来创建线程的方式是十分不好的。虽然线程是十分轻量的，但是新建和销毁消耗线程成本是系统操作，是十分消耗资源的，同时通过 <code>new Thread</code> 创建的大量线程是难以统一管理的，线程间相互竞争，可能占用过多系统资源而导致死锁。</p><p>而线程池可以做到以下几点：</p><ul><li>重用线程池中存在的线程，减少线程创建、销毁的开销。</li><li>有效控制最大并发，提高系统资源利用率，避免资源争夺，避免阻塞。</li><li>可以提供定时执行、定期执行、单线程、并发数的控制。</li></ul><h3 id="Executor-UML-图"><a href="#Executor-UML-图" class="headerlink" title="Executor UML 图"></a>Executor UML 图</h3><p><img src="./Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%94%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/2019_08_22_01.png" alt></p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><blockquote><p>An object that executes submitted {@link Runnable} tasks. This<br>interface provides a way of decoupling task submission from the<br>mechanics of how each task will be run, including details of thread<br>use, scheduling, etc.  An {@code Executor} is normally used<br>instead of explicitly creating threads. For example, rather than<br>invoking {@code new Thread(new RunnableTask()).start()} for each<br>of a set of tasks, you might use:</p></blockquote><p>Executor 是可以执行提交任务单一对象，它解耦了任务的提交和任务执行细的节。Executor 可以代替创建新建线程，可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = anExecutor();</span><br><span class="line">executor.execute(new RunnableTask1());</span><br><span class="line">executor.execute(new RunnableTask2());</span><br></pre></td></tr></table></figure><p>来代替 <code>new Thread(runnable).start();</code>。</p><p>但是 Executor 并不能保证任务能够异步执行，如下代码展示了任务在调用者的线程中执行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DirectExecutor implements Executor &#123;</span><br><span class="line">  public void execute(Runnable r) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>在 <a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/excutors/Main.java" target="_blank" rel="noopener">Main.Java</a> 中日志说明此处的 Executor 为同步执行。</p><p>但是更多的是：任务在新的线程而不是调用者的线程中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Runnable runnable) &#123;</span><br><span class="line">        new Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor 的实现类限制了任务在何时以及怎样执行，同时也可以将一个线程池中的任务交给另外一个线程执行，比如 AsyncTask 中将串行线程池中任务交给并行线程池去执行。</p><h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>ExecutorService 继承了 Executor，是使用更加广泛的接口，提供了 <strong>管理生命周期的方法</strong> 以及 <strong>跟踪一个或多个异步任务并返回 Future</strong> 的方法。 </p><p>ExecutorService 被关闭后就不会再执行新的任务，ExecutorService 提供了两个关闭 ExecutorService 的方法：</p><ul><li>void shutdown()：拒绝新的任务，但是之前的任务会被执行。</li><li>List<runnable> shutdownNow()：停止执行任何任务，返回等待执行的任务。</runnable></li></ul><p><code>submit()</code> 方法，通过创建并返回可用于取消执行和/或等待完成的 Future，来扩展基本方法 Executor#execute（Runnable）。</p><h4 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h4><p>AbstractExecutorService 为 ExecutorService  的默认实现类，<br>Java 1.5 引入。</p><h3 id="ThreadPoolExcutor-参数含义"><a href="#ThreadPoolExcutor-参数含义" class="headerlink" title="ThreadPoolExcutor 参数含义"></a>ThreadPoolExcutor 参数含义</h3><p>ThreadPoolExcutor 是 <strong>线程池的真正实现</strong> ，通过设置相应的参数来构建相应的线程池。ThreadPoolExcutor 构造函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,RejectedExecutionHandler handler) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>corePoolSize:</p><pre><code>线程池的核心线程数，默认情形下核心先线程会一直存活，即使核心线程处于闲置状态，也会一直存活。如果设置 ThreadPoolExecutor 的属性  allowCoreThreadTimeOut 为 true，那么闲置的核心线程会在等待新任务到来前执行超时策略，而对于超时的时间由 keepAliveTime 决定。</code></pre><p>maximumPoolSize：</p><pre><code>最大线程数，可允许创建的线程数，线程池中如果有这么多存活的线程，那么新到的任务会发生阻塞。</code></pre><p>keepAliveTime：</p><pre><code>闲置的非核心线程在超过这个时长后就会被回收，如果 allowCoreThreadTimeOut 被设置为 true，那么核心线程在超时后也会被回收。</code></pre><p>unit：</p><pre><code>keepAliveTime 的时间单位。</code></pre><p>workQueue：</p><pre><code>线程池的任务队列，工作队列，通过线程池的 execute 方法提交的 Runnable 对象被添加到这个队列中。</code></pre><p>threadFactory：</p><pre><code>线程工厂，为线程池实现创建新的线程的功能，ThreadFactory 为一个接口，只有 newThread(Runnable runnable) 方法。</code></pre><p>handler:</p><pre><code>定义处理被拒绝任务的策略，默认使用ThreadPoolExecutor.AbortPolicy,任务被拒绝时将抛出RejectExecutorException。</code></pre><p><strong>workQueue 的几个常见实现：</strong></p><ol><li><p>ArrayBlockingQueue</p><p> 基于数组结构的有界队列，按照 FIFO 的规则对任务进行排序。若队列满了，执行拒绝策略。</p></li><li><p>LinkedBlockingQueue</p><p> 基于链表结构的无界队列，按照 FIFO 的规则对任务进行排序。因为是无界队列，所以不存在队列满的情况，所以使用此队列的线程池忽略拒绝策略参数，同时还将忽略最大线程数 maximumPoolsize 等参数。</p></li><li><p>Synch</p></li></ol><h3 id="ThreadPoolExecutor-执行步骤"><a href="#ThreadPoolExecutor-执行步骤" class="headerlink" title="ThreadPoolExecutor 执行步骤"></a>ThreadPoolExecutor 执行步骤</h3><p>ThreadPoolExecutor 执行任务时大致遵循如下规则：</p><pre><code>1. 线程池中的线程数量没有超过核心线程数，那么直接启动一个核心线程来执行任务。2. 如果线程池中的线程数量大于或等于核心线程数，那么将任务插入到任务队列中，排队等待被执行。3. 如果在步骤 2 中任务无法正常加入任务队列，绝大部分原因是因为任务队列已满，如果此时线程数量没有达到设置的线程池的最大数量，就会启动非核心线程来执行任务。4. 如果步骤 3 中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor 会调用 RejectedExecutionHandler 的 rejectedExecution 方法来通知调用者。</code></pre><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>Executors 提供了方便获得 ExecutorService 的工厂方法，如 FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadPool 等。</p><h3 id="常见的四种线程池的创建"><a href="#常见的四种线程池的创建" class="headerlink" title="常见的四种线程池的创建"></a>常见的四种线程池的创建</h3><p>根据不同场景，为 ThreadPoolExecutor 配置不同参数来创建不同特性的线程池，常见的四种线程池有：FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadPool。</p><p><strong>FixedThreadPool</strong>(固定数量的线程池)：</p><p>构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>通过 Executors 的 newFixedThreadPool方法来创建，通过类名我们也可以得知 FixedThreadPool 为线程数量固定的线程池，除非关闭线程池，否则即使线程池中的线程处于闲置状态时，这些线程也不会被回收。由构建方法可知，FixedThreadPool 只有核心线程，所以这些线程不会被回收，所以执行效率更高。当有新任务时，如果线程池中的线程尚未达到最大线程数，直接创建新的线程；如果所有的线程均处于活动状态，那么新任务将处于等待状态，直到线程池中有空闲线程为止，需要明确的是任务队列没有大小限制。</code></pre><p><strong>CachedThreadPool</strong>：</p><p>构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>由构建函数知 CachedThreadPool 没有核心线程，线程的数量的最大值为 Integer.MAX_VALUE。当新的任务来临时，如果线程池中存在处于空闲状态下的线程，那么会复用该线程来处理任务，否则会创建新的线程。线程池中的空闲线程如果超过 60s 会被回收。SynchronousQueue 为不可添加任务的队列，这就意味着任何新的任务都会被立即执行。</code></pre><p>为了保证最大的吞吐量，如果线程池中没有空闲线程，该线程池会创建新的线程。</p><p><strong>ScheduledThreadPool</strong>：</p><p>构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>限定核心线程数，不限制非核心线程数，空闲线程在  DEFAULT_KEEPALIVE_MILLIS 后被回收。ScheduledThreadPool这类线程池主要用于执行定时任务和具有固定周期的重复任务。</code></pre><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);</span><br><span class="line">//2000ms后执行command</span><br><span class="line">scheduledThreadPool.schedule(command,2000,TimeUnit.MILLISECONDS);</span><br><span class="line">//延迟10ms后，每隔1000ms执行一次command</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(command,10,1000,TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><strong>SingleThreadPool</strong>:</p><p>构建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">        return new FinalizableDelegatedExecutorService</span><br><span class="line">            (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>由构建方法可知，SingleThreadPool 中只有一个核心线程，这意味着所有的任务都会被顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。</code></pre><hr><p><strong>知识链接</strong></p><p><a href="https://www.cnblogs.com/MOBIN/p/5436482.html" target="_blank" rel="noopener">java并发编程–Executor框架</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么使用线程池&quot;&gt;&lt;a href=&quot;#为什么使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么使用线程池&quot;&gt;&lt;/a&gt;为什么使用线程池&lt;/h3&gt;&lt;p&gt;有了 Thread，可以凭此开启子线程，执行耗时操作，那么为什么还有 Java 还有线程池这
      
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux 多用户管理</title>
    <link href="/2020/01/27/Linux-%E5%A4%9A%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
    <id>/2020/01/27/Linux-多用户管理/</id>
    <published>2020-01-27T03:44:14.000Z</published>
    <updated>2020-01-27T03:44:14.714Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gadle实战(五)：扩展 Gradle</title>
    <link href="/2020/01/19/Gradle%E5%AE%9E%E6%88%98-%E4%BA%94/"/>
    <id>/2020/01/19/Gradle实战-五/</id>
    <published>2020-01-19T08:09:48.000Z</published>
    <updated>2020-01-19T08:09:48.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-从零构建插件"><a href="#1-从零构建插件" class="headerlink" title="1.从零构建插件"></a>1.从零构建插件</h2><p>Gradle 将插件分为两类：</p><ul><li>脚本插件</li><li>对象插件</li></ul><p>一个脚本插件是一个普通的 Gradle 构建脚本，可以被导入到其他构建脚本中。对象插件可以实现你学到的事情，需要实现 <code>org.gradle.api.Plugin</code> 接口。</p><a id="more"></a><p>对象插件的源代码通常放在 buildSrc 目录下，要么和项目在一起，要么是一个独立的项目，并且以 Jar 包的形式发布。</p><h2 id="2-定制-task-的实现选项"><a href="#2-定制-task-的实现选项" class="headerlink" title="2. 定制 task 的实现选项"></a>2. 定制 task 的实现选项</h2><p>Gradle 中有多种定制 Task 的方式，最简单的一种是把它和构建代码一起放在构建脚本里,这种方式存在之前的文章。当触发一个 Task 时，<strong>定义的 Task 会自动编译并添加到 classpath 中</strong>。</p><p>另外一种方式就是将定制的 Task 放到项目根目录下的 <code>buildSrc</code> 目录中，遵从语言插件定义的源代码目录约定。<strong>位于 buildSrc 目录下的定制的 task 类，会被所有的项目构建共享，并且在 classpath 中自动可用。</strong>为了使定制的 Task 在多个项目中共享，可以将它们打成 jar 包，然后在构建脚本中的 classpath 中定义。</p><p>以下为定义 Task 的不同实现方式：</p><p><img src="/source/images/2020_01_15_01.png" alt></p><h3 id="2-1-在脚本中定制-Task"><a href="#2-1-在脚本中定制-Task" class="headerlink" title="2.1 在脚本中定制 Task"></a>2.1 在脚本中定制 Task</h3><p>Gradle 提供了一个可以通过继承的默认实现：<code>org.gradle.api.DefaultTask</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class customTask implements DefaultTask&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-buildSrc-中定制-Task"><a href="#在-buildSrc-中定制-Task" class="headerlink" title="在 buildSrc 中定制 Task"></a>在 buildSrc 中定制 Task</h3><p>以上方式2，在 buildSrc 中创建定制 Task 的源文件，这是后期通过对象插件使用它们的最好方式。</p><p>用 groovy 定义 Task，所有的定制 Task 类放在 <code>${project_rootDir}/buildSrc/src/main/groovy/项目目录/</code> 下。</p><p>使用定制 Task：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//导入定制 Task</span><br><span class="line">import xxx.xxxx.xxxx.CustomeTask</span><br><span class="line">task test(type:CustomeTask)&#123;</span><br><span class="line">    xxx</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用和构建对象插件"><a href="#3-使用和构建对象插件" class="headerlink" title="3. 使用和构建对象插件"></a>3. 使用和构建对象插件</h2><p>打包定制的 Task 实现为 Jar 的方式的优缺点,具体参见 Gradle in Action 一书。</p><p><strong>对象插件</strong> 可以灵活去封装高度复杂的逻辑，并且提供强大的扩展机制可以在构建脚本中定制它的行为。和定制 Task 一样，可以完全访问 Gradle 的公共 API 和工程模型。</p><p>Gradle 提供了开箱即用的插件，称为 <strong>标准插件</strong>，也可以通过 <strong>第三方插件</strong> 进行扩展。许多插件都是自包含的，这意味着它们要么依赖 Gradle 的核心 API，要么通过包装代码提供功能。更复杂的插件依赖于其他类库、工具或者插件提供的特性。</p><p>下图展示了插件在 Gradle 架构的位置:</p><p><img src="/source/images/2020_01_15_02.png" alt="Gradle 插件架构"></p><p>在平常的开发中，我们经常使用 Java 插件来扩展项目功能。如下图 Java 插件特性所示，插件可以提供一个 Task 集合，并且整合到执行生命周期中，引入新的项目布局并提供有意义的默认值，添加属性来定制化它的行为，给依赖管理暴露对应的配置（比如平时使用到的 compile）。</p><p><img src="/source/images/2020_01_15_03.png" alt="Java 插件特性"></p><p><strong>通过一行代码引入 Java 插件，就可以使用 Java 插件相应的功能来编译源代码、运行单元测试、生成报告，并将项目打包为Jar</strong>。</p><p>标准插件也提供了很多通用功能，大部分能够满足开发者的需求。由社区或这开源组织开发的三方插件，可以用来给构建脚本增强非标准功能。</p><h3 id="3-1-使用对象插件"><a href="#3-1-使用对象插件" class="headerlink" title="3.1 使用对象插件"></a>3.1 使用对象插件</h3><p>在项目中同通过 <code>apply</code> 方法来配置项目，从而使用标准插件，该方式是 Project 对象提供的方式，存在一个类型为 Map 的参数 options。</p><p>标准插件的便利在于他们是 Gradle 运行时的一部分，用户不需要知道插件所依赖的类库，这些类库的位置为 Gradle 安装目录的 libs/plugins 下。</p><h4 id="3-1-1-通过名字使用插件"><a href="#3-1-1-通过名字使用插件" class="headerlink" title="3.1.1 通过名字使用插件"></a>3.1.1 通过名字使用插件</h4><p>插件标识符一个简短的名字，通过插件的元信息提供，在项目中使用 Java 插件，直接传入键值对 plugin：’java‘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugins: &apos;java&apos;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-通过类型使用插件"><a href="#3-1-2-通过类型使用插件" class="headerlink" title="3.1.2 通过类型使用插件"></a>3.1.2 通过类型使用插件</h4><p>如果插件没有暴露名字，或者两个插件的命名冲突，那么可以类型来使用插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:org.gradle.api.plugins.JavaPlugin</span><br></pre></td></tr></table></figure><h4 id="3-1-3-使用外部插件"><a href="#3-1-3-使用外部插件" class="headerlink" title="3.1.3 使用外部插件"></a>3.1.3 使用外部插件</h4><p>构建脚本并不知道外部插件的存在，需要将它放到 <code>classpath</code> 下。可以通过 buildScript 方法来做这件事，它定义了外部插件的位置、仓库和插件依赖。</p><p>在配置阶段，Gradle 中构建项目模型，连接插件构建逻辑。一旦插件下载完成，就会放置在本地缓存中，以便后续的运行可以使用到它们。</p><p>以下展示如何使用 MavenCentral 中的 tomcat 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildScript&#123;</span><br><span class="line">    repostories&#123;</span><br><span class="line">        // 该插件的原始仓库</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies&#123;</span><br><span class="line">        // 定义插件依赖</span><br><span class="line">        classpath &apos;org.gradle.api.plugins:gradle-tomcat-plugin:0.9.7&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-解析对象插件"><a href="#4-解析对象插件" class="headerlink" title="4. 解析对象插件"></a>4. 解析对象插件</h2><p>以下图片显示了实现一个插件的几种选择：</p><p><img src="/source/images/2020_01_16_01.png" alt></p><p>对于实现一个对象插件，有四个元素是十分重要的：</p><ul><li>放置插件实现的位置</li></ul><p>Gradle 在这方式十分灵活，代码可以发在构建脚本中，可以放在 <code>buildSrc</code> 目录下，也可以作为一个 <strong>独立的工程</strong> 被开发并且以 Jar 包的形式发布。</p><ul><li>每一个插件都需要提供一个实现类</li></ul><p>该实现类代表插件的入口，插件可以用任何 JVM 语言编写并编译成字节码，比如 Java、Kotlin、Groovy 等。</p><ul><li>插件通过暴露出来的扩展对象进行定制</li></ul><p>当用户想要在构建脚本中覆盖插件的默认配置，这是十分重要的实现方式。</p><ul><li>插件描述符</li></ul><p>插件描述符是一个属性文件，它包含类插件的元信息，通常包含插件的简短名字和插件实现类的映射。</p><h2 id="5-编写对象插件并运用到项目"><a href="#5-编写对象插件并运用到项目" class="headerlink" title="5. 编写对象插件并运用到项目"></a>5. 编写对象插件并运用到项目</h2><p>编写一个插件的最低要求是提供 org.gradle.api.Plugin<project> 接口的一个实现类，该接口仅有一个方法：apply(Project)。</project></p><h3 id="5-1-通过-buildSrc-的形式编写对象插件"><a href="#5-1-通过-buildSrc-的形式编写对象插件" class="headerlink" title="5.1 通过 buildSrc 的形式编写对象插件"></a>5.1 通过 buildSrc 的形式编写对象插件</h3><p>使用 buildSrc 的方式定义对象插件的好处是，在早期开发插件阶段，不需要打包插件代码，可以得到一个快速的反馈，能够让开发者能够专心通过 Gradle Api 实现业务逻辑。</p><p>在 buildSrc 工程下的指定包目录中创建一个插件的实现类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomPlugin implements Plugin&lt;Project&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    void apply(Project project)&#123;</span><br><span class="line">        xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在项目中使用该插件，则在 build.gradle  中使用插件的实现类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: xxxx.xxx.CustomPlugin</span><br></pre></td></tr></table></figure><h2 id="6-插件扩展机制"><a href="#6-插件扩展机制" class="headerlink" title="6. 插件扩展机制"></a>6. 插件扩展机制</h2><p>通过 —P 和 —D 可以在执行 Gradle 命令行时提供参数，为 Task 提供输入，但这种方式不总是可取的。</p><p>Gradle 允许通过暴露一个带有唯一命名空间的 DSL 来建立自己的构建语言，下面展示一个名为 cloudBees 的闭包，允许从构建脚本中给 task 所需要的属性设置值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cloudBees&#123;</span><br><span class="line">    apiUrl = &apos;https://xxx&apos;</span><br><span class="line">    apiKey = project.apiKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gradle 会将语言结构模型化为扩展，扩展是可以被添加到 Gradle 对象中，比如 Project或者Task。</p><p>如果一个类实现了 org.gradle.api.plugins.ExtensionAware 接口，就认为它是可扩展的，每种扩展都是一种数据结构，它是扩展的基础。</p><p>以下为 CloudBees 插件的扩展模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package xxxx.xxx</span><br><span class="line">class CloudBeesPluginExtension&#123;</span><br><span class="line">    String apiUrl</span><br><span class="line">    String apiKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-注册和使用扩展"><a href="#7-注册和使用扩展" class="headerlink" title="7. 注册和使用扩展"></a>7. 注册和使用扩展</h2><h3 id="7-1-给插件一个有意义的名字"><a href="#7-1-给插件一个有意义的名字" class="headerlink" title="7.1 给插件一个有意义的名字"></a>7.1 给插件一个有意义的名字</h3><p>默认情况下，插件的名字从实现了 org.gradle.api.Plugin 接口的全限定类名继承而来。</p><p>对于对象插件来说，可以在 META-INF/gradle-plugins 目录下的一个属性文件中配置名字，<strong>该属性文件的名字自动决定了插件的名字</strong>，比如 META-INF/gradle-plugins/nuwa.properties 暴露插件的名字是 nuwa，在 nuwa.properties 中<br>需要将类的全限定类名赋值给 implementation-class,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.xxx.xxx.NuwaPlugin</span><br></pre></td></tr></table></figure><p>在构建脚本 build.gradle 中使用这个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin &apos;nuwa&apos;</span><br></pre></td></tr></table></figure><h3 id="7-2-测试对象插件"><a href="#7-2-测试对象插件" class="headerlink" title="7.2 测试对象插件"></a>7.2 测试对象插件</h3><p>具体查看 Gradle in action。</p><h2 id="8-开发和使用独立的对象插件"><a href="#8-开发和使用独立的对象插件" class="headerlink" title="8.开发和使用独立的对象插件"></a>8.开发和使用独立的对象插件</h2><p>如果想要在主构建的脚本中使用插件，那么在 buildSrc 项目中实现一个插件时是十分方便的；但是如果想要在多个模块中的共享插件，那么需要将插件作为独立的项目开发，然后将插件发布到仓库中。</p><h3 id="8-1-项目和仓库配置"><a href="#8-1-项目和仓库配置" class="headerlink" title="8.1 项目和仓库配置"></a>8.1 项目和仓库配置</h3><p>新建一个独立 module，将在 buildSrc 中的所有代码移到该  module 中。每次想要发布新的插件版本时，所产生的 Jar 文件会被发布到名为 repo 的与项目同目录的本地  maven 库中。</p><p>书中例子：假设其他项目想要使用该插件，那么在该项目的构建脚本中定义本地仓库，声明插件作为依赖，使用插件中的 Task 与 CloudBees 后端服务交互。</p><p><img src="/source/images/2020_01_16_02.png" alt></p><p>其中 plugin 为定义插件的模块。</p><h3 id="8-2-构建插件项目"><a href="#8-2-构建插件项目" class="headerlink" title="8.2 构建插件项目"></a>8.2 构建插件项目</h3><ul><li>定义依赖</li></ul><p>此时不能再访问 buildSrc 基础设施，所以需要定义对 Groovy 和 Gradle API 类库的依赖。</p><ul><li>发布插件</li></ul><p>通过 Maven 插件，可以为插件生成的 POM 文件和将插件发布到 Maven 库中。配置 Maven 部署器将 POM 和 插件上传到本地目录中，为了更好的管理插件的版本，需要为插件指定 group、name\version.</p><p><img src="/source/images/2020_01_16_03.png" alt></p><p>在插件被使用之前，需要先执行 <code>gradle uploadArchives</code> 命令，使用 Maven 插件相关 task 帮助下上传该插件。</p><p>发布插件后，在根目录下出现名为 repo 的新目录，包含了插件的 POM 文件和 Jar 文件。</p><ul><li>在项目中使用插件</li></ul><p>在项目中构建脚本中添加如下配置：</p><p><img src="/source/images/2020_01_16_04.png" alt></p><p>对本地 Maven 库的声明也可以使用相对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(&apos;./repo&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-从零构建插件&quot;&gt;&lt;a href=&quot;#1-从零构建插件&quot; class=&quot;headerlink&quot; title=&quot;1.从零构建插件&quot;&gt;&lt;/a&gt;1.从零构建插件&lt;/h2&gt;&lt;p&gt;Gradle 将插件分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脚本插件&lt;/li&gt;
&lt;li&gt;对象插件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个脚本插件是一个普通的 Gradle 构建脚本，可以被导入到其他构建脚本中。对象插件可以实现你学到的事情，需要实现 &lt;code&gt;org.gradle.api.Plugin&lt;/code&gt; 接口。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gadle实战(四）：依赖管理、版本冲突、理解缓存</title>
    <link href="/2020/01/19/Gradle%E5%AE%9E%E6%88%98-%E5%9B%9B/"/>
    <id>/2020/01/19/Gradle实战-四/</id>
    <published>2020-01-19T07:27:42.000Z</published>
    <updated>2020-01-19T07:28:32.508Z</updated>
    
    <content type="html"><![CDATA[<p>在为项目配置依赖时通过 <code>dependencies</code> 和 <code>repositories</code> 两个 DSL <strong>配置块</strong>进行配置的，配置块的名称直接映射到 Project 接口的方法。依赖管理器通过运行以上两个配置，从中央仓库下载所需要的库，将它们存储在本地缓存中。</p><p>配置块中包含配置：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//dependencies 为配置块</span><br><span class="line">dependencies&#123;</span><br><span class="line">    // compile 为配置</span><br><span class="line">    compile xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1. 依赖配置"></a>1. 依赖配置</h2><p>在 Gradle 中，<strong>依赖配置</strong> 是十分重要的概念，插件可以引入配置来 <strong>定义依赖的作用域</strong>。在项目中引入 Java 插件，就可以引入了其各种标准配置，来定义 Java 构建生命周期所应用的依赖。比如通过 compile 来配置添加编译源代码所需要的依赖。</p><h2 id="2-通过-API-认识配置"><a href="#2-通过-API-认识配置" class="headerlink" title="2. 通过 API 认识配置"></a>2. 通过 API 认识配置</h2><p>配置可以在项目的 <strong>根级别</strong> 添加和访问，可以使用插件提供的配置，也可以使用自己声明的配置。</p><p>每个 Project 都有一个 <code>ConfigurationContainer</code> 类容器来管理自己相应的配置。</p><h3 id="配置的使用场景"><a href="#配置的使用场景" class="headerlink" title="配置的使用场景"></a>配置的使用场景</h3><ol><li>配置是很灵活的，可以使用配置控制配置依赖解决方案追溯是否包含传递性依赖、定义解决策略（比如，如何解决版本冲突）等，同时使用配置可以进行。</li><li>使用配置进行逻辑分组</li></ol><p>配置分组与 Java 中包的概念十分相似，包针对其包含的类提供唯一的命名空间，同样这也适用于配置，通过逻辑分组把职责相同的配置放在一起。</p><p>在 Java 中提供了 6 个现成的配置：compile、runtime、testCompile、testRuntime、archives、default，随着版本的更新配置的数量和种类也在变化。在 Gradle 中，也可以自定义配置，实现自己的逻辑。比如需要引入部署应用的依赖 Cargo 库，但是如果使用 Java 提供的配置中的一个，会将应用程序代码和部署应用的代码相应的环境混淆，导致发布时将不必要的类库添加到发布包中，此时我们可以通过自定义配置来解决这个问题。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>为了明确 Cargo 所需的依赖，声明一个名为 cargo 的新配置，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configurations&#123;</span><br><span class="line">    cargo&#123;</span><br><span class="line">        description = &apos;classpath for cargo ant tasks&apos;</span><br><span class="line">        visibile = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为项目配置容器添加配置后，可以直接通过配置名称进行使用。</p><h3 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h3><p> 此时就可以在配置块中使用 cargo 配置，并在相应的 Task 中使用配置相应内容，并且自定义的配置也可以使用向排除传递性依赖、动态版本号等特性，具体参见以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    cargo &#123;</span><br><span class="line">        description = &apos;Classpath for Cargo Ant tasks.&apos;</span><br><span class="line">        visible = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task deployToLocalTomcat &lt;&lt; &#123;</span><br><span class="line">    // 以文件树的形式获取 cargo 配置所有的依赖</span><br><span class="line">    FileTree cargoDependencies = configurations.getByName(&apos;cargo&apos;).asFileTree</span><br><span class="line">    ant.taskdef(resource: &apos;cargo.tasks&apos;, classpath: cargoDependencies.asPath)</span><br><span class="line">    ant.cargo(containerId: &apos;tomcat7x&apos;, action: &apos;run&apos;, output: &quot;$buildDir/output.log&quot;) &#123;</span><br><span class="line">        configuration &#123;</span><br><span class="line">            deployable(type: &apos;war&apos;, file: &apos;todo.war&apos;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zipUrlInstaller(installUrl: &apos;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.50/bin/apache-tomcat-7.0.50.zip&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.cargoGroup = &apos;org.codehaus.cargo&apos;</span><br><span class="line">ext.cargoVersion = &apos;1.3.1&apos;</span><br><span class="line"></span><br><span class="line">// 在配置块中通过自定义配置声明依赖</span><br><span class="line">dependencies &#123;</span><br><span class="line">    cargo group: cargoGroup, name: &apos;cargo-core-uberjar&apos;, version: cargoVersion</span><br><span class="line">    cargo &quot;$cargoGroup:cargo-ant:$cargoVersion&quot;</span><br><span class="line">    cargo(&apos;org.codehaus.cargo:cargo-ant:1.3.1&apos;) &#123;</span><br><span class="line">        exclude group: &apos;xml-apis&apos;, module: &apos;xml-apis&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    cargo(&apos;org.codehaus.cargo:cargo-ant:1.3.1&apos;) &#123;</span><br><span class="line">        transitive = false</span><br><span class="line">    &#125;</span><br><span class="line">     cargo &apos;org.codehaus.cargo:cargo-ant:1.+&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h2><p>DSL 配置块 dependencies 通常用来将一个或者多个依赖指派给配置，但是外部依赖是依赖的唯一方式。</p><h3 id="依赖的方式"><a href="#依赖的方式" class="headerlink" title="依赖的方式"></a>依赖的方式</h3><p>外部模块依赖（dependencies）、项目依赖（settiong）、文件依赖（dependencies 中 fileTree）、Gradle 运行时依赖、客户端模块依赖（不常见）</p><h3 id="依赖相关-API"><a href="#依赖相关-API" class="headerlink" title="依赖相关 API"></a>依赖相关 API</h3><p>每个 Gradle 项目都有依赖处理器实例，由 DependencyHandler 接口来实现。</p><p>每个依赖项都是 Dependency 类型的一个实例，group、name、version、classifier 属性明确标识了一个依赖。</p><h3 id="外部模块依赖"><a href="#外部模块依赖" class="headerlink" title="外部模块依赖"></a>外部模块依赖</h3><p>在 Gradle 中，外部类库通常以 Jar 文件的形式存在，被称为 <strong>外部模块依赖</strong>。</p><p><code>androidx.appcompat:appcompat:1.1.0</code></p><p>依赖属性：</p><ul><li><p>group<br>这个属性用来标识一个组织、公司或者项目，比如 androidx.appcompat</p></li><li><p>name</p></li></ul><p>一个库的名称唯一描述了依赖，比如 appcompat</p><ul><li>version</li></ul><p>描绘了一个库的版本号。</p><ul><li>classifier</li></ul><p>可以定义另一个属性，但是以上并没有定义该属性。</p><h3 id="依赖标记"><a href="#依赖标记" class="headerlink" title="依赖标记"></a>依赖标记</h3><p>在项目中通过以下形式来声明依赖：</p><p>dependencies{<br>    // 比如 compile com.xx.xx<br>    configurationcompile xxx<br>}</p><h3 id="检查依赖报告"><a href="#检查依赖报告" class="headerlink" title="检查依赖报告"></a>检查依赖报告</h3><p>运行 <code>gradle dependencies</code> 会显示完整的 <strong>依赖树</strong>。</p><p>在依赖树中，标有星号的依赖被排除了，这意味依赖管理器使用的是另外一个版本的类库，因为他被声明另外一个顶层依赖的传递性依赖。</p><p>在 dependencies 配置中声明的依赖为 <strong>顶层依赖</strong>，这些顶层依赖所依赖的库称为 <strong>传递性依赖</strong>。</p><p><strong>针对版本冲突，Gradle 默认的解决策略是获取最新的版本</strong>，在依赖树中这样展示：1.0.0 -&gt; 1.1.0，而在依赖报告中，标有星号的依赖被排除了，意味着依赖管理器选择的是相同或者另一个版本的类库。</p><h3 id="排除传递性依赖"><a href="#排除传递性依赖" class="headerlink" title="排除传递性依赖"></a>排除传递性依赖</h3><h4 id="排除传递性依赖，依赖指定版本的远端库"><a href="#排除传递性依赖，依赖指定版本的远端库" class="headerlink" title="排除传递性依赖，依赖指定版本的远端库"></a>排除传递性依赖，依赖指定版本的远端库</h4><p>假如想要显式的指定某个类库的版本，而不使用顶层依赖所提供的传递性依赖，可以通过 exclude 排除指定库，具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    // 通过 exclude 来声明排除依赖</span><br><span class="line">    cargo(&apos;org.codehaus.cargo:cargo-ant:1.3.1&apos;)&#123;</span><br><span class="line">        exclude group:&apos;xml-apis&apos;,module:&apos;xml-apis&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 依赖指定版本的库</span><br><span class="line">    cargo &apos;xml-apis:xml-apis:2.0.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排除传递性依赖，排除所有的传递性依赖"><a href="#排除传递性依赖，排除所有的传递性依赖" class="headerlink" title="排除传递性依赖，排除所有的传递性依赖"></a>排除传递性依赖，排除所有的传递性依赖</h4><p>如果想要 <strong>排除一个库的所有传递性依赖</strong>，Gradle 提供了 <code>transitive</code> 属性来实现这一效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    // 通过 exclude 来声明排除依赖</span><br><span class="line">    cargo(&apos;org.codehaus.cargo:cargo-ant:1.3.1&apos;)&#123;</span><br><span class="line">        transitive = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态版本声明"><a href="#动态版本声明" class="headerlink" title="动态版本声明"></a>动态版本声明</h3><p>如果不想要指定依赖库的版本号，可以获取最新版本的依赖或者在版本范围内选择最新的依赖。</p><p>动态版本声明有特定的语法，如果想要使用 <strong>最新版本的依赖</strong>，则必须使用占位符 <code>lastest.intergration</code> 或者声明版本属性，通过使用一个加号（+）标定它来动态改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    cargo &apos;xml-apis:xml-apis:lastest.intergration&apos;</span><br><span class="line">    cargo &apos;xml-apis:xml-apis:2.0.+&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要最好不要使用动态版本，因为在项目的开发中，可靠性和可复用是最重要的，但是选择最新版本的类库可能在开发者不知情的情况下引入了不兼容的类库版本和副作用，基于此应该声明明确的类库版本。</strong></p><p>也可以指定版本的范围，具体查看Gradle 在线手册。</p><h3 id="文件依赖"><a href="#文件依赖" class="headerlink" title="文件依赖"></a>文件依赖</h3><p>以上为外部模块依赖，也可以依赖本地的文件。</p><p>这样一个场景：定义一个 Task，用于将从 Maven Central 获取的依赖拷贝到 home 目录下的 libs/cargo 子目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task copyDependenciesToLocalDir(type:Copy)&#123;</span><br><span class="line">    from confingurations.cargo.asFileTree</span><br><span class="line">    into &quot;$&#123;System.properties[&apos;user.home&apos;]&#125;/libs/cargo&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 dependencies 配置块中声明 Cargo 类库，以下展示如何把 Jar 文件指派给 cargo 配置作为文件依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    cargo fileTree (dir:&quot;$&#123;System.properties[&apos;user.home&apos;]&#125;/libs/cargo&quot;,include &apos;*.jar&apos;)</span><br><span class="line">    // 平时我们在 Android 如下使用，进行文件依赖</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用和配置仓库"><a href="#使用和配置仓库" class="headerlink" title="使用和配置仓库"></a>使用和配置仓库</h2><h3 id="仓库-API"><a href="#仓库-API" class="headerlink" title="仓库 API"></a>仓库 API</h3><p>在项目中定义仓库的关键是 <code>RespositoryHandler</code> 接口，<strong>该接口提供了添加各种类型仓库的方法</strong>，这些方法可以在 respositories 配置块中被调用。</p><p><img src="/source/images/2020_01_14_01.png" alt></p><p>通过上图可以看，不同类型的仓库提供了不同方法来进行相关配置，以下展示每种仓库的具体配置。</p><h3 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h3><p>最常的仓库，类库通常以 jar 文件的形式表现，元数据用 xml 标出，并且使用 pom 文件描述了类库相关信息以及其传递性依赖。</p><p>Maven 仓库下所有类库的内容会被存储在一个预定义的目录结构中，在声明一个依赖时，依赖的属性（group、name、version）来确认它在仓库中的位置。</p><p><img src="/source/images/2020_01_14_02.png" alt></p><p>Maven 提供了两个方法用来配置 Maven 仓库：</p><ul><li>mavenCentral()</li></ul><p>将 Maven Central 引用添加到一系列的仓库中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mavenLocal()</li></ul><p>在文件系统中关联一个本地的 Maven 仓库，本地 Maven 仓库的默认目录为：<user_home>/.m2/repository。</user_home></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-Maven-仓库"><a href="#自定义-Maven-仓库" class="headerlink" title="自定义 Maven 仓库"></a>自定义 Maven 仓库</h3><p>很多情况下，我们需要配置企业级的仓库来完成相应的开发，仓库管理器提供类了一个以 Maven 结构来配置仓库的功能，Gradle API 提供了两个方式来配置自定义仓库：</p><ul><li>maven()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">    maven&#123;</span><br><span class="line">        name &apos;custom maven repository&apos;</span><br><span class="line">        url &apos;http://xxx/xxx/release/&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mavenRepo()</li></ul><h3 id="Ivy-仓库"><a href="#Ivy-仓库" class="headerlink" title="Ivy 仓库"></a>Ivy 仓库</h3><p>Maven 仓库中的文件必须以一个固定的布局存储，任何文件结构的偏差都有可能导致依赖关系发生变化，而 Ivy 仓库则可以完全自定义默认布局。</p><p>在 Ivy 里，仓库依赖被存储在 ivy.xml 文件中，Gradle 提供了各种方法来配置 Ivy 仓库及特定的文件布局。</p><p>声明 ivy 仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">repositories&#123;</span><br><span class="line">    ivy&#123;</span><br><span class="line">        // Ivy 仓库的基础 URL</span><br><span class="line">        url &apos;http://xxx/xxx/release/&apos;</span><br><span class="line">        layout &apos;pattern&apos;,&#123;</span><br><span class="line">            // 工件模式</span><br><span class="line">            artifact &apos;[xx]/[xxx]/[version].[ext]&apos;</span><br><span class="line">            // 元数据模式</span><br><span class="line">            ivy &apos;[xx]/[xxx]/[version]/ivy-[revision].xml&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扁平的目录仓库"><a href="#扁平的目录仓库" class="headerlink" title="扁平的目录仓库"></a>扁平的目录仓库</h3><p>flat 目录仓库是最简单和最基本的仓库形式，<strong>在文件系统中它是一个单独的目录</strong>，只包含了 jar 文件，没有元数据。<strong>当声明此种仓库依赖时，只能使用 name 和 version 属性，不能使用 group 属性，因为它会产生不明确的依赖关系</strong>。</p><p>以下通过 map 和 快捷方式来声明从 flat 目录仓库中获取 Cargo 依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 声明扁平的目录仓库</span><br><span class="line">repositories&#123;</span><br><span class="line">    flatDir (dir:&quot;$&#123;System.properties[&apos;user.home&apos;]&#125;/libs/cargo&quot;,name :&apos;Local lins directory&apos;)</span><br><span class="line">&#125;</span><br><span class="line">dependencies&#123;</span><br><span class="line">    // 以 map 的形式声明依赖</span><br><span class="line">    cargo name:&apos;activation&apos;,version:&apos;1.1.0&apos;</span><br><span class="line">    // 以快捷方式获取依赖</span><br><span class="line">    cargo &apos;:jaxb-api:2.1.1&apos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要手动的声明传递性依赖</strong>，需单独的声明每个依赖，这种方式耗时耗力。</p><h2 id="理解本地依赖缓存"><a href="#理解本地依赖缓存" class="headerlink" title="理解本地依赖缓存"></a>理解本地依赖缓存</h2><p>以上阐述了如何声明各种类型的仓库，在执行的 Task 会自动确定所需要的依赖，<strong>在执行时从仓库中下载工件</strong>，<strong>并将它们存储在本地缓存中</strong>在之后的任何构建都会重用这些工件。</p><p>此节将深入分析缓存结构，确定缓存在底层是如何工作的，以及如何调整其行为。</p><h3 id="分析缓存结构"><a href="#分析缓存结构" class="headerlink" title="分析缓存结构"></a>分析缓存结构</h3><p>执行 Task ，Gradle 下载的 jar 文件被存放在何处？</p><p>通过以下操作，打印出完整的、指派个 cargo 配置的所有依赖的连接路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task printDependencies&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        configurations.getByName(&apos;cargo&apos;).each &#123;depency -&gt;</span><br><span class="line">            println depency</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行该 Task 会发现所有的 jar 文件都存储在 <code>.gradle/caches/artifacts-15/filestore</code> 目录中，而 artifacts-15 为一个标识符，用来指定Gradle 版本，同时需要注意的是这个文件目录结构在不同的Gradle 中可能不同。</p><p>缓存其实包含两部分：</p><ul><li>filestore 中的文件</li></ul><p>该目录中包含了从仓库下载的原始二进制文件,比如 Jar 文件。</p><ul><li>其他二进制文件</li></ul><p>这些文件中存储了已下载工件的 <strong>元数据</strong>。</p><p>具体可参见：<a href="https://docs.gradle.org/current/userguide/directory_layout.html#dir:gradle_user_home" target="_blank" rel="noopener">The Directories and Files Gradle Uses</a></p><p>以下为 .gradle 目录下的 cache 各个文件的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── caches // (1) 全局缓存目录</span><br><span class="line">│   ├── 4.8 // 特定版本的缓存，支持增量更新</span><br><span class="line">│   ├── 4.9 // (2)</span><br><span class="line">│   ├── ⋮</span><br><span class="line">│   ├── jars-3 // 共享缓存，例如对于依赖项的工件</span><br><span class="line">│   └── modules-2 // (3)</span><br><span class="line">├── daemon // (4)Gradle 守护进程的注册表和日志</span><br><span class="line">│   ├── ⋮</span><br><span class="line">│   ├── 4.8</span><br><span class="line">│   └── 4.9</span><br><span class="line">├── init.d // 全局初始化脚本</span><br><span class="line">│   └── my-setup.gradle</span><br><span class="line">├── wrapper</span><br><span class="line">│   └── dists // 由Gradle包装器下载的发行版</span><br><span class="line">│       ├── ⋮</span><br><span class="line">│       ├── gradle-4.8-bin</span><br><span class="line">│       ├── gradle-4.9-all</span><br><span class="line">│       └── gradle-4.9-bin</span><br><span class="line">└── gradle.properties // 全局层次配置属性</span><br></pre></td></tr></table></figure><h3 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a>缓存过期</h3><p>缓存下来文件并不会永久存在，会在一定时期内有效，如果在规定期限内某版本库不再被使用，那么相应版本库就会被清除，具体可参见<a href="https://docs.gradle.org/current/userguide/directory_layout.html#dir:gradle_user_home" target="_blank" rel="noopener">The Directories and Files Gradle Uses</a></p><p>支持在规定时间删除缓存和版本。</p><p>同样见上面链接。</p><h2 id="解决依赖问题"><a href="#解决依赖问题" class="headerlink" title="解决依赖问题"></a>解决依赖问题</h2><p>如果选择自动解决传递性依赖，那么版本冲突是不可避免的，Gradle 解决版本冲突的默认策略是选择最新的依赖版本。<strong>依赖报告</strong> 是十分有用的工具，它可以帮助我们选择需要的依赖版本。</p><h3 id="修改默认的策略"><a href="#修改默认的策略" class="headerlink" title="修改默认的策略"></a>修改默认的策略</h3><p>做如下修改，当遇到版本冲突时，会让构建失败,此时在打印台上你可以很清楚的指导那些传递依赖库发生了版本冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configurations.all&#123;</span><br><span class="line">  resolutionStrategy&#123;</span><br><span class="line">      // 修改gradle不处理版本冲突</span><br><span class="line">      failOnVersionConflict()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处为所有的配置重新配置策略，也可以 <strong>为指定的配置重新配置冲突解决策略</strong> ，比如上文一直使用的 cargo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations.cargo.resolutionStrategy&#123;</span><br><span class="line">    failOnVersionConflict()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制指定一个版本"><a href="#强制指定一个版本" class="headerlink" title="强制指定一个版本"></a>强制指定一个版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configuration.all&#123;</span><br><span class="line">  resolutionStrategy&#123;</span><br><span class="line">      failOnVersionConflict()</span><br><span class="line">      force &apos;org.slf4j:slf4j-api:1.7.24&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处为所有的配置重新配置策略，也可以为指定的配置重新配置冲突解决策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configuration.cargo.resolutionStrategy&#123;</span><br><span class="line">    force &apos;org.slf4j:slf4j-api:1.7.24&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖观察报告"><a href="#依赖观察报告" class="headerlink" title="依赖观察报告"></a>依赖观察报告</h3><p>依赖观察报告，解释了依赖图中的依赖是如何选择的以及为什么。</p><p>为了运行这个报告需要指定两个参数：配置名称（默认是 compile）和依赖本身。</p><blockquote><p>gradle -q dependencyInsight –configuration cargo –dependency xml-apis:xml-apis</p></blockquote><p>dependencyInsight:显示原因</p><p>使用 <code>gradle dependencies</code> 生成的依赖报告，是从顶层依赖开始的，而此处的依赖观察报告则与之相反，是从低层到顶层的。</p><p><a href="https://docs.gradle.org/current/userguide/command_line_interface.html#common_tasks" target="_blank" rel="noopener">Gradle 命令行选项含义</a></p><h3 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h3><p>针对依赖的 SNAPSHOT 版本和使用动态版本的模式声明依赖，Gradle 一旦获取了依赖，它们会缓存 24 小时，在缓存时间到后，会再次检查仓库，如果依赖库发生版本变化，Gradle 会下载最新的依赖库。</p><p>可以使用命令行选项 –refresh-dependencies 手动刷新缓存中的依赖，这个标志会强制检查配置仓库中所依赖的库版本是否发生了版本变化，如果变化则再次下载，取代缓存中的副本。</p><p>同时 Gradle 也支持配置缓存的默认行为，</p><ul><li>设置缓存动态依赖版本 0 秒超时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configuration.cargo.resolutionStrategy&#123;</span><br><span class="line">    cacheDynamicVersionsFor 0,&apos;second&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不缓存 SNAPSHOT 版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configuration.cargo.resolutionStrategy&#123;</span><br><span class="line">    cacheChangingMoudlesFor 0,&apos;second&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在为项目配置依赖时通过 &lt;code&gt;dependencies&lt;/code&gt; 和 &lt;code&gt;repositories&lt;/code&gt; 两个 DSL &lt;strong&gt;配置块&lt;/strong&gt;进行配置的，配置块的名称直接映射到 Project 接口的方法。依赖管理器通过运行以上两个配置，从中央仓库下载所需要的库，将它们存储在本地缓存中。&lt;/p&gt;
&lt;p&gt;配置块中包含配置：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gradle 基本原理" scheme="/tags/Gradle-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
      <category term="Gradle in action" scheme="/tags/Gradle-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Gadle实战(三)：自定义 Task 类</title>
    <link href="/2020/01/16/Gradle%E5%AE%9E%E6%88%98-%E4%B8%89/"/>
    <id>/2020/01/16/Gradle实战-三/</id>
    <published>2020-01-16T11:02:23.000Z</published>
    <updated>2020-02-28T03:35:09.550Z</updated>
    
    <content type="html"><![CDATA[<p>在构建脚本中编写 Task 的动作，从而操作相关逻辑的方式是十分简单的，但是当项目增长需要添加更多的逻辑时，维护起来就十分的麻烦。在这是就有了对类和方法中代码的结构化需求，按照日常开发的思维编写代码，而 Gradle 提供了这种支持，开发者可以使用任意 JVM 语言，比如 Java、Groovy、Kotlin，在构建脚本中进行编码。</p><h2 id="1-自定义-Task"><a href="#1-自定义-Task" class="headerlink" title="1. 自定义 Task"></a>1. 自定义 Task</h2><p>自定义 Task 包含两个组件：</p><a id="more"></a><ol><li>任务类型</li></ol><p>自定义的 Task 类，封装了逻辑行为，被称为 任务类型。</p><ol start="2"><li>真实的 Task </li></ol><p>提供用于配置行为的 Task 类所暴露的属性值。</p><p>Gradle 把这些 Task 称为 <strong>增强的 Task</strong>，具体的自定义 Task 可以参见官方文档：<a href="https://docs.gradle.org/current/userguide/custom_tasks.html#header" target="_blank" rel="noopener">Developing Custom Gradle Task Types</a>。</p><h2 id="2-编写自定义的-Task-类"><a href="#2-编写自定义的-Task-类" class="headerlink" title="2. 编写自定义的 Task 类"></a>2. 编写自定义的 Task 类</h2><ul><li>继承 DefaultTask 的类。</li><li>通过注解声明 Task 类的输入和输出：@Input、@OutputFile</li></ul><p>一个简单的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ReleaseVersionTask extends DefaultTask&#123;</span><br><span class="line">    // 通过注解声明 task 的输入和输出</span><br><span class="line">    @Input Boolean release</span><br><span class="line">    @OutputFile File destFile</span><br><span class="line">    // 在构造器中设置 task 的 group 和 description 属性</span><br><span class="line">    ReleaseVersionTask()&#123;</span><br><span class="line">        group = &apos;versioning&apos;</span><br><span class="line">        description = &apos;Make project a release version.&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过注解声明被执行的方法，动作方法</span><br><span class="line">    @TaskAction</span><br><span class="line">    void start()&#123;</span><br><span class="line">        project.version.release = true</span><br><span class="line">        ant.propertyfile(file: destFile) &#123;</span><br><span class="line">            entry(key: &apos;release&apos;, type: &apos;string&apos;, operation: &apos;=&apos;, value: &apos;true&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用自定义-Task-类"><a href="#3-使用自定义-Task-类" class="headerlink" title="3. 使用自定义 Task 类"></a>3. 使用自定义 Task 类</h2><p>定义一个增强的 ReleaseVersionTask 类型的 Task，通过 type 声明该 Task 派生于 ReleaseVersionTask。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task makeReleaseVerson(type:ReleaseVersionTask)&#123;</span><br><span class="line">    release = &apos;true&apos;</span><br><span class="line">    destFile = file(&apos;version.properties&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例可以认为在创建一个特定类（ReleaseVersionTask）的新实例，并在构造器中为它的属性值设置值。</p><h2 id="4-Gradle-的内置-Task"><a href="#4-Gradle-的内置-Task" class="headerlink" title="4. Gradle 的内置 Task"></a>4. Gradle 的内置 Task</h2><p>Gradle 中提供了大量的内置 Task， 它们均派生与 DefaultTask，所以可以在脚本中的增强 Task 使用。</p><p>Copy 为 Gradle 内置 Task，以下展示将 createDistribution 的输出文件复制到指定目录中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task copyFile(type:Copy)&#123;</span><br><span class="line">    from createDistribution.outputs.files</span><br><span class="line">    into &quot;$buildDir/backup&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Task-规则"><a href="#5-Task-规则" class="headerlink" title="5. Task 规则"></a>5. Task 规则</h2><p>Gradle 引入了 Task 规则的概念，可以根据 Task 名称模式执行相应的逻辑，该模式是有两部分组成：Task 名称的静态部分和一个占位符，它们联合组成动态的 Task 名称。</p><p>根据 Task名称模式执行相关逻辑，并不意味着你可以不做任何工作只通过 Task 名称来执行相关的逻辑，你需要自定义 Tast 规则，至于如何定义 Task 规则，参见 《Gradle in action》一书中第 98 页。 </p><h2 id="6-在-buildSrc-目录下构建代码"><a href="#6-在-buildSrc-目录下构建代码" class="headerlink" title="6. 在 buildSrc 目录下构建代码"></a>6. 在 buildSrc 目录下构建代码</h2><p>在构建脚本中编写的 Groovy 类最适合的位置为项目的 buildSrc 目录下。将 Java 代码放在 src/main/java 目录下，将 Groovy 代码放在 src/main/groovy 目录下，<strong>位于这些目录下的代码会被自动编译，并且会被加入到 Gradle 构建脚本的 classpath 中</strong>，所以说 buildSrc 目录是组织代码的最佳方式。</p><h2 id="7-挂接到构建生命周期过程中"><a href="#7-挂接到构建生命周期过程中" class="headerlink" title="7. 挂接到构建生命周期过程中"></a>7. 挂接到构建生命周期过程中</h2><p>在构建阶段执行的 Task 配置逻辑或者在执行阶段执行的 Task 动作，在很多时候是存在局限的，很多时候需要在特定的生命周期事件发生时执行指定的代码，比如在某个构建之间、期间或者之后。对于这种要求 Gradle 提供了两种方式可以编写回调生命周期的事件：在闭包中的或者通过 Gradle API 提供的监听器接口实现。</p><p>许多生命周期的回调方法被定义在 Project 和 Gradle 的接口中。</p><p>Task 执行图是一个有向无环图(DAG)，一个执行过的 Task 永远不会再次执行,以下展示了 Task 执行图的相关接口和方法：</p><p><img src="/source/images/2020_01_17_02.png" alt="Task 接口"></p><h3 id="7-1-在闭包中调用生命周期钩子"><a href="#7-1-在闭包中调用生命周期钩子" class="headerlink" title="7.1 在闭包中调用生命周期钩子"></a>7.1 在闭包中调用生命周期钩子</h3><p>以 whenReady 为例，whenReady 方法会在 task 图生成完成后，该函数会立即被执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 注册的生命周期钩子函数在 Task 图生成后被调用</span><br><span class="line">gradle.taskGraph.whenReady&#123; TaskExecutionGraph taskGraph -&gt;</span><br><span class="line">    // 查看Task 执行图中是否含有 release Task</span><br><span class="line">    if(taskGraph.hasTask(release))&#123;</span><br><span class="line">            // 执行相关的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-实现-Task-执行图监听器"><a href="#7-2-实现-Task-执行图监听器" class="headerlink" title="7.2 实现 Task 执行图监听器"></a>7.2 实现 Task 执行图监听器</h3><p>通过监听器挂接到构建生命周期只需要两个步骤：</p><ol><li>在构建脚本中编写一个类来实现特定的监听器接口</li></ol><p>用于监听 Task 执行图的事件的接口是 TaskExectionGraphListener 接口提供：</p><ol start="2"><li>注册监听器的实现</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 实现相应的接口</span><br><span class="line">class ReleaseVersionListener implements TaskExecutionGraphListener &#123;</span><br><span class="line"></span><br><span class="line">    final static String releaseTaskGraph = &apos;:release&apos;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void graphPopulated(TaskExecutionGraph graph) &#123;</span><br><span class="line">        // release task 在执行图中</span><br><span class="line">        if (graph.hasTask(releaseTaskGraph)) &#123;</span><br><span class="line">            List&lt;Task&gt; allTasks = graph.allTasks</span><br><span class="line">            // 从一系列的执行图中找到 release Task</span><br><span class="line">            Task releaseTask = allTasks.find&#123;it.path == releaseTaskGraph&#125;</span><br><span class="line">            // 每个 Task 都知道自己所云的 project</span><br><span class="line">            Project project = releaseTask.project</span><br><span class="line">            if (!project.version.release) &#123;</span><br><span class="line">                println &quot;i am in listener&quot;</span><br><span class="line">                // 显式的调用getProject</span><br><span class="line">                project.version.release = true</span><br><span class="line">                project.ant.propertyfile(file: versionFile) &#123;</span><br><span class="line">                    entry(key: &apos;release&apos;, type: &apos;string&apos;, operation: &apos;=&apos;, value: true)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注册接口的实现</span><br><span class="line">def releaseVersionListener = new ReleaseVersionListener()</span><br><span class="line">gradle.taskGraph.addTaskExecutionGraphListener(releaseVersionListener)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在构建脚本中编写 Task 的动作，从而操作相关逻辑的方式是十分简单的，但是当项目增长需要添加更多的逻辑时，维护起来就十分的麻烦。在这是就有了对类和方法中代码的结构化需求，按照日常开发的思维编写代码，而 Gradle 提供了这种支持，开发者可以使用任意 JVM 语言，比如 Java、Groovy、Kotlin，在构建脚本中进行编码。&lt;/p&gt;
&lt;h2 id=&quot;1-自定义-Task&quot;&gt;&lt;a href=&quot;#1-自定义-Task&quot; class=&quot;headerlink&quot; title=&quot;1. 自定义 Task&quot;&gt;&lt;/a&gt;1. 自定义 Task&lt;/h2&gt;&lt;p&gt;自定义 Task 包含两个组件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gradle 基本原理" scheme="/tags/Gradle-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
      <category term="Gradle in action" scheme="/tags/Gradle-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Gadle实战(二)：声明 Task</title>
    <link href="/2020/01/16/Gradle%E5%AE%9E%E6%88%98-%E4%BA%8C/"/>
    <id>/2020/01/16/Gradle实战-二/</id>
    <published>2020-01-16T11:02:23.000Z</published>
    <updated>2020-01-17T10:44:50.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Gradle-API-中的-Task"><a href="#1-Gradle-API-中的-Task" class="headerlink" title="1. Gradle API 中的 Task"></a>1. Gradle API 中的 Task</h2><p>在默认情况下，每个创建的 Task 为 <code>org.gradle.api.DefaultTask</code> 类型的，为 <code>org.gradle.api.Task</code> 的实现类。</p><h2 id="2-声明-Task-的动作"><a href="#2-声明-Task-的动作" class="headerlink" title="2. 声明 Task 的动作"></a>2. 声明 Task 的动作</h2><p>动作（action）就是 <strong>在 task 中合适的地方放置构建逻辑</strong>，Task 提供了两个相关的方法来声明动作：<code>doFirst</code>、<code>doLast</code>，当 Task 被执行<br>时，动作逻辑被定义为的闭包参数被依次执行。</p><a id="more"></a><p>以下展示如何声明 Task 动作。</p><h3 id="2-1-声明-task-动作"><a href="#2-1-声明-task-动作" class="headerlink" title="2.1 声明 task 动作"></a>2.1 声明 task 动作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task helle&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println &apos;last&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    doFirst&#123;</span><br><span class="line">        println &apos;First&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-为已有的-task-添加动作"><a href="#2-2-为已有的-task-添加动作" class="headerlink" title="2.2 为已有的 task 添加动作"></a>2.2 为已有的 task 添加动作</h3><p>为已有的 task 添加动作，可以实现对不是自己编写的 Task 填加自定义的逻辑，这在项目开发中是十分重要的。</p><p>为 Java 插件的 compileJava 添加一个 doFirst 动作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileJava.doFirst&#123;</span><br><span class="line">    println &quot;add action&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-访问-DefaultTask-属性"><a href="#3-访问-DefaultTask-属性" class="headerlink" title="3. 访问 DefaultTask 属性"></a>3. 访问 DefaultTask 属性</h2><p>Task 有两个属性：group(定义 Task 的逻辑分组) 和 description（描述Task 的作用)，在定义 Task 时可以指定这两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printVersion(group:&apos;version&apos;,description:&apos;print project version&apos;)&#123;</span><br><span class="line">    // 两者等效，因为可以对 project 对象进行隐式调用</span><br><span class="line">    logger.quiet &quot;Verison is $version&quot;</span><br><span class="line">    logger.quiet &quot;Verison is $&#123;project.version&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过 setter 方式对两者设置值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task printVersion)&#123;</span><br><span class="line"></span><br><span class="line">    group = &apos;version&apos;</span><br><span class="line">    description = &apos;print project version&apos;</span><br><span class="line">    // 两者等效，因为可以对 project 对象进行隐式调用</span><br><span class="line">    logger.quiet &quot;Verison is $version&quot;</span><br><span class="line">    logger.quiet &quot;Verison is $&#123;project.version&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 gradle tasks 时，可以看到该 task 的分组和描述。</p><h2 id="4-Task-依赖关系的建立"><a href="#4-Task-依赖关系的建立" class="headerlink" title="4. Task 依赖关系的建立"></a>4. Task 依赖关系的建立</h2><p>Task 的依赖关系通过两者方式建立：</p><ol><li>通过 dependensOn 方法,声明依赖一个或多个 task</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">task one &lt;&lt; &#123;</span><br><span class="line">    println &quot;one&quot;</span><br><span class="line">&#125;</span><br><span class="line">task two &lt;&lt; &#123;</span><br><span class="line">    println &quot;two&quot;</span><br><span class="line">&#125;</span><br><span class="line">task three(dependsOn:[two,one]) &#123;</span><br><span class="line">    println &quot;three&quot;</span><br><span class="line">&#125;</span><br><span class="line">task four &#123;</span><br><span class="line">    println &quot;three&quot;</span><br><span class="line">&#125;</span><br><span class="line">four.dependsOn(&apos;three&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Task 调用其他 Task 相关内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">    dest = one.output.file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task 依赖的执行顺序：<strong>被依赖项先于依赖项先执行</strong>。</p><h2 id="5-Task-终结器"><a href="#5-Task-终结器" class="headerlink" title="5. Task 终结器"></a>5. Task 终结器</h2><p>有时候需要在 Task或者依赖的 Task 执行完毕后，需要清理资源，Gradle 提供了 终结器 Task。</p><p>Task 终结器即使在</p><h2 id="6-在-Gradle-构建脚本中添加-Groovy-代码"><a href="#6-在-Gradle-构建脚本中添加-Groovy-代码" class="headerlink" title="6. 在 Gradle 构建脚本中添加 Groovy 代码"></a>6. 在 Gradle 构建脚本中添加 Groovy 代码</h2><h2 id="7-Task-配置块"><a href="#7-Task-配置块" class="headerlink" title="7. Task 配置块"></a>7. Task 配置块</h2><p>当定义的 Task 不存在动作（action）时，则称为 Task 配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">    println &apos;test&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意的一点是：<strong>Task 配置永远在 Task 动作执行之前执行</strong>。</p><h2 id="8-Gradle-构建生命周期阶段"><a href="#8-Gradle-构建生命周期阶段" class="headerlink" title="8. Gradle 构建生命周期阶段"></a>8. Gradle 构建生命周期阶段</h2><p>无论何时执行 Gradle 构建，都会运作三个不同的生命周期阶段：初始化、配置、执行，其其执行顺序如下：</p><p><img src="/source/images/2020_01_17_01.png" alt></p><ul><li>初始化阶段</li></ul><p>Gradle 为 <em>每一个项目创建了一个 Project 实例</em>，此时分为单模块项目和多模块项目。这个阶段，<strong>所有的构建脚本都不会执行</strong>。</p><ul><li>配置阶段</li></ul><p>Gradle 构造一个模型来表示任务，并且参加到构建中。采用了增量式构建特性，决定了模型中的 Task 是否会被执行。</p><ul><li>执行阶段</li></ul><p>执行 Gradle 命令执行，这一阶段 Task 会按照声明的顺序执行。</p><h2 id="9-通过声明-Task-的-inputs-和-outputs-属性的方式，引入增量式构建特性"><a href="#9-通过声明-Task-的-inputs-和-outputs-属性的方式，引入增量式构建特性" class="headerlink" title="9. 通过声明 Task 的 inputs 和 outputs 属性的方式，引入增量式构建特性"></a>9. 通过声明 Task 的 inputs 和 outputs 属性的方式，引入增量式构建特性</h2><p>Gradle 通过比较两个构建的 Task 的 inputs 和 outputs 是否变化，来判断这个 Task 是否是最新的。如果自最后一个 Task 执行以来，如果 inputs 和 outputs 没有发生变化，那么认为该 Task 为最新的，则不会执行；反之则该 Task 会执行。</p><p>inputs 可以为一个目录、一个或者多个文件、一个或者多个属性，一个 Task 的输出可以是一个目录或者任意个文件，对应于 Gradle API，inputs 和 outputs 被定义 DefaultTask 的属性，其对应类分别为 TaskInputs、TaskOutputs。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task printVersion&#123;</span><br><span class="line">    inputs.property(&apos;release&apos;,version.release)</span><br><span class="line">    outputs.file versionFile</span><br><span class="line"></span><br><span class="line">    doLast&#123;</span><br><span class="line">        version.release = true</span><br><span class="line">        // 通过 ant 修改文件属性值</span><br><span class="line">        ant.propertyfile(file:versionFile)&#123;</span><br><span class="line">            entry(key:&apos;release&apos;,type:&apos;string&apos;,operation:&apos;=&apos;,value:&apos;true&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一系列 Task 执行过程中，如果 printVersion 任务的 inputs、outputs 对应的属性没有发生变化，那么在任意 Task 执行链中就不会执行该 Task，不被执行的 Task 会在输出日志中被标记 <code>UP-TO-DATE</code> 的标记。</p><p>Task 的 inputs 和 outputs 是在配置阶段执行的，用来连接 Task 依赖的，所以需要在 Task 配置块中定义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Gradle-API-中的-Task&quot;&gt;&lt;a href=&quot;#1-Gradle-API-中的-Task&quot; class=&quot;headerlink&quot; title=&quot;1. Gradle API 中的 Task&quot;&gt;&lt;/a&gt;1. Gradle API 中的 Task&lt;/h2&gt;&lt;p&gt;在默认情况下，每个创建的 Task 为 &lt;code&gt;org.gradle.api.DefaultTask&lt;/code&gt; 类型的，为 &lt;code&gt;org.gradle.api.Task&lt;/code&gt; 的实现类。&lt;/p&gt;
&lt;h2 id=&quot;2-声明-Task-的动作&quot;&gt;&lt;a href=&quot;#2-声明-Task-的动作&quot; class=&quot;headerlink&quot; title=&quot;2. 声明 Task 的动作&quot;&gt;&lt;/a&gt;2. 声明 Task 的动作&lt;/h2&gt;&lt;p&gt;动作（action）就是 &lt;strong&gt;在 task 中合适的地方放置构建逻辑&lt;/strong&gt;，Task 提供了两个相关的方法来声明动作：&lt;code&gt;doFirst&lt;/code&gt;、&lt;code&gt;doLast&lt;/code&gt;，当 Task 被执行&lt;br&gt;时，动作逻辑被定义为的闭包参数被依次执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gradle 基本原理" scheme="/tags/Gradle-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
      <category term="Gradle in action" scheme="/tags/Gradle-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Gadle实战(一)：Project、Task、Property 的基本了解</title>
    <link href="/2020/01/16/Gradle%E5%AE%9E%E6%88%98-%E4%B8%80/"/>
    <id>/2020/01/16/Gradle实战-一/</id>
    <published>2020-01-16T10:44:39.000Z</published>
    <updated>2020-01-17T10:44:50.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最基础的Gradle构建块-project和task，以及它们是如何映射到 Gradle 的 API 上面的。</p><ol><li>声明简单的 task</li><li>编写自定义的 task 类</li><li>如何获取 task 属性</li><li>定义显示和隐式的 task 依赖</li><li>添加增量式构建支持</li><li>使用 Gradle 的内置 task 类型</li><li>Gradle 的构建生命周期</li><li>编写使用闭包和监听器 实现的生命周期钩子</li></ol></blockquote><h2 id="1-构建块"><a href="#1-构建块" class="headerlink" title="1. 构建块"></a>1. 构建块</h2><p>Gradle 构建包括三个基本的构建: <code>project</code>、<code>task</code>、<code>property</code>。每个构建中至少包含一个 project，进而又包含一个或者多个task。project 和 task 暴露的属性可以控制构建。</p><a id="more"></a><p>Gradle 使用领域驱动设计（DDD）的原理为自己的领域构建软件模型，因此 Gradle API 中有相应的类来表示 project和task。</p><h3 id="1-1-project"><a href="#1-1-project" class="headerlink" title="1.1 project"></a>1.1 project</h3><p>在 Gradle 中，<strong>一个 project 代表一个正在构建的组件，或者一个想要完成的目标</strong>,比如需要部署的应用程序。</p><p>每个 Gradle 构建脚本至少定义 Project。</p><p>当构建进程启动后，Gradle 基于 <code>build.gradle</code> 中的配置,实例化 <code>org.gradle.api.Project</code> 类，并且能够通过 <code>project</code> 变量使其隐式使用，可以通过查看 Project 类查看其中可用的方法.</p><p><img src="/source/images/2020_01_16_07.png" alt></p><h3 id="1-2-Task"><a href="#1-2-Task" class="headerlink" title="1.2 Task"></a>1.2 Task</h3><p>任务的一些重要功能：<strong>任务动作</strong> 和 <strong>任务依赖</strong>，任务动作定义了一个任务执行时 <strong>最小的工作单位</strong>。</p><p>task 对应的 Gradle API：org.gradle.api.Task 接口：<br><img src="/source/images/2020_01_16_08.png" alt></p><h3 id="1-3-属性"><a href="#1-3-属性" class="headerlink" title="1.3 属性"></a><strong>1.3 属性</strong></h3><p>每个 Project 和 Task 实例都提供了很多可以通过 setter 和 getter 方法访问的属性，一个属性可能是一个任务的描述或者是项目的版本。</p><p>在项目开发中，可以自定义属性，进行读写操作。自定义属性的操作，可以通过 <strong>扩展属性</strong> 和 <strong>在gradle.properties 中定义</strong>的方式实现。</p><ol><li>扩展属性</li></ol><p>使用命名空间 ext 自定义属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义只读属性</span><br><span class="line">project.ext.name = &apos;name&apos;</span><br><span class="line">// 定义可读写属性</span><br><span class="line">ext&#123;</span><br><span class="line">    age = 1</span><br><span class="line">&#125;</span><br><span class="line">ext.one = 2</span><br></pre></td></tr></table></figure><ol start="2"><li>在 gradle.properties 中定义</li></ol><p>可以在 <code>gradle.properties</code> 文件中可以添加 Gradle 属性。</p><ul><li>在 <code>&lt;USER_HOME&gt;/.gradle</code> 文件下的 <code>gradle.properties</code> 中添加的 Gradle 属性，所有的项目都可以使用。</li><li>在项目下的 <code>gradle.properties</code> 中添加的 Gradle 属性，可以在项目中所以的模块中使用。</li></ul><p>在 gradle.properties 中声明属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;tom&apos;</span><br><span class="line">age = 1</span><br></pre></td></tr></table></figure><p>在 build.gradle 中的访问方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task test&#123;</span><br><span class="line">    println project.name</span><br><span class="line">    println age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>声明属性的其他方式</p><ol><li><p>在命令行模式下通过 —P 命令选项提供项目属性</p><pre><code>gradle -Pname = &apos;tom&apos;</code></pre></li><li><p>在命令行模式下通过 -D 命令选项提供系统属性</p><pre><code>gradle -Pname = &apos;tom&apos;</code></pre></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最基础的Gradle构建块-project和task，以及它们是如何映射到 Gradle 的 API 上面的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明简单的 task&lt;/li&gt;
&lt;li&gt;编写自定义的 task 类&lt;/li&gt;
&lt;li&gt;如何获取 task 属性&lt;/li&gt;
&lt;li&gt;定义显示和隐式的 task 依赖&lt;/li&gt;
&lt;li&gt;添加增量式构建支持&lt;/li&gt;
&lt;li&gt;使用 Gradle 的内置 task 类型&lt;/li&gt;
&lt;li&gt;Gradle 的构建生命周期&lt;/li&gt;
&lt;li&gt;编写使用闭包和监听器 实现的生命周期钩子&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-构建块&quot;&gt;&lt;a href=&quot;#1-构建块&quot; class=&quot;headerlink&quot; title=&quot;1. 构建块&quot;&gt;&lt;/a&gt;1. 构建块&lt;/h2&gt;&lt;p&gt;Gradle 构建包括三个基本的构建: &lt;code&gt;project&lt;/code&gt;、&lt;code&gt;task&lt;/code&gt;、&lt;code&gt;property&lt;/code&gt;。每个构建中至少包含一个 project，进而又包含一个或者多个task。project 和 task 暴露的属性可以控制构建。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gradle 基本原理" scheme="/tags/Gradle-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
      <category term="Gradle in action" scheme="/tags/Gradle-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Gadle实战(零)：Gradle 的基本使用</title>
    <link href="/2020/01/16/Gradle%E5%AE%9E%E6%88%98-%E9%9B%B6/"/>
    <id>/2020/01/16/Gradle实战-零/</id>
    <published>2020-01-16T10:04:11.000Z</published>
    <updated>2020-01-17T10:44:50.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java-项目引入-Gradle-插件"><a href="#1-Java-项目引入-Gradle-插件" class="headerlink" title="1. Java 项目引入 Gradle 插件"></a>1. Java 项目引入 Gradle 插件</h2><p>当我们不通过 IDE 的方式构建 Java 项目，那么在编写完成后，运行项目就需要使用 javac 、jar 等这样的工具来帮我们运行项目，无疑在开发过程中这是十分痛苦的。</p><p>而 Gradle 插件具体自动化执行编译、运行等过程。</p><p>Gradle 通过引入特定领域的约定和 Task 来扩展项目。而 Java 插件是 Gradle 自身装载的一个插件，可以实现很多的功能，比如定义标准的项目布局、有顺序的执行任务。</p><a id="more"></a><p>如果想要使用 Java 插件，则在 build.gradle 中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin:&apos;java&apos;</span><br></pre></td></tr></table></figure><p>项目中配置类该插件，就可以构建编写的 Java 代码。Java 插件引入很多之一，其中之一是项目的源代码位置，默认情况下 Java 插件回到 src/main/java 目录下查找 Java 类。</p><h2 id="2-构建-Java-项目"><a href="#2-构建-Java-项目" class="headerlink" title="2. 构建 Java 项目"></a>2. 构建 Java 项目</h2><p>在上文的基础上，构建创建的项目。Java 插件中的存在一个 build 的任务，以正确的顺序编译项目源代码，运行测试、组装 Jar 文件。</p><p>执行 <code>gradle build</code> 会得到相应的输出，每一行输出为 Java 插件提供的一个可执行任务，有些任务被标记了 UP-TO-DATE，这意味着这个任务被跳过了，因为  Gradle 支持增量式构建，不会运行不需要运行的任务。</p><h2 id="3-构建产生的文件"><a href="#3-构建产生的文件" class="headerlink" title="3. 构建产生的文件"></a>3. 构建产生的文件</h2><p>执行以上命令后，可以发现在根目录生成了一个 build 目录，该目录包含了构建运行时的所有输出，包括 jar 文件、测试报告和 class 文件，还有一些像清单一样对构建有用的临时文件。<br>构建输出的目录的名字是可以配置的，但是不建议自定义。</p><p>对 Java 项目完成构建后，可以运行该项目：</p><blockquote><p>java -cp build/classes.main com.xxx.xx.Main</p></blockquote><p>-cp:告诉 Java 运行时去哪里找到 class。</p><h2 id="4-解析依赖"><a href="#4-解析依赖" class="headerlink" title="4. 解析依赖"></a>4. 解析依赖</h2><p>在构建脚本中添加依赖，如果依赖库没有被解挂过（成功下载过），那么就会在使用时去下载它，以下图片展示了依赖继续传递性依赖的过程：</p><p><img src="/source/images/2020_01_16_05.png" alt></p><h2 id="5-Gradle-包装器"><a href="#5-Gradle-包装器" class="headerlink" title="5. Gradle  包装器"></a>5. Gradle  包装器</h2><p>Gradle 包装器是 Gradle 的核心特性，能够让机器在没有安装 Gradle 的情况下运行 Gradle 构建。在项目中配置包装器，需要两步操作：</p><ol><li>创建包装器任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(type:Wrapper)&#123;</span><br><span class="line">    // 指定下载的 Gradle 版本</span><br><span class="line">    gradleVersion = &apos;5.4.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>执行任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle wrapper</span><br></pre></td></tr></table></figure><p>下载的文件如下：</p><p><img src="/source/images/2020_01_16_06.png" alt></p><p>其中的 gradle-wrapper.properties 文件内容大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip</span><br></pre></td></tr></table></figure><p>此时，就可以使用包装器的脚本执行构建类。</p><h2 id="6-定制包装器"><a href="#6-定制包装器" class="headerlink" title="6. 定制包装器"></a>6. 定制包装器</h2><p>包装器是可以被重新配置的，指向运行有发布文件的企业内部服务器，同时还可以指定本地存储路径”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(type:Wrapper)&#123;</span><br><span class="line">    gradleVersion = &apos;5.4.1&apos;</span><br><span class="line">    distributionUrl = ’http://companycenter.com/gradle/dists‘</span><br><span class="line">    distributionPath = &apos;gradle-dists&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java-项目引入-Gradle-插件&quot;&gt;&lt;a href=&quot;#1-Java-项目引入-Gradle-插件&quot; class=&quot;headerlink&quot; title=&quot;1. Java 项目引入 Gradle 插件&quot;&gt;&lt;/a&gt;1. Java 项目引入 Gradle 插件&lt;/h2&gt;&lt;p&gt;当我们不通过 IDE 的方式构建 Java 项目，那么在编写完成后，运行项目就需要使用 javac 、jar 等这样的工具来帮我们运行项目，无疑在开发过程中这是十分痛苦的。&lt;/p&gt;
&lt;p&gt;而 Gradle 插件具体自动化执行编译、运行等过程。&lt;/p&gt;
&lt;p&gt;Gradle 通过引入特定领域的约定和 Task 来扩展项目。而 Java 插件是 Gradle 自身装载的一个插件，可以实现很多的功能，比如定义标准的项目布局、有顺序的执行任务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gradle 基本原理" scheme="/tags/Gradle-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
      <category term="Gradle in action" scheme="/tags/Gradle-in-action/"/>
    
  </entry>
  
  <entry>
    <title>Flutter核心技术与实战(二)：Widget 是什么？</title>
    <link href="/2020/01/06/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E4%BA%8C/"/>
    <id>/2020/01/06/Flutter核心技术与实战-二/</id>
    <published>2020-01-06T08:01:28.000Z</published>
    <updated>2020-01-07T02:52:55.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget-是什么？"><a href="#Widget-是什么？" class="headerlink" title="Widget 是什么？"></a>Widget 是什么？</h2><p> Flutter 的核心思想是：一切皆为 Widget，那么什么是 Widget 呢？</p><p> Widget 是 Flutter <strong>功能的抽象描述</strong>，是 <strong>视图的配置信息</strong>，是数据的映射。</p><h2 id="Widget-的渲染过程"><a href="#Widget-的渲染过程" class="headerlink" title="Widget 的渲染过程"></a>Widget 的渲染过程</h2><p> Flutter 如何结构化的组织数据，提供给渲染引擎，最终完成界面显示。</p><p> Flutter 将视图树的概念进行扩展，把视图数据的 <strong>组织</strong> 和 <strong>渲染</strong> 分为三部分，即 <code>Widget、Element、RenderObject。</code></p><p><img src="/source/images/2020_01_06_01.png" alt="Widget、Element、RenderObject 的关系"></p><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>Widget 是在 Flutter 世界里对视图的一种结构化的描述，可以类比 Android 中的控件的概念，Widget 里面存储的是有关视图渲染的配额制信息，包括布局、渲染属性、事件响应信息等。</p><p>Flutter 将 Widget 设计成不可变的，当视图渲染的配置信息发生改变时，Flutter 会选择重建 Widget 树的方式进行数据更新，以数据驱动 UI 的构建方式控制视图显示。 Flutter<br>这样的设计会存在大量的数据的销毁和重建，会对垃圾回收造成压力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Widget-是什么？&quot;&gt;&lt;a href=&quot;#Widget-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Widget 是什么？&quot;&gt;&lt;/a&gt;Widget 是什么？&lt;/h2&gt;&lt;p&gt; Flutter 的核心思想是：一切皆为 Widget，那么什么是 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter核心技术与实战(一)：Dart语言基础</title>
    <link href="/2020/01/06/Flutter%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98-%E4%B8%80/"/>
    <id>/2020/01/06/Flutter核心技术与实战-一/</id>
    <published>2020-01-06T07:45:58.000Z</published>
    <updated>2020-01-06T07:47:58.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Dart的变量与类型"><a href="#1-Dart的变量与类型" class="headerlink" title="1. Dart的变量与类型"></a>1. Dart的变量与类型</h2><p>在 Dart 中，可以使用 var 或者具体的类型来声明一个变量，当使用 var 定义变量时，表示类型交由编译器推断决定。Dart 是 <strong>类型安全</strong> 的语言，所以的类型均继承与 Object，因此所有的类型都是对象类型，默认情况下，<strong>未初始化的变量的值为 null</strong>。</p><h3 id="1-1-num、bool与-String"><a href="#1-1-num、bool与-String" class="headerlink" title="1.1 num、bool与 String"></a>1.1 num、bool与 String</h3><p>num 为 Dart 的数据类型，只有两种子类：int 和 double，使用 bool 表示布尔值，有 false 和 true 两种状态，它们均是编译时常量。在 Dart 中字符串可以通过单引号、双引号、嵌入表达式、多行字符串的形式表示。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">double y = 12.0;</span><br><span class="line">var isZero = false;</span><br><span class="line">var str = &apos;name&apos;;</span><br><span class="line">var stri = &quot;name&quot;;</span><br><span class="line">var length = &quot;length is &amp;&#123;str.lenght&#125;&quot;;</span><br><span class="line">var string = &quot;&quot;&quot; name is </span><br><span class="line">hahah&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><h3 id="1-2-Dart-中的集合类型"><a href="#1-2-Dart-中的集合类型" class="headerlink" title="1.2 Dart 中的集合类型"></a>1.2 Dart 中的集合类型</h3><p>在 Dart 中集合类型为 List 和 Map，对应其他编程语言中的数组和字典，具体使用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 以下变量的声明，没有对集合中的元素进行限制，那么集合中可以添加任何类型的值</span><br><span class="line">var array = [&quot;one&quot;,&quot;two&quot;];</span><br><span class="line">var array2 = List.of([1,2,3]);</span><br><span class="line">var array3 = [1,2,&quot;Name&quot;];// 集合中同时包含 int 和 String 类型的元素</span><br><span class="line">var map = &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:2&#125;; // Map 中同时存在 String：String、String：int 的键值对</span><br><span class="line">// 对集合元素进行限制，那么添加到集合中的元素必须为限制的类型</span><br><span class="line">var array4 = &lt;int&gt;[1,2,3];</span><br><span class="line">var array5 = &lt;int&gt;[1,2,&quot;name&quot;];// 错误示例，对 array5 添加元素限制</span><br><span class="line">var map2 = new Map&lt;String,String&gt;();// 对 Map 集合添加限制</span><br><span class="line">var map3 = &lt;String,String&gt;&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 1&#125;;// 错误示例，对 Map 元素添加限制，那么 第二个键值对不可以添加到 Map 中</span><br></pre></td></tr></table></figure><h3 id="1-3-常量定义"><a href="#1-3-常量定义" class="headerlink" title="1.3 常量定义"></a>1.3 常量定义</h3><p>Dart 中定义不可变的变量，可以在变量前添加 final 或者 const 关键字：</p><ul><li>final：在运行期确定值，定义运行时常量</li><li>const：在编译期确定值，定义编译器常量</li></ul><h2 id="2-Dart-中的函数、类和运算符"><a href="#2-Dart-中的函数、类和运算符" class="headerlink" title="2. Dart 中的函数、类和运算符"></a>2. Dart 中的函数、类和运算符</h2><h3 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h3><p>在 Dart 中一切类型都是对象类型，包括函数，它的类型为 Function，所以在 Dart 中函数也可以被定义为变量，也可以通过参数传递给另外一个函数。</p><p>test.dart</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool isMan(String sex) =&gt; sex == &quot;man&quot;;</span><br><span class="line">// 在文件中声明 Function 对象</span><br><span class="line">Function test = isMan;</span><br><span class="line">// 将 Function 作为参数传入函数</span><br><span class="line">void showSex(String sex,Function checker)&#123;</span><br><span class="line">  print(&apos;$sex isMan:$&#123;checker(sex)&#125;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">  showSex(&quot;man&quot;, test);</span><br><span class="line">  // 在函数中声明 Function 对象并完成调用</span><br><span class="line">  Function test2 = isMan;</span><br><span class="line">  showSex(&quot;man&quot;, test2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-函数重载"><a href="#2-2-函数重载" class="headerlink" title="2.2 函数重载"></a>2.2 函数重载</h3><p>在 Dart 中支持 Java 中提供同名函数不同参数列表形式的方法重载，而提供了 <strong>可选命名参数</strong> 和 <strong>可选参数</strong>。</p><p>在定义函数时：</p><ul><li>可选命名参数</li></ul><p>给参数增加 {},以 paramName：param 的形式指定参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//声明可选参数函数</span><br><span class="line">void enable1Flags(&#123;bool bold, bool hidden&#125;) =&gt; print(&quot;$bold , $hidden&quot;);</span><br><span class="line">//为可选命名参数时增加默认值 </span><br><span class="line">void enable2Flags(&#123;bool bold = true, bool hidden = false&#125;) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br></pre></td></tr></table></figure><ul><li>可选参数</li></ul><p>给参数增加 [],意味这些参数是可以忽略的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 声明可忽略的可选参数函数</span><br><span class="line">void enable3Flags(bool bold, [bool hidden]) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br><span class="line">//为可选参数增加默认值</span><br><span class="line">void enable4Flags(bool bold, [bool hidden = false]) =&gt; print(&quot;$bold ,$hidden&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-3-类的声明"><a href="#2-3-类的声明" class="headerlink" title="2.3 类的声明"></a>2.3 类的声明</h3><p>与 Java 的构造函数略有不同，Dart 中可以定义 <strong>命名构造函数</strong>，使类的实例化过程更加清晰，并且在构造函数真正执行前，还有机会给实例变量赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123; </span><br><span class="line">    num x, y, z;</span><br><span class="line">    Point(this.x, this.y) : z = 0; </span><br><span class="line">    // 初始化变量z </span><br><span class="line">    Point.bottom(num x) : this(x, 0); // 重定向构造函数 </span><br><span class="line">    void printInfo() =&gt; print(&apos;($x,$y,$z)&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Dart-中的复用"><a href="#2-4-Dart-中的复用" class="headerlink" title="2.4 Dart 中的复用"></a>2.4 Dart 中的复用</h3><p>与 Java 中不同，Dart 中不存在 interface 关键字，所以在 Dart 中可以对同一个父类进行继承（extend）和接口实现（implement），在 Dart 中继承与实现的不同：</p><ul><li>继承</li></ul><p>子类继承父类，子类可以获取父类的成员变量和方法，也可以覆写构造函数以及父类方法。</p><ul><li>实现</li></ul><p>在 Dart 中，接口的实现代表子类仅仅获得接口的成员变量符号和方法符号，需要重新实现成员变量、方法的声明以及初始化。</p><ul><li>混入（Mixin）</li></ul><p>在 Dart中还支持通过 <strong>混入（关键字：with）</strong> 来实现复用，混入可以被视为 <strong>具有方法实现的接口</strong>，<strong>Dart 语言不支持多继承</strong>，但是可以通过 混入 实现 Dart 的多继承。</p><p>具体编码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  num x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">  void printInfo() =&gt; print(&apos;x is $x,y is $y&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承</span><br><span class="line">class Vector extends Point &#123;</span><br><span class="line">  num z = 0;</span><br><span class="line"></span><br><span class="line">  // 覆写父类的方法</span><br><span class="line">  @override</span><br><span class="line">  void printInfo() =&gt; print(&apos;x is $x,y is$y,z is $z&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现，需要重新声明父类的成员变量以及方法</span><br><span class="line">class Coordinate implements Point &#123;</span><br><span class="line">  num x = 0, y = 0;</span><br><span class="line"></span><br><span class="line">  void printInfo() =&gt; print(&apos;x is $x,y is $y&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WithCoordinate with Point &#123;</span><br><span class="line">  @override</span><br><span class="line">  void printInfo() =&gt; print(&quot;with x is $x,y is $y&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  var vector = Vector();</span><br><span class="line">  vector</span><br><span class="line">    ..x = 0</span><br><span class="line">    ..y = 2</span><br><span class="line">    ..z = 3;//级联运算符，等同于vector.x=0; vector.y=2;vector.z=3;</span><br><span class="line">  vector.printInfo();</span><br><span class="line"></span><br><span class="line">  Coordinate coordinate = new Coordinate();</span><br><span class="line">  coordinate</span><br><span class="line">    ..x = 23</span><br><span class="line">    ..y = 90;</span><br><span class="line">  coordinate.printInfo();</span><br><span class="line"></span><br><span class="line">  var withCoordinate = WithCoordinate();</span><br><span class="line">  withCoordinate</span><br><span class="line">    ..x = 2</span><br><span class="line">    ..x = 98;</span><br><span class="line">  withCoordinate.printInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h3><p>Dart 中的运算符和其他语言中大致相同，但是提供了几个特殊的运算符，简化处理实例变量为 null 的情况：</p><ul><li>?. 运算符</li></ul><p><code>a?.length</code>: a 不为 null 时，调用 a.length,否则抛出异常。</p><ul><li>??= 运算符</li></ul><p><code>a??=value</code>: a 在为 null时，进行 a=value 的赋值。</p><ul><li>?? 运算符</li></ul><p><code>a??b</code>:a 不为 null 时返回 a 的值，否则返回 b 的值，类比 Java 中的三目运算符。</p><h3 id="2-6-覆写或者自定义运算符"><a href="#2-6-覆写或者自定义运算符" class="headerlink" title="2.6 覆写或者自定义运算符"></a>2.6 覆写或者自定义运算符</h3><p>在 Dart 中，一切均为对象，就连运算符也是对象成员函数的一部分。在 Dart 中可以通过 opeartor 进行自定义或者覆写运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Vector &#123;</span><br><span class="line">  num x, y;</span><br><span class="line">  Vector(this.x, this.y);</span><br><span class="line">  // 自定义相加运算符，实现向量相加</span><br><span class="line">  Vector operator +(Vector v) =&gt;  Vector(x + v.x, y + v.y);</span><br><span class="line">  // 覆写相等运算符，判断向量相等</span><br><span class="line">  bool operator == (dynamic v) =&gt; x == v.x &amp;&amp; y == v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final x = Vector(3, 3);</span><br><span class="line">final y = Vector(2, 2);</span><br><span class="line">final z = Vector(1, 1);</span><br><span class="line">print(x == (y + z)); //  输出true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Dart的变量与类型&quot;&gt;&lt;a href=&quot;#1-Dart的变量与类型&quot; class=&quot;headerlink&quot; title=&quot;1. Dart的变量与类型&quot;&gt;&lt;/a&gt;1. Dart的变量与类型&lt;/h2&gt;&lt;p&gt;在 Dart 中，可以使用 var 或者具体的类型来声明一个变量，当使用 var 定义变量时，表示类型交由编译器推断决定。Dart 是 &lt;strong&gt;类型安全&lt;/strong&gt; 的语言，所以的类型均继承与 Object，因此所有的类型都是对象类型，默认情况下，&lt;strong&gt;未初始化的变量的值为 null&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-1-num、bool与-String&quot;&gt;&lt;a href=&quot;#1-1-num、bool与-String&quot; class=&quot;headerlink&quot; title=&quot;1.1 num、bool与 String&quot;&gt;&lt;/a&gt;1.1 num、bool与 String&lt;/h3&gt;&lt;p&gt;num 为 Dart 的数据类型，只有两种子类：int 和 double，使用 bool 表示布尔值，有 false 和 true 两种状态，它们均是编译时常量。在 Dart 中字符串可以通过单引号、双引号、嵌入表达式、多行字符串的形式表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="/tags/Flutter/"/>
    
      <category term="Dart" scheme="/tags/Dart/"/>
    
      <category term="极客时间专栏" scheme="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>初始数据压缩</title>
    <link href="/2019/12/19/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"/>
    <id>/2019/12/19/数据压缩/</id>
    <published>2019-12-19T08:13:00.000Z</published>
    <updated>2019-12-19T08:14:21.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0010-文件以字节为单位保存"><a href="#0x0010-文件以字节为单位保存" class="headerlink" title="0x0010 文件以字节为单位保存"></a>0x0010 文件以字节为单位保存</h3><p>在计算机中，一切文件均是以字节为单位进行保存，文件包括文本文件、图片、程序等。</p><p>1B(1字节) = 1Byte = 8 bite 可以表示 256 中字节数据 </p><p>2⌃8 = 256</p><a id="more"></a><p>在任何情况下，文件中的字节数据都是 <code>连续</code> 存储的。</p><p>文件是字节数据的集合体。</p><h3 id="0x0020-RLE-算法机制"><a href="#0x0020-RLE-算法机制" class="headerlink" title="0x0020 RLE 算法机制"></a>0x0020 RLE 算法机制</h3><blockquote><p>例子：AAAAAABBCCCCDDDEE  17 个字符</p></blockquote><p>把文件中的内容用 “数据 x 重复次数” 的形式来表示的压缩方法称为 <strong>RLE</strong> (Run Length Encoding, 行程长度编码)</p><p>使用这种压缩方式的上文表示如下：</p><blockquote><p>A6B2C4D3E2 5个字符</p></blockquote><p>那么其压缩率为： 5 ÷ 17 = 0.29 = 29％</p><h4 id="0x0021-RLE-算法的缺点"><a href="#0x0021-RLE-算法的缺点" class="headerlink" title="0x0021  RLE 算法的缺点"></a>0x0021  RLE 算法的缺点</h4><p>RLE 算法的缺点：</p><pre><code>不适合文本文件的压缩</code></pre><p>原因： 文本文件中同样的字符连续出现的部分不多</p><blockquote><p>This is a girl.  ==＞  T1h1i1s1 i1s1 a1 g1i1r1l1.1</p></blockquote><p>很明显的是：压缩后的文件大小反而变大，效果与愿景相悖。</p><h3 id="0x0030-哈夫曼编码"><a href="#0x0030-哈夫曼编码" class="headerlink" title="0x0030 哈夫曼编码"></a>0x0030 哈夫曼编码</h3><p>哈夫曼编码是根据日常文本中各字符的出现频率来决定各个字符的编码的数据长度。</p><p>哈夫曼算法是指，为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩。</p><p>用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据。</p><p>如果仅仅依照 “出现频率最高的字符使用最短的位数编码来表示”，不免会造成识别混乱的现象。而在真实的哈夫曼算法中，通过哈夫曼树 构造编码体系，可以避免此现象的发生。</p><blockquote><p>例子: AAAAAABBCCCCDDDEE</p></blockquote><p><img src="https://note.youdao.com/src/WEBRESOURCEfb87dab9de9ab6795c3cc48c24999644" alt="image"></p><p>具体看一下压缩比：</p><p>17 x 8 = 136   很明显是 17B</p><p>利用哈夫曼算法压缩文件后的大小：</p><p>2 x 13 + 3 x 4 = 48  文件大小为 6B</p><p>压缩率为：<br>    6 ÷ 17 = 35％</p><p>使用哈夫曼树后，出现频率越高的数据占用的数据位数越少，而且数据的区分也可以很清晰的实现。</p><p>Q：哈夫曼算法为什么可以达到这么好的效果？</p><p>A：通过上图我们发现，在用枝条连接数据时，我们是从频率较低的数据开始的，这意味着出现频率越低的数据到达根部的枝条数越多，而枝条数越多，编码的位数就随之增多了。</p><h3 id="0x0040"><a href="#0x0040" class="headerlink" title="0x0040"></a>0x0040</h3><p>我们把压缩后能够还原到压缩状态的压缩称为 可逆压缩，无法还原的称为 非可逆压缩。</p><hr><p>— From 『程序是怎么跑起来的』</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0010-文件以字节为单位保存&quot;&gt;&lt;a href=&quot;#0x0010-文件以字节为单位保存&quot; class=&quot;headerlink&quot; title=&quot;0x0010 文件以字节为单位保存&quot;&gt;&lt;/a&gt;0x0010 文件以字节为单位保存&lt;/h3&gt;&lt;p&gt;在计算机中，一切文件均是以字节为单位进行保存，文件包括文本文件、图片、程序等。&lt;/p&gt;
&lt;p&gt;1B(1字节) = 1Byte = 8 bite 可以表示 256 中字节数据 &lt;/p&gt;
&lt;p&gt;2⌃8 = 256&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据压缩" scheme="/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>图解 HTTP 学习笔记(二)：简单了解 HTTP</title>
    <link href="/2019/12/10/%E5%9B%BE%E8%A7%A3-HTTP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>/2019/12/10/图解-HTTP-学习笔记-二/</id>
    <published>2019-12-10T03:09:44.000Z</published>
    <updated>2019-12-10T03:19:38.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HTTP-协用于客户端和服务端之间的通信"><a href="#1-HTTP-协用于客户端和服务端之间的通信" class="headerlink" title="1. HTTP 协用于客户端和服务端之间的通信"></a>1. HTTP 协用于客户端和服务端之间的通信</h3><p><strong>HTTP 协议能够区分哪一端是客户端，哪一端是服务端。</strong></p><h3 id="2-通过请求和响应的交换达成通信"><a href="#2-通过请求和响应的交换达成通信" class="headerlink" title="2. 通过请求和响应的交换达成通信"></a>2. 通过请求和响应的交换达成通信</h3><p>肯定是客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: abc.jp</span><br></pre></td></tr></table></figure><a id="more"></a><p>这段请求的内容的意思是：请求访问某台 HTTP 服务器上的 /index.html 页面资源。</p><p>请求报文是由请求方法(GET)、请求 URI(上文中的 index.html)、协议版本HTTP/1.1)、可选的请求首部字段和内容实体构成。</p><p><img src="/source/images/2019_12_09_04.jpg" alt="dns.jpg"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><h3 id="3-HTTP-是不保存状态的协议"><a href="#3-HTTP-是不保存状态的协议" class="headerlink" title="3. HTTP 是不保存状态的协议"></a>3. HTTP 是不保存状态的协议</h3><p>无状态的协议</p><p>HTTP 协自身不对请求和响应之间的通信状态进行保存。<strong>协议本身不保留之前一切的请求或者响应报文的信息</strong>，为的是更快的处理大量事务，确保协议的可伸缩性，这就是为什么把 HTTP 协议设计如此简单的原因。</p><p>为了实现保存状态的功能，引入了 Cookie 技术。</p><h3 id="4-请求-URI-定位资源"><a href="#4-请求-URI-定位资源" class="headerlink" title="4. 请求 URI 定位资源"></a>4. 请求 URI 定位资源</h3><p>Uniform Resource identies</p><p>HTTP 协议通过 URI 定位互联网上的资源，正是因为 URI 的特定功能，所以在互联网上的任意资源都是可以访问的到的。</p><p>当客户端访问网络资源发起请求时，URI 将作为请求报文包含在其中。</p><h3 id="5-持久连接节省通信量"><a href="#5-持久连接节省通信量" class="headerlink" title="5. 持久连接节省通信量"></a>5. 持久连接节省通信量</h3><p>在 HTTP 的初始版本时，每进行一次 HTTP 通信就要经过 TCP 连接、TCP 断开操作，客户端和服务端在频繁的交互过程中，会产生大量无谓的 TCP 连接和断开，增大了通信量。</p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>在 HTTP1.1 版本中，通过引入持久连接的概念，解决了上述问题，在 HTTP 中表现为 HTTP 首部字段 keep-alive 为 true，并且在 HTTP1.1 版本中，more所有的连接都是持久连接。</p><p>持久连接的特点就是没有明确提出断开连接，则会保持 TCP 连接。</p><p>持久化连接，减少了 TCP 连接的重复建立和断开，减少了额外的开销，减轻了服务器的负载。</p><h4 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h4><p>HTTP/2 支持管道化，不过自己还没有使用过 HTTP/2，故在此不详述，在使用时再学习。</p><h3 id="6-使用-Cookie-进行状态该管理"><a href="#6-使用-Cookie-进行状态该管理" class="headerlink" title="6. 使用 Cookie 进行状态该管理"></a>6. 使用 Cookie 进行状态该管理</h3><p>HTTP 是无状态协议，即不会对之前发生的请求和响应进行状态管理，所以无法实现根据之前的状态进行本次请求的处理。</p><p>所以就会存在这样一个场景：需要登录验证的页面，需要在每次跳转都需要进行登录，当然这是很不合理的。</p><p>基于 HTTP 的无状态连接，引入了 Cookie 技术，该技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p><p>具体流程：</p><ul><li>如果服务端的响应报文中存在 Set-Cookie 的首部字段，那么 Cookie 就会通过客户端保存 cookie。</li><li>如果客户端再向服务端发送请求，那么就会自动在请求报文中添加 Cookie值，然后发送出去。</li><li>服务端发现客户端发送的 Cookie 后，就会查明是哪一个客户端发来的连接请求，然后在服务器中进行对比，<strong>得到之前的状态</strong>。</li></ul><ol><li><p>请求报文（此时的请求报文没有 Cookie 信息）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /show/ HTTP/1.1</span><br><span class="line">Host: baidu.com</span><br></pre></td></tr></table></figure></li><li><p>响应报文(服务端生成 Cookie 信息)</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date:xxx</span><br><span class="line">Server:Ngix</span><br><span class="line">&lt;Set-Cookie: sid=24143434334;path=/;expires=Wed 10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type:text/plain;charset=UTF-8</span><br></pre></td></tr></table></figure><ol start="3"><li>请求报文(自动填充 Cookie 信息)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /getImage/ HTTP1.1</span><br><span class="line">Host:baidu.com</span><br><span class="line">Cookie:sid=24143434334</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-HTTP-协用于客户端和服务端之间的通信&quot;&gt;&lt;a href=&quot;#1-HTTP-协用于客户端和服务端之间的通信&quot; class=&quot;headerlink&quot; title=&quot;1. HTTP 协用于客户端和服务端之间的通信&quot;&gt;&lt;/a&gt;1. HTTP 协用于客户端和服务端之间的通信&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;HTTP 协议能够区分哪一端是客户端，哪一端是服务端。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-通过请求和响应的交换达成通信&quot;&gt;&lt;a href=&quot;#2-通过请求和响应的交换达成通信&quot; class=&quot;headerlink&quot; title=&quot;2. 通过请求和响应的交换达成通信&quot;&gt;&lt;/a&gt;2. 通过请求和响应的交换达成通信&lt;/h3&gt;&lt;p&gt;肯定是客户端开始建立通信，服务端在没有接收到请求之前不会发送响应。&lt;/p&gt;
&lt;h4 id=&quot;请求报文&quot;&gt;&lt;a href=&quot;#请求报文&quot; class=&quot;headerlink&quot; title=&quot;请求报文&quot;&gt;&lt;/a&gt;请求报文&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET /index.html HTTP/1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Host: abc.jp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络协议" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="图解 HTTP" scheme="/tags/%E5%9B%BE%E8%A7%A3-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>图解 HTTP 学习笔记(一)：网络基础</title>
    <link href="/2019/12/10/%E5%9B%BE%E8%A7%A3-HTTP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>/2019/12/10/图解-HTTP-学习笔记一/</id>
    <published>2019-12-10T03:09:22.000Z</published>
    <updated>2019-12-10T03:21:58.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络基础-TCP-IP"><a href="#1-网络基础-TCP-IP" class="headerlink" title="1. 网络基础 TCP/IP"></a>1. 网络基础 TCP/IP</h2><p>我们使用的网络是在 TCP/IP 协议族的基础上运行的， HTTP 属于它内部的一个子集。</p><h3 id="1-TCP-IP-协议族"><a href="#1-TCP-IP-协议族" class="headerlink" title="1. TCP/IP 协议族"></a>1. TCP/IP 协议族</h3><p>计算机与网络设备之间需要相互通信、不同硬件和不同系统之间的通信，双方就必须基于相同的方法，所有的一切都需要一种规则，我们把这种规则称为协议。</p><a id="more"></a><p>把互联网相关联的协议的集合起来称为 TCP/IP 协议族。</p><h3 id="2-TCP-IP-的分层管理"><a href="#2-TCP-IP-的分层管理" class="headerlink" title="2. TCP/IP 的分层管理"></a>2. TCP/IP 的分层管理</h3><p>TCP/IP 协议族里重要的一点就是 <strong>分层</strong> ，按照层次分为以下 4 层 (<strong>TCP/IP 概念层模型</strong>)：</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层 。</li></ul><p>TCP/IP 的分层是有好处的，分层之后更容易管理，各层内部设计不受其它层的干扰，只考虑本层的职责。</p><h4 id="2-1-TCP-IP-概念层模型"><a href="#2-1-TCP-IP-概念层模型" class="headerlink" title="2.1 TCP/IP 概念层模型"></a>2.1 TCP/IP 概念层模型</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层决定了向用户提供应用服务时通信的活动。</p><p>HTTP 属于该层。</p><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>传输层对上层 (应用层) 提供处于网络连接中的两台计算机之间的数据传输。</p><p>传输层中有两个性质不同的协议： </p><ul><li>TCP(Transmission Control Protocol,传输控制协议) </li><li>UDP(User Data Protocol,用户数据包协议)。</li></ul><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>网络层用来处理在网络上流动的数据包 (<strong>数据包是网络传输的最小数据单位</strong>)。</p><p>该层规定了通过怎样的路径(传输路线)到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><h5 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h5><p>用来处理连接网络的硬件部分。</p><p>控制硬件操作系统、硬件的设备驱动、NIC(网络适配器，即网卡)、光纤等物理可见部分的硬件部分均在链路层的范围之内。</p><h4 id="2-2-TCP-IP-通信传输流"><a href="#2-2-TCP-IP-通信传输流" class="headerlink" title="2.2 TCP/IP 通信传输流"></a>2.2 TCP/IP 通信传输流</h4><p>利用 TCP/IP协议族进行网络通信时，会通过分层顺序与对方通信，发送端从应用层往下走，接收端从链路层往上走。</p><!-- ![dns.jpg](/source/images/2019_12_09_01.jpg) --><p><img src="/public/images/2019_12_09_01.jpg" alt></p><p>发送端在层与层之间传递数据，没经过一层必定被打上一个该层所属的首部信息，反之，接收端在层与层之间传递数据时，每经过一层会把对应的首部信息去掉，具体见上图。</p><p>这种把信息包装起来的做法叫做封装。</p><h2 id="2-与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#2-与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="2. 与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>2. 与 HTTP 关系密切的协议：IP、TCP 和 DNS</h2><h3 id="1-负责传输的-IP-协议"><a href="#1-负责传输的-IP-协议" class="headerlink" title="1. 负责传输的 IP 协议"></a>1. 负责传输的 IP 协议</h3><p>IP(Internet Protocol) 协议位于网络层。</p><p>IP 协议的作用是把各种数据包传送给对方，确保数据包正确传送到对方，需要满足各类条件,其中最重要的是 <strong>IP 地址</strong>和 <strong>MAC 地址 (Media Access Control Address)</strong> 。</p><ul><li>IP 地址指明了节点被分配到的地址，可变换。</li><li>MAC 地址指的是网卡所属的固定地址，基本不会变更。</li></ul><h4 id="使用-ARP-协议凭借-MAC-地址进行通信"><a href="#使用-ARP-协议凭借-MAC-地址进行通信" class="headerlink" title="使用 ARP 协议凭借 MAC 地址进行通信"></a>使用 ARP 协议凭借 MAC 地址进行通信</h4><p>IP 间的通信依赖 MAC 地址。在网络通信过程中，进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。 ARP 协议是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p><h3 id="2-确保可靠的-TCP-协议"><a href="#2-确保可靠的-TCP-协议" class="headerlink" title="2. 确保可靠的 TCP 协议"></a>2. 确保可靠的 TCP 协议</h3><p><strong>TCP 位于传输层，作用是提供可靠的字节流服务。</strong></p><p>在上面对 TCP 的描述中，有两个关键字：</p><ol><li>字节流服务：是指为了传输方便，将大块的数据分割为以报文段 (segment) 为单位的数据包进行管理。</li><li>可靠性：是指能够把数据准确的传送给对方。</li></ol><h4 id="三次握手：确保数据能达到目标"><a href="#三次握手：确保数据能达到目标" class="headerlink" title="三次握手：确保数据能达到目标"></a>三次握手：确保数据能达到目标</h4><p>使用 TCP 协议把数据包发送出去， TCP 会向对方确认数据是否成功送达到对方。在握手中使用了 TCP 标志 – SYC(sychronize 同步) 和 ACK(acknowledgement 确认、收条)。</p><h3 id="3-负责域名解析的-DNS-服务"><a href="#3-负责域名解析的-DNS-服务" class="headerlink" title="3. 负责域名解析的 DNS 服务"></a>3. 负责域名解析的 DNS 服务</h3><p>DNS( Domain Name System) 服务位于应用层，提供域名到 IP 地址之间的解析服务。</p><p>人们记忆主机名或域名比较容易，但是对于计算机处理 IP 地址比较容易些。为了解决以上问题，DNS 服务就应运而生。</p><p>DNS 协议通过域名查找 IP 地址，或者通过 IP 地址逆向查找域名的服务。</p><p><img src="/source/images/2019_12_09_02.jpg" alt></p><h3 id="4-各种协议与-HTTP-协议的关系"><a href="#4-各种协议与-HTTP-协议的关系" class="headerlink" title="4. 各种协议与 HTTP 协议的关系"></a>4. 各种协议与 HTTP 协议的关系</h3><p><img src="/source/images/2019_12_09_03.jpg" alt></p><p>由上面的图中，我们可以看出在 HTTP 协议的通信过程中 TCP、IP 协议和 DNS 发挥的作用。</p><h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><p>URI：Uniform Resource Identifiier,统一资源标识符<br>URL：Uniform Resource Locator,统一资源定位府</p><p>我们平时在 Web 页面输入的网页地址如：<a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a> 就是 URL。</p><p>URI： 就是由某个协议方案表示的资的定位标识符，协议方案是指访问资源所用到的协议类型名称。常见的协议方案：http、ftp、file 等。</p><p><strong>URI 用字符串标志某一互联网资源，而 URL 表示资源的地点(互联网上所处的位置)，URL 是 URI 的子集。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-网络基础-TCP-IP&quot;&gt;&lt;a href=&quot;#1-网络基础-TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;1. 网络基础 TCP/IP&quot;&gt;&lt;/a&gt;1. 网络基础 TCP/IP&lt;/h2&gt;&lt;p&gt;我们使用的网络是在 TCP/IP 协议族的基础上运行的， HTTP 属于它内部的一个子集。&lt;/p&gt;
&lt;h3 id=&quot;1-TCP-IP-协议族&quot;&gt;&lt;a href=&quot;#1-TCP-IP-协议族&quot; class=&quot;headerlink&quot; title=&quot;1. TCP/IP 协议族&quot;&gt;&lt;/a&gt;1. TCP/IP 协议族&lt;/h3&gt;&lt;p&gt;计算机与网络设备之间需要相互通信、不同硬件和不同系统之间的通信，双方就必须基于相同的方法，所有的一切都需要一种规则，我们把这种规则称为协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络协议" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="图解 HTTP" scheme="/tags/%E5%9B%BE%E8%A7%A3-HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(九):Kotlin 集合及 Lambda 表达式</title>
    <link href="/2019/12/03/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%B9%9D-Kotlin-%E9%9B%86%E5%90%88%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>/2019/12/03/Kotlin-核心编程-九-Kotlin-集合及-Lambda-表达式/</id>
    <published>2019-12-03T05:24:43.000Z</published>
    <updated>2019-12-03T05:30:41.335Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。</p><p>Kotlin 集合中的 API 大量使用了 Lambda。</p><h3 id="0x0001-Kotlin-调用-Java-的函数式接口"><a href="#0x0001-Kotlin-调用-Java-的函数式接口" class="headerlink" title="0x0001 Kotlin 调用 Java 的函数式接口"></a>0x0001 Kotlin 调用 Java 的函数式接口</h3><p>Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：</p><a id="more"></a><p>Java 的函数式接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IClick&#123;</span><br><span class="line">    void onClick()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.setIClickListener(new IClick()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClik()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上例子在 Kotlin 中做如下调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener(object:IClick&#123;</span><br><span class="line"></span><br><span class="line">    override public void onClik()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 Lambda 语法进行简化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>由 Kotlin 语法糖的存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0002-带接收者的-Lambda-这个是什么？"><a href="#0x0002-带接收者的-Lambda-这个是什么？" class="headerlink" title="0x0002 带接收者的 Lambda  这个是什么？"></a>0x0002 带接收者的 Lambda  这个是什么？</h3><p>通过之前的内容我们知道了函数的类型，比如以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; String// 参数类型为 Int ，返回值类型为 String 的函数</span><br><span class="line">(Int) -&gt; (Int,String) -&gt; String</span><br></pre></td></tr></table></figure><p>同时在 Kotlin 中还允许定义带有参数的函数类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int.(Int) -&gt; Int</span><br></pre></td></tr></table></figure><p>具体应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum:Int.(Int) -&gt; Int = &#123;other -&gt; plus(other)&#125;</span><br></pre></td></tr></table></figure><p><strong>类型安全构造器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class HTML&#123;</span><br><span class="line">    fun body()&#123;</span><br><span class="line">        println(&quot;body&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun header()&#123;</span><br><span class="line">        println(&quot;head&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun content(num:Int):Int&#123;</span><br><span class="line">        println(&quot;content $num&quot;)</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun showText(a:Int):String =&quot;showText&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun html(init:HTML.() -&gt; Unit):HTML&#123;</span><br><span class="line">    val html = HTML()//创建接受者</span><br><span class="line">    html.init()// 把接受者对象传给 Lambda</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun html2(init:HTML.() -&gt; String):HTML&#123;</span><br><span class="line">    val html = HTML()</span><br><span class="line">    html.init()</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;R&gt; html4(init:HTML.() -&gt; R):R&#123;</span><br><span class="line">    val html = HTML()</span><br><span class="line">    val result = html.init()</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    html &#123; body() &#125;// 调用接受者对象的 body 方法，调用 1</span><br><span class="line">    html &#123; header() &#125;// 调用 2，往下依次类推</span><br><span class="line">    html &#123; content(2) &#125;</span><br><span class="line">    html &#123; showText(2) &#125;</span><br><span class="line"></span><br><span class="line">//    html2 &#123; body() &#125;</span><br><span class="line">//    html2 &#123; header() &#125;</span><br><span class="line">//    html2 &#123; content(2) &#125;</span><br><span class="line">    html2 &#123; showText(2) &#125;</span><br><span class="line"></span><br><span class="line">//    html3 &#123; body() &#125;</span><br><span class="line">//    html3 &#123; header() &#125;</span><br><span class="line">    html3 &#123; content(2) &#125;</span><br><span class="line">//    html3 &#123; showText(3) &#125;   </span><br><span class="line"></span><br><span class="line">    val result = html4 &#123; showText(3)</span><br><span class="line">    &quot;3435&quot;&#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个概念虽然看示例挺容易看懂，但是概念确实是难以理解，经过验证有以下结论：</p><p><code>init:HTML.() -&gt; Unit</code>: 其中 <code>HTML</code> 代表 Lambda 表达式 init 为 HTML 类中的函数，而 <code>Unit</code> 代表 Lambda 表达式的返回值，这里需要注意的是，当此处声明返回值类型为 Unit 时，可以调用 HTML 中返回值类型为各个类型的函数，所以 调用 1~4 均是可以的，但是当声明返回值类型为非 Unit 时，只能调用返回值类型相同的函数，所以调用 5、6、7、9、10、12 是非法调用。需要注意调用 13 是可以有返回值的。</p><p>其实我们常见的 with、apply 就是这样的函数，正式因为这种机制，我们可以在相应的闭包中使用 this 代指调用接收者,并且 this 可以省略，但是不同的是 with 可以返回自由类型，如上例中的 html4，with、apply 的使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val html = HTML()</span><br><span class="line">with(html)&#123;</span><br><span class="line">    body()</span><br><span class="line">    header()</span><br><span class="line">    content(2)</span><br><span class="line">    showText(2)</span><br><span class="line">    &quot;over&quot;</span><br><span class="line">&#125;</span><br><span class="line">html.apply &#123;</span><br><span class="line">    body()</span><br><span class="line">    header()</span><br><span class="line">    content(2)</span><br><span class="line">    showText(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 with 和 apply 的源码，通过源码更深理解两者的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return receiver.block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0X0003-使用内联函数优化-Kotlin-中-Lambda-表达式额外的开销"><a href="#0X0003-使用内联函数优化-Kotlin-中-Lambda-表达式额外的开销" class="headerlink" title="0X0003 使用内联函数优化 Kotlin 中 Lambda 表达式额外的开销"></a>0X0003 使用内联函数优化 Kotlin 中 Lambda 表达式额外的开销</h3><p>Kotlin 中 Lambda 的额外开销：在 Kotliln 声明的每一个 Lambda 会在字节码中产生一个匿名类，每次调用都会创建一个新的对象，所以存在额外开销。而 Java 中通过 invokedynamic 技术实现了在运行期才产生相应的翻译代码。</p><p><strong>内联函数：</strong><br>使用 <strong>inline</strong> 关键字来修饰函数，这些函数就成为了内联函数。内联函数的函数体在编译期会被嵌入每一个调用的地方，以免减少额外生产的匿名类数量，同时减少函数执行的时间开销。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo &#123; println(&quot;block&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun foo(block:()-&gt;Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码反编译后的相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class TwoKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      foo((Function0)null.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      String var1 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">      block.invoke();</span><br><span class="line">      var1 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的内容，我们知道 Lambda 表达式会生成相应的匿名内部类，在这里调用 foo 会产生一个 Function0 类型的 block 类，通过调用其 invoke 方法来执行，这就是所说的增加的额外的生成类和调用开销。</p><p>使用 inline 关键子修饰 foo 函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun foo(block:()-&gt;Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var1 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">      // block 函数体从这里开始粘贴</span><br><span class="line">      String var2 = &quot;block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      // block 函数体从这里结束粘贴</span><br><span class="line">      var1 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      String var2 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      block.invoke();</span><br><span class="line">      var2 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 foo 函数体代码以及被调用的 Lambda 代码都粘贴到了相应的调用位置，从而减少匿名类的生产和调用开销。但是内联函数存在的一个问题是会增加空间复杂度，通过空间换取时间上的优势。</p><p>使用内联函数需要注意：</p><ul><li>普通函数不需要使用 inline 关键字修饰。</li><li>避免对具有大量函数体的函数进行内联，会导致过多的字节码数量。</li><li>函数被定义为内联函数，则不能访问闭包类中的私有成员，除非声明为 internal。</li></ul><h3 id="0X0004-使用-noinline-避免参数被内联"><a href="#0X0004-使用-noinline-避免参数被内联" class="headerlink" title="0X0004 使用 noinline 避免参数被内联"></a>0X0004 使用 noinline 避免参数被内联</h3><p>通过上节可是看到内联函数的整个函数会被粘贴到调用函数中，但是存在这样一种情况：函数接收多个参数，我们只想对部分 Lambda 参数进行内联，而其他不内联，应该如何操作。</p><p>针对以上情况，我们可以使用关键字 <strong>noline</strong> 来修饰不想内联的参数，那么该参数就不会有内联效果。我们对以上的示例进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo (&#123; println(&quot;block1&quot;)&#125;,&#123; println(&quot;block2&quot;)&#125;, &quot;tree&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun foo(block:()-&gt;Unit,noinline block2: () -&gt; Unit,mess:String)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    block2()</span><br><span class="line">    println(mess)</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      Function0 block2$iv = (Function0)null.INSTANCE;</span><br><span class="line">      String mess$iv = &quot;tree&quot;;</span><br><span class="line">      String var3 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">      String var4 = &quot;block1&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      block2$iv.invoke();</span><br><span class="line">      System.out.println(mess$iv);</span><br><span class="line">      var3 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block, @NotNull Function0 block2, @NotNull String mess) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block2, &quot;block2&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(mess, &quot;mess&quot;);</span><br><span class="line">      String var4 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      block.invoke();</span><br><span class="line">      block2.invoke();</span><br><span class="line">      System.out.println(mess);</span><br><span class="line">      var4 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 online 修饰的 block2 Lambda 表达式， 在调用时并没有将其函数体复制到调用处。</p><h3 id="0X0005-非局部返回和具体化参数类型"><a href="#0X0005-非局部返回和具体化参数类型" class="headerlink" title="0X0005 非局部返回和具体化参数类型"></a>0X0005 非局部返回和具体化参数类型</h3><p><strong>使用 inline 实现非局部返回</strong></p><p>非局部返回，那么就是全局返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // foo &#123; return&#125; 促成为非法调用，Lambda 中不允许 return 关键字出现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun foo(block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时通过 inline 修饰 foo 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo &#123; return&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun foo(block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before block</span><br></pre></td></tr></table></figure><p>只执行 block 上面的操作，原因很容易理解，使用 inline 将代码进行替换，那么 return 在编译期会出现在 main 函数中，当然会针对全局生效。</p><p><strong>crossinline 关键字</strong></p><p>但是在某些情况下，非局部返回可能会引发某些问题，因为有时候内联函数所接收的 Lambda 常数往往来自上下文的其他地方。为了避免带有 return 的 Lambda参数带来破话，使用 <strong>crossinline</strong> 来避免非局部返回的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //foo &#123; return&#125; 此时 Lambda 中带有 return 参数是非法的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun foo(crossinline block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 inline 实现具体化参数类型</strong></p><p>其实这部分内容在 Kotlin 泛型提及过，在此处探究器原因。</p><p>和 Java 一样，由于运行时存心类型擦除，所以不能直接获取一个参数的类型，而使用内联函数会直接在字节码中生成相应的函数体，这种情况下可以获得参数类型，可以通过关键字 <strong>reified</strong> 实现这一效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    getType&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun &lt;reified T&gt; getType()&#123;</span><br><span class="line">    println(T::class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure><p>反编译后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      KClass var1 = Reflection.getOrCreateKotlinClass(String.class);</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static final void getType() &#123;</span><br><span class="line">      Intrinsics.reifiedOperationMarker(4, &quot;T&quot;);</span><br><span class="line">      KClass var1 = Reflection.getOrCreateKotlinClass(Object.class);</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。&lt;/p&gt;
&lt;p&gt;Kotlin 集合中的 API 大量使用了 Lambda。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-Kotlin-调用-Java-的函数式接口&quot;&gt;&lt;a href=&quot;#0x0001-Kotlin-调用-Java-的函数式接口&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Kotlin 调用 Java 的函数式接口&quot;&gt;&lt;/a&gt;0x0001 Kotlin 调用 Java 的函数式接口&lt;/h3&gt;&lt;p&gt;Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(十一):作用域函数 let、run、with、apply、also</title>
    <link href="/2019/12/03/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%8D%81%E4%B8%80-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0/"/>
    <id>/2019/12/03/Kotlin-核心编程-十一-作用域函数/</id>
    <published>2019-12-03T05:24:17.000Z</published>
    <updated>2020-01-03T08:36:15.609Z</updated>
    
    <content type="html"><![CDATA[<p>在 also、let 的 Lambda 表达式内，it 代表接收者类型对象，而不像 《Kotlin 核心编程》 一书中所说的，this 代表接收者类型对象，而且在 also、let 中同时存在 this，并且通过 this 可以访问到外层变量，自己对此充满疑问，感觉书中对 this 为接收者对象的方法过于武断，查官方文档，十分幸运，正好有一篇关于此内容的文档，不过为英文，自己读了一遍，觉得在翻译此文在自己能力范围内，故做大致翻译，但是不会逐字翻译，得其大概即可。</p><a id="more"></a><p>具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">data class Student(val age: Int, val name: String, val score: Int)</span><br><span class="line"></span><br><span class="line">class Kot &#123;</span><br><span class="line">    val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line">    var age = 2</span><br><span class="line">    fun showTest() &#123;</span><br><span class="line">        </span><br><span class="line">        student?.apply &#123;</span><br><span class="line">            println(name)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        student?.also &#123;</span><br><span class="line">            println(it.name)</span><br><span class="line">            println(it.age)</span><br><span class="line">            println(this.age)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        student.let &#123;</span><br><span class="line">            println(this.age)</span><br><span class="line">            println(it.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域函数的作用"><a href="#作用域函数的作用" class="headerlink" title="作用域函数的作用"></a>作用域函数的作用</h3><p>Koltin 标准库中存在这样一类函数，它存在的 <strong>唯一作用就是在执行传入闭包中的代码</strong>。当向这类函数传入 Lambda 表达式时，在该闭包范围内存在作用域对象，<strong>可以不通过对象的名字直接访问该对象的成员</strong>，这样的函数在 Kotlin 称为 <strong>作用域函数</strong>。在 Kotlin 中有 5 个作用域函数： <code>let、run、with、apply、also。</code></p><p>上面提到的 5 个函数的作用基本都一致：在对象作用域内之下代码块，所以在开发中如何根据需求选择合适的函数就变得不那么容易，需要考虑具体需求意图、一致性等因素。基于此，以下内容主要用于陈述以上 5 个作用域函数的区别以及常规用法。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>不同点主要体现在以下两点：</p><ol><li>闭包内上下文对象的表示方法。</li><li>整个表达式的返回结果。</li></ol><h4 id="上下文对象的表示方法：this-or-it"><a href="#上下文对象的表示方法：this-or-it" class="headerlink" title="上下文对象的表示方法：this or it"></a>上下文对象的表示方法：this or it</h4><p>在作用域函数中，<strong>上下文对象可以通过短引用(this 或者 it)而不是实际名称来使用</strong>。在作用域函数中可以通过<br>每个作用域函数上下文对象只能是以下两种方式中的一种方式获得：</p><ol><li>作用域函数的接收者类型对象，在闭包中通过 this 进行访问。</li><li>Lambda 表达式的传入参数对象，在闭包中通过 it 进行访问。</li></ol><p><strong>this</strong></p><p>作用域函数 run、with、apply 中的上下文对象为作用域函数的类型接收者对象，在闭包中通过 this 进行指代。</p><p>在这里以 run 函数解释一下作用域函数的 <strong>上下文对象</strong> 和 <strong>类型接收者对象</strong>，run 函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 的 <strong>上下文对象</strong> 为 <code>T.run</code>  中的 T，而 <strong>类型接收对象</strong> 为 run 函数所属的类，即 <code>block: T.() -&gt; R</code>中的 T，可见 上下文对象 和 类型接收对象 是相同的，所以在 Lambda 中使用 this 来表达上下文对象。</p><p>通过以下示例具体展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data class Student(val age: Int, val name: String, val score: Int)</span><br><span class="line"></span><br><span class="line">fun show()&#123;</span><br><span class="line">    val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line">    student.run &#123; </span><br><span class="line">        this.age</span><br><span class="line">        this.score</span><br><span class="line">        name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 Lambd 中 this 即为 run 函数的类型接收者对象 student，可以在闭包中通过 this 访问 student 的成员变量，同时关键字 this 也可以省略。</p><p><strong>it</strong></p><p>let、also 作用域函数的上下文对象为 Lambda 对象中传入的类型对象。如果在 Lambda 中参数名称没有显式声明，那么该对象可以通过 it 隐式访问。</p><p>以 let 作用域函数具体说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return block(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看到的是：函数的上下文对象为 <code>T.let</code> 中的 T，而在该函数中 T 并不是像 run 函数 中那样作为传入的 Lambda 的类型接收对象，而是为传入 Lambda 表达式的参数类型，所以此时函数的上下对象使用 it 来表示。</p><p>至于为什么是 it，我感觉这是 Kotlin 中针对 Lambda 表达式的语法糖：<strong>单个参数的隐式名称</strong>，当 Lambda 表达式的参数为一个时，可以使用 it 代表所接收的单个参数，就如下面表达式一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(1,2,3).forEach&#123;</span><br><span class="line">    it -&gt; sout(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>it 的具体使用案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun show()&#123;</span><br><span class="line">    val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line"></span><br><span class="line">    student.also &#123; </span><br><span class="line">        it.age</span><br><span class="line">        it.score</span><br><span class="line">    &#125;</span><br><span class="line">    // 指定参数的名称，与上面的效果一样</span><br><span class="line">    student.also &#123;  stu -&gt; </span><br><span class="line">        stu.age</span><br><span class="line">        stu.score</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>以上提到的 5 个作用域函数的返回值对象是不同的：</p><ul><li>apply、also 返回值为上下文对象。</li><li>let、run、with 返回值为 Lambda 表达式结果。</li></ul><p><strong>上下文对象</strong></p><p>apply、also 返回的是上下文对象，所以使用它们进行链式操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun show() &#123;</span><br><span class="line">    val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line"></span><br><span class="line">    //返回值对象为上下文对象</span><br><span class="line">    val returnResult: Student = student.also &#123; stu -&gt;</span><br><span class="line">        stu.age</span><br><span class="line">        stu.score</span><br><span class="line">    &#125;.apply &#123;</span><br><span class="line">        this.score++</span><br><span class="line">        println(score)</span><br><span class="line">    &#125;</span><br><span class="line">    println(returnResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lambda 表达式结果</strong></p><p>let、run、with 返回的对象为 Lambda 表达式结果，同时也可以不返回任何对象，如在 Lambda 表达式的最后执行 print 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun show() &#123;</span><br><span class="line">    val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line"></span><br><span class="line">    val str = student.let &#123; </span><br><span class="line">        var getScore = it.score</span><br><span class="line">        getScore++</span><br><span class="line">        getScore// 此为 Lambda 表达式结果，也为作用域函数的返回结果</span><br><span class="line">    &#125;</span><br><span class="line">    println(str)</span><br><span class="line"></span><br><span class="line">    val withResult = with(student)&#123;</span><br><span class="line">        var getScore = score</span><br><span class="line">        getScore++</span><br><span class="line">        getScore</span><br><span class="line">    &#125;</span><br><span class="line">    println(withResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><p>一般情况下，以上几个作用域函数都是可以互相替换的，但是此处说明一下每个函数的适合的场景。</p><p><strong>let</strong></p><p>上下文对象为 Lambda 传入的参数，使用 it 表示，整个表达式的返回值为 Lambda 的结果。</p><ol><li>let 可以用于在调用链的结果上调用一个或多个函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)</span><br><span class="line">numbers.map &#123; it.length &#125;.filter &#123; it &gt; 3 &#125;.let &#123; </span><br><span class="line">    println(it)</span><br><span class="line">    // and more function calls if needed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果let 闭包中的只有一个函数，并且 it 为该函数的参数，那么可以使用使用(::xxx) 的形式代替 lambda 闭包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val student: Student = Student(9, &quot;aline&quot;, 3)</span><br><span class="line">val str1 = student.let&#123;</span><br><span class="line">    show(it)</span><br><span class="line">&#125;</span><br><span class="line">val str2 = student.let(::show)</span><br><span class="line">fun show(stu:Student)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>let 常用于对象不为空时执行相关操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val str: String? = &quot;Hello&quot;</span><br><span class="line">val length = str?.let&#123;</span><br><span class="line">    sout(it)</span><br><span class="line">    it.lenght</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>let 常用于为闭包引入局部变量，以提高代码的可读性：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class="line">val modifiedFirstItem = numbers.first().let &#123; firstItem -&gt;</span><br><span class="line">        println(&quot;The first item of the list is &apos;$firstItem&apos;&quot;)</span><br><span class="line">    if (firstItem.length &gt;= 5) firstItem else &quot;!&quot; + firstItem + &quot;!&quot;</span><br><span class="line">&#125;.toUpperCase()</span><br><span class="line">println(&quot;First item after modifications: &apos;$modifiedFirstItem&apos;&quot;)</span><br></pre></td></tr></table></figure><p><strong>with</strong></p><p>上下文对象 with 传入的参数，整个表达式的返回值为 Lambda 的结果。</p><ol><li>with 常用于不返回 Lambda 结果的情况，给人直观的感受：通过这个对象，你可以进行如下操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">with(numbers) &#123;</span><br><span class="line">    println(&quot;&apos;with&apos; is called with argument $this&quot;)</span><br><span class="line">    println(&quot;It contains $size elements&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>with 的另一个用例是引入一个辅助对象，其属性或函数将用于计算值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">// firstAndLast 引入的辅助对象</span><br><span class="line">val firstAndLast = with(numbers) &#123;</span><br><span class="line">    &quot;The first element is $&#123;first()&#125;,&quot; +</span><br><span class="line">        &quot; the last element is $&#123;last()&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">println(firstAndLast)</span><br></pre></td></tr></table></figure><p><strong>run</strong></p><p>上下文对象通过 this 表示，整个表达式的返回值为 Lambda 的结果。</p><p>run 的功能和 with 相同，不同的是通过扩展函数进行执行相关操作。</p><ol><li>当 lambda 同时包含对象初始化和返回值的计算时，t推荐使用 run：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val service = MultiportService(&quot;https://example.kotlinlang.org&quot;, 80)</span><br><span class="line"></span><br><span class="line">val result = service.run &#123;</span><br><span class="line">    port = 8080</span><br><span class="line">    query(prepareRequest() + &quot; to port $port&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the same code written with let() function:</span><br><span class="line">val letResult = service.let &#123;</span><br><span class="line">    it.port = 8080</span><br><span class="line">    it.query(it.prepareRequest() + &quot; to port $&#123;it.port&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>run 同时可以作为非扩展函数使用，可以需要表达式的地方同时执行多行代码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val hexNumberRegex = run &#123;</span><br><span class="line">    val digits = &quot;0-9&quot;</span><br><span class="line">    val hexDigits = &quot;A-Fa-f&quot;</span><br><span class="line">    val sign = &quot;+-&quot;</span><br><span class="line"></span><br><span class="line">    Regex(&quot;[$sign]?[$digits$hexDigits]+&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (match in hexNumberRegex.findAll(&quot;+1234 -FFFF not-a-number&quot;)) &#123;</span><br><span class="line">    println(match.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>apply</strong></p><p>上下文对象通过 this 表示，整个表达式的返回值为 上下文对象。</p><p>使用 apply 不会</p><ol><li>对象配置，不返回任何值，获取上下的成员。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val adam = Person(&quot;Adam&quot;).apply &#123;</span><br><span class="line">    age = 32</span><br><span class="line">    city = &quot;London&quot;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上下文对象作为返回对象，可以十分方便的引用到调用链上。</p><p><strong>also</strong></p><p>上下文对象使用 it 表示，整个表达式的返回值为 上下文对象。</p><ol><li>常用于不改变对象的其他操作，例如记录或打印调试信息，这样即使从调用链移除 also 也不会对逻辑造成影响。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">numbers</span><br><span class="line">    .also &#123; println(&quot;The list elements before adding new one: $it&quot;) &#125;</span><br><span class="line">    .add(&quot;four&quot;)</span><br></pre></td></tr></table></figure><p><strong>简单总结：</strong></p><ul><li>在非空对象上执行lambda：let</li><li>将表达式引入为局部作用域中的变量：let</li><li>对象配置：apply</li><li>对象配置和计算结果：run</li><li>需要表达式的运行语句：非扩展函数 run</li><li>附加效果：also</li><li>分组对对象的函数调用：with</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 also、let 的 Lambda 表达式内，it 代表接收者类型对象，而不像 《Kotlin 核心编程》 一书中所说的，this 代表接收者类型对象，而且在 also、let 中同时存在 this，并且通过 this 可以访问到外层变量，自己对此充满疑问，感觉书中对 this 为接收者对象的方法过于武断，查官方文档，十分幸运，正好有一篇关于此内容的文档，不过为英文，自己读了一遍，觉得在翻译此文在自己能力范围内，故做大致翻译，但是不会逐字翻译，得其大概即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title> Kotlin 核心编程(七):Kotlin 泛型，让类型更加安全</title>
    <link href="/2019/12/03/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%B8%83-Kotlin-%E6%B3%9B%E5%9E%8B/"/>
    <id>/2019/12/03/Kotlin-核心编程-七-Kotlin-泛型/</id>
    <published>2019-12-03T03:32:19.000Z</published>
    <updated>2020-02-26T07:43:21.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-为什么引入泛型？"><a href="#0x0001-为什么引入泛型？" class="headerlink" title="0x0001 为什么引入泛型？"></a>0x0001 为什么引入泛型？</h3><ul><li>泛型让类型更安全。</li></ul><p>有了泛型后，不仅可以在编译期进行类型检查，在运行时还会自动转型。</p><p><strong>使用泛型时是否可以主动的指定类型？</strong></p><p>在 Java 中这样是可以的：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br></pre></td></tr></table></figure><p>而 Kotlin 中这样是不可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样是不可以的</span><br><span class="line">val arrayList = ArrayList()</span><br></pre></td></tr></table></figure><p>为什么 Java 中是可以的，因为泛型是 Java1.5 时加入的，Java 为了 <strong>向前兼容</strong>，可以允许声明没有具体类型参数的泛型类，而 Kotlin 是基于 Java1.6 的，不存在兼容老版本的情况，所以是不可以的。</p><p>至于 Java 中如何使用泛型，请查看:<a href="https://www.jianshu.com/p/ff6618f7c840" target="_blank" rel="noopener">Java泛型初探一 之 泛型类 、泛型接口 、泛型方法</a>.</p><h3 id="0x0002-如何在-Kotlin-中使用泛型"><a href="#0x0002-如何在-Kotlin-中使用泛型" class="headerlink" title="0x0002 如何在 Kotlin 中使用泛型"></a>0x0002 如何在 Kotlin 中使用泛型</h3><p><strong>泛型类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Test&lt;T&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; show(data:T)&#123;..&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展函数支持泛型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun &lt;T&gt; ArrayList&lt;T&gt;.find(t: T): T? &#123;</span><br><span class="line">    val index = this.indexOf(t)</span><br><span class="line">    return if (index &gt;= 0) this.get(index) else null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val list = ArrayList&lt;String&gt;()</span><br><span class="line">    list.add(&quot;one&quot;)</span><br><span class="line">    println(list.find(&quot;one&quot;))</span><br><span class="line">    println(list.find(&quot;two&quot;).isNullOrEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-设定类型上限"><a href="#0x0003-设定类型上限" class="headerlink" title="0x0003 设定类型上限"></a>0x0003 设定类型上限</h3><p>上界约束表示方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 不可空</span><br><span class="line">class FuritPlant&lt;T : Furit&gt;(val t: T)</span><br><span class="line">// 可空</span><br><span class="line">class FuritPlantNullable&lt;T : Furit?&gt;(val t: T)</span><br><span class="line">// 使用 where 对泛型添加多个约束条件</span><br><span class="line">fun &lt;T&gt; cut(t:T) where T:Furit,T:Ground&#123;</span><br><span class="line">    println(&quot;i am on the ground fruit&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-泛型背后：类型擦除"><a href="#0x0003-泛型背后：类型擦除" class="headerlink" title="0x0003 泛型背后：类型擦除"></a>0x0003 泛型背后：类型擦除</h3><p>具体内容参见：<a href="https://leegyplus.github.io/2018/11/20/Java-%E6%B3%9B%E5%9E%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/" target="_blank" rel="noopener">Java 泛型:深入理解泛型的类型擦除</a></p><h3 id="0x0004-由类型擦除引起的问题-如何获取到参数类型"><a href="#0x0004-由类型擦除引起的问题-如何获取到参数类型" class="headerlink" title="0x0004 由类型擦除引起的问题:如何获取到参数类型?"></a>0x0004 由类型擦除引起的问题:如何获取到参数类型?</h3><p>一般情况下，我们不用在意类型是否被类型擦除了，但是在一些场景下，<strong>我们却需要知道运行时泛型参数的类型</strong>，比如序列化/反序列化、Gson 解析时，那如何获取呢？</p><p><strong>主动指定泛型参数类型</strong></p><p>Kotlin 和 Java 都是在编译后擦除泛型参数类型，那么我们是否可以 <strong>主动的指定参数类型</strong> 来达到运行时获取泛型参数的类型呢？答案是肯定的。</p><ol><li><strong>自定义类获得泛型参数类型</strong></li></ol><p>Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class One&lt;T&gt; &#123;</span><br><span class="line">    private Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    public One(T t, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        this.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void getType()&#123;</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        One&lt;String&gt; one = new One&lt;String&gt;(&quot;&quot;, String.class);</span><br><span class="line">        one.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OneKt&lt;T&gt;(val t:T,val clazz: Class&lt;T&gt;)&#123;</span><br><span class="line">    fun getType()&#123;</span><br><span class="line">        println(clazz)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val one = OneKt(&quot;&quot;,String::class.java)</span><br><span class="line">    one.getType()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 和 Java 都可以获得相应泛型参数类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure><p>但是这种方法只适用于自定义的泛型类，我们无法对三方库中的泛型类做如此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样是不被允许的</span><br><span class="line">val clazz = ArrayList&lt;String&gt;::class.java</span><br></pre></td></tr></table></figure><p>那么是否有其他方法可以获得类型参数？答案是可以的，通过匿名内部类：</p><ol start="2"><li><strong>通过匿名内部类获得泛型参数类型</strong></li></ol><p>具体示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Java </span><br><span class="line">ArrayList arrayList = new ArrayList&lt;String&gt;()&#123;&#125;;</span><br><span class="line">System.out.println(arrayList.getClass().getGenericSuperclass());</span><br><span class="line"></span><br><span class="line">// Kotlin</span><br><span class="line">val clazz = object :ArrayList&lt;String&gt;()&#123;&#125;// Kotlin 的匿名内部类</span><br><span class="line">println(clazz.javaClass.genericSuperclass)</span><br></pre></td></tr></table></figure><p>为什么可以通过匿名内部类可以在运行期获得泛型参数的类型呢？这是因为 <strong>泛型的类型擦除并不是完全的将所有信息擦除</strong>，而会 <strong>将类型信息放在所属 class 的常量池中</strong>，这样我们就可以通过相应的方式获得类型信息，而匿名内部类就可以实现这个功能。</p><p><a href="https://stackoverflow.com/questions/937933/where-are-generic-types-stored-in-java-class-files/937999#937999" target="_blank" rel="noopener">Java 将泛型信息存储在何处</a>：类信息的签名中。</p><p><strong>匿名内部类在初始化的时候就会绑定父类或者父接口的信息，这样就能通过获取父类或父接口的泛型类型信息，来实现我们的需求</strong>，可以通过利用此来设计一个获得所有类型信息的泛型类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">open class GenericsToken&lt;T&gt;&#123;</span><br><span class="line">    var type : Type = Any::class.java</span><br><span class="line">    init &#123;</span><br><span class="line">        val superClass = this.javaClass.genericSuperclass</span><br><span class="line">        type = (superClass as ParameterizedType).actualTypeArguments[0]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 创建一个匿名内部类</span><br><span class="line">    val oneKt = object:GenericsToken&lt;Map&lt;String,String&gt;&gt;()&#123;&#125;</span><br><span class="line">    println(oneKt.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map&lt;java.lang.String, ? extends java.lang.String&gt;</span><br></pre></td></tr></table></figure><p>至于如果获得参数化类型，可参见此博客：<a href="https://blog.csdn.net/datouniao1/article/details/53788018" target="_blank" rel="noopener">ParameterizedType应用，java反射，获取参数化类型的class实例</a></p><p>其实正是因为类型擦除的原因，在使用 Gson 反序列化对象的时候除了制定泛型参数，还需要传入一个 class ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123; </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Gson 没有办法根据 T 直接去反序列化，所以 Gson 也是使用了相同的设计，通过匿名内部类获得相应的类型参数，然后传到 fromJson 中进行反序列化。</p><p>看一下在 Kotlin 中我们使用 Gson 来进行泛型类的反序列化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val  json = &quot;....&quot;</span><br><span class="line">val rType = object: TypeToken&lt;List&lt;String&gt;&gt;()&#123;&#125;.type// 获得反序列化的数据类型</span><br><span class="line">val stringList = Gson().fromJson&lt;List&lt;String&gt;&gt;(json,rType)</span><br></pre></td></tr></table></figure><p>当然可以直接传输数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 存在局限，比如不能传入 List&lt;String&gt; 的数据类型</span><br><span class="line">val stringList = Gson().fromJson&lt;String::class.java&gt;(json,rType)</span><br></pre></td></tr></table></figure><p>在 Kotlin 中除了使用匿名内部类获得泛型参数外，还可以使用内联函数来获取。</p><ol start="3"><li><strong>使用内联函数获取泛型的参数类型</strong></li></ol><p>内联函数的特征：</p><p>内联函数(<code>inline</code>)在编译时会将具体的函数字节码插入调用的地方，类型插入相应的字节码中，这就意味着泛型参数类型也会被插入到字节码中，那么就可以实现在运行时就可以获得对应的参数类型了。</p><p>使用内联函数获取泛型的参数类型十分的简单，只要加上 <strong><code>reified</code></strong> 关键字，意思是：在编译时会将 <strong>具体的类型</strong> 插入到相应的字节码中，那么就可以获得对应参数的类型，与 Java 中的泛型在编译器进行类型擦除不同，Kotlin 中使用 <strong>reified</strong>  修饰泛型，<strong>该泛型类型信息不会被抹去</strong>，所以 Kotiln 中的该泛型为 <strong>真泛型</strong>。</p><blockquote><p><strong>reified</strong> 为 Kotlin 中的一个关键字，还有一个叫做 <strong>inline</strong>，后者可以将函数定义为内联函数，前者可以将内联函数的泛型参数当做真实类型使用.</p></blockquote><p>可以借此来为 Gson 定义一个扩展函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;reified T</span><br><span class="line">: Any&gt; Gson.fromJson(json: String): T&#123; </span><br><span class="line">     return fromJson(json, T::class.java) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有了此扩展方法，就无须在 Kotlin 当中显式的传入一个 class 对象就可以直接反序列化 json 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(var id: Int, var name: String) </span><br><span class="line">　 </span><br><span class="line">fun test()&#123; </span><br><span class="line">    val person: Person = Gson().fromJson&lt;User&gt;(&quot;&quot;&quot;&#123;&quot;id&quot;: 0, &quot;name&quot;: &quot;Jack&quot; &#125;&quot;&quot;&quot;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Gson.fromJson</code> 是内联函数，方法调用时插入调用位置，T 的类型在编译时就可以确定了，反编译之后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final void test() &#123; </span><br><span class="line">  Gson $receiver$iv = new Gson(); </span><br><span class="line">  String json$iv = &quot;&#123;\&quot;id\&quot;: 0, \&quot;name\&quot;: \&quot;Jack\&quot; &#125;&quot;; </span><br><span class="line">  Person person = (Person)$receiver$iv.fromJson(json$iv, Person.class); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 Kotin 的泛型被称为 <strong>真泛型</strong> 的原因。</p><p>但是 refied 存在一个问题：<code>reified</code> 只能修饰方法，而当定义一个泛型类时，reified 是无法通过类似以上的方式获得泛型参数的，但是仍然可以通过其他方式获得泛型类中的泛型参数类型，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class View&lt;T&gt;(val clazz:Class&lt;T&gt;)&#123;</span><br><span class="line">    val presenter by lazy &#123; clazz.newInstance() &#125;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        // 在构造函数执行之前，执行了此处，真泛型的重载函数。</span><br><span class="line">        inline operator fun &lt;reified T&gt; invoke() = View(T::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Presenter</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 两者等效，具体实现如下</span><br><span class="line">    val p = View&lt;Presenter&gt;().presenter</span><br><span class="line">    val a  = View.Companion.invoke&lt;Presenter&gt;().presenter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法特别适合在 android 中的 MVP，不用再在 Activity 中显式的显示 Presenter 的类名。</p><p><strong>实现一个 Android MVP 框架</strong></p><p>Model 层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class User(var id: Int, var name: String)</span><br></pre></td></tr></table></figure><p>Presenter 层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IPresenter &#123;</span><br><span class="line">    fun doLogin(): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IView &#123;</span><br><span class="line">    fun getLayoutID(): Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 第一种方式，通过动态代理 by </span><br><span class="line">class MainActivity : AppCompatActivity(),</span><br><span class="line">        IView by MVPView(), IPresenter by EmptyPresenter() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(getLayoutID())</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            getPresenter&lt;EmptyPresenter&gt;().doLogin()</span><br><span class="line">                // 第一种方法，通过动态代理，可以直接调用 EmptyPresenter 的方法</span><br><span class="line">               doLogin() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EmptyPresenter : IPresenter &#123;</span><br><span class="line">    override fun doLogin(): User &#123;</span><br><span class="line">        //执行各种逻辑</span><br><span class="line">        return User(1, &quot;zhangtao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MVPView : IView &#123;</span><br><span class="line">    override fun getLayoutID() = R.layout.activity_main</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">open class BaseActivity&lt;T&gt;(val clazz: Class&lt;T&gt;) : AppCompatActivity() &#123;</span><br><span class="line">    val presenter by lazy &#123; clazz.newInstance() &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        inline operator fun &lt;reified T&gt; invoke() = BaseActivity(T::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainActivity : BaseActivity&lt;EmptyPresenter&gt;(EmptyPresenter::class.java),</span><br><span class="line">    IView by MVPView() &#123;</span><br><span class="line">    </span><br><span class="line">    // 删除  getPresenter 的逻辑</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(getLayoutID())</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            // 直接获得 present 对象</span><br><span class="line">            presenter.doLogin()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EmptyPresenter : IPresenter &#123;</span><br><span class="line">    override fun doLogin(): User &#123;</span><br><span class="line">        //执行各种逻辑</span><br><span class="line">        return User(1, &quot;zhangtao&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方式：</p><p>如果不想继承 BaseActivity，则可以按照下面的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity(),</span><br><span class="line">    IView by MVPView() &#123;</span><br><span class="line"></span><br><span class="line">    inline fun &lt;reified T : IPresenter&gt; getPresenter(): T &#123;</span><br><span class="line">        return T::class.java.newInstance()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(getLayoutID())</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.button).setOnClickListener &#123;</span><br><span class="line">            getPresenter&lt;EmptyPresenter&gt;().doLogin()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-Kotlin-型变"><a href="#0x0005-Kotlin-型变" class="headerlink" title="0x0005 Kotlin 型变"></a>0x0005 Kotlin 型变</h3><h4 id="Java-中的型变"><a href="#Java-中的型变" class="headerlink" title="Java 中的型变"></a>Java 中的型变</h4><p><code>? extends E</code>其实就是使用 <strong>点协变</strong>，允许传入的参数可以是 <strong>E及其子类</strong> 的任意类型。</p><p><code>? super E</code>使用 <strong>点逆变</strong>，这表示元素类型 <strong>为 E 及其父类</strong>，这个通常也叫作逆变。</p><p>型变包括 协变、逆变、不变 三种。</p><p><strong>为什么 Java 中 List 是不变的 ?</strong></p><p>List<string> 是不能赋值给 List<object> 的，这是因为 List 是不变的，即两者没有任何关系，我们可以使用反证法来说明：</object></string></p><p>假设 List<string> 可以赋值给 List<object>,那么将会出现以下情况：</object></string></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Object&gt; objList = stringList;// 假设这样是可以的</span><br><span class="line">objList.add(Integer(1));</span><br><span class="line">String str = stringList.get(0);// 将会出错，所以假设错误</span><br></pre></td></tr></table></figure><p>如果假设成立的话，那么 List 将不再保证类型安全，而 Java 设计师明确保证泛型的最基本原则就是保证类型安全，所以不支持这种行为。</p><p><strong>为什么 Kotlin 中的 List 支持协变？</strong></p><p>在 Kotlin 中是允许 List<string> 赋值给 List<any> 的，这是因为 Java 和 Kotlin 中的 List 不是同一个，在 Kotlin 中重新定义了 List 接口，具体如下：</any></string></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 关键字 out </span><br><span class="line">public interface List&lt;out E&gt; : Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，如果定义的泛型类和泛型方法的泛型参数前面加上 <strong>out 关键字</strong>，那么就说明这个泛型和泛型方法是协变的，说明这是一个 <strong>只读列表</strong>。</p><p>在 Java 中也可以声明泛型协变，用通配符及泛型上界来实现协变：&lt; ? extend Object&gt; 一样。因为这个 List 是协变的，所以它将 <strong>无法添加元素，只能从里面获取元素</strong> ,要验证此结论，同样我们可以使用反证法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val stringList: List&lt;String&gt; = ArrayList&lt;String&gt;()</span><br><span class="line">val anyList: List&lt;Any&gt; = stringList</span><br><span class="line">anyList.add(1)</span><br><span class="line">val str:String = anyList.get(0)// 无法转换成 String，同样违背了泛型类型安全的原则</span><br></pre></td></tr></table></figure><p><strong>同时，假如一个泛型类 Generic<out t> 支持协变，那么它里面方法的参数不能使用 T 类型，因为一个方法的参数不能使用传入参数父类型的对象</out></strong>，因此，使用该关键字的泛型类，可以叫做一个 <strong>可读、可写功能受限的类型</strong>。</p><p><strong>Kotlin 中的逆变</strong></p><p>在 Kotlin 中存在 <code>in</code> 关键字，它使泛型有了另一个特性：<strong>逆变</strong>。何为逆变？逆变就是：类型 A 是类型 B 的子类型，那么 <code>Generics&lt;B&gt;</code> 反过来是 <code>Generics&lt;A&gt;</code> 的子类型。与 out 相反，使用该关键字的泛型类，可以看做一个 <strong>可写、可读功能受限的类型</strong>。</p><p>表示支持逆变的泛型类：</p><p><code>Generic&lt;in T&gt;</code></p><p><strong>型变的使用</strong></p><p>假设有这么一个场景：将 Double 的数组拷贝到另一个 Double 的数组上，具体试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun copy(dest:Array&lt;Double&gt;,src:Array&lt;Double&gt;)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数只能满足拷贝 Double 的数据类型，如果是 String 的话，又要重新写一个方法，学过了泛型就利用起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; copy(dest:Array&lt;T&gt;,src:Array&lt;T&gt;)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们要把 Array<double> 拷贝到 Array<number> 呢？上面的方法不可以了，学习了型变以后，用起来：</number></double></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//in 版本</span><br><span class="line">fun &lt;T&gt; copy(dest:Array&lt;in T&gt;,src:Array&lt;T&gt;)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">// out 版本</span><br><span class="line">fun &lt;T&gt; copy(dest:Array&lt;T&gt;,src:Array&lt;out T&gt;)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>注意 in 和 out 的位置，修饰不同的类型参数。</p><p>Kotlin 和 Java 中的型变对比</p><table><thead><tr><th></th><th>协变</th><th>逆变</th><th>不变</th></tr></thead><tbody><tr><td>Kotlin</td><td>实现方式：<code>&lt;out T&gt;</code>，只能作为消费者，只能读取不能添加</td><td>实现方式：<code>&lt;in T&gt;</code>，只能作为生产者，只能添加，不能读取</td><td>实现方式: <code>&lt;T&gt;</code> ,既可以添加，也可以读取</td></tr><tr><td>Java</td><td>实现方式：&lt;? extends T&gt;，只能作为消费者，只能读取不能添加</td><td>实现方式：&lt;? super T&gt;,只能作为生产者，只能添加，不能读取</td><td>同上</td></tr></tbody></table><h3 id="0x0006-Kotlin-中的通配符"><a href="#0x0006-Kotlin-中的通配符" class="headerlink" title="0x0006 Kotlin 中的通配符"></a>0x0006 Kotlin 中的通配符</h3><p>与 Java 中的通配符表示方法为 <strong>问号(?)</strong> 不同，Kotlin 中表示方法 <strong>星号(*)</strong>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val list:MutableList&lt;*&gt; = mutableListOf(1,&quot;test&quot;)</span><br><span class="line">list.add(2)// 出错</span><br></pre></td></tr></table></figure><p>以上代码出错，根据通配符的含义 list 不是应该可以添加任意元素吗？</p><p>其实不是这样的，<code>MutableList&lt;*&gt;</code> 与 <code>MutableList &lt;Any?&gt;</code> 不同，后者可以添加任意元素，<strong>而前者只能匹配某一种类型</strong>，但是编译器不知道是一种什么样的类型，所以它不允许添加元素，和泛型协变类似，其实通配符是一种语法糖，背后也是通过协变来实现的，所以MutableList&lt;*&gt; 本质上是 <code>MutableList &lt;out Any?&gt;</code> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-为什么引入泛型？&quot;&gt;&lt;a href=&quot;#0x0001-为什么引入泛型？&quot; class=&quot;headerlink&quot; title=&quot;0x0001 为什么引入泛型？&quot;&gt;&lt;/a&gt;0x0001 为什么引入泛型？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;泛型让类型更安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了泛型后，不仅可以在编译期进行类型检查，在运行时还会自动转型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用泛型时是否可以主动的指定类型？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中这样是可以的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="泛型" scheme="/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(六):空安全</title>
    <link href="/2019/12/02/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%85%AD/"/>
    <id>/2019/12/02/Kotlin-核心编程-六/</id>
    <published>2019-12-02T10:53:55.000Z</published>
    <updated>2019-12-03T04:39:40.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-Java-中存在歧义的-null"><a href="#0x0001-Java-中存在歧义的-null" class="headerlink" title="0x0001 Java 中存在歧义的 null"></a>0x0001 Java 中存在歧义的 null</h3><p>null 含义：</p><ul><li>该值未初始化</li><li>该值不合法</li><li>该值不需要</li><li>该值不存在</li></ul><h3 id="0x0002-难以控制的-NPE"><a href="#0x0002-难以控制的-NPE" class="headerlink" title="0x0002 难以控制的 NPE"></a>0x0002 难以控制的 NPE</h3><p>在 Java 中任何对象引用都可以为 null，而当调用为 null 对象的方法时，将产生 NPE，最终导致的是：编译顺畅通过，但是运行代码时却产生了 NPE。</p><!-- mores --><p>比如此种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">System.out.println(name.length());</span><br></pre></td></tr></table></figure><p>而我们只能通过一些判空代码进行避免，但是往往将 null 和空字符串混为一谈，违背了业务初衷，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">if(name != null || (&quot;&quot;).equal.(name))&#123;</span><br><span class="line">    System.out.println(name.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-可空类型"><a href="#0x0003-可空类型" class="headerlink" title="0x0003 可空类型"></a>0x0003 可空类型</h3><p>Kotlin 在类型层面提供了空类型，以此来解决由 null 引发的问题。</p><p><strong>Java8 中的 Optional</strong></p><p>对于不确定是否存在的属性，可以使用 Optional 来封装。</p><p>但是 Optional 的耗时大约是普通判空的十倍，原因是 Optional<t> 是一个包含类型 T 引用的泛型类，在使用时多个创建一个对象，在数据量比较大的时候，频繁实例化造成很大的性能损失。</t></p><p><strong>Kotlin 中的可空类型</strong></p><p>而 Kotlin 中处理 NPE 问题十分容易。</p><p>Java 中存在 Optional 包装类，而 Kotin 中可空类型使用 <code>类型？</code> 表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name:String? = null</span><br></pre></td></tr></table></figure><p><strong>Kotlin 中的安全调用 ?.</strong></p><p>在 Java 这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(name != null)&#123;</span><br><span class="line">    sout(name.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sout(&quot;$&#123;name?.length&#125;&quot;)</span><br></pre></td></tr></table></figure><p><code>?.</code> 称为 <strong>安全调用</strong>，只有当 name 存在时才会调用 name.length。</p><p><strong>Kotlin 中的 Elvis 操作符 ?:</strong></p><p><code>?:</code> 左侧为 null 时，则执行其右侧值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val num = name?.length?:-1</span><br><span class="line">println(num)</span><br></pre></td></tr></table></figure><p><code>?:</code> 左侧不仅可以是语句还可以是表达式或者函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val type = getType() ?: getDefaultType()</span><br><span class="line">println(type)</span><br><span class="line">val type2 = getType() ?: &quot;Default: $&#123;type?.length&#125;&quot;</span><br><span class="line">println(type2)</span><br></pre></td></tr></table></figure><p>Kotlin 如今实现类型的空安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun test301(name: String? ) &#123;</span><br><span class="line">    println(name?.length)</span><br><span class="line">&#125;</span><br><span class="line">// 编译后的 Java 代码</span><br><span class="line">public static final void test301(@Nullable String name) &#123;</span><br><span class="line">    Integer var1 = name != null ? name.length() : null;</span><br><span class="line">    boolean var2 = false;</span><br><span class="line">    System.out.println(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实Kotlin 最终的空安全还是靠 if-else 进行判断。</p><p><strong>非空断言 !!.</strong></p><p>类比 Java 中 Assert(断言)，对象为空时，抛出 NPE 异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val len = name!!.length</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x0001-Java-中存在歧义的-null&quot;&gt;&lt;a href=&quot;#0x0001-Java-中存在歧义的-null&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Java 中存在歧义的 null&quot;&gt;&lt;/a&gt;0x0001 Java 中存在歧义
      
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(五)：面向对象</title>
    <link href="/2019/11/25/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%BA%94/"/>
    <id>/2019/11/25/Kotlin-核心编程-五/</id>
    <published>2019-11-25T10:32:02.000Z</published>
    <updated>2019-11-25T12:48:18.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-Kotlin-中的类"><a href="#0x0001-Kotlin-中的类" class="headerlink" title="0x0001 Kotlin 中的类"></a>0x0001 Kotlin 中的类</h3><p>Kotlin 中类与 Java 中的几点不同:</p><ul><li>在 Kotlin 中除非显示声明延时初始化，那么属性需要显式的指定默认值。</li><li>val 为不可变属性</li><li>修饰符的访问权限不同，Kotlin 默认全局可见， Java 默认包可见。</li><li>在接口中，不可为属性初始化值( Kotlin 接口中抽象属性，背后通过方法实现)</li></ul><h3 id="0x0002-Koltlin-中的接口"><a href="#0x0002-Koltlin-中的接口" class="headerlink" title="0x0002 Koltlin 中的接口"></a>0x0002 Koltlin 中的接口</h3><p>在 Kotlin 中，接口可以拥有属性和默认方法：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IShow&#123;</span><br><span class="line">    val value:Int</span><br><span class="line">    fun show()</span><br><span class="line">    fun test()&#123;</span><br><span class="line">        println(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface IShow &#123;</span><br><span class="line">   int getValue();</span><br><span class="line">   void show();</span><br><span class="line">   void test();</span><br><span class="line">   public static final class DefaultImpls &#123;</span><br><span class="line">      public static void test(IShow $this) &#123;</span><br><span class="line">         String var1 = &quot;test&quot;;</span><br><span class="line">         boolean var2 = false;</span><br><span class="line">         System.out.println(var1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 接口中的属性其实是通过方法来实现的，而方式是基于静态内部类实现的，由于 Kotlin 是基于 Java6 的，而在 Java 6 中接口是不支持默认方法的，所以在 Kotlin 中接口不支持对属性进行赋值以及默认方法的实现，满满的语法糖既视感。</p><h3 id="0x0003-类的构造方法"><a href="#0x0003-类的构造方法" class="headerlink" title="0x0003 类的构造方法"></a>0x0003 类的构造方法</h3><p><strong>1. 主从构造方法</strong></p><p>在类外部定义的构造方法称为 <code>主构造方法</code>，在类内部通过 <code>constructor</code> 定义的方法称为 <code>从构造方法</code>。如果主构造方法存在注解或者可见修饰符，那么需要添加 constructor 关键字。</p><p>从构造器由两部分组成：</p><ol><li>对其他构造方法的委托(必须要有的)。</li><li>{} 内部包裹的代码块。</li></ol><p>$如果一个类存在主构造方法，那么所有的从构造方法需要直接或间接的委托给它，执行顺序是为先执行委托的方法，然后执行自身代码块的逻辑。$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog(val country: String) &#123;</span><br><span class="line">    var telNum: Int? = 0</span><br><span class="line">    constructor(tel: Int, country: String) : this(country) &#123;</span><br><span class="line">        telNum = tel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    val dog = Dog(123,&quot;China&quot;)</span><br><span class="line">    println(&quot;dog`s tel num is $&#123;dog.telNum&#125;, country is $&#123;dog.country&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 为构造器参数指定默认值</strong></p><p>在 Kotlin 中可以给构造函数的参数指定默认值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Bird(val color:String = &quot;white&quot;, val age : Int = 1)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类初始化时可以指定其参数名，或者按照参数的顺序赋值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val  bird = Bird(age = 3,color =  &quot;red&quot;)</span><br><span class="line">或者</span><br><span class="line">val  bird = Bird( &quot;red&quot;,3)</span><br></pre></td></tr></table></figure><p><strong>3. 为构造器参数添加修饰符</strong></p><p>使用 val 或者 var 声明构造方法的参数，有两个作用：</p><ul><li>代表参数的引用可变性，var 可变，val 不可变。</li><li>简化构造类中语法。</li></ul><p>至于怎样简化，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Bird(val color:String = &quot;white&quot;, val age : Int = 1)&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">// 与下面的写法等效，很明显上面写法简洁</span><br><span class="line">class Bird( color:String = &quot;white&quot;,  age : Int = 1)&#123;</span><br><span class="line">    private val color: String</span><br><span class="line">    private val age: Int</span><br><span class="line">    init &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">        this.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. init 代码块</strong></p><p><strong>当构造方法的参数没有 val 或者 var 时，构造方法的参数可以在 init 语句中使用，除了 init 代码块，此时构造方法中的参数不可以在其他位置使用</strong>。</p><p>Kotlin 中规定类中的所有非抽象属性成员必须在对象创建时被初始化,但是可以在声明val 属性时不赋值，但是在 init 代码块中进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bird( color:String = &quot;white&quot;,  age : Int = 1)&#123;</span><br><span class="line">    private val color: String</span><br><span class="line">    private val age: Int</span><br><span class="line">    init &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">        this.color = color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以拥有多个 init 代码块，执行顺序：自上而下，多个 init 代码块可以将初始化的操作进行智能分离，在复杂业务时使逻辑更加清晰。</p><h3 id="0x0004-属性的延迟初始化"><a href="#0x0004-属性的延迟初始化" class="headerlink" title="0x0004 属性的延迟初始化"></a>0x0004 属性的延迟初始化</h3><p>延迟初始化的属性，可以在对象初始化时不必有值。</p><p><strong>1. by lazy</strong></p><p>可以使用 <code>by lazy</code> 修饰 val 声明的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">    val name by lazy &#123; </span><br><span class="line">        &quot;Ni&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首次调用时，才会进行赋值操作，一旦赋值，后续将不能更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public actual fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value</span><br></pre></td></tr></table></figure><p>lazy 的背后是接受一个 Lambda 表达式，并且返回一个 Lazy<t> 实例的函数，第一次调用该属性时，会执行 lazy 对应 Lambda 表达式并记录，后续访问该属性会返回记录的结果。</t></p><p>默认系统会为 lazy 属性加上同步锁 - LazyThreadSafetyMode.SYNCHRONIZED，同一时刻只有一个线程可以对 lazy 的属性进行初始化，为线程安全的。同时 lazy 可以指定其他线程参数，以此来满足需求。如果能够确保可以并行执行，可以给 lazy 传递其他线程参数。</p><p><strong>2. lateinit</strong></p><p>lateinit 主要用于声明 var 变量，<strong>不能用于基本数据类型</strong>，如 Int 等，如果需要的话，使用 Interger 等包装类替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">    lateinit var color: String</span><br><span class="line"></span><br><span class="line">    fun printColor(newColor: String) &#123;</span><br><span class="line">        color = newColor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-类的访问修饰符权限"><a href="#0x0005-类的访问修饰符权限" class="headerlink" title="0x0005 类的访问修饰符权限"></a>0x0005 类的访问修饰符权限</h3><ul><li><p>Kotlin 中类和方法默认修饰符是 final，默认是不被继承或重写的，如果有这样的需求，必须添加 open 修饰符。</p></li><li><p>Kotlin 的默认修饰符为 public，Java 为 default。</p></li><li><p>Kotlin 独特的修饰符：internal。</p></li><li><p>Kotlin 和 Java 的 protected 的访问权限不同，Java 中是包、子类可访问，而 Kotlin 中只允许子类访问。</p></li></ul><p>internal 修饰符的作用域是模块内可见，那么在 Kotlin 中模块是什么？<br>一个模块可以看成是一起编译的 Kotlin 文件组成的集合。</p><table><thead><tr><th>修饰符</th><th>Kotlin 中含义</th><th>Java 中含义</th></tr></thead><tbody><tr><td>public</td><td>Kotlin 的默认修饰符，全局可见</td><td>与Java 中public 效果相同</td></tr><tr><td>protected</td><td>受保护的修饰符，类及子类可见</td><td>含义一致，但是访问权限为类、子类、包</td></tr><tr><td>private</td><td>私有修饰符，类内修饰只有本类可见，类外修饰本文件可见</td><td>私有修饰符，本类可见</td></tr><tr><td>internal</td><td>模块可见</td><td>无</td></tr></tbody></table><h3 id="0x0006-密闭类"><a href="#0x0006-密闭类" class="headerlink" title="0x0006 密闭类"></a>0x0006 密闭类</h3><p>Kotlin 中除了使用 final 来限制类的继承外，还可以使用密闭类来限制一个类的继承。</p><p>Kotlin 通过 sealed 关键字来修饰一个类为密闭类，若要继承密闭类，<strong>则子类只能定义在同一个文件中(文件内或者本类内)</strong>，其他文件无法继承它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sealed class Animal&#123;</span><br><span class="line">    abstract fun eat()</span><br><span class="line"></span><br><span class="line">    fun breath()&#123;</span><br><span class="line">        println(&quot;I can breath.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    class Cat:Animal() &#123;</span><br><span class="line">        override fun eat() &#123;</span><br><span class="line">            println(&quot;I eat mouse&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish: Animal()&#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;I drink water&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>密闭类可以看成一个功能强大的枚举类。</p><h3 id="0x0007-Kotlin-中的多继承问题"><a href="#0x0007-Kotlin-中的多继承问题" class="headerlink" title="0x0007 Kotlin 中的多继承问题"></a>0x0007 Kotlin 中的多继承问题</h3><p><strong>1. 多继承中存在的钻石问题</strong></p><p>Java 中的类时不支持多继承的，但是可以通过接口实现多继承，但是此方式存在一个缺陷：当多个类中存在同一个方法时，那么无法完成实现的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    void eat();</span><br><span class="line">    default void kind()&#123;</span><br><span class="line">        System.out.println(&quot;i am animal&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Flyer &#123;</span><br><span class="line">    void fly();</span><br><span class="line">    default void kind()&#123;</span><br><span class="line">        System.out.println(&quot;i am flyer&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于Flyer,Animal存在相同的默认方法，所以 Bird 无法定义</span><br><span class="line">public class Bird implements Flyer,Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 Kotlin 中通过一些写法支持这样的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface Flyer &#123;</span><br><span class="line">    fun fly()</span><br><span class="line">    fun kind() &#123;</span><br><span class="line">        println(&quot;i am flyer&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Animal &#123;</span><br><span class="line">    fun eat()</span><br><span class="line">    fun kind() &#123;</span><br><span class="line">        println(&quot;i can animal&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird : Flyer, Animal &#123;</span><br><span class="line">    override fun fly() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以通过 super 关键字指定继承哪个父类的方法</span><br><span class="line">    override fun kind() = super&lt;Flyer&gt;.kind()</span><br><span class="line">//同时也可以主动重写</span><br><span class="line">//    override fun kind() &#123;</span><br><span class="line">//        println(&quot;i am bird&quot;)</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 内部类解决多继承的问题</strong></p><blockquote><p>嵌套类和内部类：嵌套类包括静态内部类和非静态内部类，而非静态内部类被称为内部类，内部类持有外部类的引用。</p></blockquote><p>在 Kotlin 中使用 <code>inner</code> 标记一个类为 <strong>内部类</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    class Nested &#123;</span><br><span class="line">        fun foo() = 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Outer2 &#123;</span><br><span class="line">    private val bar: Int = 1</span><br><span class="line">    inner class Inner &#123;</span><br><span class="line">        fun foo() = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class Outer &#123;</span><br><span class="line">   private final int bar = 1;</span><br><span class="line">   // 没有使用　inner 修饰的类，会被编译成静态内部类</span><br><span class="line">   public static final class Nested &#123;</span><br><span class="line">      public final int foo() &#123;</span><br><span class="line">         return 2;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final class Outer2 &#123;</span><br><span class="line">   private final int bar = 1;</span><br><span class="line">   // 使用　inner 修饰的类，会被编译成内部类</span><br><span class="line">   public final class Inner &#123;</span><br><span class="line">      public final int foo() &#123;</span><br><span class="line">         return Outer2.this.bar;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可以使用　private　修饰内部类，这样其他类就不能访问该内部类，具有很好的封装性。</p><p>使用内部类实现多继承：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">open class Horse&#123;</span><br><span class="line">    fun runFast()&#123;</span><br><span class="line">        println(&quot;run fast&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        println(&quot;horse eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class Donkey&#123;</span><br><span class="line">    fun doLongTimeThing()&#123;</span><br><span class="line">        println(&quot;do longtime thing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        println(&quot;donkey eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mule&#123;</span><br><span class="line">    fun runFast()&#123;</span><br><span class="line">        HorseC().runFast()</span><br><span class="line">    &#125;de</span><br><span class="line"></span><br><span class="line">    fun doLongTimeThing()&#123;</span><br><span class="line">        DonkeyC().doLongTimeThing()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private inner class HorseC:Horse()</span><br><span class="line">    private inner class DonkeyC:Donkey()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在　Mule　中定义两个内部类分别继承　Horse 和 Donkey，那么 Mule 可以通过内部类访问 Horse 和 Donkey 的特性，在一定程度上能够达到继承的效果。</p><p><strong>3. 使用委托代替多继承</strong></p><blockquote><p>什么是委托？委托是一种特殊的类型，用于方法事件de委托，比如你调用 A 类的 methodA 方法，其实背后是 B 类的 methodB 方法，在 Java 中有静态委托和动态委托。</p></blockquote><p>在 Kotlin 中可以使用关键字 <code>by</code> 来实现委托的效果，比如 by lazy 为通过委托实现延时初始化。</p><p>使用 Kotlin 中的类委托实现多继承的需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface CanFly&#123;</span><br><span class="line">    fun fly()</span><br><span class="line">&#125;</span><br><span class="line">interface CanEat&#123;</span><br><span class="line">    fun eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class Flyer:CanFly&#123;</span><br><span class="line">    override fun fly() &#123;</span><br><span class="line">        println(&quot;can fly&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open class Animal:CanEat&#123;</span><br><span class="line">    override fun eat() &#123;</span><br><span class="line">        println(&quot;can eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird(flyer: Flyer,animal: Animal):CanEat by animal,CanFly by flyer&#123;</span><br><span class="line">    fun main(args:Array&lt;String&gt;)&#123;</span><br><span class="line">        val flyer = Flyer()</span><br><span class="line">        val animal = Animal()</span><br><span class="line">        val bird = Bird(flyer,animal)</span><br><span class="line">        bird.fly()</span><br><span class="line">        bird.eat()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <strong>类委托</strong>，则委托类(Bird)拥有了和被委托类(Flyer、Animal)一样的状态和属性，在一定程度上实现了多继承的效果。</p><h3 id="0x0008-数据类"><a href="#0x0008-数据类" class="headerlink" title="0x0008 数据类"></a>0x0008 数据类</h3><p>通过 <strong>data</strong> 关键字实现数据类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Student(val name:String,var age:Int)</span><br></pre></td></tr></table></figure><p>反编译 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final class Student &#123;</span><br><span class="line">   @NotNull</span><br><span class="line">   private final String name;</span><br><span class="line">   private int age;</span><br><span class="line"></span><br><span class="line">   @NotNull</span><br><span class="line">   public final String getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int getAge() &#123;</span><br><span class="line">      return this.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void setAge(int var1) &#123;</span><br><span class="line">      this.age = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Student(@NotNull String name, int age) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);</span><br><span class="line">      super();</span><br><span class="line">      this.name = name;</span><br><span class="line">      this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @NotNull</span><br><span class="line">   public final String component1() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int component2() &#123;</span><br><span class="line">      return this.age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @NotNull</span><br><span class="line">   public final Student copy(@NotNull String name, int age) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, &quot;name&quot;);</span><br><span class="line">      return new Student(name, age);</span><br><span class="line">   &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数据类的规则：</p><ul><li>数据类必须有一个构造函数，并且构造函数中至少包括一个参数。</li><li>数据类构造函数的参数必须使用 var 或者 val 修饰。</li><li>data class 不能用 abstract、open、sealed、inner 修饰。</li><li>数据类可以实现接口，也可以继承类。</li></ul><p>可以发现最终还是像 JavaBean 中一样实现 getter/setter 方法，重写 hashCode、equal 等方法，但是其中的存在的 copy、componentN 是我们从来没见过的。</p><p><strong>1.copy、componentN 与解构</strong></p><p>通过反编译的代码我们可以知道 copy 方法主要是帮我们从一个已有对象拷贝一个新的数据类对象，其中需要重点关注的是这里的拷贝是 <strong>浅拷贝</strong>，注意其使用场景。</p><p>copy 的使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun testMethod()&#123;</span><br><span class="line">    val student = Student(&quot;小明&quot;,3)</span><br><span class="line">    //因为 val 为不可变量，所以不能通过以下方式进行浅拷贝，而 copy 提供了一种简洁的方式进行浅拷贝，</span><br><span class="line">    //但是通过反编译的代码我们可以其实现原理，所以 copy 是一种语法糖，但在 Kotlin 中有哪些特性不是语法糖呢？</span><br><span class="line">//    val student3 = student</span><br><span class="line">//    student3.name = &quot;小明&quot;</span><br><span class="line">    val student2 = student.copy(name = &quot;小刚&quot;,age = 3)</span><br><span class="line">    val student4 = student.copy(name = &quot;小刚&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 componentN 方法，componentN 可以理解为类属性的值，而 <strong>N 代表属性的声明顺序</strong>，比如上例中 方法，component1 代表 name 的属性值，而 component2 代表 age 的属性值。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun testTwo()&#123;</span><br><span class="line">    val student = Student(&quot;小明&quot;,3)</span><br><span class="line">    val name = student.name</span><br><span class="line">    val age = student.age</span><br><span class="line">    // 使用 Kotlin </span><br><span class="line">    val(name2,age2)= student</span><br><span class="line">    // 更可以这样使用，一次性实现多个属性赋值</span><br><span class="line">    val str= &quot;nike,2,10086&quot;</span><br><span class="line">    val(tag,num,phone) = str.split(&quot;,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上能够实现原因就是 <strong>解构</strong>，通过编译器的约定实现解构。在数据类中，可以直接使用编译器自动生成的 componentN 方法，也可以自己实现对应属性的 componentN 方法，为上例中的 Student 数据类添加自定义 componentN 方法，该方法需要使用 <strong>operator</strong> 修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data class Student(val name: String, var age: Int) &#123;</span><br><span class="line">    var phoneNum = 110</span><br><span class="line">    operator fun component3() = phoneNum</span><br><span class="line"></span><br><span class="line">    constructor(name: String, age: Int, phoneNum: Int) : this(name, age) &#123;</span><br><span class="line">        this.phoneNum = phoneNum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun testThree() &#123;</span><br><span class="line">    val student = Student(&quot;mike&quot;, 2, 10087)</span><br><span class="line">    var (name, age, phoneNum) = student</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了数据类外，数组也支持解构，不过其默认最多允许赋值 5 个变量，若变量过多，反而适得其反，但是可以通过扩展实现多余 5 的变量的赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 为 Array&lt;T&gt; 扩展解构函数</span><br><span class="line">operator fun &lt;T&gt; Array&lt;T&gt;.component6(): T &#123;</span><br><span class="line">    return this[5]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val array = arrayOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">    val (a, b, c) = array</span><br><span class="line">    println(&quot;$a $b $c&quot;)</span><br><span class="line">    // 通过扩展方法扩大解构个数</span><br><span class="line">    val list = arrayOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)</span><br><span class="line">    val (one, two, three, four, five, six) = list</span><br><span class="line">    println(&quot;$one $two $three $four $five $six&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 系统定义的其他支持解构的数据类：Pair、Triple</strong></p><ul><li><p>Pair</p><p>Pair 为二元组，代表这个数据类有两个属性。</p></li><li><p>Triple </p></li></ul><p>Triple为三元组，代表这个数据类有三个属性。</p><p>两者的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public data class Pair&lt;out A, out B&gt;(</span><br><span class="line">    public val first: A,</span><br><span class="line">    public val second: B</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">public data class Triple&lt;out A, out B, out C&gt;(</span><br><span class="line">    public val first: A,</span><br><span class="line">    public val second: B,</span><br><span class="line">    public val third: C</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun testFive()&#123;</span><br><span class="line">    val pair = Pair(&quot;Name&quot;,3)</span><br><span class="line">    val triple = Triple(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;)</span><br><span class="line">    val name = pair.first</span><br><span class="line">    val age = pair.second</span><br><span class="line">    val(one,two,three) = triple</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0009-Object-关键字"><a href="#0x0009-Object-关键字" class="headerlink" title="0x0009 Object 关键字"></a>0x0009 Object 关键字</h3><p>在 Kotlin 中没有 static 关键字，使用全新的 object 关键字，可以替代 static 所有的场景，object 除了替代 static 的关键字之外，还有其他很多功能，比如单例对象、简化匿名表达式。</p><p><strong>1. 伴生对象</strong></p><p>针对 Java 中的 static，Kotin 中引入了 companion object 关键字。companion object 意为 伴生对象，所谓 伴生 意为伴随着某个类，伴生对象即为伴随着某个类产生的对象，所以伴生对象属于类，和 Java 中的 static 关键字是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        val MEAL = 1</span><br><span class="line">        val FEMEAL = 2</span><br><span class="line">        fun play()&#123;</span><br><span class="line">            println(&quot;i am play&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(Cat.FEMEAL)</span><br><span class="line">    Cat.play()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 天生的单例：object</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object Config&#123;</span><br><span class="line">    var host:String = &quot;localhost&quot;</span><br><span class="line">    var port:Int = 8080 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例类可以像普通类一样实现接口和继承类，还可以进行扩展函数。</p><p><strong>3. object 表达式</strong></p><p>在 Java 中的匿名内部类可以使用 object 表达式进行替换，更易理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val comparator = object :Comparator&lt;String&gt;&#123;</span><br><span class="line">    override fun compare(s1: String?, s2: String?): Int &#123;</span><br><span class="line">        if ( s1 == null)&#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;else if(s2 == null)</span><br><span class="line">            return 1</span><br><span class="line">        return s1.compareTo(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, comparator)</span><br></pre></td></tr></table></figure><p>object 表达式在运行中不像在单例模式中所说的那样，全局只有一个对象，而是每次运行时都会生成一个对象。</p><p>但是在一些场合下，匿名内部类和 object 表达式并不适合，而 Lambda 更适合，那么 Lambda 和 object 表达式哪一个更适合替代匿名内部类？</p><blockquote><p>当匿名内部类使用的接口只需要实现一个方法时，使用 Lambda 表达式更适合，当匿名内部类内有多个方法时，使用 object 表示式更适合。</p></blockquote><p>所以以上 object 表示式可以使用 Lambda 替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val comparator = Comparator&lt;String&gt; &#123; s1, s2 -&gt;</span><br><span class="line">    if (s1 == null) &#123;</span><br><span class="line">        return@Comparator -1</span><br><span class="line">    &#125; else if (s2 == null)</span><br><span class="line">        return@Comparator 1</span><br><span class="line">    s1.compareTo(s2)</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, comparator)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-Kotlin-中的类&quot;&gt;&lt;a href=&quot;#0x0001-Kotlin-中的类&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Kotlin 中的类&quot;&gt;&lt;/a&gt;0x0001 Kotlin 中的类&lt;/h3&gt;&lt;p&gt;Kotlin 中类与 Java 中的几点不同:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Kotlin 中除非显示声明延时初始化，那么属性需要显式的指定默认值。&lt;/li&gt;
&lt;li&gt;val 为不可变属性&lt;/li&gt;
&lt;li&gt;修饰符的访问权限不同，Kotlin 默认全局可见， Java 默认包可见。&lt;/li&gt;
&lt;li&gt;在接口中，不可为属性初始化值( Kotlin 接口中抽象属性，背后通过方法实现)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;0x0002-Koltlin-中的接口&quot;&gt;&lt;a href=&quot;#0x0002-Koltlin-中的接口&quot; class=&quot;headerlink&quot; title=&quot;0x0002 Koltlin 中的接口&quot;&gt;&lt;/a&gt;0x0002 Koltlin 中的接口&lt;/h3&gt;&lt;p&gt;在 Kotlin 中，接口可以拥有属性和默认方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(四)：表达式、中缀函数、中缀表达式</title>
    <link href="/2019/11/25/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E5%9B%9B/"/>
    <id>/2019/11/25/Kotlin-核心编程-四/</id>
    <published>2019-11-25T10:30:09.000Z</published>
    <updated>2019-12-03T04:38:56.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-在-Kotlin-中什么是表达式？"><a href="#0x0001-在-Kotlin-中什么是表达式？" class="headerlink" title="0x0001 在 Kotlin 中什么是表达式？"></a>0x0001 在 Kotlin 中什么是表达式？</h3><blockquote><p>在 Kotlin 中表达式可以是一个值、变量、常量、操作符、函数，或者它们的组合，编程语言对其进行解释和计算，以 <strong>产生另外一个值</strong>。</p></blockquote><p>其定义的关键点：</p><a id="more"></a><ul><li>表达式必须会有一个值</li><li>Unit 类型让函数称为表达式，没有返回值的函数此时的返回类型为 Unit，符合表达式产生了新值的定义。</li></ul><h3 id="0x0002-常见的表达式"><a href="#0x0002-常见的表达式" class="headerlink" title="0x0002 常见的表达式"></a>0x0002 常见的表达式</h3><p><code>if</code> 和 <code>when</code> 作为表达式时必须要有 else 语句。</p><p>枚举类结合 when 表达式可以十分方便的表示多分支情况，同时keyi使用 when 来代替 if-else 表达式。</p><p><strong>范围表达式</strong></p><p><code>..</code> 表示范围，<strong>包括前面不包括后面</strong>，如 1..3 表示 12</p><p><code>in</code> 表示成员关系，意为在的含义。</p><p>其他关键字，如 until、step、downTo 等</p><h3 id="0x0003-中缀函数和中缀表达式"><a href="#0x0003-中缀函数和中缀表达式" class="headerlink" title="0x0003 中缀函数和中缀表达式"></a>0x0003 中缀函数和中缀表达式</h3><p>until、step 等可以不通过点号进行使用，这是中缀表达式调用方式。</p><p>downTo 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public infix fun Int.downTo(to: Int): IntProgression &#123;</span><br><span class="line">    return IntProgression.fromClosedRange(this, to, -1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Kotlin 中，像 downTo 这样通过关键字 infix 修饰的函数称为中缀函数。</p><p>定义一个中缀函数满足以下条件：</p><ul><li><strong>为某个类型的扩展函数或者成员方法</strong>。</li><li><strong>只有一个参数</strong>。</li><li>参数不支持默认值，不为可变参数。</li></ul><p>定义中缀函数需要使用 <strong>infix</strong> 修饰，下面为自定义中缀函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    // 在类内部定义中缀函数</span><br><span class="line">    infix fun message(name:String)&#123;</span><br><span class="line">        println(&quot;name is $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过扩展函数定义中缀函数</span><br><span class="line">infix fun People.showAge(age:Int)&#123;</span><br><span class="line">    println(&quot;age is $age&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val people = People()</span><br><span class="line">    people message &quot;Mike&quot;</span><br><span class="line">    people.message(&quot;Mike&quot;)// 正常方法调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中缀表达式</strong>：类似 <code>A 中缀方法 B</code> 的形式。</p><p>像 in、step、until、downTo 这样不通过点号，而是通过中缀表达式调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-在-Kotlin-中什么是表达式？&quot;&gt;&lt;a href=&quot;#0x0001-在-Kotlin-中什么是表达式？&quot; class=&quot;headerlink&quot; title=&quot;0x0001 在 Kotlin 中什么是表达式？&quot;&gt;&lt;/a&gt;0x0001 在 Kotlin 中什么是表达式？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 Kotlin 中表达式可以是一个值、变量、常量、操作符、函数，或者它们的组合，编程语言对其进行解释和计算，以 &lt;strong&gt;产生另外一个值&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其定义的关键点：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava 源码学习(四)-自定义操作符:lift、compose</title>
    <link href="/2019/11/23/Rxjava-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%9B%9B/"/>
    <id>/2019/11/23/Rxjava-源码学习-四/</id>
    <published>2019-11-23T07:46:18.000Z</published>
    <updated>2019-11-23T15:15:32.007Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-lift-和-compose-的区别"><a href="#0x0001-lift-和-compose-的区别" class="headerlink" title="0x0001 lift 和 compose 的区别"></a>0x0001 lift 和 compose 的区别</h3><p>看一下在源码中的是如何对两者进行描述的：</p><blockquote><p>This compose operates on the ObservableSource itself whereas lift operates on the ObservableSource’s Observers.<br> If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource, use lift. If your operator is designed to transform the source ObservableSource as a whole(for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}</p></blockquote><a id="more"></a><blockquote><p>如果自定义的操作符的操作对象为数据源发出的每条数据，那么使用 lift 操作符；如果自定义的操作符的操作对象为整个可观察源(比如对它使用的 Rxjava 操作符)，那么使用 compose。</p></blockquote><p>两个操作符的作用对象不同：</p><ul><li>compose 操作符作用于 Observable 事件源。</li><li>lift 操作符作用于 ObservableSource 的 Observers。</li></ul><p>官方文档中建议，不要滥用 lift 操作符，因为它的使用存在诸多限制，也会对性能有轻微的影响，具体请查看 <a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0" target="_blank" rel="noopener">Writing-operators-for-2.0</a>。</p><h3 id="0x0002-lift、compose-实现原理"><a href="#0x0002-lift、compose-实现原理" class="headerlink" title="0x0002 lift、compose 实现原理"></a>0x0002 lift、compose 实现原理</h3><p>lift、compose 操作符的实现其实和 Rxjava 中其他内置的操作符实现是一样的，同样是通过 <code>onSubscribe</code> 和 <code>subscribeActual</code> 方法作为关键点，链路到整个事件流中，两者的具体实现实现通过源码就可以很清晰的看到，因为分析源码的套路和之前的文章一样，在此不详述。</p><p>关于两者对整个事件流的影响，个人认为不过是在原来的链式添加了其他的 Observable 和 Obsever，和其他操作符没有什么区别。不过有了这两个操作符确实能够很方便的实现一些需求。</p><h3 id="0x0003lift、compose-的使用"><a href="#0x0003lift、compose-的使用" class="headerlink" title="0x0003lift、compose 的使用"></a>0x0003lift、compose 的使用</h3><p>合理使用量这，可以大幅度的减少重复代码的书写，以下列举 lift、compose 常见的使用场景：</p><ul><li>compose:相同的 operator 组合重复出现</li></ul><p>比如在 Rxjava 中实现线程切换的操作，使用 compose 可以避免对每个 Rxjava 事件流书写重复代码，具体实现可以查看:<a href="https://leegyplus.github.io/2019/01/17/RxJava%20%E4%BD%BF%E7%94%A8%20Transformer%20%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2/" target="_blank" rel="noopener">RxJava Transformer</a></p><ul><li>lift:对事件发射器发出的事件执行相同的逻辑操作</li></ul><p>比如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(list)</span><br><span class="line">    .flatMap(integer -&gt; &#123;</span><br><span class="line">        switch (integer) &#123;</span><br><span class="line">            case 1: return Observable.just(&quot;First Odd Number : &quot; + integer);</span><br><span class="line">            case 2: return Observable.just(&quot;First Even Number : &quot; + integer);</span><br><span class="line">            default: return Observable.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>类似对数据源的操作还有可能出现在其他 Rxjava 的事件流中，那么这时我们就可以把该部分逻辑操作封装在定义类中，使用 lift 操作符链接到原原来的事件流中，同样也避免了重复代码。</p><hr><p><strong>知识来源：</strong></p><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="noopener">Rxjava 操作符分类 中文翻译文档</a></p><p><a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0" target="_blank" rel="noopener">Writing-operators-for-2.0</a></p><p><a href="https://ansgarlin.github.io/zh-tw/rxjava/compose_and_lift.html" target="_blank" rel="noopener">lift() 和 compose()</a>:文章的质量很高，让我对 lift 和 compose 的朦胧的理解具象化，真心赞。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-lift-和-compose-的区别&quot;&gt;&lt;a href=&quot;#0x0001-lift-和-compose-的区别&quot; class=&quot;headerlink&quot; title=&quot;0x0001 lift 和 compose 的区别&quot;&gt;&lt;/a&gt;0x0001 lift 和 compose 的区别&lt;/h3&gt;&lt;p&gt;看一下在源码中的是如何对两者进行描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This compose operates on the ObservableSource itself whereas lift operates on the ObservableSource’s Observers.&lt;br&gt; If the operator you are creating is designed to act on the individual items emitted by a source ObservableSource, use lift. If your operator is designed to transform the source ObservableSource as a whole(for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下的几个函数的基本了解</title>
    <link href="/2019/11/20/Linux-%E4%B8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <id>/2019/11/20/Linux-下的几个函数/</id>
    <published>2019-11-20T06:23:15.000Z</published>
    <updated>2019-11-25T13:01:23.592Z</updated>
    
    <content type="html"><![CDATA[<p>在对 Android 系统源码的学习过程中，总是会不可避免的查看 Linux 层的实现，那么此时总会碰到关键性的函数操作，而理解这些函数对要分析的功能模块是不可缺少的。本文为 Android 系统中常见的 Linux 函数，主要描述其作用，帮助理解。</p><h3 id="mmap-函数"><a href="#mmap-函数" class="headerlink" title="mmap 函数"></a>mmap 函数</h3><p><strong>一种内存映射文件的方法</strong>。</p><a id="more"></a><p>函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">int munmap(void* start,size_t length);</span><br></pre></td></tr></table></figure><p><strong>具体描述：</strong></p><ul><li><p>mmap 将一个文件或者其他对象映射到内存。</p></li><li><p>mmap 在用户空间映射调用系统中作用很大。</p></li><li><p>mmap() 必须以 PAGE_SIZE 为单位进行映射，在内存也只能以页为单位进行映射。</p></li><li><p>mmap操作提供了一种机制，<strong>让用户程序直接访问设备内存</strong>，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap，mmap的实现和硬件有关。</p></li><li><p>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</p></li><li><p>在内核中分配一块内存，用于存储数据。</p></li></ul><h3 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl 函数"></a>ioctl 函数</h3><p>ioctl(input/output control)是一个专门用于设备输入输出操作的系统调用，该请求传入一个与设备有关的请求码，系统调用的功能完全取决于请求码。</p><p>ioctl是 <strong>设备驱动程序</strong> 中对 <strong>设备的I/O通道</strong> 进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。它的调用个数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)；</span><br></pre></td></tr></table></figure><p>其中fd是用户程序打开设备时使用open函数返回的文件标示符，cmd是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。<br>　　ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数来控制设备的I/O通道。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对 Android 系统源码的学习过程中，总是会不可避免的查看 Linux 层的实现，那么此时总会碰到关键性的函数操作，而理解这些函数对要分析的功能模块是不可缺少的。本文为 Android 系统中常见的 Linux 函数，主要描述其作用，帮助理解。&lt;/p&gt;
&lt;h3 id=&quot;mmap-函数&quot;&gt;&lt;a href=&quot;#mmap-函数&quot; class=&quot;headerlink&quot; title=&quot;mmap 函数&quot;&gt;&lt;/a&gt;mmap 函数&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;一种内存映射文件的方法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="/tags/C/"/>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>WorkManager 进阶</title>
    <link href="/2019/11/18/WorkManager-%E8%BF%9B%E9%98%B6/"/>
    <id>/2019/11/18/WorkManager-进阶/</id>
    <published>2019-11-18T08:13:49.000Z</published>
    <updated>2019-11-21T04:44:21.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>WorkManager 是 Jetpack 的一个可延迟的、基于条件约束的后台进程处理库。</p></blockquote><h3 id="0x0001-WorkManager-如何与-OS-进行交互"><a href="#0x0001-WorkManager-如何与-OS-进行交互" class="headerlink" title="0x0001 WorkManager 如何与 OS 进行交互"></a>0x0001 WorkManager 如何与 OS 进行交互</h3><p>WorkManager 基本流程：</p><p>具体细节可以查看 <a href="https://leegyplus.github.io/2019/11/14/JobScheduler-%E5%92%8C-WorkManager-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">JobScheduler 和 WorkManager 的基本使用</a></p><a id="more"></a><p>官方 DEMO：</p><p><img src="/public/images/2019_11_18_09.png" alt="基本使用"></p><p><strong>1. 如何持久化请求？</strong></p><ol><li>保存在 WorkManager 数据库中</li></ol><p>WorkManager 数据库是后续一切的基础，WorkManager 的任何信息都保存在数据库中：</p><ul><li>工作程序是否允许</li><li>是否完成</li><li>是否失败</li><li>是否重试 5 次</li><li>and so on</li></ul><p><img src="/source/images/2019_11_18_10.png" alt="1"></p><ul><li>如果 API &gt;= 23</li></ul><p>会把这个请求发送到 JobScheduler，</p><ul><li>22 及以下</li></ul><p>如图所示，根据情况不同，会把请求发送到 GcmNetWorkManager 或者 AlarmManager 中。</p><p><strong>2. 如何运行 WorkRequest？</strong></p><p><img src="/source/images/2019_11_18_11.png" alt="2"></p><p>假设在 API 23+ 的设置上，有一个约束条件为网络连接的 Work，当有网络后，JobScheduler 就会唤醒你的应用，进行相关的工作，WorkManager 会运行相关的 Work。</p><p>如上图所示，JobScheduler、GcmNetWorkManager、AlarmManger 都属于应用外的组件，而 GreedyScheduler 存在你的应用进程中，它们的作用是一样的，会追踪部分约束条件，在符合条件后要求 WorkManager 运行相关的 Work。由于 GreedyScheduler 存在于引用进程中，所以他无法唤醒你的应用，这个组件不依赖于 OS 的其他部分，它会适时并且更快的运行定义的 Work。</p><h3 id="0x0002-WorkManager-–-Your-old-work-will-still-work"><a href="#0x0002-WorkManager-–-Your-old-work-will-still-work" class="headerlink" title="0x0002 WorkManager – Your old work will still work!"></a>0x0002 WorkManager – Your old work will still work!</h3><p>WorkManager 不仅对应用内产生影响，也会对整个 OS 系统产生影响，从上文 WorkManager 的运行机制也可以看出， WorkManager 的信息会被存到数据库中，加入到相应的队列中，然后通过 OS 的其他组件去调用(在这里可以看出 WorkManager 需要应用外的组件进行配合执行)，即使此刻停用 WorkManager，那么之前已经存在的请求(未执行)也会被执行的，当然这是不符合开发者的要求的，所以如果在应用中弃用  WorkManager 的话，需要手动的取消所有的请求。</p><h3 id="0x0003-what-if-i-don’t-initialize-WorkManager-for-an-experimental-population"><a href="#0x0003-what-if-i-don’t-initialize-WorkManager-for-an-experimental-population" class="headerlink" title="0x0003 what if i don’t initialize WorkManager for an experimental population?"></a>0x0003 what if i don’t initialize WorkManager for an experimental population?</h3><h4 id="1-with-auto-initialization-it-will-throw-an-uninitialization-execption"><a href="#1-with-auto-initialization-it-will-throw-an-uninitialization-execption" class="headerlink" title="1. with auto initialization, it will throw an uninitialization execption."></a>1. with auto initialization, it will throw an uninitialization execption.</h4><p><img src="/source/images/2019_11_19_05.png" alt="334"></p><p>抛出一个异常。</p><h4 id="2-your-old-work-will-still-run-for-on-demand-initalization"><a href="#2-your-old-work-will-still-run-for-on-demand-initalization" class="headerlink" title="2. your old work will still run for on-demand initalization."></a>2. your old work will still run for on-demand initalization.</h4><p><img src="/source/images/2019_11_19_04.png" alt="4"></p><h4 id="3-what-if-i-remove-WorkManager-for-an-experimental-population"><a href="#3-what-if-i-remove-WorkManager-for-an-experimental-population" class="headerlink" title="3. what if i remove WorkManager for an experimental population."></a>3. what if i remove WorkManager for an experimental population.</h4><p><img src="/source/images/2019_11_19_06.png" alt="4"></p><p>your old work will get ingored,but still use system resources!</p><p>比如应用中仍然存在一个网络连接约束，JobScheduler 会持续追踪、持续等待联网，并且在联网成功之后通知应用开始运行，但是此刻应用中已经没有 WorkManager 了</p><h4 id="4-Best-Practice"><a href="#4-Best-Practice" class="headerlink" title="4. Best Practice"></a>4. Best Practice</h4><p>Cancel all your WorkRequests to clean up after youself.</p><h3 id="0x0003-why-is-my-work-not-running"><a href="#0x0003-why-is-my-work-not-running" class="headerlink" title="0x0003 why is my work not running?"></a>0x0003 why is my work not running?</h3><ol><li>未满足约束条件</li></ol><p>use <code>adb shell dumpsys jobscheduler</code> to debug on api 23+</p><ol start="2"><li>处于低电量模式(doze mode)</li></ol><p>Job can be delayed in doze mode to preserve battery.</p><ol start="3"><li>Battery saver (省电模式)</li></ol><p>Background jobs don’t run in battery saver mode.</p><p>比如 pixel 设备电量低于 15% 就会默认这一模式。</p><ol start="4"><li>overall system or app workload</li></ol><p>OS 或者 App 工作负荷太大。</p><ul><li><p>Android only run a certain number of active jobs at a time.<br>JobScheduler 在同一时间下只允许一定数据的活跃工作</p></li><li><p>WorkManager is limited by the ThreadPool you give it in its Configuration.</p></li></ul><p>线程池内默认 2~4 个活跃的 Job，如果 Job 过多，就会加入延迟执行的队列中。</p><ol start="5"><li>Failed or incomplete prerequistites(先决条件).</li></ol><ul><li>Are your prerequiste WorkRequests to finished.</li><li>Have they all Successed<ul><li>A Failed prent job will fail all descendents.</li></ul></li></ul><p>如果有的添加没有满足，导致母工作失败，将会导致一切子工作失败。</p><p>Be carefull of this with unique work and Existing *WorkPolicy .APPEND，官方会马上提供解决此功能的 API</p><ol start="6"><li>Is  your app force-stopped?</li></ol><ul><li>Force-stopped wipes out all jobs and alarms.</li><li>The next time the app is started and workmanager is initialized,it will rescheduler everything for you.</li></ul><p>但是由于被强制停止属于具有破坏性的操作，所以无法保证被强制停止的应用被唤醒，那么如果应用不能被唤醒，应用内的 Work 将不会被执行，但是 Work 仍然存在于 应用中，因为这些 Work 存储在数据库中。</p><h3 id="0x0004-why-is-my-Work-running-too-ofen-为什么我的-Work-运行的如下次频繁"><a href="#0x0004-why-is-my-Work-running-too-ofen-为什么我的-Work-运行的如下次频繁" class="headerlink" title="0x0004 why is my Work running  too ofen(为什么我的 Work 运行的如下次频繁)?"></a>0x0004 why is my Work running  too ofen(为什么我的 Work 运行的如下次频繁)?</h3><p>我们常常在应用中看到这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ThirdActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private val duration: Duration = Duration.ofHours(1)</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        WorkManager.getInstance(this)</span><br><span class="line">                .enqueue(PeriodicWorkRequestBuilder&lt;BackgroundWork&gt;(duration).build())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这是错误的，因为每次在 onCreate 的时候都会将 Work 添加到队列中，然后 PeriodicWorkRequestBuilder 会越积越多，正确的做法应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ThirdActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private val duration: Duration = Duration.ofHours(1)</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        WorkManager.getInstance(this)</span><br><span class="line">                .enqueueUniquePeriodicWork(</span><br><span class="line">                        &quot;test_work&quot;,</span><br><span class="line">                        ExistingPeriodicWorkPolicy.KEEP,</span><br><span class="line">                        PeriodicWorkRequestBuilder&lt;BackgroundWork&gt;(duration).build())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要把单一的 WorkRequest 加入到队列中，而针对这条周期性 Work 可以指定当同名的 WorkRequest 已经存在时该发生什么事情，在上例中采取的措施为保留旧的 WorkRequest ,如果之前我们已经把它加入到队列，那么就不需要重复创建这个 Work，继续使用它就好，这才是正确的处理方式。</p><h3 id="0x0005-WorkManager-初始化"><a href="#0x0005-WorkManager-初始化" class="headerlink" title="0x0005 WorkManager 初始化"></a>0x0005 WorkManager 初始化</h3><ul><li>自动初始化</li><li>按需初始化</li><li><em>1. 自动初始化*</em></li></ul><p>让 WorkManager 采用默认的配置自动完成初始化，其具体原理为存在一个 名为 WorkManagerInitializer 的 ContentProvider，它可以把 manifest 导入到应用中，ContentProvider 的工作原理是 ContentProvider 首先进行初始化，然后才轮到 Application 的 onCreate() 方法，这一点利用了 ContentProvider 的初始化时机，在 LeakCanary3.x 中也是使用了这一点完成的自动初始化。</p><p><img src="/source/images/2019_11_19_01.png" alt="45"></p><p>基于此，在应用中调用 <code>WorkManager.getInstance(this)</code> 才会获取到一个非空对象。</p><p><strong>2. 按需初始化</strong></p><p>WorkManager 的自动初始化中，应用启动时除了完成自身的初始化，还要对 WorkManager 进行初始化，无疑这使应用初始化变得重起来，不是很好的操作，所以提供了 WorkManager 的按需初始化操作，这样我们可以在需要时初始化 WorkManager。</p><p>使用场景：延迟初始化 WorkManager。</p><p>如何进行按需初始化?</p><p><img src="/source/images/2019_11_19_02.png" alt="64"></p><ol><li>禁用自动初始化</li><li>初始化</li></ol><p><strong>3. 如何发现 WorkManager 所需的配置？</strong><br><img src="/source/images/2019_11_19_03.png" alt="2"></p><p>自定义  Application 实现 Configuration.Provider:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class App:Application(), Configuration.Provider &#123;</span><br><span class="line">    override fun getWorkManagerConfiguration(): Configuration &#123;</span><br><span class="line">        TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按需配置 WorkManager 的利弊：</p><p>利：</p><ol><li>避免 Application 初始化过重，提供应用的性能</li><li>使用按需初始化而不是自动初始化，会避免在一些设备上的问题。</li></ol><p>弊：</p><ol><li>未能正确初始化 WorkManager，导致一些问题。</li><li>重新启动应用，Work 重排会被延迟执行。</li><li><h3 id="0x0006-Test-your-Workers"><a href="#0x0006-Test-your-Workers" class="headerlink" title="0x0006 Test your Workers."></a>0x0006 Test your Workers.</h3></li></ol><p>在 2.1 版本中，增强了测试功能。</p><p>提供了 TestListenableWorkerBuilder，对 WorkManager 的初始化、配置流程的步骤的简化。</p><p>具体查看 Demo。</p><hr><p><strong>知识来源：</strong></p><p><a href="https://www.bilibili.com/video/av74528360" target="_blank" rel="noopener">WorkManager 进阶课堂 </a></p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/testing?hl=zh" target="_blank" rel="noopener">Test your works</a></p><p><a href="https://github.com/leeGYPlus/background-tasks-samples" target="_blank" rel="noopener">WorkManager 官方 DEMO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;WorkManager 是 Jetpack 的一个可延迟的、基于条件约束的后台进程处理库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x0001-WorkManager-如何与-OS-进行交互&quot;&gt;&lt;a href=&quot;#0x0001-WorkManager-如何与-OS-进行交互&quot; class=&quot;headerlink&quot; title=&quot;0x0001 WorkManager 如何与 OS 进行交互&quot;&gt;&lt;/a&gt;0x0001 WorkManager 如何与 OS 进行交互&lt;/h3&gt;&lt;p&gt;WorkManager 基本流程：&lt;/p&gt;
&lt;p&gt;具体细节可以查看 &lt;a href=&quot;https://leegyplus.github.io/2019/11/14/JobScheduler-%E5%92%8C-WorkManager-%E7%9A%84%E4%BD%BF%E7%94%A8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JobScheduler 和 WorkManager 的基本使用&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="WorkManager" scheme="/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>使用 CPU Profiler 检查 CPU Activity 和函数跟踪</title>
    <link href="/2019/11/18/%E4%BD%BF%E7%94%A8-CPU-Profiler-%E6%A3%80%E6%9F%A5-CPU-Activity-%E5%92%8C%E5%87%BD%E6%95%B0%E8%B7%9F%E8%B8%AA/"/>
    <id>/2019/11/18/使用-CPU-Profiler-检查-CPU-Activity-和函数跟踪/</id>
    <published>2019-11-18T08:11:35.000Z</published>
    <updated>2019-11-18T08:11:35.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-使用-Call-Chart-标签检查跟踪"><a href="#0x0001-使用-Call-Chart-标签检查跟踪" class="headerlink" title="0x0001 使用 Call Chart 标签检查跟踪"></a>0x0001 使用 Call Chart 标签检查跟踪</h3><p>Call Chart 标签提供函数跟踪的图形表示形式。</p><p>水平方法表示函数执行的时间段和时间，并 <strong>沿垂直轴显示其被调用者</strong>。图形不同颜色表示不同函数级别：</p><ul><li>橙色 – 对系统 API 的调用</li><li>绿色 – 对应自有函数的调用</li><li>蓝色 – 对第三方 API(包括 Java 的 API) 的调用</li></ul><a id="more"></a><p>直接拿官方文档图片来展示 Call Chart 具体含义。</p><p><img src="https://developer.android.google.cn/studio/images/profile/call_chart_1-2X.png" alt="Call Chart(方法调用图)"></p><p>根据图片我们可以得知各方法的调用关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun A()&#123;</span><br><span class="line">    B();</span><br><span class="line">    D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun B()&#123;</span><br><span class="line">    C();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun D()&#123;</span><br><span class="line">    C();</span><br><span class="line">    B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从图片上我们可以得知方法 D 执行时间以及其调用函数的执行时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D(self time) + D(children time) = D(total time)</span><br><span class="line"></span><br><span class="line">其中 D(chidren time) = C(total time) + B(total time)</span><br><span class="line">B(total time) = B(self time) + B(children time)</span><br><span class="line">B(children time) = C(toal time)</span><br></pre></td></tr></table></figure><p><img src="/source/images/2019_11_18_01.png" alt></p><h4 id="0x0002-使用-Flame-Chart-标签检查跟踪"><a href="#0x0002-使用-Flame-Chart-标签检查跟踪" class="headerlink" title="0x0002 使用 Flame Chart 标签检查跟踪"></a>0x0002 使用 Flame Chart 标签检查跟踪</h4><p>使用 <strong>Call Chart</strong> 图并不能很容易的发现那些长时间运行的代码，所以需要 Flame Chart。</p><p>收集 <strong>共享相同调用方顺序的完全相同</strong> 的函数，并在火焰图中用一个较长的横条表示它们（而不是将它们显示为多个较短的横条，如调用图表中所示）。</p><p>水平轴不再像调用图一样代表时间线，它表示 <strong>每个函数相对的执行时间</strong>，这样更方便查看 <strong>哪些函数消耗最多时间</strong>。</p><p> 下面展示从 Call Chart 如何转换为 Flame Chart。</p><p> <img src="https://developer.android.google.cn/studio/images/profile/call_chart_2-2X.png" alt="Call Chart(方法调用图)"></p><p> 其中 D 多次调用了 B(B1、B2、B3)，那么B1、B2、B3 共享相同的调用顺序(A-&gt;D-B)。B 多次调用了 C(C1、C3)，那么 C1、C3 共享相同的调用顺序(A-&gt;D-&gt;B-&gt;C)。</p><p> 那么汇总相同共享调用堆栈的函数，如下:</p><p> <img src="https://developer.android.google.cn/studio/images/profile/flame_chart_aggregation-2X.png" alt="汇总相同共享调用堆栈的函数"></p><p> 汇总的函数调用用于创建 Flame Chart 图形，如下：</p><p> <img src="https://developer.android.google.cn/studio/images/profile/flame_chart-2X.png" alt="Flame Chart"></p><p>在 Flame Chart 火焰图中 CPU 时间的被调用方首先显示。</p><p><img src="/source/images/2019_11_18_02.png" alt></p><p>因此 Flame Chart 被称为 聚合栈调用，与 Call Chart 的转换关系：</p><p><img src="/source/images/2019_11_18_03.png" alt></p><p>Call chart 会保留时间线信息，会记录函数调用发生的确切时间，但是 Flame Chart 会显示聚合持续的时间信息，方便探索代码中长时间运行的函数，。</p><h4 id="0x0003-使用-Top-Down-检查跟踪"><a href="#0x0003-使用-Top-Down-检查跟踪" class="headerlink" title="0x0003 使用 Top Down 检查跟踪"></a>0x0003 使用 Top Down 检查跟踪</h4><p>Flame Chart 有助于通览全局，但是有时候想要找到准确的时间信息，这时候需要 Top Down。</p><p>Top Down 根据语义显示为自上而下，映射到函数调用关系为自上而下产生调用关系。</p><p> Top down 显示  <strong>一个</strong> 函数的调用列表，在该列表中展开函数节点将展示该函数调用的其他函数，即最上面的位置为一系列函数调用的起点()。</p><p> Top Down 为 Flame Chart 图表的另一种表示方法，所以该图标的绘制原则也是汇总相同共享调用堆栈的函数。</p><p> 上面 Flame Chart 图表对应的 Top Down 图表如下：</p> <img src="https://developer.android.google.cn/studio/images/profile/top_down_tree-2X.png" height="30%" width="50%"><p> Top Bottom 标签提示信息可以向我们展示 <strong>每个函数调用上所花费的 CPU 时间</strong>（时间也可以用线程总时间占所选时间范围的持续时间的百分比表示）：</p><p><img src="/source/images/2019_07_24_01.png" alt></p><table><thead><tr><th>Self</th><th>Children</th><th>Total</th></tr></thead><tbody><tr><td>函数调用在执行自己的代码（而非被调用方的代码）上所花的时间(对应 Call Chart 中函数 D 中相应的时间)</td><td>函数调用在执行自己的被调用方（而非自己的代码）上所花的时间(同左)</td><td>函数的 Self 和 Children 时间的总和(同左)。</td></tr></tbody></table><p>举例查看具体含义</p><p><img src="/source/images/2019_11_18_04.png" alt></p><p>很明显调用函数的最底端的函数 Self = Total，Chidren = 0。</p><h4 id="0x0004-Bottom-Up-检查跟踪"><a href="#0x0004-Bottom-Up-检查跟踪" class="headerlink" title="0x0004 Bottom Up 检查跟踪"></a>0x0004 Bottom Up 检查跟踪</h4><p>Top Down 可以找到准确的时间信息，但是有时候需要花费很长时间寻找，才能寻找到某个特定的方法，这时候可以使用 Bottom Up。</p><p>Bottom Up 标签显示一个函数调用列表，在该列表中展开函数节点将显示函数的调用方。</p><img src="https://developer.android.google.cn/studio/images/profile/bottom_up_tree-2X.png" height="30%" width="50%"><p>上面图形向我们展示了  Flame Chart 图形中函数 C 的 Bottom Up 函数调用关系图，即展示了函数 C 的所有的调用者以及延续。</p><p>举例查看具体的 Flame Chart 向 Bottom Up 的转换：</p><p><img src="/source/images/2019_11_18_05.png" alt></p><p>Bottom Up 标签用于按照消耗最多（最少）CPU 时间排序函数，通过各个节点可以查看函数的哪个调用方所花费的时间</p><table><thead><tr><th>节点属性</th><th>Self</th><th>Children</th><th>Total</th></tr></thead><tbody><tr><td>最顶层节点</td><td>函数在执行自己的代码（非该函数所调用的函数的代码）上所花的时间，同时也是所有调用该函数(可被记录的)的函数的时间和</td><td>调用该函数</td><td>Self 和 Children 的总和</td></tr><tr><td>子节点</td><td>被调用函数的 self time 总和(函数 B 的 self time 为函数 C 每个执行的 self time 总和 )</td><td>被调用的函数的总 Children time(函数 B 的 Children time 为函数 C 每个执行的 Children time 总和 )</td><td></td></tr></tbody></table><p><img src="/source/images/2019_11_18_06.png" alt></p><p><strong>什么时候使用 Bottom Up</strong></p><p>当想要知道某个方法是如何被调用的，找到它的调用点，寻找感兴趣的节点</p><p><img src="/source/images/2019_11_18_07.png" alt></p><h4 id="0x0005-如何选择使用哪个图表"><a href="#0x0005-如何选择使用哪个图表" class="headerlink" title="0x0005 如何选择使用哪个图表"></a>0x0005 如何选择使用哪个图表</h4><p>四张图表的对比：</p><table><thead><tr><th>Call Chart</th><th>Flame Chart</th><th>Top Down</th><th>Bottom Up</th></tr></thead><tbody><tr><td>提供清晰的函数调用路径</td><td>很容易的发现那些长时间运行的代码</td><td>找到准确的时间信息</td><td>快速寻找到某个特定的方法</td></tr></tbody></table><p><img src="/source/images/2019_11_18_08.png" alt></p><hr><p><strong>知识链接：</strong></p><p><a href="https://developer.android.google.cn/studio/profile/cpu-profiler#method_traces" target="_blank" rel="noopener">Google 官方文档</a></p><p><a href="https://www.jianshu.com/p/a3d91986b4c7" target="_blank" rel="noopener">Android性能优化之CPU Profiler</a></p><p><a href="https://www.bilibili.com/video/av75349812/" target="_blank" rel="noopener">读懂 Android Studio 分析工具数据</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-使用-Call-Chart-标签检查跟踪&quot;&gt;&lt;a href=&quot;#0x0001-使用-Call-Chart-标签检查跟踪&quot; class=&quot;headerlink&quot; title=&quot;0x0001 使用 Call Chart 标签检查跟踪&quot;&gt;&lt;/a&gt;0x0001 使用 Call Chart 标签检查跟踪&lt;/h3&gt;&lt;p&gt;Call Chart 标签提供函数跟踪的图形表示形式。&lt;/p&gt;
&lt;p&gt;水平方法表示函数执行的时间段和时间，并 &lt;strong&gt;沿垂直轴显示其被调用者&lt;/strong&gt;。
图形不同颜色表示不同函数级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;橙色 – 对系统 API 的调用&lt;/li&gt;
&lt;li&gt;绿色 – 对应自有函数的调用&lt;/li&gt;
&lt;li&gt;蓝色 – 对第三方 API(包括 Java 的 API) 的调用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JobScheduler 和 WorkManager 的基本使用</title>
    <link href="/2019/11/14/JobScheduler-%E5%92%8C-WorkManager-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>/2019/11/14/JobScheduler-和-WorkManager-的使用/</id>
    <published>2019-11-14T08:37:39.000Z</published>
    <updated>2020-02-26T02:54:06.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-JobScheduler-的使用"><a href="#0x0001-JobScheduler-的使用" class="headerlink" title="0x0001 JobScheduler 的使用"></a>0x0001 JobScheduler 的使用</h3><blockquote><p>对于满足网络、电量、时间等一定预定条件而触发的任务，那么 <code>JobScheduler</code> 便是绝佳选择。 <code>JobScheduler</code> 主要用于在 <strong>未来某个时间</strong> 下满足 <strong>一定条件时</strong>,触发执行某项任务的情况，那么可以创建一个 <code>JobService</code> 的子类，重写其 <code>onStartJob()</code> 方法来实现这个功能。</p></blockquote><p>JobScheduler 的使用步骤：</p><a id="more"></a><ul><li>创建 ComponentName 对象。</li><li>构建 JobInfo 对象。</li><li>构建 JobScheduler 对象。</li><li>调用 JobScheduler 对象 schedule() 调度任务。</li></ul><ol><li>创建 ComponentName 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComponentName mServiceComponent = new ComponentName(this, MyJobService.class);</span><br></pre></td></tr></table></figure><ol start="2"><li>构建 JobInfo 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 setXX 方法，为 JobInfo 设置条件</span><br><span class="line">JobInfo jobInfo = new JobInfo.Builder(123, jobService) //任务Id等于123</span><br><span class="line">        .setMinimumLatency(5000)// 任务最少延迟时间 </span><br><span class="line">        .setOverrideDeadline(60000)// 任务deadline，当到期没达到指定条件也会开始执行 </span><br><span class="line">        .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)// 网络条件，默认值NETWORK_TYPE_NONE</span><br><span class="line">        .setRequiresCharging(true)// 是否充电 </span><br><span class="line">        .setRequiresDeviceIdle(false)// 设备是否空闲</span><br><span class="line">        .setPersisted(true) //设备重启后是否继续执行</span><br><span class="line">        .setBackoffCriteria(3000，JobInfo.BACKOFF_POLICY_LINEAR) //设置退避/重试策略</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><ol start="3"><li>构建 JobScheduler 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler scheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br></pre></td></tr></table></figure><ol start="4"><li>调用 JobScheduler 对象 schedule() 调度任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler.schedule(jobInfo);</span><br></pre></td></tr></table></figure><ol start="5"><li>Service 中的关键方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyService extends JobService&#123;</span><br><span class="line">    // 在任务开始执行时，执行该方法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStartJob(final JobParameters params) &#123;</span><br><span class="line">        .....</span><br><span class="line">        .....</span><br><span class="line">        // 需要在 Handler 中执行 Job，这一点是十分重要的</span><br><span class="line">        // true 代表执行任务后，定义的 Job 会继续运行，直到调用 jobFinished </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用 jobFinished 后执行</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onStopJob(JobParameters params) &#123;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>取消 Job</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 取消所有</span><br><span class="line">JobScheduler jobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">jobScheduler.cancelAll();</span><br><span class="line">// 取消指定 Job</span><br><span class="line">int jobId = job.getId();</span><br><span class="line">jobScheduler.cancel(jobId);</span><br></pre></td></tr></table></figure><p>具体代码参见文末 DEMO 链接。</p><h3 id="0x0002-WorkManager-使用"><a href="#0x0002-WorkManager-使用" class="headerlink" title="0x0002 WorkManager 使用"></a>0x0002 WorkManager 使用</h3><p><code>WorkManager</code> 为 <code>JetPack</code> <code>框架中的一个组件，WorkManager</code> 用来执行那些 <strong>不需要立刻执行、不需要可靠的执行的任务</strong>，甚至在 App 退出或者手机重启时运行任务。</p><p>例如可以执行以下任务：</p><ul><li>上传日志到服务器。</li><li>定期与服务器同步数据。</li></ul><p>使用 WorkManager 相应 API 可以创建任务，<strong>当满足任务的执行条件是，把任务发送到 WorkManager 中执行</strong>。</p><p>WorkManager 不适用于正在进行中的后台任务，比如：</p><ul><li>应用退出，后台任务取消。</li><li>需要立即执行的任务。</li></ul><p>如果使用到上面的功能，请参见<a href="https://developer.android.google.cn/guide/background/?hl=en" target="_blank" rel="noopener">后台任务处理指南</a>。</p><ol><li>创建一个后台任务</li></ol><p>在 WorkManager 中通过 Work 来定义一个任务， doWork 方法在 WorkManager 提供的后台线程中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class BackgroundWork(appContext: Context, workParams: WorkerParameters) : Worker(appContext, workParams) &#123;</span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        Log.e(&quot;doWork&quot;,&quot;time start&quot;)</span><br><span class="line">        Thread.sleep(3000L)</span><br><span class="line">        Log.e(&quot;doWork&quot;,&quot;time end&quot;)</span><br><span class="line">        return Result.success(workDataOf(&quot;name&quot; to &quot;success&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 Result 通知 WorkManager 任务是否成功执行。</p><ol start="2"><li>定义任务执行的的条件和时机：WorkRequest </li></ol><p>在 WorkManager 存在两种 WorkRequest ：</p><ul><li><p>OneTimeWorkRequest(一次性)</p></li><li><p>PeriodicWorkRequest(周期式)</p></li></ul><p> 2.1 构建一个 OneTimeWorkRequestBuilder ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private val backWorkRequest by lazy &#123;</span><br><span class="line">    OneTimeWorkRequestBuilder&lt;BackgroundWork&gt;()</span><br><span class="line">            .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.2 构建一个 PeriodicWorkRequest:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val oneTimeRequest = PeriodicWorkRequestBuilder&lt;BackgroundWork&gt;(15, TimeUnit.MINUTES)// 定义周期性间隔</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>不过周期性执行的时间最小为 15 分钟，这一点需要注意，具体可以参见：<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/recurring-work?hl=zh" target="_blank" rel="noopener">Recurring work</a></p><p>2.3 为 WorkRequest 添加约束条件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(true)</span><br><span class="line">        .setRequiresCharging(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">val oneTimeRequest = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br><span class="line">val oneTimeRequest = PeriodicWorkRequestBuilder&lt;BackgroundWork&gt;(15, TimeUnit.MINUTES)// 定义周期性间隔</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>定义的 Work 只有在 <strong>所有的约束条件满足时</strong>，才会执行。如果在任务运行时，约束条件变更，不再满足添加的约束条件，WorkManager 将停止执行 Worker，会在满足约束条件时，将重试该任务。  </p><p>不过自己在 DEMO 中为 oneTimeRequest 添加约束条件后，在任务执行过程中，手机不满足约束条件时，任务也会继续执行下去。</p><p>再者还需要注意一点的是，系统检测约束条变化需要一定的时间，并不是约束条件变化系统都会马上通知 WorkManager 去执行相应的 Work 的，必须上例中的充电状态的变化后，在经过 20s 左右后， WorkManager 才会通知执行相应的 Work。</p><ol start="3"><li>向系统发送任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure><h3 id="0x0003-两者的对比"><a href="#0x0003-两者的对比" class="headerlink" title="0x0003 两者的对比"></a>0x0003 两者的对比</h3><p>官方文档给出关于两者的描述：</p><blockquote><p><strong>JobScheduler</strong>: This is an API for scheduling various types of jobs against the framework that will be executed in your application’s own process.</p></blockquote><blockquote><p><strong>WorkManager</strong>: With WorkManager, you can easily set up a task and hand it off to the system to run under the conditions you specify.</p></blockquote><p>其实两者所能实现的功能是相似的：定义任务，交给 Android 系统执行。但是 WorkManager 作为 Jetpack 的一部分，拥有更多的特性，更推荐使用 WorkManager。</p><hr><p><a href="https://github.com/googlearchive/android-JobScheduler" target="_blank" rel="noopener">JobScheduler 官方 DEMO</a></p><p><a href="https://github.com/leeGYPlus/background-tasks-samples" target="_blank" rel="noopener">WorkManager 官方 DEMO</a></p><p><a href="https://developer.android.google.cn/reference/android/app/job/JobScheduler?hl=en" target="_blank" rel="noopener">JobScheduler 官方文档</a></p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager?hl=zh" target="_blank" rel="noopener">WorkManager 官方文档</a></p><p><a href="http://gityuan.com/2017/03/10/job_scheduler_service/" target="_blank" rel="noopener">理解JobScheduler机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-JobScheduler-的使用&quot;&gt;&lt;a href=&quot;#0x0001-JobScheduler-的使用&quot; class=&quot;headerlink&quot; title=&quot;0x0001 JobScheduler 的使用&quot;&gt;&lt;/a&gt;0x0001 JobScheduler 的使用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于满足网络、电量、时间等一定预定条件而触发的任务，那么 &lt;code&gt;JobScheduler&lt;/code&gt; 便是绝佳选择。 &lt;code&gt;JobScheduler&lt;/code&gt; 主要用于在 &lt;strong&gt;未来某个时间&lt;/strong&gt; 下满足 &lt;strong&gt;一定条件时&lt;/strong&gt;,触发执行某项任务的情况，那么可以创建一个 &lt;code&gt;JobService&lt;/code&gt; 的子类，重写其 &lt;code&gt;onStartJob()&lt;/code&gt; 方法来实现这个功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JobScheduler 的使用步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JobScheduler" scheme="/tags/JobScheduler/"/>
    
      <category term="WorkManager" scheme="/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(三)：Kotlin 中的高阶函数和 Lambad 表达式</title>
    <link href="/2019/11/14/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E4%B8%89/"/>
    <id>/2019/11/14/Kotlin-核心编程三/</id>
    <published>2019-11-14T07:52:39.000Z</published>
    <updated>2019-11-14T07:54:14.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-什么是高阶函数？"><a href="#0x0001-什么是高阶函数？" class="headerlink" title="0x0001 什么是高阶函数？"></a>0x0001 什么是高阶函数？</h3><p>Kotlin 天然支持函数特性，与 Java 类为一等公民不同，在 Kotlin 中 <strong>函数为一等公民</strong>，函数可以直接定义在 kt 文件中。</p><p>在 Java 中限制方法只能接收数据作为参数，而高阶函数除此外，<strong>方法的参数可以是函数</strong>，<strong>并且函数的返回值也可以为函数</strong>。</p><h3 id="0x0002-一个实例说明为什么使用高阶函数"><a href="#0x0002-一个实例说明为什么使用高阶函数" class="headerlink" title="0x0002 一个实例说明为什么使用高阶函数"></a>0x0002 一个实例说明为什么使用高阶函数</h3><p>下面通过一个示例，依据需求的演进来一步一步揭开为什么要引入高阶函数。</p><a id="more"></a><p>此例 《Java8 实战》中的一个例子,具体需求从众多 country 中过滤符合要求的国家。</p><p>首先构造 Country 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class Country(</span><br><span class="line">    val name: String,</span><br><span class="line">    val continient: String,</span><br><span class="line">    val population: Int</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>需求一：过滤出 EU 的国家</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CountApp &#123;</span><br><span class="line">    fun filterCounties(countries: List&lt;Country&gt;): List&lt;Country&gt; &#123;</span><br><span class="line">        val res = mutableListOf&lt;Country&gt;()</span><br><span class="line">        for (country in countries) &#123;</span><br><span class="line">            if (country.continient == &quot;EU&quot;) &#123;</span><br><span class="line">                res.add(country)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求二：过滤出符合指定洲的国家</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CountApp &#123;</span><br><span class="line">    fun filterCounties(continient: String,countries: List&lt;Country&gt;): List&lt;Country&gt; &#123;</span><br><span class="line">        val res = mutableListOf&lt;Country&gt;()</span><br><span class="line">        for (country in countries) &#123;</span><br><span class="line">            if (country.continient == continient) &#123;</span><br><span class="line">                res.add(country)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求三：在以上基础上加入过滤条件：人口数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CountApp &#123;</span><br><span class="line">    fun filterCounties(continient: String,population:Int,countries: List&lt;Country&gt;): List&lt;Country&gt; &#123;</span><br><span class="line">        val res = mutableListOf&lt;Country&gt;()</span><br><span class="line">        for (country in countries) &#123;</span><br><span class="line">            if (country.continient == continient &amp;&amp; country.population &gt; population) &#123;</span><br><span class="line">                res.add(country)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这样的设计，当筛选条件增加时，业务逻辑也会高度耦合，业务维护成本较大。解决问题的核心是 <strong>把 filterCounties 方法进行解耦</strong>，常见的思路是传入一个类对象，根据不同需求创建不同的子类(工厂模式)。但是在 Kotlin 中支持高阶函数的特性，可以把筛选条件抽象成一个方法传入。</p><p>基于上面的描述，我们可以终结出，使用高阶函数的一个重要目标是：<strong>解耦</strong>。</p><p>根据此可以很快的抽象出一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CountryTest&#123;</span><br><span class="line">    fun isWantCountries(country:Country):Boolean&#123;</span><br><span class="line">        return country.continient == &quot;EU&quot; &amp;&amp; country.population &gt; 10000</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如何将一个函数作为另一个函数的参数？很明显如果直接传入方法名 isWantCountries， 函数名不是一个表达式，不具有类型信息，而且在 Kotlin 中万物都有类型，那么函数的类型是什么？</p><p><strong>1. 函数作为参数时的声明类型</strong></p><p>参数中声明函数的类型：</p><ul><li>通过 <code>-&gt;</code> 符号组织参数类型和返回值，左边是参数类型，右边是返回值类型。</li><li><strong>参数必须使用括号包裹</strong>。</li><li>返回值类型为 Unit，也要显式声明。</li></ul><p>基于此我们可以举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; String</span><br><span class="line">() -&gt; Int</span><br><span class="line">(Int,String) -&gt; Unit</span><br><span class="line">(name: String,age: Int) -&gt; People// 为声明参数指定名字</span><br><span class="line">(Int,String?) -&gt; Int // 参数可为空</span><br><span class="line">(Int) -&gt; ((Int,String) -&gt; Unit)// 返回值为另外一个函数</span><br><span class="line">(Int) -&gt; ((Int) -&gt; Unit) 简化等效 (Int) -&gt; Int -&gt; Unit</span><br></pre></td></tr></table></figure><p>这里需要注意的是，以上声明的是 <strong>作为参数</strong> 时的函数的类型，而在定义函数时需要注意写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 以 (Int) -&gt; ((Int,String) -&gt; Unit) 为例编写方法</span><br><span class="line">fun showTest() &#123;</span><br><span class="line">    show &#123; a: Int -&gt;</span><br><span class="line">        &#123; age: Int, name: String -&gt;</span><br><span class="line">            println(&quot;$a $age $name&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun show(block: (Int) -&gt; ((Int, String) -&gt; Unit)) &#123;</span><br><span class="line">    //此处的调用为下文中描述的 柯里化风格</span><br><span class="line">    block(1)(1,&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 声明函数的返回值为函数</span><br><span class="line">fun showAnother():(Int) -&gt;String = &#123;a:Int -&gt; &quot;&quot;&#125;</span><br><span class="line">fun showMore():(Int) -&gt;((Int,String) -&gt; String) = &#123;a:Int -&gt; &#123;</span><br><span class="line">    c,d:String -&gt; &quot;&quot;</span><br><span class="line">&#125;&#125;</span><br><span class="line">// showMore 函数可以简写成如下格式</span><br><span class="line">fun showMore2():(Int) -&gt;(Int,String) -&gt; String = &#123;a:Int -&gt; &#123;</span><br><span class="line">        c,d -&gt; &quot;&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>这时可以重新定义 filterCounties 方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun filterCounties(filter: (Country) -&gt; Boolean, countries: List&lt;Country&gt;): List&lt;Country&gt; &#123;</span><br><span class="line">    val res = mutableListOf&lt;Country&gt;()</span><br><span class="line">    for (country in countries) &#123;</span><br><span class="line">        if (filter(country)) &#123;</span><br><span class="line">            res.add(country)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 将方法传递给另外一个方法</strong></p><p>Kotlin 中存在一种特殊的语法：<strong>通过两个冒号(::)实现对某个类的方法进行引用</strong>，在 Kotlin 中万物都有对象，那么这个方法的引用可以理解为此方法类型对应的一个对象，注意这里是引用，不是调用，不能通过这种方法对方法进行调用，因为这种方法不能只能方法的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private fun test105() &#123;</span><br><span class="line">    val countApp = CountApp()</span><br><span class="line">    val countryTest = CountryTest()</span><br><span class="line">    val countries = listOf(</span><br><span class="line">        Country(&quot;A&quot;, &quot;EU&quot;, 100000)</span><br><span class="line">        , Country(&quot;B&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">        , Country(&quot;C&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">    )</span><br><span class="line">    // 双冒号引用，传入函数</span><br><span class="line">    val result = countApp.filterCounties(countryTest::isWantCountries, countries)</span><br><span class="line">    result.forEach &#123;</span><br><span class="line">        println(&quot;Country info is: $&#123;it.name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 近一步：匿名函数</strong></p><p>Kotlin 可以在 缺省方法名时，直接定义一个函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun (country:Country):Boolean&#123;</span><br><span class="line">        return country.continient == &quot;EU&quot; &amp;&amp; country.population &gt; 10000</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么可以直接使用该函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun(country: Country): Boolean &#123;</span><br><span class="line">    return country.continient == &quot;EU&quot; &amp;&amp; country.population &gt; 10000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以直接将匿名函数传入方法中，这样就省去了声明 CountryTest 变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private fun test105() &#123;</span><br><span class="line">    val countApp = CountApp()</span><br><span class="line">    val countryTest = CountryTest()</span><br><span class="line">    val countries = listOf(</span><br><span class="line">        Country(&quot;A&quot;, &quot;EU&quot;, 100000)</span><br><span class="line">        , Country(&quot;B&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">        , Country(&quot;C&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">    )</span><br><span class="line">    // 传入匿名函数</span><br><span class="line">    val result = countApp.filterCounties(fun(country: Country): Boolean &#123;</span><br><span class="line">        return country.continient == &quot;EU&quot; &amp;&amp; country.population &gt; 10000</span><br><span class="line">    &#125;, countries)</span><br><span class="line">    result.forEach &#123;</span><br><span class="line">        println(&quot;Country info is: $&#123;it.name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 更进一步： Lambda 表达式</strong></p><p>其实可以把 Lambda 理解成 <strong>简化后的匿名函数</strong>，实质是一种语法糖。将上例改进为 Lambda 表示式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private fun test105() &#123;</span><br><span class="line">    val countApp = CountApp()</span><br><span class="line">    val countries = listOf(</span><br><span class="line">        Country(&quot;A&quot;, &quot;EU&quot;, 100000)</span><br><span class="line">        , Country(&quot;B&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">        , Country(&quot;C&quot;, &quot;AS&quot;, 1000)</span><br><span class="line">    )</span><br><span class="line">    // 使用 Lambad 表达式</span><br><span class="line">    val result =</span><br><span class="line">        countApp.filterCounties(&#123; country -&gt; country.continient == &quot;EU&quot; &amp;&amp; country.population &gt; 10000 &#125;, countries)</span><br><span class="line">    result.forEach &#123;</span><br><span class="line">        println(&quot;Country info is: $&#123;it.name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-Lambda-表达式"><a href="#0x0003-Lambda-表达式" class="headerlink" title="0x0003 Lambda 表达式"></a>0x0003 Lambda 表达式</h3><p>那么具体看一下 Lambda 表达式的语法：</p><ul><li>使用 -&gt; 连接参数和返回值。</li><li>如果 Lambda 表达式返回值不为 Unit，那么默认最后一行为表达式的返回类型，此时 return 可以省略。</li><li>Lambda 表达式必须通过 {} 包裹。</li><li>如果 Lambda 声明了参数部分，且返回值类型支持类型推导，那么 Lambda 变量的类型可以省略。</li><li>如果 Lambda 变量声明了函数类型，那么 Lambda 的参数部分可以省略。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123;x:Int,y:Int -&gt; x + y&#125;</span><br><span class="line">或</span><br><span class="line">val sum:(Int,Int) -&gt; Int = &#123;x,y -&gt; x + y&#125;</span><br></pre></td></tr></table></figure><p>至此，代码解耦了过滤方法，可以按照需求传入过滤 Lambda 表达式。</p><h3 id="0x0004-Lambda-表达式是如何实现的"><a href="#0x0004-Lambda-表达式是如何实现的" class="headerlink" title="0x0004 Lambda 表达式是如何实现的"></a>0x0004 Lambda 表达式是如何实现的</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun test301() &#123;</span><br><span class="line">    listOf(1, 2, 3).forEach &#123;</span><br><span class="line">        foo(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意这里有一个等号，为 Lambda，不是普通的函数</span><br><span class="line">fun foo(int: Int) = &#123;</span><br><span class="line">    println(int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 <code>test301</code> 看到关键字 <strong>it</strong>，这是 Kotlin 简化 Lambda 表达的一种语法糖，叫做 <strong>单个参数的隐式名称</strong>，代表了 <strong>这个 Lambda 所接收的单个参数</strong>。</p><p>带有 <code>it</code> 的写法其实和以下等效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 4).forEach &#123; item -&gt;</span><br><span class="line">    foo(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是以上方法却不会有任何的打印效果，因为 Kotlin 的 Lambda 在编译以后会被编译成匿名内部类，而 foo 编译后会被编译成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> @NotNull</span><br><span class="line">public static final Function0 foo(final int var0) &#123;</span><br><span class="line">   return (Function0)(new Function0() &#123;</span><br><span class="line">      // $FF: synthetic method</span><br><span class="line">      // $FF: bridge method</span><br><span class="line">      public Object invoke() &#123;</span><br><span class="line">         this.invoke();</span><br><span class="line">         return Unit.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final void invoke() &#123;</span><br><span class="line">         int var1 = var0;</span><br><span class="line">         boolean var2 = false;</span><br><span class="line">         System.out.println(var1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在调用 foo 时其实只是返回了一个 Function0 对象，要想指定其方法需要执行其 invoke 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 4).forEach &#123; item -&gt;</span><br><span class="line">    foo(item).invoke()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时如果觉得调用 invoke 显得比较丑陋，那么可以使用括号来代替,invoke 和 括号 的作用是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 4).forEach &#123; item -&gt;</span><br><span class="line">    foo(item)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么在 Kotlin 要如此的设计？</strong></p><p>这是因为需要 <strong>兼容 Java 中的 Lambda 表达式</strong>，而在 Java 中实现 Lambda 的前提是该接口为 <strong>函数接口</strong>，而 Kotlin 这么设计就是为了能够在 Kotlin 中调用 Java 的 Lambda，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tvSelectedCh.setOnClickListener &#123;</span><br><span class="line">    // doSomethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-函数、Lambda-和闭包"><a href="#0x0005-函数、Lambda-和闭包" class="headerlink" title="0x0005 函数、Lambda 和闭包"></a>0x0005 函数、Lambda 和闭包</h3><ul><li>fun 在没有等号、只有花括号的情况下，为我们常见的函数，函数返回值类型为 Unit 时，必须声明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 函数</span><br><span class="line">fun test()&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>fun 带有等号，是 <strong>单表达式函数体</strong>。</li><li>不管是 val 还是 fun，如果是等号加花括号的语法，那么构建的就是 Lambda 表达式。如果左侧是 fun，那么就是 Lambda 表达式函数体，<strong>必须通过 invoke 或者 () 来调用 Lambda 表达式</strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//单表达式函数体、Lambda 表达式</span><br><span class="line">fun test(x:Int,y：Int):Int = x+y</span><br><span class="line">// 调用</span><br><span class="line">test.invoke(1,2)</span><br><span class="line">test(1,2)</span><br></pre></td></tr></table></figure><ul><li>在 Kotlin 中，由花括号包裹的代码块如果 <code>访问了外部的环境变量</code> 则被称为 <strong>闭包</strong>，闭包可以被当做参数传递或者直接使用，Lambda 是 Kotin 中最常见的闭包。</li></ul><p>Kotlin 中的闭包与 Java 中不同，Kotlin 中的闭包不仅可以访问外部变量还可以修改外部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    oneMain.setIClick(() -&gt; &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        //a++; 报错，不可以修改外部变量</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun test()&#123;</span><br><span class="line">    var a = 1</span><br><span class="line">    oneMain.setIClick &#123;</span><br><span class="line">        println(a)</span><br><span class="line">        a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0006-柯里化风格"><a href="#0x0006-柯里化风格" class="headerlink" title="0x0006 柯里化风格"></a>0x0006 柯里化风格</h3><p>柯里化语法是 <strong>将函数作为返回值</strong> 的一种典型的应用.</p><p>简单来说，柯里化是指 <strong>把接收到的多个参数的函数变换成一系列仅接受单一参数函数的过程</strong>，在返回最终结果前，前面的函数可以依次接收单个参数，然后返回下一个新的函数。</p><p>概念有点晦涩，直接看代码:</p><p>正常编写的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun method(a: Int, b: Int): Int = a + b</span><br><span class="line">// 进行调用</span><br><span class="line">method(1,2)</span><br></pre></td></tr></table></figure><p>// 按照柯里化的思想，重新编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun method(a: Int) = &#123; b: Int -&gt; a + b &#125;</span><br><span class="line">// 进行调用</span><br><span class="line">method(1)(2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-什么是高阶函数？&quot;&gt;&lt;a href=&quot;#0x0001-什么是高阶函数？&quot; class=&quot;headerlink&quot; title=&quot;0x0001 什么是高阶函数？&quot;&gt;&lt;/a&gt;0x0001 什么是高阶函数？&lt;/h3&gt;&lt;p&gt;Kotlin 天然支持函数特性，与 Java 类为一等公民不同，在 Kotlin 中 &lt;strong&gt;函数为一等公民&lt;/strong&gt;，函数可以直接定义在 kt 文件中。&lt;/p&gt;
&lt;p&gt;在 Java 中限制方法只能接收数据作为参数，而高阶函数除此外，&lt;strong&gt;方法的参数可以是函数&lt;/strong&gt;，&lt;strong&gt;并且函数的返回值也可以为函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;0x0002-一个实例说明为什么使用高阶函数&quot;&gt;&lt;a href=&quot;#0x0002-一个实例说明为什么使用高阶函数&quot; class=&quot;headerlink&quot; title=&quot;0x0002 一个实例说明为什么使用高阶函数&quot;&gt;&lt;/a&gt;0x0002 一个实例说明为什么使用高阶函数&lt;/h3&gt;&lt;p&gt;下面通过一个示例，依据需求的演进来一步一步揭开为什么要引入高阶函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(二)</title>
    <link href="/2019/11/14/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%BA%8C/"/>
    <id>/2019/11/14/Kotlin-核心编程-二/</id>
    <published>2019-11-14T06:13:08.000Z</published>
    <updated>2019-11-14T07:54:17.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-var-和-val-的使用规则"><a href="#0x0001-var-和-val-的使用规则" class="headerlink" title="0x0001 var 和 val 的使用规则"></a>0x0001 var 和 val 的使用规则</h3><p>在 Kotlin 中声明变量使用 var 和 val 关键字，var 可以理解为 variable，代表变量，在 val 可以理解为 final variable，代表 <strong>引用不可变</strong>，这里需要引用不可变不代表不可变，具体的含义同 Java 中 final，不再详述。</p><a id="more"></a><p>在 Kotlin 中优先使用 val 避免产生 <strong>副作用</strong>。</p><blockquote><p>副作用：修改了某处的一些东西：修改外部变量的值、IO 操作)</p></blockquote><p><strong>副作用</strong>，这个概念在函数式编程中十分重要，需要重点理解。通过下面我们可以更直观的理解副作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">private fun test104(x: Int) &#123;</span><br><span class="line">    a += 1</span><br><span class="line">    println(x + a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test104(1)</span><br><span class="line">test104(1)</span><br></pre></td></tr></table></figure><p>则打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>现在你看到的调用两次 test104(1)，但是打印结果不同，这就是很明显的副作用，而如果使用 val 声明变量 a，那么就不会存在这种情况，因为对 val 变量赋值是错误的。</p><p>基于此，在 Kotlin 中 <strong>尽量使用 val 声明本身不可变的变量</strong>，以此来避免副作用。</p><ul><li>var 的适用场景：</li></ul><p>var 占用内存少，在某些业务中如果需要存储大量的数据，使用 var 则更适合。</p><h3 id="0x0002-const-修饰符"><a href="#0x0002-const-修饰符" class="headerlink" title="0x0002 const 修饰符"></a>0x0002 const 修饰符</h3><p>在 Kotlin 中 const 为常量修饰符，const 只能够修饰 val，不能修饰 var，其实 val 拥有了 const 的大部分功能，但是经过const修饰的属性只能用拼接 const 修饰的属性去拼接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val one = &quot;one&quot;</span><br><span class="line">const val two = &quot;two$one&quot;// 这样会报错的</span><br><span class="line">const val three = &quot;three&quot;</span><br><span class="line">const val four = &quot;four$three&quot;</span><br></pre></td></tr></table></figure><h3 id="0x0003-增强的类型推导"><a href="#0x0003-增强的类型推导" class="headerlink" title="0x0003 增强的类型推导"></a>0x0003 增强的类型推导</h3><p>编译器可以在不显示声明类型的情况下，自动推导出它需要的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val num = 12</span><br><span class="line">    val numLong = 12L</span><br><span class="line">    println(num.javaClass.name)</span><br><span class="line">    println(numLong.javaClass.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过日志，Kotlin 会自动推导变量的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">long</span><br></pre></td></tr></table></figure><h3 id="0x0004-增强的函数"><a href="#0x0004-增强的函数" class="headerlink" title="0x0004 增强的函数"></a>0x0004 增强的函数</h3><p>在 Kotlin 中增强了函数特性，可以吧 ‘{}’ 取消，用等号直接定义函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 增强的函数</span><br><span class="line">private fun test102(x: Int, y: Int) = x + y</span><br></pre></td></tr></table></figure><p><strong>表达式函数</strong>：在 Kotlin 中支持使用单行表达式与等号的语法来定义函数，可以成为表达式函数。</p><p>在 Kotlin 中 <strong>表达式</strong> 有非常重要的地位，那么什么是表达式呢？</p><blockquote><p>在 Kotlin 中表达式可以是一个值、变量、常量、操作符、函数，或者它们的组合，编程语言对其进行解释和计算，以 <strong>产生另外一个值(重点)</strong>。</p></blockquote><p>在 Kotlin 中 if 是一个语句，同时也是表达式，如果把 if 语句赋值给变量，那么此时 if 语句为表达式，则必须存在 else 语句，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// if 作为语句</span><br><span class="line">if(条件判断)&#123;</span><br><span class="line">    // 执行操作</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    // 执行操作</span><br><span class="line">&#125;</span><br><span class="line">// if 作为表达式</span><br><span class="line">val name = if (isTrue) &#123;</span><br><span class="line">    println(&quot;true&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;false&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-字符串判等"><a href="#0x0005-字符串判等" class="headerlink" title="0x0005 字符串判等"></a>0x0005 字符串判等</h3><p>在 Kotlin 中，相等有结构相等和引用相等：</p><ul><li>结构相等：通过操作符 == 判断两个对象的 <strong>内容</strong> 是否相等。</li><li>引用相等：通过操作符 === 两个对象的 <strong>引用</strong> 是否相等。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val a = &quot;Kotlin&quot;</span><br><span class="line">val b = &quot;Kotlin&quot;</span><br><span class="line">val c = &quot;Kot&quot;</span><br><span class="line">val d = &quot;lin&quot;</span><br><span class="line">val e = c + d</span><br><span class="line">println(&quot;a==b? :$&#123;a == b&#125;&quot;)</span><br><span class="line">println(&quot;a===b? :$&#123;a === b&#125;&quot;)</span><br><span class="line">println(&quot;a==e? :$&#123;a == e&#125;&quot;)</span><br><span class="line">println(&quot;a===e? :$&#123;a === e&#125;&quot;)</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a==b? :true</span><br><span class="line">a===b? :true</span><br><span class="line">a==e? :true</span><br><span class="line">a===e? :false</span><br></pre></td></tr></table></figure><hr><p><strong>读书笔记：</strong></p><p><a href="https://item.jd.com/12519581.html" target="_blank" rel="noopener">Kotlin 核心编程</a></p><p><strong>知识备份：</strong></p><p><a href="https://blog.csdn.net/u010218288/article/details/86062858" target="_blank" rel="noopener">Kotlin 编译流程简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-var-和-val-的使用规则&quot;&gt;&lt;a href=&quot;#0x0001-var-和-val-的使用规则&quot; class=&quot;headerlink&quot; title=&quot;0x0001 var 和 val 的使用规则&quot;&gt;&lt;/a&gt;0x0001 var 和 val 的使用规则&lt;/h3&gt;&lt;p&gt;在 Kotlin 中声明变量使用 var 和 val 关键字，var 可以理解为 variable，代表变量，在 val 可以理解为 final variable，代表 &lt;strong&gt;引用不可变&lt;/strong&gt;，这里需要引用不可变不代表不可变，具体的含义同 Java 中 final，不再详述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 核心编程(一)：Kotlin 生态的基本了解</title>
    <link href="/2019/11/14/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B-%E4%B8%80/"/>
    <id>/2019/11/14/Kotlin-核心编程-一/</id>
    <published>2019-11-14T05:59:04.000Z</published>
    <updated>2019-11-14T07:54:19.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-Kotlin-产生的背景"><a href="#0x0001-Kotlin-产生的背景" class="headerlink" title="0x0001  Kotlin 产生的背景"></a>0x0001  Kotlin 产生的背景</h3><p>Kotlin  和 Java 一样，为在 JVM 平台上运行的语言。JVM 平台下的语言比较火的有：Java、Scala、Kotlin 等。</p><p>Java8 的探索：</p><ul><li>高阶函数和 Lambda</li><li>Stream API</li><li>Optional 类</li><li>等其他特性</li></ul><a id="more"></a><p>在更高版本的 Java 中，引入更多的特性。</p><p>Kotlin 和 Scala 的设计理念不同。</p><p><strong>Scala</strong></p><ul><li>设计理念：more than Java</li><li>Scala 发明者：在 Java 中引入泛型的大佬。</li><li>Scala 在设计之初就集成了面向对象和函数式。</li></ul><p>Scala 彻底拥抱了函数式，同时拥有各种特性，是程序员梦想中的语言。</p><p>Scala 现在主要的使用领域：大数据。Spark 用 Scala 开发的。</p><p>Scala 简单而不容易的哲学相应的代价：</p><ul><li>更加抽象的编程范式，学习成本大。</li><li>建立了与 Java 完全不同的思维模式。</li></ul><p>基于此 Kotlin 作为 JVM 上新兴的编程语言，慢慢的走入开发者的视野。</p><h3 id="0x0002-Kotlin-的设计理念：改良的-Java"><a href="#0x0002-Kotlin-的设计理念：改良的-Java" class="headerlink" title="0x0002 Kotlin 的设计理念：改良的 Java"></a>0x0002 Kotlin 的设计理念：改良的 Java</h3><ul><li>设计理念：a better Java</li></ul><p>2010 年，JetBrains 看到了 Java 相比与新语言的滞后性，产生创造了 Kotlin 这种改良 Java 的想法。</p><p>Kotlin 与现有的 Java 代码完全兼容,。</p><ul><li>兼容其语法和生态，Java 程序员更容易掌握。</li><li>更加实用，创造扩展的语法。</li><li>Java 中没有的语法糖，改善了开发中的体验，比如 Smart Cast:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Smart Cast 语法</span><br><span class="line">if(view is ViewGroup)&#123;</span><br><span class="line">    view.addView(childView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强大的生态</strong></p><ul><li>Android开发，现在 Kotlin 已经为 Google Android 的官方开发语言。</li><li>服务端开发，Spring FrameWork 5 已经拥抱了 Kotlin。</li><li>前端开发</li><li>原生开发，Kotlin Native 项目使 Kotlin 离开了 JVM，直接编译成机器代码提供系统环境运行，单处于早期阶段。</li></ul><hr><p><strong>读书笔记：</strong></p><p><a href="https://item.jd.com/12519581.html" target="_blank" rel="noopener">Kotlin 核心编程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-Kotlin-产生的背景&quot;&gt;&lt;a href=&quot;#0x0001-Kotlin-产生的背景&quot; class=&quot;headerlink&quot; title=&quot;0x0001  Kotlin 产生的背景&quot;&gt;&lt;/a&gt;0x0001  Kotlin 产生的背景&lt;/h3&gt;&lt;p&gt;Kotlin  和 Java 一样，为在 JVM 平台上运行的语言。JVM 平台下的语言比较火的有：Java、Scala、Kotlin 等。&lt;/p&gt;
&lt;p&gt;Java8 的探索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高阶函数和 Lambda&lt;/li&gt;
&lt;li&gt;Stream API&lt;/li&gt;
&lt;li&gt;Optional 类&lt;/li&gt;
&lt;li&gt;等其他特性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kotlin 核心编程" scheme="/tags/Kotlin-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    
      <category term="读书笔记" scheme="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android CPU 架构</title>
    <link href="/2019/11/12/Android-CPU-%E6%9E%B6%E6%9E%84/"/>
    <id>/2019/11/12/Android-CPU-架构/</id>
    <published>2019-11-12T10:29:44.000Z</published>
    <updated>2019-11-12T10:34:22.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-什么是-ABI"><a href="#0x0001-什么是-ABI" class="headerlink" title="0x0001 什么是 ABI"></a>0x0001 什么是 ABI</h3><p>ABI(Application Binary Interface、程序二进制接口)，描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低接口。</p><p>由于不同的手机使用不同的 CPU，而不同的 CPU 支持不同的指令集，不同指令集下的数据格式、操作规范不尽相同，所以CPU 与指令集的每种组合都有专属的应用二进制接口，即 ABI，所以在开发过程中，如果我们引入 so 库，就需要为每个 CPU 架构指定</p><a id="more"></a><p>相应的 ABI 下的 so 库。</p><h3 id="0x0002-配置-so-库规则"><a href="#0x0002-配置-so-库规则" class="headerlink" title="0x0002 配置 so 库规则"></a>0x0002 配置 so 库规则</h3><blockquote><p>你应该尽可能的提供专为每个ABI优化过的.so文件，但要么全部支持，要么都不支持：你不应该混合着使用。你应该为每个ABI目录提供对应的.so文件。</p></blockquote><p>以 arm64-v8a 为例展示上面规则，<code>arm64-v8a</code> 是可以向下兼容的，但前提是你的项目里面没有 <code>arm64-v8a</code> 的文件夹，这是什么意思呢？以下为例：</p><ul><li><p>armeabi: a.so、b.so</p></li><li><p>arm64-v8a: a.so</p></li></ul><p>在ABI 类型为 arm64-v8a 的手机中使用到 b.so 时，发现存在 arm64-v8a 目录，但是此时该文件夹下没有 b.so，就会产生运行时异常。可以将 <code>arm64-v8a</code> 文件夹删除，那么手机在检索 so 库时发现没有 <code>arm64-v8a</code> 文件，就会去查找 armeabi 文件夹下是否有需要的 b.so。</p><h3 id="0x0003-Android开发中常见的指令集体系"><a href="#0x0003-Android开发中常见的指令集体系" class="headerlink" title="0x0003 Android开发中常见的指令集体系"></a>0x0003 Android开发中常见的指令集体系</h3><table><thead><tr><th>指令集</th><th>厂商</th><th>位数</th></tr></thead><tbody><tr><td>x86(x86)</td><td>Intel</td><td>32</td></tr><tr><td>x86_64(Intel 64)</td><td>Intel</td><td>64</td></tr><tr><td>arm64-v8a(ARMV8-A)</td><td>AMR</td><td>64</td></tr><tr><td>armeabi(ARM v5)</td><td>ARM</td><td>32</td></tr><tr><td>armeabi-v7a(ARM v7)</td><td>ARM</td><td>32</td></tr><tr><td>mips</td><td>MIPS</td><td>32</td></tr><tr><td>mips64</td><td>MIPS</td><td>64</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intel 64 指令集在 x86基础上扩展的</span><br><span class="line">armabi 是针对旧的或者普通的ARM v5 CPU</span><br><span class="line">armabi-v7a 是针对 ARM v7 CPU</span><br><span class="line">arm64-v8a 是针对最新的 ARM v8a CPU的。</span><br><span class="line"></span><br><span class="line">特别注意：x86指令集有两种CPU位，既有32位的，也有64位的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">armeabi 设备只兼容 armeabi；</span><br><span class="line">armeabi-v7a 设备兼容 armeabi-v7a、armeabi；</span><br><span class="line">arm64-v8a 设备兼容 arm64-v8a、armeabi-v7a、armeabi；</span><br><span class="line">X86 设备兼容 X86、armeabi；</span><br><span class="line">X86_64 设备兼容 X86_64、X86、armeabi；</span><br><span class="line">mips64 设备兼容 mips64、mips；</span><br><span class="line">mips 只兼容 mips；</span><br></pre></td></tr></table></figure><p>很多设备都支持多于一种的ABI。例如 ARM64 和 x86 设备也可以同时运行armeabi-v7a 和 armeabi 的二进制包。但最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等)，但同时也增大了 APK 的体积，需自行权衡。</p><h3 id="0x0004-安装时自动解压原生代码"><a href="#0x0004-安装时自动解压原生代码" class="headerlink" title="0x0004 安装时自动解压原生代码"></a>0x0004 安装时自动解压原生代码</h3><p>安装文件时，软件包管理器服务将扫描 APK，并查找合适的共享库文件。找到所需库时，软件包管理器会将它们复制到应用的 data 目录 (<code>data/data/&lt;package_name&gt;/lib/</code>) 下的 /lib/lib<name>.so。</name></p><p>如果根本没有共享对象文件，应用也会编译并安装，但在运行时会崩溃。</p><hr><p><strong>知识链接：</strong></p><p><a href="https://developer.android.google.cn/ndk/guides/abis" target="_blank" rel="noopener">Google 官方文档：ABI 管理</a></p><p><a href="http://www.jianshu.com/p/b758e36ae9b5" target="_blank" rel="noopener">Android jniLibs下目录详解 (.so文件)</a></p><p><a href="http://www.jianshu.com/p/cb15ba69fa89" target="_blank" rel="noopener">Android SO文件的概念、兼容、适配和可能的错误</a></p><p><a href="http://www.jianshu.com/p/cb05698a1968" target="_blank" rel="noopener">关于Android的.so文件你所需要知道的</a></p><p><a href="http://www.jianshu.com/p/7b9ab71a491e" target="_blank" rel="noopener">Android开发——关于.so文件的那些事</a></p><p><a href="http://www.cnblogs.com/janehlp/p/7473240.html" target="_blank" rel="noopener">Android 关于arm64-v8a、armeabi-v7a、armeabi、x86下的so文件兼容问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-什么是-ABI&quot;&gt;&lt;a href=&quot;#0x0001-什么是-ABI&quot; class=&quot;headerlink&quot; title=&quot;0x0001 什么是 ABI&quot;&gt;&lt;/a&gt;0x0001 什么是 ABI&lt;/h3&gt;&lt;p&gt;ABI(Application Binary Interface、程序二进制接口)，描述了应用程序和操作系统之间，一个应用和它的库之间，或者应用的组成部分之间的低接口。&lt;/p&gt;
&lt;p&gt;由于不同的手机使用不同的 CPU，而不同的 CPU 支持不同的指令集，不同指令集下的数据格式、操作规范不尽相同，所以CPU 与指令集的每种组合都有专属的应用二进制接口，即 ABI，所以在开发过程中，如果我们引入 so 库，就需要为每个 CPU 架构指定&lt;/p&gt;
    
    </summary>
    
    
      <category term="CPU 架构" scheme="/tags/CPU-%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>git submodule 使用</title>
    <link href="/2019/11/05/git-submodule-%E4%BD%BF%E7%94%A8/"/>
    <id>/2019/11/05/git-submodule-使用/</id>
    <published>2019-11-05T04:22:23.000Z</published>
    <updated>2019-11-13T10:18:09.665Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-为项目添加子模块"><a href="#1-为项目添加子模块" class="headerlink" title="1. 为项目添加子模块"></a>1. 为项目添加子模块</h3><blockquote><p>git submodule add [repository] [path] </p></blockquote><p>此命令会生成 .gitmodule 文件以及在 .git/config 文件中添加子模块的相应信息</p><h3 id="2-克隆一个带有子模块的项目"><a href="#2-克隆一个带有子模块的项目" class="headerlink" title="2. 克隆一个带有子模块的项目"></a>2. 克隆一个带有子模块的项目</h3><a id="more"></a><p><strong>方式一：</strong></p><blockquote><p>git clone xxxx</p></blockquote><p>这是会发现子模块的内容并未被克隆，只有对象模块的文件夹，通过以下命令可以查看子模块的状态：</p><blockquote><p>git submodule status</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-01xxxxx lib/lib_a</span><br><span class="line">-f25xxxx lib/lib_b</span><br></pre></td></tr></table></figure><p>最前面的减号的含义是该子模组未被检出。</p><p>如果想要检出子模组的外部库，需要执行以下命令：</p><blockquote><p>git submodule init</p></blockquote><p>此命令会生成 .gitmodule 文件以及在 .git/config 文件中添加子模块的相应信息。</p><p>然后执行以下命令完成子模组的克隆：</p><blockquote><p>git submodule update</p></blockquote><p><strong>方式二：</strong></p><p>可以直接使用如下命令，在克隆项目的同时递归克隆子模块组：</p><blockquote><p>git clone [reps] [path] –recursive</p></blockquote><h3 id="修改子模组以及子模组的更新"><a href="#修改子模组以及子模组的更新" class="headerlink" title="修改子模组以及子模组的更新"></a>修改子模组以及子模组的更新</h3><p><strong>修改子模组</strong></p><p>在子模组版本库的工作区中修改相应内容，之后提交远端库，修改子模组库对主项目库不会有影响。</p><p>此情况下，推荐先推送子模组，在推送父版本库。</p><p><strong>更新子模组库</strong></p><p>在子模组库中拉取子模组远端库最新提交。</p><h3 id="删除子模组"><a href="#删除子模组" class="headerlink" title="删除子模组"></a>删除子模组</h3><blockquote><p>git rm –cached xxx<br>rm -rf xxx<br>rm .gitmodules</p></blockquote><p>移除 .git/config 文件中关于子模组的配置。</p><hr><p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">Git 中 .git/config 中的属性含义</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-为项目添加子模块&quot;&gt;&lt;a href=&quot;#1-为项目添加子模块&quot; class=&quot;headerlink&quot; title=&quot;1. 为项目添加子模块&quot;&gt;&lt;/a&gt;1. 为项目添加子模块&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;git submodule add [repository] [path] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此命令会生成 .gitmodule 文件以及在 .git/config 文件中添加子模块的相应信息&lt;/p&gt;
&lt;h3 id=&quot;2-克隆一个带有子模块的项目&quot;&gt;&lt;a href=&quot;#2-克隆一个带有子模块的项目&quot; class=&quot;headerlink&quot; title=&quot;2. 克隆一个带有子模块的项目&quot;&gt;&lt;/a&gt;2. 克隆一个带有子模块的项目&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Git" scheme="/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础学习(二)：环境变量</title>
    <link href="/2019/11/04/Shell%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>/2019/11/04/Shell基础学习环境变量/</id>
    <published>2019-11-04T10:10:36.000Z</published>
    <updated>2019-11-25T13:02:58.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-环境变量配置文件"><a href="#0x0001-环境变量配置文件" class="headerlink" title="0x0001 环境变量配置文件"></a>0x0001 环境变量配置文件</h3><p>要想对配置文件的修改想要永久生效，需要写入配置文件。</p><p>那环境变量配置文件的作用是什么？</p><a id="more"></a><p>环境变量配置文件主要是 <strong>定义对系统操作环境生效的系统默认环境变量</strong>，比如 PATH、PSI、HISTSIZE、HOSTNAME 等默认环境变量。</p><h3 id="0x0002-source-命令"><a href="#0x0002-source-命令" class="headerlink" title="0x0002 source 命令"></a>0x0002 source 命令</h3><p>环境变量的配置后需要重新登录才会生效，操作起来比较麻烦，使用 source 命令可以使修改后的配置立即生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source 配置文件 </span><br><span class="line">或 </span><br><span class="line">. 配置文件</span><br></pre></td></tr></table></figure><p>以上两者等效。</p><h3 id="0x0003-系统中的环境变量配置文件"><a href="#0x0003-系统中的环境变量配置文件" class="headerlink" title="0x0003 系统中的环境变量配置文件"></a>0x0003 系统中的环境变量配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br><span class="line">/etc/bashrc</span><br><span class="line">以上对所有登录用户有效</span><br><span class="line">~/.bash_profile</span><br><span class="line">~/.bashrc</span><br><span class="line">以上两个文件只对当前用户有效</span><br></pre></td></tr></table></figure><h3 id="0x0004-环境变量配置文件的调用顺序"><a href="#0x0004-环境变量配置文件的调用顺序" class="headerlink" title="0x0004 环境变量配置文件的调用顺序"></a>0x0004 环境变量配置文件的调用顺序</h3><p> 登录情况下：</p><p><img src="/../images/2019_09_20_01.png" alt></p><p>按照顺序查看每个配置文件的作用</p><p>/etc/profile 的作用：</p><ul><li><p>USER 变量</p></li><li><p>LOGNAME 变量</p></li><li><p>MAIL 变量</p></li><li><p>PATH 变量</p></li><li><p>HOSTNAME 变量</p></li><li><p>HISTNAME 变量</p></li><li><p>umask</p></li><li><p>调用 /etc/profile.d/*.sh 文件</p><p>~/.bash_profile 的作用：</p></li><li><p>调用了 ~/.bashrc 文件</p></li><li><p>在PATH变量后面加入了“:$HOME/bin” 这个目录</p><p>~/.bashrc 的作用：</p></li><li><p>定义默认别名</p></li><li><p>调用 /etc/bashrc</p></li></ul><p>/etc/bashrc 的作用：</p><ul><li>PS1 变量</li><li>umask</li><li>PATH 变量</li><li>调用 /etc/profile.d/*.sh 文文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-环境变量配置文件&quot;&gt;&lt;a href=&quot;#0x0001-环境变量配置文件&quot; class=&quot;headerlink&quot; title=&quot;0x0001 环境变量配置文件&quot;&gt;&lt;/a&gt;0x0001 环境变量配置文件&lt;/h3&gt;&lt;p&gt;要想对配置文件的修改想要永久生效，需要写入配置文件。&lt;/p&gt;
&lt;p&gt;那环境变量配置文件的作用是什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础学习(一）</title>
    <link href="/2019/11/04/Shell%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>/2019/11/04/Shell基础学习一/</id>
    <published>2019-11-04T10:09:45.000Z</published>
    <updated>2019-11-25T13:03:04.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-Bash-常用快捷键"><a href="#0x0001-Bash-常用快捷键" class="headerlink" title="0x0001 Bash 常用快捷键"></a>0x0001 Bash 常用快捷键</h3><p>Ctrl + A: 将光标移到命令行开头</p><p>Ctrl + E: 将光标移到命令行结尾</p><p>Ctrl + U: 删除或剪切光标之前的命令</p><p>Ctrl + K: 删除或剪切光标之后的命令</p><p>Ctrl + Y: 粘贴以上两个快捷键的内容</p><a id="more"></a><p>Ctrl + R: 在历史命令中搜索</p><p>Ctrl + D: 退出当前终端</p><p>Ctrl + L: 清屏</p><p>Ctrl + C: 强制终止当前命令</p><h3 id="0x0002-Bash-变量"><a href="#0x0002-Bash-变量" class="headerlink" title="0x0002 Bash 变量"></a>0x0002 Bash 变量</h3><p><strong>变量分类：</strong></p><ul><li>用户自定义变量</li><li>系统变量：保存和系统操作环境相关的数据。</li><li>位置参数变量：用来向脚本传递参数或数据，变量名不可自定义，变量的作用是固定的。</li><li>预定义变量：在 Bash 中已经定义好的变量，不可自定义，变量的作用是固定的。</li></ul><h3 id="0x0003-用户自定义变量-本地变量"><a href="#0x0003-用户自定义变量-本地变量" class="headerlink" title="0x0003 用户自定义变量(本地变量)"></a>0x0003 用户自定义变量(本地变量)</h3><ul><li>定义变量</li></ul><blockquote><p>name=123</p></blockquote><ul><li>变量叠加</li></ul><blockquote><p>aa=123</p></blockquote><blockquote><p>aa=”$aa”356</p></blockquote><blockquote><p>aa=${aa}3533</p></blockquote><ul><li>变量的调用</li></ul><blockquote><p>echo $aa</p></blockquote><ul><li>变量的查看</li></ul><blockquote><p>set</p></blockquote><ul><li>变量的删除</li></ul><blockquote><p>unset aa</p></blockquote><h3 id="0x0003-环境变量"><a href="#0x0003-环境变量" class="headerlink" title="0x0003 环境变量"></a>0x0003 环境变量</h3><p>用户自定义变量只在当前 Shell 中生效，而环境变量会在当前 Shell 和这个 Shell 的所有子 Shell 中生效。如果把环境变量配置到相应的配置文件中，那么这个环境变量会在所有的 Shell 中生效。</p><ul><li>设置环境变量</li></ul><blockquote><p>export 变量名=变量值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export name=qwe</span><br><span class="line">或</span><br><span class="line">name=qwe</span><br><span class="line">export name</span><br></pre></td></tr></table></figure><ul><li>查询环境变量</li></ul><blockquote><p>env</p></blockquote><ul><li>删除环境变量</li></ul><blockquote><p>unset 变量名</p></blockquote><p><strong>系统常见常用环境变量：</strong></p><ul><li>PATH</li></ul><p>系统查找命令的路径。可以通过变量叠加将自己写的 shell 文件加入 PATH 中，临时生效。</p><ul><li><p>PS1</p><p>定义系统提示符变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\d: 显示日期。格式：星期 月 日</span><br><span class="line">\h: 显示简写主机名。如果 “loalhost”</span><br><span class="line">\t: 显示 24 小时制时间。格式为： HH：MM：SS。</span><br><span class="line">\T: 显示 12 小时制时间。格式为： HH：MM：SS。</span><br><span class="line">\A: 显示 24 小时制时间。格式为： HH：MM。</span><br><span class="line">\u: 显示当前用户名。</span><br><span class="line">\w: 显示当前目录所在完整名称。</span><br><span class="line">\W: 显示当前目录的最后一个目录。</span><br><span class="line">\#: 显示执行的第几个命令。</span><br><span class="line">\$: 提示符，若是 root 则显示为 “#”，普通用户显示为：“$”</span><br></pre></td></tr></table></figure></li></ul><h3 id="0x0004-位置参数变量"><a href="#0x0004-位置参数变量" class="headerlink" title="0x0004  位置参数变量"></a>0x0004  位置参数变量</h3><p>向 shell 脚本中传递参数。</p><p>位置参数变量| 作用<br>|–|–|<br>$n| n 为数字，$0 代表命令本身，$1~$9 代表第一到第九个参数，十以上的参数需要使用大括号，如： ${10}<br>|$*|这个变量代表命令行中所有的参数，把所有的参数看成一个整体<br>|$@|这个变量代表命令行中所有的参数，把参数分开来看<br>|$#|这个变量代表命令行中所有参数的个数</p><p>注意 $* h和 $@ 的区别。</p><h3 id="0x0005-预定义变量"><a href="#0x0005-预定义变量" class="headerlink" title="0x0005 预定义变量"></a>0x0005 预定义变量</h3><p>其实位置参数变量也是预定义变量的一种，不过由于其独特的作用而单独拿出来标识一下。</p><p>预定义变量| 作用<br>|–|–|<br>|$?| 最后一次执行命令的返回状态。如果是 0 ，代表上一条命令执行成功<br>$$|当前进程的进程号(PID)<br>$!|后台运行的最后一个进程的进程号(PID)</p><p>在编写 Shell 时不可能都是固定值，有时候需要操作者进行输入操作。</p><ul><li>接收键盘输入</li></ul><blockquote><p>read [选项] [变量名]</p></blockquote><p>选项：</p><ul><li>-p “提示信息”: 等待输入的提示信息</li><li>-t 秒数：指定命令等待输入的时间</li><li>-n z字符数：命令只接受指定数量的字符，开始执行脚本</li><li>-s：隐藏输入内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-Bash-常用快捷键&quot;&gt;&lt;a href=&quot;#0x0001-Bash-常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Bash 常用快捷键&quot;&gt;&lt;/a&gt;0x0001 Bash 常用快捷键&lt;/h3&gt;&lt;p&gt;Ctrl + A: 将光标移到命令行开头&lt;/p&gt;
&lt;p&gt;Ctrl + E: 将光标移到命令行结尾&lt;/p&gt;
&lt;p&gt;Ctrl + U: 删除或剪切光标之前的命令&lt;/p&gt;
&lt;p&gt;Ctrl + K: 删除或剪切光标之后的命令&lt;/p&gt;
&lt;p&gt;Ctrl + Y: 粘贴以上两个快捷键的内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>从EventBus 3.0 源码理解事件总线机制</title>
    <link href="/2019/11/04/%E4%BB%8EEventBus%203.0%20%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6/"/>
    <id>/2019/11/04/从EventBus 3.0 源码理解事件总线机制/</id>
    <published>2019-11-04T09:44:46.000Z</published>
    <updated>2019-11-05T06:45:37.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-基本介绍"><a href="#0x0001-基本介绍" class="headerlink" title="0x0001 基本介绍"></a>0x0001 基本介绍</h3><p>EventBus 可以将事件在 <strong>线程之间传递</strong>，实现跨进程通信，上手简单。</p><h3 id="0x0002-项目配置-EventBus-以及基本使用"><a href="#0x0002-项目配置-EventBus-以及基本使用" class="headerlink" title="0x0002 项目配置 EventBus 以及基本使用"></a>0x0002 项目配置 EventBus 以及基本使用</h3><p>在 app 模块下进行以来配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &quot;org.greenrobot:eventbus:$versions.eventbus_version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>具体使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义事件</span><br><span class="line">public class EventBusEvent &#123;</span><br><span class="line">    private String msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 在相应类中注册 EventBus，定义相应事件的方法，并且在销毁时解绑 EventBus</span><br><span class="line"></span><br><span class="line">public class EventBusActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Button button;</span><br><span class="line">    private TextView textView;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_event_bus);</span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line">        textView = findViewById(R.id.text);</span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line">        button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View view) &#123;</span><br><span class="line">                EventBusEvent event = new EventBusEvent();</span><br><span class="line">                event.setMsg(&quot;已接收到事件!&quot;);</span><br><span class="line">                // 发布事件</span><br><span class="line">                EventBus.getDefault().post(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">    public void onTestEvent(EventBusEvent event) &#123;</span><br><span class="line">        textView.setText(event.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 在相应类的操作中向 EventBus 发送事件,就如上面 `EventBus.getDefault().post(event)` 的操作。</span><br></pre></td></tr></table></figure><h3 id="0x0003-EventBus-源码中的关键类"><a href="#0x0003-EventBus-源码中的关键类" class="headerlink" title="0x0003 EventBus 源码中的关键类"></a>0x0003 EventBus 源码中的关键类</h3><ul><li><p>EventBusBuilder：</p><p>  为 EventBus 设置初始条件的类。</p></li><li><p>SubscriberMethodFinder：</p><p>  在订阅者的类中寻找订阅方法 ，即标注 @Subscribe 的方法。从 EventBusBuilder 中获取初始对象。</p></li></ul><ul><li><p>FindState:</p><p>  保存了订阅者是谁、订阅者的订阅方法。EventBus 防止大量创建 FindState，使用享元模式复用 FindState。</p></li><li><p>SubscriberInfo：(子类 AbstractSubscriberInfo、最终子类 SimpleSubscriberInfo))</p><p>  见字识意，订阅者的信息，保存了父类信息、订阅方法等信息。</p></li><li><p>Subscription：</p><p>  一个订阅关系。其中包含的信息有：订阅者、订阅方法。</p></li><li><p>SubscriberMethod：</p><p>  订阅者方法描述类。</p></li></ul><ul><li><p>Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber:</p><p>一个订阅者拥有多少个事件类型。</p></li><li><p>Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList<subscription>&gt; subscriptionsByEventType:</subscription></p></li></ul><p>事件类型下的订阅关系。</p><h3 id="0x0004源码解析"><a href="#0x0004源码解析" class="headerlink" title="0x0004源码解析"></a>0x0004源码解析</h3><h4 id="1-在订阅者中注册-EventBus"><a href="#1-在订阅者中注册-EventBus" class="headerlink" title="1. 在订阅者中注册 EventBus"></a>1. 在订阅者中注册 EventBus</h4><p>具体订阅见上面示例中的代码，最终通过以下代码开始注册逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(this);</span><br><span class="line"></span><br><span class="line">public void register(Object subscriber) &#123;</span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    // 获取订阅事件</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">            // 产生订阅关系</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，EventBus 完成了获得订阅事件、产生订阅关系的过程。</p><h4 id="2-获得订阅者中的订阅事件的方式"><a href="#2-获得订阅者中的订阅事件的方式" class="headerlink" title="2. 获得订阅者中的订阅事件的方式"></a>2. 获得订阅者中的订阅事件的方式</h4><p>获得订阅者中的订阅事件(被 @Subscribe 标记的方法)，会从子类到父类依次寻找订阅方法。</p><p>根据是否配置 APT 分为两种情况：</p><ul><li>没有使用 APT 生成索引</li></ul><p>通过反射识别订阅者中被 @Subscribe 标记的方法。</p><ul><li>使用 APT 生成索引</li></ul><p>通过索引直接获得订阅方法，使用 APT 生成索引不在此处详述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br></pre></td></tr></table></figure><p>继续跟进代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    // 首先，检查缓存中是否含义订阅者相应的订阅方法</span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    if (subscriberMethods != null) &#123;</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">    // 默认为 false</span><br><span class="line">    if (ignoreGeneratedIndex) &#123;</span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass</span><br><span class="line">                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 将新的订阅者添加到缓存中</span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        return subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Eventbus 会通过 findUsingInfo 方法获取订阅者的订阅方法，会在此处根据 findState.subscriberInfo 的具体返回值，判断项目是否配置 APT 生成索引，具体生成如下两个分支：</p><ol><li>通过反射获取订阅事件。</li><li>通过 APT 方式获取订阅事件。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    while (findState.clazz != null) &#123;</span><br><span class="line">        // 如果使用索引，那么 findState.subscriberInfo 不为 null</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        if (findState.subscriberInfo != null) &#123;</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处仅具体阐述通过反射获取订阅方法的方式，通过 APT 索引的方式见：<a href="https://leegyplus.github.io/2019/11/04/EventBus%20使用%20APT%20生成索引以及源码分析/" target="_blank" rel="noopener">EventBus 使用 APT 生成索引以及源码分析</a></p><h4 id="3-通过反射的方式获取订阅事件"><a href="#3-通过反射的方式获取订阅事件" class="headerlink" title="3. 通过反射的方式获取订阅事件"></a>3. 通过反射的方式获取订阅事件</h4><p>使用反射获取订阅事件的具体流程，在 findUsingReflectionInSingleClass 方法中操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void findUsingReflectionInSingleClass(FindState findState) &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    // 通过反射获取订阅者中的所有方法</span><br><span class="line">    methods = findState.clazz.getMethods();</span><br><span class="line">    ....</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        int modifiers = method.getModifiers();</span><br><span class="line">        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            if (parameterTypes.length == 1) &#123;</span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                if (subscribeAnnotation != null) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[0];</span><br><span class="line">                    if (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">                throw new EventBusException(&quot;@Subscribe method &quot; + methodName +</span><br><span class="line">                        &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();</span><br><span class="line">            throw new EventBusException(methodName +</span><br><span class="line">                    &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射的方式遍历订阅者的所有方法，从而获得所有的订阅方法，如果订阅者没有订阅方法，则会报出相应的异常。</p><h4 id="4-产生订阅关系"><a href="#4-产生订阅关系" class="headerlink" title="4. 产生订阅关系"></a>4. 产生订阅关系</h4><p>在第一步中获得了订阅者的所有订阅方法，下面为第二阶段，重点为：订阅者与如何与订阅方法产生订阅关系(订阅者和一个订阅方法产生一个 Subscription 对象)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe(subscriber, subscriberMethod);</span><br></pre></td></tr></table></figure><p>subscribe 的关键代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    // 订阅者和订阅方法产生的订阅关系</span><br><span class="line">    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    if (subscriptions == null) &#123;</span><br><span class="line">        subscriptions = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        // 以事件类型为 key，将订阅关系集合作为 value ，添加到 Map 中</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    int size = subscriptions.size();</span><br><span class="line">    for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            // 将 newSubscription 添加到集合中</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // typesBySubscriber 以 订阅者为 key ，以订阅事件类型为 value 的 Map</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    if (subscribedEvents == null) &#123;</span><br><span class="line">        subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，订阅的动作得以完成，说是订阅动作，其实就是将订阅关系、事件类型、订阅者三者之间的对应关系通过集合保存下来，重点关注两个 Map 集合。</p><h4 id="5-两个重要的-Map-对象"><a href="#5-两个重要的-Map-对象" class="headerlink" title="5. 两个重要的 Map 对象"></a>5. 两个重要的 Map 对象</h4><p><strong>第一个 Map 集合：typesBySubscriber</strong></p><p>根据变量名可知，typesBySubscriber 为 <strong>以订阅者为 key</strong>，以 <strong>事件类型为 value</strong> 的 Map 集合。</p><blockquote><p>Map&lt;订阅者(比如在CustomActivity 中有订阅方法，那么 key 为 CustomActivity),该 Class 中所以的订阅事件类型的集合&gt;。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br></pre></td></tr></table></figure><p>List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</p><p>以订阅者为 Key，对存储该订阅者想所有的订阅事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">if (subscribedEvents == null) &#123;</span><br><span class="line">    subscribedEvents = new ArrayList&lt;&gt;();</span><br><span class="line">    typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">&#125;</span><br><span class="line">subscribedEvents.add(eventType);</span><br></pre></td></tr></table></figure><p><strong>第二个 Map 集合：subscriptionsByEventType</strong></p><p>根据变量名就可知为以 <strong>事件类型为 key</strong>，以 <strong>订阅关系集合为 value</strong> 的 Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br></pre></td></tr></table></figure><p>以订阅的事件类型(eventType)为 Key，将订阅关系集合存储到对应的 Map 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Map&lt;事件类型,List&lt;该事件对应的订阅关系(Subscription 对象)&gt;&gt;</span><br><span class="line"> CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"> ...</span><br><span class="line">subscriptionsByEventType.put(eventType, subscriptions);</span><br></pre></td></tr></table></figure><p>两个 Map 可以组合成以下关系流：<strong>订阅者 -&gt; 订阅事件 -&gt; 订阅关系</strong>。</p><h4 id="6-这两个-Map-的使用"><a href="#6-这两个-Map-的使用" class="headerlink" title="6. 这两个 Map 的使用"></a>6. 这两个 Map 的使用</h4><p>以上两个 Map 对象的一个重要用途：解除订阅关系。</p><ol><li>通过 typesBySubscriber 找到该类(订阅者)所有的订阅事件类型</li><li>通过事件类型获得所有该类型事件的所有订阅关系集合，</li><li>根据订阅者类型去 订阅关系集合 中删除对应的订阅关系。</li><li>移除此订阅者</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 步骤 1：typesBySubscriber 通过订阅者获得对应的订阅者中的事件集合</span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">if (subscribedTypes != null) &#123;</span><br><span class="line">    for (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">        unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    typesBySubscriber.remove(subscriber);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;</span><br><span class="line">    // 步骤 2 subscriptionsByEventType 通过指定事件获得对应的订阅关系</span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    if (subscriptions != null) &#123;</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            // 移除指定订阅者中订阅关系</span><br><span class="line">            if (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = false;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在事件发布时两个 map 对象也发挥十分重要的作用：通过事件类型获得所有的所有的订阅关系(订阅关系中含有订阅者和订阅方法的信息)，为每一个订阅关系发布事件。</p><p>理解这两个 Map 对象的意义，那么可以大致猜想 EventBus 发布事件时的基本流程：会根据事件类型在 subscriptionsByEventType 获得相应的订阅关系，由于订阅关系中含有订阅者和订阅方法的信息，那么就可以执行订阅者的订阅方法来，下面进一步查看事件发布的流程。</p><h3 id="0x0005-事件发布：post-事件"><a href="#0x0005-事件发布：post-事件" class="headerlink" title="0x0005 事件发布：post 事件"></a>0x0005 事件发布：post 事件</h3><p>通过 post 方法，发布事件，以下为 post 具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void post(Object event) &#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    if (!postingState.isPosting) &#123;</span><br><span class="line">        ....</span><br><span class="line">            while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是 currentPostingThreadState 这个变量，看一下其初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected PostingThreadState initialValue() &#123;</span><br><span class="line">        return new PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是 ThreadLocal 这个类，它存储线程相关的变量，ThreadLocal 原理请查看：<a href="https://leegyplus.github.io/2019/09/19/ThreadLocal(Jdk1.8)%20%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">ThreadLocal 源码分析</a>。使用 ThreadLocal 来存储消息队列，其目的是让每个线程维护自己单独的事件队列，避免重复发送事件，如果多个线程共用同一个事件序列，那么会出现以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共用事件队列：Queue</span><br><span class="line"></span><br><span class="line">同一订阅者中开启两个线程：线程 A 和 线程 B，线程 A 向 Queue 成功添加事件 EventOne (事件类型为 Test), 线程 B 向 Queue 成功添加事件 EventTwo (事件类型相同，为 Test)。但是在事件处理过程中，事件 EventOne 由于某种原因长时间阻塞，而事件 EventTwo 顺利完成，并从事件序列 Queue 中移除，但是由于事件 a 此时还在事件序列中，所以此时线程 B 会去执行从线程 A 发送的事件，这样就造成了事件的重复处理现象。</span><br></pre></td></tr></table></figure><p>将事件添加到对应的 事件序列 中，循环发送队列中的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // 获取到以该事件为 key 的所有订阅关系。</span><br><span class="line">            subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">            for (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                boolean aborted = false;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 发布订阅信息</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postingState.event = null;</span><br><span class="line">                    postingState.subscription = null;</span><br><span class="line">                    postingState.canceled = false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (aborted) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>postToSubscription 源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        case POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        case MAIN:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MAIN_ORDERED:</span><br><span class="line">            if (mainThreadPoster != null) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case BACKGROUND:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是在此处实现了 EventBus 实现线程间传递事件的魔法，根据 ThreadMode 的不同，分别在相应的线程执行事件，具体操作如下：</p><ul><li>POSTING</li></ul><p>在事件发布的线程执行事件操作，最终通过反射实现。</p><ul><li>MAIN</li></ul><p>标记事件在 主线程 中执行，根据事件发布的线程分为两种情况：</p><ol><li>发布者线程为主线程，在主线程执行响应，通过反射实现。</li><li>发布者为非主线程，在子线程中通过 Handler 将事件发布到主线程，在主线程通过反射实现(HandlerPoster)。</li></ol><p>如果事件没有执行完毕，那么后续的 post 操作会被阻塞，直到事件执行完毕，所以订阅者的订阅方法不能执行长时间的操作。</p><ul><li>MAIN_ORDERED</li></ul><p>标记订阅者在主线程中执行订阅方方法，与 Main 不同的是事件会存储在相应的事件序列中，不会阻塞 post 操作，通过序列依次执行相关事件(HandlerPoster)。</p><p>根据 mainThreadPoster 是否为空，分为两种情况：</p><ol><li>mainThreadPoster 不为空，加入主线程事件序列，进行顺序执行。</li><li>mainThreadPoster 为空，通过回调执行</li></ol><ul><li><p>BACKGROUND</p><ol><li>事件发布者所在线程为子线程，那么通过线程池分配线程执行(BackgroundPoster)。</li><li>事件发布者所在线程为主线程，通过反射执行。</li></ol></li><li><p>ASYNC</p></li></ul><p>无论事件发布者所在的线程是否为主线程，都会在异步线程中执行(AsyncPoster)。</p><p>通过源码可以看到，子线程为线程池中分配的线程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventBus.getExecutorService().execute(this);</span><br></pre></td></tr></table></figure><h3 id="0x0006-解绑-EventBus"><a href="#0x0006-解绑-EventBus" class="headerlink" title="0x0006 解绑 EventBus"></a>0x0006 解绑 EventBus</h3><p>List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</p><p>以订阅者为 Key，对所有的订阅事件分类：</p><pre><code>Map&lt;订阅者(比如在CustomActivity 中有订阅方法，那么 key 为 CustomActivity),该 Class 中所以的订阅事件类型的集合&gt;。</code></pre><p>解除订阅关系需要。找到该类(订阅者)所有的订阅事件类型，通过事件类型获得所有该类型事件的所有订阅关系集合，根据订阅者类型去 订阅关系集合 中删除对应的订阅关系。</p><h3 id="0x0007-总结"><a href="#0x0007-总结" class="headerlink" title="0x0007 总结"></a>0x0007 总结</h3><p>EventBus 作为事件总线框架，将应用中所有的订阅者与订阅函数统一维护，在 post 事件后，触发所有该事件类型的订阅函数，进行相关逻辑的执行，实现了线程间组件的事件传递。</p><hr><p><strong>你还可以阅读其他知识来源：</strong></p><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus 源码</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650242621&idx=1&sn=cc9c31aba5ff33b20fb9fecc3b0404b2&chksm=88638f52bf14064453fc09e6e53798ac5a1299d84df490b15764f9a85292732879eb4a1c0665&scene=38#wechat_redirect" target="_blank" rel="noopener">从源码入手来学习EventBus 3事件总线机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-基本介绍&quot;&gt;&lt;a href=&quot;#0x0001-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;0x0001 基本介绍&quot;&gt;&lt;/a&gt;0x0001 基本介绍&lt;/h3&gt;&lt;p&gt;EventBus 可以将事件在 &lt;strong&gt;线程之间传递&lt;/strong&gt;，实现跨进程通信，上手简单。&lt;/p&gt;
&lt;h3 id=&quot;0x0002-项目配置-EventBus-以及基本使用&quot;&gt;&lt;a href=&quot;#0x0002-项目配置-EventBus-以及基本使用&quot; class=&quot;headerlink&quot; title=&quot;0x0002 项目配置 EventBus 以及基本使用&quot;&gt;&lt;/a&gt;0x0002 项目配置 EventBus 以及基本使用&lt;/h3&gt;&lt;p&gt;在 app 模块下进行以来配置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;quot;org.greenrobot:eventbus:$versions.eventbus_version&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="EventBus" scheme="/tags/EventBus/"/>
    
      <category term="源码解析" scheme="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 粘性事件</title>
    <link href="/2019/11/04/EventBus%20%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6/"/>
    <id>/2019/11/04/EventBus 粘性事件/</id>
    <published>2019-11-04T09:44:35.000Z</published>
    <updated>2019-11-05T06:28:41.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-普通事件和粘性事件"><a href="#0x0001-普通事件和粘性事件" class="headerlink" title="0x0001 普通事件和粘性事件"></a>0x0001 普通事件和粘性事件</h3><p>通过源码我们看一下两者的差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void postSticky(Object event) &#123;</span><br><span class="line">    synchronized (stickyEvents) &#123;</span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void post(Object event) &#123;</span><br><span class="line">    ....</span><br><span class="line">    while (!eventQueue.isEmpty()) &#123;</span><br><span class="line">        // 每次发布一个事件，会将该事件从事件序列中移除，也就是说，事件发布后，不管是否有订阅者，</span><br><span class="line">        postSingleEvent(eventQueue.remove(0), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以看到相较于普通事件将事件添加到事件队列中，粘性事件还会被添加到 stickyEvents 中，而 stickyEvents 会在订阅者注册时进行发布。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;</span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line"></span><br><span class="line">     if (subscriberMethod.sticky) &#123;</span><br><span class="line">         if (eventInheritance) &#123;</span><br><span class="line">             Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">             for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                 Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                 if (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                     Object stickyEvent = entry.getValue();</span><br><span class="line">                     checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">             checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到在初始化订阅者时，如果订阅方法的 @Subscribe 中的 sticky 属性为 ture， 那么会从 stickyEvents  获得最新的一个事件，并执行 checkPostStickyEventToSubscription 方法直接发布该事件。</p><h3 id="0x0002-为什么使用-Sticky-Event"><a href="#0x0002-为什么使用-Sticky-Event" class="headerlink" title="0x0002 为什么使用 Sticky Event"></a>0x0002 为什么使用 Sticky Event</h3><p>官方文档对 Sticky Event 有以下描述；</p><blockquote><p>Some events carry information that is of interest after the event is posted. For example, an event signals that some initialization is complete. Or if you have some sensor or location data and you want to hold on the most recent values. Instead of implementing your own caching, you can use sticky events. So EventBus keeps the last sticky event of a certain type in memory. Then the sticky event can be delivered to subscribers or queried explicitly. Thus, you don’t need any special logic to consider already available data。</p></blockquote><blockquote><p>某些事件携带事件发布后有用的信息，比如收到事件表示一些初始化动作完成，或者需要保留有关传感器的最新信息，这时可以使用 Sticky Event，而不用自己去实现缓存。EventBus 会将最后一个 Sticky Event 保留在内存中(实际上是获取 Sticky Event 集合中最新元素))。在注册订阅关系过程中，EventBus 会将该 Sticky Event 发布。</p></blockquote><p>我们可以来看一个 Sticky Event 的使用场景：</p><blockquote><p>在一个 A/F 中的成功执行结果，比如说定位信息， 项目中定位信息在很多页面都需要，此时如果使用 post 发布事件，其中一些没有初始化成功的页面就不会收到该事件，无关获得定位信息，而如果使用 postSticky 来发布事件，那么其他页面在初始化时也是可以获得该事件，也可以获得包含其中的定位信息。</p></blockquote><h3 id="0x0003-手动获取和删除"><a href="#0x0003-手动获取和删除" class="headerlink" title="0x0003 手动获取和删除"></a>0x0003 手动获取和删除</h3><p>手动获得粘性事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBusEvent stickyEvent = EventBus.getDefault().getStickyEvent(EventBusEvent.class);</span><br></pre></td></tr></table></figure><p>手动删除粘性事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">EventBusEvent stickyEvent = EventBus.getDefault().getStickyEvent(EventBusEvent.class);</span><br><span class="line">if(stickyEvent != null)&#123;</span><br><span class="line">    EventBus.getDefault().removeStickyEvent(stickyEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法二 使用此方法：当你传入类时，它将返回先前持有的粘性事件</span><br><span class="line">EventBusEvent stickyEvent = EventBus.getDefault().removeStickyEvent(EventBusEvent.class);</span><br><span class="line">if(stickyEvent != null) &#123;</span><br><span class="line">    //  do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-普通事件和粘性事件&quot;&gt;&lt;a href=&quot;#0x0001-普通事件和粘性事件&quot; class=&quot;headerlink&quot; title=&quot;0x0001 普通事件和粘性事件&quot;&gt;&lt;/a&gt;0x0001 普通事件和粘性事件&lt;/h3&gt;&lt;p&gt;通过源码我们看一下两者的差别：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void postSticky(Object event) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    synchronized (stickyEvents) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stickyEvents.put(event.getClass(), event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    post(event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void post(Object event) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (!eventQueue.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 每次发布一个事件，会将该事件从事件序列中移除，也就是说，事件发布后，不管是否有订阅者，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        postSingleEvent(eventQueue.remove(0), postingState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="EventBus" scheme="/tags/EventBus/"/>
    
      <category term="Sticky Event" scheme="/tags/Sticky-Event/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 使用 APT 生成索引以及源码分析</title>
    <link href="/2019/11/04/EventBus%20%E4%BD%BF%E7%94%A8%20APT%20%E7%94%9F%E6%88%90%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2019/11/04/EventBus 使用 APT 生成索引以及源码分析/</id>
    <published>2019-11-04T09:42:24.000Z</published>
    <updated>2019-11-05T06:29:07.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-配置-EventBus-使用-APT-生成索引"><a href="#0x0001-配置-EventBus-使用-APT-生成索引" class="headerlink" title="0x0001 配置 EventBus 使用 APT 生成索引"></a>0x0001 配置 EventBus 使用 APT 生成索引</h3><p><a href="http://greenrobot.org/eventbus/documentation/subscriber-index/" target="_blank" rel="noopener">具体可以参见官方文档</a></p><p>通过文档可以看到可以通过三种方式为 项目配置索引：APT、kapt、android-apt，这只是实现功能的不同方式，本文介绍 APT 生成索引，其他两种原理基本相同.</p><p>使用 APT 生成索引，不可在匿名内部类中定义订阅方法。要想使用 APT 生成索引，需要对项目进行如下配置：</p><p>针对 app 模块下的 <code>build.gradle</code> 文件做以下更改：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                // EventBus Apt 索引类生成位置</span><br><span class="line">                arguments = [ eventBusIndex : applicationId + &apos;.EventBusIndex&apos; ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">    // 添加注解处理器依赖</span><br><span class="line">    annotationProcessor &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kapt 下的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;kotlin-kapt&apos; // ensure kapt plugin is applied</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">    kapt &apos;org.greenrobot:eventbus-annotation-processor:3.1.1&apos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(&apos;eventBusIndex&apos;, &apos;com.example.myapp.MyEventBusIndex&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目自定义的 Application 中添加如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    EventBus.builder()</span><br><span class="line">            .ignoreGeneratedIndex(false) // 使用 Apt 插件</span><br><span class="line">            .addIndex(new EventBusIndex()) // 添加索引类</span><br><span class="line">            .installDefaultEventBus(); // 作为默认配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0002-索引类"><a href="#0x0002-索引类" class="headerlink" title="0x0002 索引类"></a>0x0002 索引类</h3><p>重新构建项目，则可以项目 build 相关文件夹下生成 EventBusIndex 源文件，大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/** This class is generated by EventBus, do not edit. */</span><br><span class="line">public class MyEventBusIndex implements SubscriberInfoIndex &#123;</span><br><span class="line">    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line">        // 这些信息是如何的生成？是根据项目中存在订阅者的类生成的。</span><br><span class="line">        putIndex(new SimpleSubscriberInfo(EventBusStickyActtivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class="line">            new SubscriberMethodInfo(&quot;onTestEvent&quot;, EventBusEvent.class, ThreadMode.MAIN, 0, true),</span><br><span class="line">            new SubscriberMethodInfo(&quot;onTestEventSec&quot;, EventBusEvent.class, ThreadMode.BACKGROUND),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void putIndex(SubscriberInfo info) &#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        if (info != null) &#123;</span><br><span class="line">            return info;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-索引类中相关代码分析"><a href="#0x0003-索引类中相关代码分析" class="headerlink" title="0x0003 索引类中相关代码分析"></a>0x0003 索引类中相关代码分析</h3><p>重点查看一下静态代码块中对 putIndex 方法的调用，传入订阅者信息，并以订阅者为 key 将订阅者存入 SUBSCRIBER_INDEX 中。</p><p>SimpleSubscriberInfo 的继承关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface SubscriberInfo &#123;</span><br><span class="line">    Class&lt;?&gt; getSubscriberClass();</span><br><span class="line">    SubscriberMethod[] getSubscriberMethods();</span><br><span class="line">    SubscriberInfo getSuperSubscriberInfo();</span><br><span class="line">    boolean shouldCheckSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class AbstractSubscriberInfo implements SubscriberInfo &#123;&#125;</span><br><span class="line">public class SimpleSubscriberInfo extends AbstractSubscriberInfo&#123;&#125;</span><br></pre></td></tr></table></figure><p>SimpleSubscriberInfo 的构造函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * subscriberClass：订阅者</span><br><span class="line"> * shouldCheckSuperclass： 是否检查父类的标志位</span><br><span class="line"> * methodInfos: 订阅者中中订阅方法的数组集合</span><br><span class="line"> */</span><br><span class="line">public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos) &#123;</span><br><span class="line">    super(subscriberClass, null, shouldCheckSuperclass);</span><br><span class="line">    this.methodInfos = methodInfos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscriberMethodInfo 的构造函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * methodName: 方法名。如上面代码中的 onTestEvent、onTestEventSec</span><br><span class="line"> * eventType: 事件的类型，EventBusEvent.class</span><br><span class="line"> * threadMode： 事件类型处理的线程模式</span><br><span class="line"> * priority： 优先级</span><br><span class="line"> * sticky： 是否为粘性事件</span><br><span class="line"> **/</span><br><span class="line">public SubscriberMethodInfo(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,</span><br><span class="line">                            int priority, boolean sticky) &#123;</span><br><span class="line">    this.methodName = methodName;</span><br><span class="line">    this.threadMode = threadMode;</span><br><span class="line">    this.eventType = eventType;</span><br><span class="line">    this.priority = priority;</span><br><span class="line">    this.sticky = sticky;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过调用 getSubscriberInfo 方法来获得 SubscriberInfo(其实在这里是 SimpleSubscriberInfo 对象)</p><h3 id="0x0004-使生成的索引生效"><a href="#0x0004-使生成的索引生效" class="headerlink" title="0x0004 使生成的索引生效"></a>0x0004 使生成的索引生效</h3><p>以上主要分析了 APT 生成的索引类的信息，那么如何使这些信息生效，具体分析如下。</p><p>在自定义 Application 中我们对EventBus 以及生成的索引做了如下初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder()</span><br><span class="line">        .ignoreGeneratedIndex(false) </span><br><span class="line">        .addIndex(new MyEventBusIndex()) // 添加索引类</span><br><span class="line">        .installDefaultEventBus();</span><br></pre></td></tr></table></figure><p>EventBus.builder() 生成了 EventBusBuilder 对象。</p><p>看一下具体的 addIndex 做了什么：</p><p>EventBusBuilder#addIndex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public EventBusBuilder addIndex(SubscriberInfoIndex index) &#123;</span><br><span class="line">    if (subscriberInfoIndexes == null) &#123;</span><br><span class="line">        subscriberInfoIndexes = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    subscriberInfoIndexes.add(index);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码为向 subscriberInfoIndexes 添加具体的索引，此时 EventBusBuilder 对象已经持有 索引 的信息。</p><p>EventBusBuilder#installDefaultEventBus 对 EventBus 对象进行初始化，并赋值给 EventBus.defaultInstance。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public EventBus installDefaultEventBus() &#123;</span><br><span class="line">    synchronized (EventBus.class) &#123;</span><br><span class="line">        if (EventBus.defaultInstance != null) &#123;</span><br><span class="line">            throw new EventBusException(&quot;Default instance already exists.&quot; +</span><br><span class="line">                    &quot; It may be only set once before it&apos;s used the first time to ensure consistent behavior.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 生成 EventBus 对象</span><br><span class="line">        EventBus.defaultInstance = build();</span><br><span class="line">        return EventBus.defaultInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/** Builds an EventBus based on the current configuration. */</span><br><span class="line">public EventBus build() &#123;</span><br><span class="line">    return new EventBus(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，EventBus 已经完成了初始化，由于其在进程中为单例，所以此后 通过 EventBus.getDefault() 获得 EventBus 对象皆为此处所配置。</p><p>答案就是将 <strong>EventBus 设计为进程单例</strong>，那么在 Application 为 EventBus 对象做的一切配置都是全局生效的。</p><p>以下为将此生成的索引与 EventBus 建立连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    ....</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;</span><br><span class="line">    // 在此初始化 SubscriberMethodFinder， 并为之配置 索引</span><br><span class="line">    subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，通过 EventBusBuilder 对象生成的索引信息就会被配置到 EventBus 的属性 SubscriberMethodFinder 上，如上所说，通过 EventBus.getDefault() 获取到的 EventBus 都持有 APT 生成的索引的信息。</p><p>在此后查询订阅者的订阅方法，那么在接下来的步骤中 <code>getSubscriberInfo()</code> 方法返回值不为空，并会调用索引类中的 getSubscriberInfo 来返回订阅者信息，从而可以获取订阅方法。</p><p>SubscriberMethodFinder#findUsingInfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    while (findState.clazz != null) &#123;</span><br><span class="line">        // 如果使用索引，那么此处值不为 null</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        if (findState.subscriberInfo != null) &#123;</span><br><span class="line">            // 通过 findState.subscriberInfo.getSubscriberMethods() 则可以直接获得索引类生成的订阅方法数组，相较于通过反射获取订阅者的订阅方法，效率大大提高。</span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            for (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    return getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscriberMethodFinder#getSubscriberInfo 获取订阅信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private SubscriberInfo getSubscriberInfo(FindState findState) &#123;</span><br><span class="line">    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        if (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            return superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (subscriberInfoIndexes != null) &#123;</span><br><span class="line">        // 使用索引，则 subscriberInfoIndexes 不为空，index.getSubscriberInfo(findState.clazz) 获取的即为 索引类中 静态方法块中通过 putIndex 设置的订阅信息</span><br><span class="line">        for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            if (info != null) &#123;</span><br><span class="line">                return info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-使用-APT-生成索引类的优点"><a href="#0x0005-使用-APT-生成索引类的优点" class="headerlink" title="0x0005 使用 APT 生成索引类的优点"></a>0x0005 使用 APT 生成索引类的优点</h3><p>如上面所说，在编译期通过 APT 生成的索引类，即在编译期就获取了订阅者的信息(所有的订阅者以及其中的订阅方法)，从而取代在代码执行期(运行期)通过反射获得订阅方法的动作，效率大大提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-配置-EventBus-使用-APT-生成索引&quot;&gt;&lt;a href=&quot;#0x0001-配置-EventBus-使用-APT-生成索引&quot; class=&quot;headerlink&quot; title=&quot;0x0001 配置 EventBus 使用 APT 生成索引&quot;&gt;&lt;/a&gt;0x0001 配置 EventBus 使用 APT 生成索引&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://greenrobot.org/eventbus/documentation/subscriber-index/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;具体可以参见官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过文档可以看到可以通过三种方式为 项目配置索引：APT、kapt、android-apt，这只是实现功能的不同方式，本文介绍 APT 生成索引，其他两种原理基本相同.&lt;/p&gt;
&lt;p&gt;使用 APT 生成索引，不可在匿名内部类中定义订阅方法。要想使用 APT 生成索引，需要对项目进行如下配置：&lt;/p&gt;
&lt;p&gt;针对 app 模块下的 &lt;code&gt;build.gradle&lt;/code&gt; 文件做以下更改：&lt;/p&gt;
    
    </summary>
    
    
      <category term="EventBus" scheme="/tags/EventBus/"/>
    
      <category term="EventBus APT" scheme="/tags/EventBus-APT/"/>
    
  </entry>
  
  <entry>
    <title>利用异常机制获取堆栈轨迹元素</title>
    <link href="/2019/10/31/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E8%8E%B7%E5%8F%96%E5%A0%86%E6%A0%88%E8%BD%A8%E8%BF%B9%E5%85%83%E7%B4%A0/"/>
    <id>/2019/10/31/利用异常机制获取堆栈轨迹元素/</id>
    <published>2019-10-31T04:37:24.000Z</published>
    <updated>2019-11-01T05:01:48.412Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0x0001-什么是堆栈轨迹？"><a href="#0x0001-什么是堆栈轨迹？" class="headerlink" title="0x0001 什么是堆栈轨迹？"></a>0x0001 什么是堆栈轨迹？</h4><p>堆栈轨迹(stack trace) 是 <strong>一个方法调用过程的列表</strong>，它包含程序在执行过程中调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，就可以通过这个列表显示出来。</p><h4 id="0x0002-获得堆栈轨迹元素"><a href="#0x0002-获得堆栈轨迹元素" class="headerlink" title="0x0002 获得堆栈轨迹元素"></a>0x0002 获得堆栈轨迹元素</h4><p><strong>方法一：</strong></p><p>可以通过调用 Throwable 的 <code>printStackTrace</code> 方法，<strong>访问堆栈轨迹的文本描述信息</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable throwable = new Throwable();</span><br><span class="line">StringWriter out = new StringWriter();</span><br><span class="line">throwable.printStackTrace(new PrintWriter(out));</span><br><span class="line">String desc = out.toString();</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方法二：</strong></p><p>相较于方法一，这是一种更灵活的方法：<code>getStackTrace</code> 方法，它会 <strong>获得 StackTraceElement 对象的数组</strong>，可以通过分析数组，可以获得相应的信息。</p><p>可以使用如下示例进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable throwable = new Throwable();</span><br><span class="line">StackTraceElement[] elements = throwable.getStackTrace();</span><br><span class="line">for(StackTraceElement element:elements)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 StackTraceElement 可以获得文件名、当前执行代码的行号、类名、方法名等消息，StackTraceElement 的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final class StackTraceElement implements Serializable &#123;</span><br><span class="line">    public StackTraceElement(String declaringClass, String methodName, String fileName, int lineNumber) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得文件名</span><br><span class="line">    public String getFileName() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得行号</span><br><span class="line">    public int getLineNumber() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得所在类的类名</span><br><span class="line">    public String getClassName() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得所在方法的方法名</span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // // 获得所在方法是否是 native 方法</span><br><span class="line">    public boolean isNativeMethod() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Stub!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：</strong></p><p>通过 <code>Thread.getAllStackTrace</code> 方法，可以获得 <strong>所有线程的堆栈轨迹</strong>，具体调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Tread,StackTraceElement&gt; map = Thread.getAllStackTrace();</span><br><span class="line">for(Thread thread:map.keySet())&#123;</span><br><span class="line">    StrackTraceElement[] elements = map.get(thread);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-该机制的典型应用"><a href="#0x0003-该机制的典型应用" class="headerlink" title="0x0003 该机制的典型应用"></a>0x0003 该机制的典型应用</h3><p>以此机制可以打印调用方法的堆栈信息，一个比较常见的例子，在 Android 中通过 Log 日志调用方法的详细堆栈信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">object LogUtil &#123;</span><br><span class="line">    private val isDebug = BuildConfig.DEBUG</span><br><span class="line"></span><br><span class="line">    private fun generateTag(): String &#123;</span><br><span class="line">        val caller = Throwable().stackTrace[2]</span><br><span class="line">        var tag = &quot;%s.%s(L:%d)&quot;</span><br><span class="line">        var callerClazzName = caller.className</span><br><span class="line">        callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(&quot;.&quot;) + 1)</span><br><span class="line">        tag = String.format(</span><br><span class="line">            Locale.CHINA, tag, callerClazzName, caller.methodName,</span><br><span class="line">            caller.lineNumber</span><br><span class="line">        )</span><br><span class="line">        val customTagPrefix = &quot;h_log&quot;</span><br><span class="line">        tag = if (TextUtils.isEmpty(customTagPrefix)) tag else &quot;$customTagPrefix:$tag&quot;</span><br><span class="line">        return tag</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun d(content: Any?) &#123;</span><br><span class="line">        if (!isDebug || content == null) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        val tag = generateTag()</span><br><span class="line">        Log.d(tag, content.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于  Throwable().stackTrace[2] 中为什么取索引 2，这是因为该方法单独定义在一个类中，根据代码所在的位置不同，取得索引也是不同的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;0x0001-什么是堆栈轨迹？&quot;&gt;&lt;a href=&quot;#0x0001-什么是堆栈轨迹？&quot; class=&quot;headerlink&quot; title=&quot;0x0001 什么是堆栈轨迹？&quot;&gt;&lt;/a&gt;0x0001 什么是堆栈轨迹？&lt;/h4&gt;&lt;p&gt;堆栈轨迹(stack trace) 是 &lt;strong&gt;一个方法调用过程的列表&lt;/strong&gt;，它包含程序在执行过程中调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，就可以通过这个列表显示出来。&lt;/p&gt;
&lt;h4 id=&quot;0x0002-获得堆栈轨迹元素&quot;&gt;&lt;a href=&quot;#0x0002-获得堆栈轨迹元素&quot; class=&quot;headerlink&quot; title=&quot;0x0002 获得堆栈轨迹元素&quot;&gt;&lt;/a&gt;0x0002 获得堆栈轨迹元素&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过调用 Throwable 的 &lt;code&gt;printStackTrace&lt;/code&gt; 方法，&lt;strong&gt;访问堆栈轨迹的文本描述信息&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Throwable throwable = new Throwable();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringWriter out = new StringWriter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;throwable.printStackTrace(new PrintWriter(out));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String desc = out.toString();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java 异常" scheme="/tags/Java-%E5%BC%82%E5%B8%B8/"/>
    
      <category term="堆栈轨迹" scheme="/tags/%E5%A0%86%E6%A0%88%E8%BD%A8%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>使用 Kotlin 协程改善 App 性能</title>
    <link href="/2019/10/29/%E4%BD%BF%E7%94%A8-Kotlin-%E5%8D%8F%E7%A8%8B%E6%94%B9%E5%96%84-App-%E6%80%A7%E8%83%BD/"/>
    <id>/2019/10/29/使用-Kotlin-协程改善-App-性能/</id>
    <published>2019-10-29T03:50:16.000Z</published>
    <updated>2019-12-03T03:42:20.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-概述"><a href="#0x0001-概述" class="headerlink" title="0x0001 概述"></a>0x0001 概述</h3><p>协程是一种并发设计模式，您可以在 Android上 使用它来简化异步执行的代码。协程在 1.3 版中添加到 Kotlin，基于其他语言的既定概念进行设计 Kotlin 中的协程。</p><p>在Android上，协程可帮助解决两个主要问题：</p><ul><li>管理长时间运行的任务，这些任务可能会阻塞主线程并导致您的应用程序冻结。</li><li>提供主安全性，或从主线程安全地调用网络或磁盘操作。</li></ul><a id="more"></a><p>本主题介绍如何使用Kotlin协程来解决这些问题，从而使您能够编写更简洁，更简洁的应用程序代码。</p><h3 id="0x0002-管理行长时间运行的任务"><a href="#0x0002-管理行长时间运行的任务" class="headerlink" title="0x0002 管理行长时间运行的任务"></a>0x0002 管理行长时间运行的任务</h3><p>在 Android上，每个应用程序都有一个主线程来处理用户界面并管理用户交互。如果在 应用程序给主线程分配了过多的工作，则该应用程序 UI 界面会出现丢帧、卡顿的现象。同时像网络请求、JSON解析、读写数据库、甚至只是遍历大列表都可能导致您的应用运行缓慢，以至于 UI 界面会出现丢帧、卡顿的现象，所以长时间运行的操作应在主线程之外运行。</p><p>下面示例展示了通过协程运行长时间任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchDocs() &#123;                             // Dispatchers.Main</span><br><span class="line">    val result = get(&quot;https://developer.android.com&quot;) // Dispatchers.IO for `get`</span><br><span class="line">    show(result)                                      // Dispatchers.Main</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun get(url: String) = withContext(Dispatchers.IO) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><p>除了 call（或 invoke）和 return 外，协程通过在常规的函数上添加两个操作来完成构建，依次可以处​​理长时间运行的任务，这两个操作分别是：</p><ul><li>suspend(挂起): 会暂停当前协程的执行，并且保存所有的本地局部变量。</li><li>resume(恢复): 会从挂起的位置继续执行挂起的协程。</li></ul><p>需要注意的是，只能可以在挂起函数中或者协程构建器中才可以调用挂起函数。</p><p>在上面的示例中，<strong>get() 仍在主线程上运行</strong>，但是它 <strong>在启动网络请求之前挂起了协程</strong>。网络请求完成后，get 会恢复挂起的协程，而不是使用回调将结果通知给主线程中的调用者。</p><p>Kotlin 使用 <strong>栈帧</strong> 来管理函数运行时所需要的局部变量。<strong>当挂起一个协程，当前函数的栈帧会被拷贝下来，并且保存。当协程恢复时，栈帧会从其保存位置拷贝回来，方法重新运行</strong>。所以使用协程，即使代码看起来像是普通的顺序阻塞请求，协程也可以确保网络请求避免阻塞主线程。</p><h3 id="0x0003-Use-coroutines-for-main-safety、-使用-Kotlin-协程来保证主线程调用安全"><a href="#0x0003-Use-coroutines-for-main-safety、-使用-Kotlin-协程来保证主线程调用安全" class="headerlink" title="0x0003 Use coroutines for main-safety、 使用 Kotlin 协程来保证主线程调用安全"></a>0x0003 Use coroutines for main-safety、 使用 Kotlin 协程来保证主线程调用安全</h3><p>Kotlin 协程使用 Dispatchers API 去指定哪一个线程用来执行协程代码。为了在主线程以外的线程中运行代码，应该指定 Kotlin 协程执行的 <strong>调度器</strong>(Dispatchers.Default 或 Dispatchers.IO)。<strong>在 Kotlin 中所有的协程必须运行在调度器中</strong>，即使协程运行在主线程中也需要指定调度器。协程可以挂起自己，调度器用来恢复挂起的协程。</p><p>为了指定协程运行的位置，Kotlin 提供了如下调度器：</p><ul><li><p>Dispatchers.Main</p><p>  使用此调度器，用来指定协程运行在主线程中。此调度器应该仅在 <strong>与 UI 交互或者执行短时间任务</strong> 时使用，否则会造成主线程阻塞，比如：调用挂起函数，运行 Android UI 中的操作、更新 LiveData 对象。</p></li><li><p>Dispatchers.IO</p><p>  此调度器主要可以用来优化 <strong>在主线程中运行磁盘或者网络 IO 的情况</strong>，比如：使用 Room 组件、读写文件、网络操作。</p></li><li><p>Dispatchers.Default </p><p>  此调度器主要用来优化 <strong>在主线程之外执行 CPU 密集型工作</strong> 的情况，比如：对列表排序、解析 Gson。</p></li></ul><p>继续上面的示例，现在可以使用 Dispatchers 去重新定义 get 函数。在 get 的方法内，调用 <code>withContext(Dispatchers.IO)</code> 创建运行在 IO 线程池中的闭包，该闭包中的所有代码都会在调度器 Dispatchers.IO 指定的线程中运行。由于 <code>withContext</code> 本身也是一个挂起函数，所以 get 也要定义为挂起函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchDocs() &#123;                      // Dispatchers.Main</span><br><span class="line">    val result = get(&quot;developer.android.com&quot;)  // Dispatchers.Main</span><br><span class="line">    show(result)                               // Dispatchers.Main</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun get(url: String) =                 // Dispatchers.Main</span><br><span class="line">    withContext(Dispatchers.IO) &#123;              // Dispatchers.IO (main-safety block)</span><br><span class="line">        /* perform network IO here */          // Dispatchers.IO (main-safety block)</span><br><span class="line">    &#125;                                          // Dispatchers.Main</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 withContext() 让我们无需引入回调，就可以控制任何代码行所运行的线程池，并且可以将其应用到很小的功能上，例如从数据库读取或执行网络请求，可见使用 Kotlin 协程，可以通过<strong>细粒度的控制来调度线程</strong>。</p><p>Kotlin 协程中一个好的实践是：使用 withContext（）来确保每个函数都是主安全(主线程安全的)的，这意味着 <strong>可以从主线程调用该函数</strong>。</p><p>正是 withContext 的作用，在上面的示例中，fetchDocs 运行在主线程，但是该方法可以安全的调用在后台执行网络请求的 get 方法。由于 Kotlin 协程支持 suspend 和 resume，当 whitContext 闭包执行完毕后，在主线程中相应的协程会携带 get 方法的结果恢复运行。</p><blockquote><p>重要：在 Kotlin 中仅仅使用 suspend 是不能指定方法在后台线程中运行的。 在 Kotlin 挂起函数运行在主线中是十分场景的。在需要安全调用时，应该使用 withContext 而不是 suspend 函数，就像读写磁盘、执行网络操作、运行 CPU 密集型任务。</p></blockquote><h3 id="0x0004-withContext-的性能表现"><a href="#0x0004-withContext-的性能表现" class="headerlink" title="0x0004 withContext 的性能表现"></a>0x0004 withContext 的性能表现</h3><p>与实现相同效果的回调的实现相比，withContext（）不会增加额外的开销。此外，在某些情况下，除了回调(效果与 withContext 相同)的实现之外，还可以使用 withContext() 来优化调用。例如，如果一个函数对网络进行了十次调用，则可以通过使用外部 withContext() 告诉 Kotlin 仅切换一次线程。即使 网络库多次使用 withContext 指定不同的调度器，但是在程序中网络请求仍保留在同一调度程序上，避免切换线程。另外，Kotlin优化了Dispatchers.Default和Dispatchers.IO之间的切换，以尽可能避免线程切换。</p><blockquote><p>重要：使用使用诸如 Dispatchers.IO 或 Dispatchers.Default 之类的线程池的调度器，并不能保证闭包中代码从上到下在同一线程上执行。在一些情况下，在 suspend-resume 动作后，Kotlin 协程可能会从一个线程移到另一个线程中执行，这意味着对于整个 withContext（）块，线程局部变量可能会执行不同的值。</p></blockquote><h3 id="0x0005-Designate-a-CoroutineScope-指定协程范围"><a href="#0x0005-Designate-a-CoroutineScope-指定协程范围" class="headerlink" title="0x0005 Designate a CoroutineScope(指定协程范围)"></a>0x0005 Designate a CoroutineScope(指定协程范围)</h3><p>当定义个协程时，同时也会定义它的 CoroutineScope 对象(协程范围)。一个 CoroutineScope 对象管理一个或多个相关的协程，在其范围内，可以使用 CoroutineScope 对象开启一个新的协程。与调度器(Dispatcher)不同，CoroutineScope 不会运行协程。</p><p>CoroutineScope 需要保证在用户离开应用程序中的内容区域时停止协程执行，通过使用 CoroutineScope，可以确保任何正在运行的操作都能够正确的停止。</p><h4 id="0x0006-将-CoroutineScope-与-Android-Architecture-组件一起使用"><a href="#0x0006-将-CoroutineScope-与-Android-Architecture-组件一起使用" class="headerlink" title="0x0006 将 CoroutineScope 与 Android Architecture 组件一起使用"></a>0x0006 将 CoroutineScope 与 Android Architecture 组件一起使用</h4><p>在 Android 中，可以将 CoroutineScope 的实现与组件生命周期相关联，这样的话，可以避免内存泄漏或为与用户不再相关的 Activity 或 Fragment 进行额外的工作。使用 Jetpack 组件，它们自然地适合 ViewModel，因为 ViewModel 对象在 Activity 配置(比如屏幕旋转)更改时不会被销毁，不用担心 Kotlin 协程会被取消或重启。</p><p>Scope 对象知道它们开启的每一个协程，这就意味着，在任何时候，你都可以在取消该作用域内开启的所有动作。作用域可以自行传播，因此，如果协程开始另一个协程，则两个协程都具有相同的作用域。这意味着，即使其他库从你的作用域(Scope)中启动协程，你也可以随时取消它们。当你在 ViewModel 中使用协程时，这一点是十分重要的，如果 ViewModel 对象被销毁了，那么所有正在执行的异步任务会被取消，否则的话会浪费资源，严重的话会导致内存泄漏。如果有异步工作需要在销毁 ViewModel 对象之后继续进行，则应在应用程序体系结构的较低层进行。</p><blockquote><p>通过抛出 CancellationException 协同地取消协程。在协程取消期间触发捕获Exception或Throwable的异常处理程序。</p></blockquote><p>借助适用于 Android 的 KTX 库，您还可以使用扩展属性 viewModelScope 创建协程，这些协程可以一直运行到 ViewModel 被销毁为止。</p><h3 id="0x0007-Start-a-coroutine-开启一个协程"><a href="#0x0007-Start-a-coroutine-开启一个协程" class="headerlink" title="0x0007 Start a coroutine(开启一个协程)"></a>0x0007 Start a coroutine(开启一个协程)</h3><p>开启协程的两种方法：</p><ul><li><p>launch</p><p>  启动一个新的协程，并且不将结果返回给调用方。可以使用发布启动任何被认为是“即发即弃”的工作。</p></li><li><p>async</p><p>  启动一个新的协程，并使用 await 方法并返回挂起函数的结果。</p></li></ul><p>通常，您应该从常规函数启动新的协程，因为常规函数无法调用 await。仅当在另一个协程内部 或在 suspend 函数内部并执行 <code>并行分解</code> 任务时才使用 async 开启协程。</p><p>在前面的示例的基础上，下面是一个带有 viewModelScope KTX 扩展属性的协程，该属性使用 launch 从常规函数切换到协程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun onDocsNeeded() &#123;</span><br><span class="line">    viewModelScope.launch &#123;    // Dispatchers.Main</span><br><span class="line">        fetchDocs()            // Dispatchers.Main (suspend function call)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>launch 和 async 协程构造器处理异常的方式有所不同。由于 async 期望在某个时刻最终调用 await ，因此它会保留异常并将其作为 await 调用的一部分重新抛出。这意味着，如果使用 await 从常规函数中启动新的协程，则可能会静默删除异常。这些丢弃的异常不会出现在崩溃指标中，也不会在logcat中记录。</p></blockquote><h3 id="0x0008-Parallel-decomposition-并发分解"><a href="#0x0008-Parallel-decomposition-并发分解" class="headerlink" title="0x0008 Parallel decomposition(并发分解)"></a>0x0008 Parallel decomposition(并发分解)</h3><p>由 suspend 函数启动的所有协程必须在该函数返回时停止，因此您可能需要确保这些协程在返回之前完成。使用 Kotlin中 的结构化并发，您可以定义一个 coroutineScope 来启动一个或多个协程。然后，使用 await()（用于单个协程）或 awaitAll()（用于多个协程），可以保证这些协程在从函数返回之前完成。</p><p>作为示例，定义一个 coroutineScope，它异步获取两个文档。通过延迟引用上调用 await（），我们保证两个异步操作在返回值之前都已完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchTwoDocs() =</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        val deferredOne = async &#123; fetchDoc(1) &#125;</span><br><span class="line">        val deferredTwo = async &#123; fetchDoc(2) &#125;</span><br><span class="line">        deferredOne.await()</span><br><span class="line">        deferredTwo.await()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也可以使用 awaitAll ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">suspend fun fetchTwoDocs() =        // called on any Dispatcher (any thread, possibly Main)</span><br><span class="line">    coroutineScope &#123;</span><br><span class="line">        val deferreds = listOf(     // fetch two docs at the same time</span><br><span class="line">            async &#123; fetchDoc(1) &#125;,  // async returns a result for the first doc</span><br><span class="line">            async &#123; fetchDoc(2) &#125;   // async returns a result for the second doc</span><br><span class="line">        )</span><br><span class="line">        deferreds.awaitAll()        // use awaitAll to wait for both network requests</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即使 fetchTwoDocs() 使用 async 启动新的协程，该函数仍使用 awaitAll() 在启动的协程完成后再返回。但是请注意，即使我们没有调用 awaitAll()，coroutineScope 生成器也不会在所有新的协程完成之后才恢复调用 fetchTwoDocs 的协程。—-存疑？？？？</p><p>此外，coroutineScope会捕获协程抛出的所有异常，并将其路由回调用方。</p><h3 id="0x0009-Architecture-components-with-built-in-support-具有内置支持的架构组件"><a href="#0x0009-Architecture-components-with-built-in-support-具有内置支持的架构组件" class="headerlink" title="0x0009 Architecture components with built-in support(具有内置支持的架构组件)"></a>0x0009 Architecture components with built-in support(具有内置支持的架构组件)</h3><p>一些架构组件，包括 ViewModel 和 Lifecycle，包含了对协程的内置支持，通过其自己的 CoroutineScope 成员实现的。</p><p>比如，ViewModle 内部包含了 viewModelScope，这提供了一种 <strong>在 ViewModel 范围内启动协程的方法</strong>，如以下示例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    fun launchDataLoad() &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            sortList()</span><br><span class="line">            // Modify UI</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * Heavy operation that cannot be done in the Main Thread</span><br><span class="line">    * 主线程中不能运行繁琐的运算</span><br><span class="line">    */</span><br><span class="line">    suspend fun sortList() = withContext(Dispatchers.Default) &#123;</span><br><span class="line">        // Heavy work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 LiveData 通过 liveData 闭包 支持协程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liveData &#123;</span><br><span class="line">    // runs in its own LiveData-specific scope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>知识链接：</strong></p><p><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">Google 官方文档:Improve app performance with Kotlin coroutines</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-概述&quot;&gt;&lt;a href=&quot;#0x0001-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0001 概述&quot;&gt;&lt;/a&gt;0x0001 概述&lt;/h3&gt;&lt;p&gt;协程是一种并发设计模式，您可以在 Android上 使用它来简化异步执行的代码。协程在 1.3 版中添加到 Kotlin，基于其他语言的既定概念进行设计 Kotlin 中的协程。&lt;/p&gt;
&lt;p&gt;在Android上，协程可帮助解决两个主要问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理长时间运行的任务，这些任务可能会阻塞主线程并导致您的应用程序冻结。&lt;/li&gt;
&lt;li&gt;提供主安全性，或从主线程安全地调用网络或磁盘操作。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 Android 组件 与 Kotlin 协程共同使用</title>
    <link href="/2019/10/29/Jetpack%20%E4%B9%8B%20Android%20%E7%BB%84%E4%BB%B6%20%E4%B8%8E%20Kotlin%20%E5%8D%8F%E7%A8%8B%E5%85%B1%E5%90%8C%E4%BD%BF%E7%94%A8/"/>
    <id>/2019/10/29/Jetpack 之 Android 组件 与 Kotlin 协程共同使用/</id>
    <published>2019-10-29T03:39:37.000Z</published>
    <updated>2019-12-03T05:32:16.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-概述"><a href="#0x0001-概述" class="headerlink" title="0x0001 概述"></a>0x0001 概述</h3><p>Kotlin 协程提供了 API 以供开发者写出简单的异步代码。在 Kotlin 协程中，可以定义 CoroutineScope 作用域，它可以帮助开发者何时运行协程，每一个异步操作运行在特定的作用域内。</p><p>本主题说明如何协程如何与系统组件一起有效使用。</p><h3 id="0x0002-添加组件的协程依赖"><a href="#0x0002-添加组件的协程依赖" class="headerlink" title="0x0002 添加组件的协程依赖"></a>0x0002 添加组件的协程依赖</h3><p>通过引入对应的 KTX 扩展包，来使用相应组件的内置 Kotlin 协程作用域，相应依赖如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ViewModelScope</span><br><span class="line">androidx.lifecycle:lifecycle-viewmodel-ktx:xxx</span><br><span class="line">// LifeCycleScope</span><br><span class="line">use androidx.lifecycle:lifecycle-runtime-ktx:xxx</span><br><span class="line">// LiveData</span><br><span class="line">androidx.lifecycle:lifecycle-livedata-ktx:xxx</span><br></pre></td></tr></table></figure><a id="more"></a><p>在不同组件中使用 Kotlin 协程需要引入不同的依赖。</p><h3 id="0x0003-不同组件的内置协程作用域"><a href="#0x0003-不同组件的内置协程作用域" class="headerlink" title="0x0003 不同组件的内置协程作用域"></a>0x0003 不同组件的内置协程作用域</h3><p>Android 框架定义了以下几种内置的作用域，可以在应该开发中使用它们。</p><p><strong>ViewModelScope</strong></p><p>每一个 ViewModel 都定义了 ViewModelScope，当 ViewModel 被销毁时，在它的作用域内构建的所有协程都会被 cancel，因为只有当 ViewModel 处于 Active 状态下，协程中所执行的动作才有意义。假如你正在执行一些计算动作，那么你就应该把这部分工作放在 ViewModel 中，当 ViewModel 被销毁时，计算工作会自动终止，这样避免了消耗不必要的资源。</p><p>Kotlin 协程在 ViewModel 中的协程作用作用域对象为 viewModelScope，具体获取如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel: ViewModel() &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            // Coroutine that will be canceled when the ViewModel is cleared.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LifcycleScope</strong></p><p>为每个 Lifecycle 对象定义一个 LifecycleScope，当 Lifecycle 对象销毁时，所有在该作用域构建的协程会自动取消。可以通过 <code>lifecycle.coroutineScope</code> 或者 <code>lifecycleOwner.lifecycleScope</code> 的方式获得 Lifecycle 对象的协程作用域。</p><p>下面的例子展示如何通过 <code>lifecycleOwner.lifecycleScope</code> 异步创造 text:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyFragment: Fragment() &#123;</span><br><span class="line">    override fun onViewCreated(view: View, savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onViewCreated(view, savedInstanceState)</span><br><span class="line">        viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">            val params = TextViewCompat.getTextMetricsParams(textView)</span><br><span class="line">            val precomputedText = withContext(Dispatchers.Default) &#123;</span><br><span class="line">                PrecomputedTextCompat.create(longTextContent, params)</span><br><span class="line">            &#125;</span><br><span class="line">            TextViewCompat.setPrecomputedText(textView, precomputedText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0004-挂起特定生命周期状态下的协程"><a href="#0x0004-挂起特定生命周期状态下的协程" class="headerlink" title="0x0004 挂起特定生命周期状态下的协程"></a>0x0004 挂起特定生命周期状态下的协程</h3><p>尽管 CoroutineScope 提供了一种自动取消长时间的运行操作的方式，但是也存在这样一种需求：在 Lifecycle 处于特定的状态才会执行相应的代码。</p><p>存在这样一种场景：为了执行 FragmentTransaction 相应操作，需要 Lifecycle 至少处于 STARTED 的状态。为了解决这样情况，Lifecycle 提供了以下方法：<code>lifecycle.whenCreated, lifecycle.whenStarted, and lifecycle.whenResumed</code>，<strong>当 Lifecycle 没有执行到以上指定状态时，处于以上协程内的代码会被挂起</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class MyFragment: Fragment &#123;</span><br><span class="line">    init &#123; // Notice that we can safely launch in the constructor of the Fragment.</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            whenStarted &#123;</span><br><span class="line">                // 此闭包中的代码只有在 STARTED 状态下才会运行，针对当前情况，当 Fragment 启动时，协程闭包中的代码会被执行，并且可以调用其他挂起函数。</span><br><span class="line">                loadingView.visibility = View.VISIBLE</span><br><span class="line">                val canAccess = withContext(Dispatchers.IO) &#123;</span><br><span class="line">                    checkUserAccess()</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // When checkUserAccess returns, the next line is automatically</span><br><span class="line">                // suspended if the Lifecycle is not *at least* STARTED.</span><br><span class="line">                // We could safely run fragment transactions because we know the</span><br><span class="line">                // code won&apos;t run unless the lifecycle is at least STARTED.</span><br><span class="line">                // 当checkUserAccess返回时，如果 Fragmeng 的生命周期不是 STARTED或 STARTED 以后的状态，那么下一行自动挂起，。</span><br><span class="line">                loadingView.visibility = View.GONE</span><br><span class="line">                if (canAccess == false) &#123;</span><br><span class="line">                    findNavController().popBackStack()</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    showContent()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // This line runs only after the whenStarted block above has completed(此处的代码只有在 whenStarted 闭包执行完毕后才会执行)。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当协程是通过 lifecycleScope 的 whenxxx 方法开启的，如果组件生命周期处于销毁(destroyed) 状态，那么这个协程会被自动取消，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyFragment: Fragment &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Call some suspend functions.</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // This line might execute after Lifecycle is DESTROYED.</span><br><span class="line">                if (lifecycle.state &gt;= STARTED) &#123;</span><br><span class="line">                    // Here, since we&apos;ve checked, it is safe to run any</span><br><span class="line">                    // Fragment transactions.</span><br><span class="line">                    // 对状态进行审核，这样更安全</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里例子中，一旦生命周期处于 DESTROYED 状态，那么就会执行 finally 闭包中的代码，此处为了确保安全调用，对生命周期的状态进行校验。</p><blockquote><p>注意：尽管这些方法在使用 Lifecycle 时提供了便利，但仅在信息（例如，预先计算的文本）在组件生命周期范围内，才能使用它们。需要注意的是:如果 Activity 重新启动，协程将不会重新启动。</p></blockquote><h3 id="0x0005-LiveData-组件与-Kotlin-协程组合使用"><a href="#0x0005-LiveData-组件与-Kotlin-协程组合使用" class="headerlink" title="0x0005 LiveData 组件与 Kotlin 协程组合使用"></a>0x0005 LiveData 组件与 Kotlin 协程组合使用</h3><p>在使用 LiveData 时，你可以需要异步的计算的操作。比如你想要获取用户的选择项，并把选择呈现到 UI 上，在这个场景下就可以使用 <code>livedata 构造器方法</code> 去调用挂起函数，并且将然后的结果包装成 LiveData 对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val user: LiveData&lt;User&gt; = liveData &#123;</span><br><span class="line">    val data = database.loadUser() // loadUser is a suspend function.</span><br><span class="line">    emit(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>liveData 构建块在 协程和 LiveData 之间充当 <code>结构化并发函数</code> 的作用。以上代码块在 LiveData 变为活跃状态后开始执行，在 LiveData 变为非活跃状态下会自动取消，其取消时间是可配置的。如果在完成之前取消，那么该闭包会在 LiveData 变为活跃状态后重新执行，而如果在取消前已经完成，那么该闭包就不会重新执行。由其他原因(比如抛出异常)导致该闭包取消执行，那么该闭包不会重复执行。</p><p>同时可以在该闭包内发送多个值，每次调用 emit() 都会挂起该闭包的执行，直到在主线程上设置 LiveData 值为止，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val user: LiveData&lt;Result&gt; = liveData &#123;</span><br><span class="line">    emit(Result.loading())//挂起，直到 Result.loading() 执行完毕</span><br><span class="line">    try &#123;</span><br><span class="line">        emit(Result.success(fetchUser()))</span><br><span class="line">    &#125; catch(ioException: Exception) &#123;</span><br><span class="line">        emit(Result.error(ioException))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可以使用 Transformations API 来组合 liveData，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel: ViewModel() &#123;</span><br><span class="line">    private val userId: LiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">    val user = userId.switchMap &#123; id -&gt;</span><br><span class="line">        liveData(context = viewModelScope.coroutineContext + Dispatchers.IO) &#123;</span><br><span class="line">            emit(database.loadUserById(id))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当要发出新值时，都可以通过调用 embedSource() 函数从 LiveData 中发出多个值。请注意，每次调用emit() 或 emitSource()都会删除先前添加的源,示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class UserDao: Dao &#123;</span><br><span class="line">    @Query(&quot;SELECT * FROM User WHERE id = :id&quot;)</span><br><span class="line">    fun getUser(id: String): LiveData&lt;User&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyRepository &#123;</span><br><span class="line">    fun getUser(id: String) = liveData&lt;User&gt; &#123;</span><br><span class="line">        val disposable = emitSource(</span><br><span class="line">            userDao.getUser(id).map &#123;</span><br><span class="line">                Result.loading(it)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        try &#123;</span><br><span class="line">            val user = webservice.fetchUser(id)</span><br><span class="line">            // Stop the previous emission to avoid dispatching the updated user</span><br><span class="line">            // as `loading`.</span><br><span class="line">            // 停止之前发起的 emission，以避免调度更新的用户为 loading </span><br><span class="line">            disposable.dispose()</span><br><span class="line">            // Update the database.</span><br><span class="line">            userDao.insert(user)</span><br><span class="line">            // Re-establish the emission with success type.</span><br><span class="line">            // 用成功类型重新建立 emission。</span><br><span class="line">            emitSource(</span><br><span class="line">                userDao.getUser(id).map &#123;</span><br><span class="line">                    Result.success(it)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125; catch(exception: IOException) &#123;</span><br><span class="line">            // Any call to `emit` disposes the previous one automatically so we don&apos;t</span><br><span class="line">            // need to dispose it here as we didn&apos;t get an updated value.</span><br><span class="line">            // 任何对 emit 的调用都会自动处理前一个，因此我们不用调用 dispose 方法，因为我们没有更新的值。</span><br><span class="line">            emitSource(</span><br><span class="line">                userDao.getUser(id).map &#123;</span><br><span class="line">                    Result.error(exception, it)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>知识链接</strong></p><p><a href="https://developer.android.com/topic/libraries/architecture/coroutines" target="_blank" rel="noopener">Google 官方文档 : Use Kotlin coroutines with Architecture components</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-概述&quot;&gt;&lt;a href=&quot;#0x0001-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0001 概述&quot;&gt;&lt;/a&gt;0x0001 概述&lt;/h3&gt;&lt;p&gt;Kotlin 协程提供了 API 以供开发者写出简单的异步代码。在 Kotlin 协程中，可以定义 CoroutineScope 作用域，它可以帮助开发者何时运行协程，每一个异步操作运行在特定的作用域内。&lt;/p&gt;
&lt;p&gt;本主题说明如何协程如何与系统组件一起有效使用。&lt;/p&gt;
&lt;h3 id=&quot;0x0002-添加组件的协程依赖&quot;&gt;&lt;a href=&quot;#0x0002-添加组件的协程依赖&quot; class=&quot;headerlink&quot; title=&quot;0x0002 添加组件的协程依赖&quot;&gt;&lt;/a&gt;0x0002 添加组件的协程依赖&lt;/h3&gt;&lt;p&gt;通过引入对应的 KTX 扩展包，来使用相应组件的内置 Kotlin 协程作用域，相应依赖如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// ViewModelScope&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidx.lifecycle:lifecycle-viewmodel-ktx:xxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// LifeCycleScope&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;use androidx.lifecycle:lifecycle-runtime-ktx:xxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// LiveData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;androidx.lifecycle:lifecycle-livedata-ktx:xxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava 源码学习(三):线程切换</title>
    <link href="/2019/10/21/Rxjava-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <id>/2019/10/21/Rxjava-源码学习-三-线程切换/</id>
    <published>2019-10-21T07:06:53.000Z</published>
    <updated>2019-11-22T06:20:43.324Z</updated>
    
    <content type="html"><![CDATA[<p>根据官方文档的翻译：<br>subscribeOn 操作符指定 Observable 将在哪个线程上开始操作，无论该运算符在运算符链中的哪个点被调用。 ObserveOn 操作符影响下游 Observer 的运行线程，因此，可以在 Observable 操作符链中的各个点多次调用 ObserveOn，以更改某些运算符的运行线程。</p><a id="more"></a><ul><li>subscribeOn： 指定 Observable 运行的线程，更近一步就是指定事件发射器发射动作的线程，但是 <strong>只有第一个 subscribeOn 有效</strong>。其实多个 subscribeOn 对整个事件流是有影响的，比如指定上游操作符对应的 Observer 的生成和订阅关系的建立所在的线程，但是这些都是发生在 Rxjava 库内部，不用也没有必要暴露给使用者，所以 subscribeOn 最终体现是：<strong>指定事件发射器发射动作的线程</strong>。</li></ul><ul><li>observeOn：指定该操作符影响与下一个 observeOn 之间的 Observer 运行的线程。</li></ul><p><img src="/../images/2019_10_18_02.png" alt="Rxjava 线程切换"></p><p>为了明确 Rxjava 中相应的 Observer、Observable 运行在哪个线程，我们先看一个基本的关于 Thead 的知识点，帮助理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    thread(name = &quot;Outer-Thread&quot;) &#123;</span><br><span class="line">        println(&quot;thread name is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        thread(name = &quot;Inner-Thread&quot;) &#123;</span><br><span class="line">            println(&quot;thread name is $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread name is Outer-Thread</span><br><span class="line">thread name is Inner-Thread</span><br></pre></td></tr></table></figure><p>以上代码就是只有第一个 subscribeOn 生效和 subscribeOn 操作符不会影响 observeOn 操作符指定线程的原因。</p><p>其实这是很容易理解的，在这里说一下的原因是帮助理解。</p><h3 id="subscribeOn-操作符"><a href="#subscribeOn-操作符" class="headerlink" title="subscribeOn 操作符"></a>subscribeOn 操作符</h3><p>同为 Rxjava 操作符，subscribeOn 的基本操作基本一致：生成相应的 Observer 、产生订阅关系，但是不同的是产生订阅关系所在的线程为 subscribeOn 指定的线程，下面看一下具体的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(final Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line">    // scheduleDirect 操作会开启新的线程</span><br><span class="line">    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final class SubscribeTask implements Runnable &#123;</span><br><span class="line">    private final SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    // 订阅关系产生在新的线程中</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他操作符订阅关系发生的线程，以 map 操作符为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的流程图以及关于 Thread 的代码，这就是 subscribeOn 生效的原因。</p><p>具体说明一下，当 subscribeOn 指定线程后，那么就如流程图中所示，其后的操作都会在该线程中运行，最终事件发生器也会在该线程中发射新的事件。但是该 subscribeOn 操作符的上游再次使用了 subscribeOn ，那么事件发生器发布事件的线程最终由上游的 subscribeOn 指定的线程，具体原因为上文中提到的关于 Thread 的代码。</p><h3 id="observeOn-操作符"><a href="#observeOn-操作符" class="headerlink" title="observeOn 操作符"></a>observeOn 操作符</h3><p>observeOn 操作符只能用来指定下游 Observer 的 onNext 等方法的线程，上面流程图可以非常形象的明确这一点。与 <strong>subscribeOn 指定订阅关系发生的线程不同，observeOn 指定具体的动作的执行线程</strong>，下面通过源码具体说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    if (scheduler instanceof TrampolineScheduler) &#123;</span><br><span class="line">        source.subscribe(observer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Scheduler.Worker w = scheduler.createWorker();</span><br><span class="line">        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (done) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sourceMode != QueueDisposable.ASYNC) &#123;</span><br><span class="line">        queue.offer(t);</span><br><span class="line">    &#125;</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void schedule() &#123;</span><br><span class="line">    if (getAndIncrement() == 0) &#123;</span><br><span class="line">        worker.schedule(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (outputFused) &#123;</span><br><span class="line">        drainFused();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        drainNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最终发送的事件在指定的线程中执行</span><br><span class="line">void drainNormal() &#123;</span><br><span class="line">    a.onNext(v);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果下游没有 observeOn 操作符，那么后续的 onNext 也同样在该线程中执行，同理，onError、onComplete 也会执行通过的操作，从而完成了 observeOn 操作符可以执行下游 Observer 的线程(具体来说是指定执行事件的线程)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据官方文档的翻译：&lt;br&gt;subscribeOn 操作符指定 Observable 将在哪个线程上开始操作，无论该运算符在运算符链中的哪个点被调用。 ObserveOn 操作符影响下游 Observer 的运行线程，因此，可以在 Observable 操作符链中的各个点多次调用 ObserveOn，以更改某些运算符的运行线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>关于 Runnable Future Callable FutureTask 的简单理解</title>
    <link href="/2019/10/20/%E5%85%B3%E4%BA%8E%20Runnable%20Future%20Callable%20FutureTask%20%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>/2019/10/20/关于 Runnable Future Callable FutureTask 的简单理解/</id>
    <published>2019-10-20T08:02:26.000Z</published>
    <updated>2019-10-21T03:25:14.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Runnable-源代码"><a href="#1-Runnable-源代码" class="headerlink" title="1. Runnable 源代码"></a>1. Runnable 源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 Runnable 不允许声明受检异常以及定义返回值。不允许声明受检异常意味着必须手动的捕获并处理受检异常，这是十分麻烦的。</p><a id="more"></a><p>Executors 中存在可以将 Runnable 转换成 Callable 的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Callable&lt;Object&gt; callable(Runnable task) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;Object&gt;(task, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 1.5 后引入了 Callable 和 Future 使得以上问题能够被优雅的解决。</p><h3 id="2-Callable-源代码"><a href="#2-Callable-源代码" class="headerlink" title="2. Callable 源代码"></a>2. Callable 源代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 Callable 的实现类中声明返回的数据类型，也可以抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CallableTask implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        String name;</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        name = &quot;Mike&quot;;</span><br><span class="line">        System.out.println(&quot;我是 CallableTask，执行 call 的线程为: &quot; + Thread.currentThread().getName());</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Future、FutureTask-相关"><a href="#3-Future、FutureTask-相关" class="headerlink" title="3. Future、FutureTask 相关"></a>3. Future、FutureTask 相关</h3><h4 id="3-1-Future-部分源码"><a href="#3-1-Future-部分源码" class="headerlink" title="3.1 Future 部分源码"></a>3.1 Future 部分源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@code true&#125; if this task was cancelled before it completed</span><br><span class="line">     * normally.</span><br><span class="line">     */</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@code true&#125; if this task completed.</span><br><span class="line">     */</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Waits if necessary for the computation to complete, and then</span><br><span class="line">     * retrieves its result.</span><br><span class="line">     * 在返回执行结果前，一直阻塞</span><br><span class="line">     */</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Waits if necessary for at most the given time for the computation</span><br><span class="line">     * to complete, and then retrieves its result, if available.</span><br><span class="line">     */</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable 和 Callable 一旦开启，就难以管理，而 Future 为线程池制定了一个可管理的任务标准，它提供了对 Runnable  和 Callable 任务的执行结果进行取消、查询是否完成、获取结果、设置结果的操作，分别对应于 cancel、isDone、get、set 函数，get 方法会阻塞，直到返回结果。</p><h4 id="3-2-FutureTask-部分源码"><a href="#3-2-FutureTask-部分源码" class="headerlink" title="3.2 FutureTask 部分源码"></a>3.2 FutureTask 部分源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future 只是定义了一些接口规范，而 FutureTask 则是它的实现类。</p><p>FutureTask 理解为 <strong>可以被取消的任务</strong>，它提供实现了 Future 的基本方法：启动、终止、查询是否执行完毕、返回执行结果。</p><p>可以通过执行 get() 获取执行结果，在任务执行结束之前，会一直阻塞，直到任务执行完成，获取结果。<strong>阻塞的原因</strong>为执行的循环 <code>for(;;)</code>, 只有在状态为结束后才会继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// FutureTask#get()</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int awaitDone(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        //最终返回状态，如果状态为完成，则执行 report(s)</span><br><span class="line">        return state;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 执行 call 方法，最终执行相应的操作，置位状态</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sFuture 实现了 RunnableFuture，而RunnableFuture 实现了 Runnable 和 Future，所以它可以被当做 Runnable 被线程执行，也可以作为 Future 得到 Callable 的返回值。</p><h4 id="3-3-通过-Thread-执行-FutureTask-任务"><a href="#3-3-通过-Thread-执行-FutureTask-任务" class="headerlink" title="3.3 通过 Thread 执行 FutureTask 任务"></a>3.3 通过 Thread 执行 FutureTask 任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">            = new FutureTask&lt;&gt;(() -&gt; 1 + 2);</span><br><span class="line">Thread thread = new Thread(futureTask);</span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(&quot;result 2： &quot; + futureTask.get().intValue());</span><br></pre></td></tr></table></figure><h4 id="3-4-通过-ThreadPoolExecutor-执行-FutureTask-任务"><a href="#3-4-通过-ThreadPoolExecutor-执行-FutureTask-任务" class="headerlink" title="3.4 通过 ThreadPoolExecutor 执行 FutureTask 任务"></a>3.4 通过 ThreadPoolExecutor 执行 FutureTask 任务</h4><p>通过线程池执行 FutureTask 任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">            = new FutureTask&lt;&gt;(() -&gt; 1 + 2);</span><br><span class="line">ExecutorService es =</span><br><span class="line">        Executors.newCachedThreadPool();</span><br><span class="line">// 提交 FutureTask</span><br><span class="line">es.submit(futureTask);</span><br><span class="line">// 获取任务执行结果</span><br><span class="line">Integer result = futureTask.get();</span><br><span class="line">System.out.println(&quot;result： &quot; + result);</span><br></pre></td></tr></table></figure><p>下面具体看一下 ExecutorService 为何物。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line">    // 提交 Callable 任务</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">// 提交 Runnable 任务，并声明返回值类型</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">// 提交 Runnable 任务</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ExecutorService 中声明了 3 个 submit() 方法和一个定义的 Future 类用来支持获得任务执行的结果的需求。</p><p>这 3 个方法在 AbstractExecutorService 中具体实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;</span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        if (task == null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task == null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        if (task == null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是通过 newTaskFor() 方法获得 FutureTask 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 execute 在不同的线程池中有不同的实现方式，具体可以查看线程池的相关源代码。</p><h3 id="4-Runnable、Callable-、Future-、FutureTask-异同"><a href="#4-Runnable、Callable-、Future-、FutureTask-异同" class="headerlink" title="4.Runnable、Callable 、Future 、FutureTask 异同"></a>4.Runnable、Callable 、Future 、FutureTask 异同</h3><p>Future Callable FutureTask(FutureTask 由于实现了 RunnableFuture  是可以使用在 Thread 的，但是运行效果和 Runnable 一样，没有什么意义) 只能运用到线程池中，而 Runnable 既能运行在 Thread 中，又能运用在线程池中。</p><hr><p><strong>知识链接：</strong></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">一个并发编程系列</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Runnable-源代码&quot;&gt;&lt;a href=&quot;#1-Runnable-源代码&quot; class=&quot;headerlink&quot; title=&quot;1. Runnable 源代码&quot;&gt;&lt;/a&gt;1. Runnable 源代码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface Runnable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract void run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是 Runnable 不允许声明受检异常以及定义返回值。不允许声明受检异常意味着必须手动的捕获并处理受检异常，这是十分麻烦的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Future" scheme="/tags/Future/"/>
    
      <category term="FutureTask" scheme="/tags/FutureTask/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava 源码学习(二):基本流程流程图</title>
    <link href="/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%8C):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>/2019/10/18/Rxjava 源码学习(二):基本流程流程图/</id>
    <published>2019-10-18T07:32:54.000Z</published>
    <updated>2019-10-18T09:33:36.987Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://leegyplus.github.io/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">Rxjava 源码学习(一):基本流程分析</a> 分析了基本流程，并且通过 Map 操作符一窥 Rxjava 操作符的特色，而本篇主体只有一张 Rxjava 流程图，但是这张流程图基本上可以概括 Rxjava 的框架，整个流程可以看做是一个 “横向 S” 模型。</p><p>该图共涉及 Rxjava 事件流的以下几个方面：</p><ol><li>Observable 的创建</li><li>Observer 的创建、产生订阅关系</li><li>订阅关系的传递</li><li>取消订阅的流程</li></ol><a id="more"></a><p>具体看图上的标记:</p><p><img src="/../images/2019_10_18_01.png" alt></p><h3 id="1-关于源码中的-upsteam-和-downstream"><a href="#1-关于源码中的-upsteam-和-downstream" class="headerlink" title="1. 关于源码中的 upsteam 和 downstream"></a>1. 关于源码中的 upsteam 和 downstream</h3><p>从图上可以看到，在最终订阅 Observer 之前，执行每一个操作符并不会同时生成相应的 Observable 和 Observer，以调用 subscribe 为分界线，将整个事件流分成两部分：</p><ol><li>调用 subscribe 之前，生成相应操作符的 Observable。</li><li>调用 subscribe 之后，生成相应操作符的 Observer，并产生订阅关系。</li></ol><p>需要注意的一点是在查看源码会看到 upstream、downstream，具体的 up 和 down 不是有相应对象的生成顺序决定的，而是有 Rxjava 相应操作符的调用先后决定。</p><h3 id="2-关于自定义-Observer-的-onSubscribe-方法的执行线程问题"><a href="#2-关于自定义-Observer-的-onSubscribe-方法的执行线程问题" class="headerlink" title="2. 关于自定义 Observer 的 onSubscribe 方法的执行线程问题"></a>2. 关于自定义 Observer 的 onSubscribe 方法的执行线程问题</h3><p>Rxjava 中的 observerOn 和 subscribeOn 可以指定相应的 Observer 和 Observable 的运行线程，但是通过打印日志我们可以看到 onSubscribe 运行的线程并不是两个操作符指定的线程，而是代码执行的线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void onSubscribe(Disposable d) &#123;</span><br><span class="line">    Log.e(&quot;TAG&quot;, &quot;onSubscribe(): 所在线程为 &quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志为：<br>onSubscribe(): 所在线程为 main</p><p>至于为什么会这样，可以看一下最上游的 Observable 的 subscribeActual 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">    observer.onSubscribe(parent);</span><br><span class="line">    try &#123;</span><br><span class="line">        source.subscribe(parent);</span><br><span class="line">    &#125; catch (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        parent.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    subscribeActual(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <a href="https://leegyplus.github.io/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">Rxjava 源码学习(一):基本流程分析</a>  的分析知道，Rxjava 整个事件流的核心方法为 subscribeActual、subscribe，而两个方法均在代码调用的线程执行(这里是 main)，基于此 onSubscribe 方法就是在这里开始调用下游对象的 onSubscribe 方法，所以 onSubscribe 的执行线程也不会发生改变(这里是 main)。</p><h3 id="3-关于取消订阅关系"><a href="#3-关于取消订阅关系" class="headerlink" title="3. 关于取消订阅关系"></a>3. 关于取消订阅关系</h3><p>在日常开发中，我们会遇到类似这样的需求：当退出 Activity 时，需要取消正在执行的实现，此功能的实现就是通过取消订阅关系来实现。</p><p>情况一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">             emitter.onNext(&quot;one&quot;);</span><br><span class="line">             emitter.onNext(&quot;two&quot;);</span><br><span class="line">             emitter.onNext(&quot;three&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">         Disposable mDisposable;</span><br><span class="line">         @Override</span><br><span class="line">         public void onSubscribe(Disposable d) &#123;</span><br><span class="line">             mDisposable = d;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public void onNext(String s) &#123;</span><br><span class="line"></span><br><span class="line">             if(s == &quot;two&quot;)&#123;</span><br><span class="line">                 mDisposable.dispose();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>情况二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">CompositeDisposable compositeDisposable = new CompositeDisposable();</span><br><span class="line"></span><br><span class="line">private void test()&#123;</span><br><span class="line">   Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">                emitter.onNext(&quot;one&quot;);</span><br><span class="line">                emitter.onNext(&quot;two&quot;);</span><br><span class="line">                emitter.onNext(&quot;three&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                // 将订阅关系添加到 compositeDisposable</span><br><span class="line">                compositeDisposable.add(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        // 解除所有的订阅关系</span><br><span class="line">        compositeDisposable.clear();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在自定义 Observer(最下游) 调用 Disposable#dispose():</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">    upstream.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最终会通过事件流将取消订阅的动作传递到最上游：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CreateEmitter#dispose</span><br><span class="line">@Override</span><br><span class="line">public void dispose() &#123;</span><br><span class="line">    DisposableHelper.dispose(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于订阅关系取消，所以后续事件无法发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CreateEmitter#onNext</span><br><span class="line">@Override</span><br><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        onError(new NullPointerException(&quot;onN</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 取消订阅后 isDisposed 为 false</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CreateEmitter#isDisposed</span><br><span class="line">@Override</span><br><span class="line">public boolean isDisposed() &#123;</span><br><span class="line">    return DisposableHelper.isDisposed(get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此整个事件流被终止。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://leegyplus.github.io/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#more&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Rxjava 源码学习(一):基本流程分析&lt;/a&gt; 分析了基本流程，并且通过 Map 操作符一窥 Rxjava 操作符的特色，而本篇主体只有一张 Rxjava 流程图，但是这张流程图基本上可以概括 Rxjava 的框架，整个流程可以看做是一个 “横向 S” 模型。&lt;/p&gt;
&lt;p&gt;该图共涉及 Rxjava 事件流的以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Observable 的创建&lt;/li&gt;
&lt;li&gt;Observer 的创建、产生订阅关系&lt;/li&gt;
&lt;li&gt;订阅关系的传递&lt;/li&gt;
&lt;li&gt;取消订阅的流程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava 源码学习(一):基本流程分析</title>
    <link href="/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>/2019/10/18/Rxjava 源码学习(一):基本流程分析/</id>
    <published>2019-10-18T07:02:06.000Z</published>
    <updated>2019-11-22T09:08:47.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Rxjava 源码版本：Rxjava2.2.8 </p></blockquote><h3 id="1-Rxjava-的基本实现"><a href="#1-Rxjava-的基本实现" class="headerlink" title="1. Rxjava 的基本实现"></a>1. Rxjava 的基本实现</h3><p>首先看一下最简单的例子，具体查看其内部实现：<br>通过以下代码查看 Rxjava 的典型使用：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        System.out.println(&quot;onSubscribe:&quot; + d.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;Throwable：&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        System.out.println(&quot;onComplete：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印日志为如下，可以看到事件接收的顺序和事件发送的顺序相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe:CreateEmitter&#123;null&#125;</span><br><span class="line">onNext：one</span><br><span class="line">onNext：two</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><h3 id="2-创建-Observable-对象"><a href="#2-创建-Observable-对象" class="headerlink" title="2. 创建 Observable 对象"></a>2. 创建 Observable 对象</h3><p>在上面的代码中，Observable 通过 create 来创建 Observable 对象，其具体源码如下：</p><p>Observable#create</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)</span><br><span class="line">    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 RxJavaPlugins.onAssembly 去组装 Observable，具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123;</span><br><span class="line">    Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    if (f != null) &#123;</span><br><span class="line">        return apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 onObservableAssembly 是什么没看懂，但是不影响对流程的分析，在此方法中，我们可以认为直接返回传入的 Observable 对象。</p><p>其中 source 即为我们在使用 Rxjava 的 create 中传入的匿名对象，在上文中为 ObservableOnSubscribe，其方法 – subscribe 的参数为 <code>事件发生器</code>，可以用来发送事件，事件发生器为整个事件流的驱动。</p><p>其中涉及了 ObservableCreate，由于这个类对流程进行十分重要，所以我们查看一下其具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;</span><br><span class="line">    final ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123;</span><br><span class="line">        this.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class CreateEmitter&lt;T&gt;</span><br><span class="line">    extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">    implements ObservableEmitter&lt;T&gt;, Disposable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = -3434801548987643227L;</span><br><span class="line"></span><br><span class="line">        final Observer&lt;? super T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">            this.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class SerializedEmitter&lt;T&gt;</span><br><span class="line">    extends AtomicInteger</span><br><span class="line">    implements ObservableEmitter&lt;T&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的类层级结构为：ObservableCreate 内部包含两个内部类，分别为：CreateEmitter、SerializedEmitter，两者均继承了 ObservableEmitter，是事件发生器，为整个事件流的起点，但是具体如果发送事件，继续向下分析。</p><p>在 subscribeActual 方法中，我们可以看到创建了  CreateEmitter 对象，并通过以下调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.onSubscribe(parent);</span><br><span class="line">source.subscribe(parent);</span><br></pre></td></tr></table></figure><p>以上代码使 Obervable、Observer 与时间发射器分别产生关联，是事件流得以进行下去的关键。其实 <code>observer.onSubscribe(parent)</code> 即为在使用 Rxjava 过程的 Observer 中的 <code>onSubscribe(Disposable d)</code>，而 <code>source.subscribe(parent)</code> 即为 即为在使用 Rxjava 过程的 Observable 中的 <code>public void subscribe(ObservableEmitter&lt;String&gt; emitter)</code>，以上全是在方法 subscribeActual 中调用的，具体 subscribeActual 什么时候调用，查看下面的分析。</p><p>综上分析，其实这一步仅仅是创建了 一个 Observerable 对象，其他的事情，比如产生订阅关系、创建事件发生器等都没有做，都会在产生订阅关系时才会进行，通观全局在调用 subscribe 方法前，所有的操作符都只是创建了该操作符下的 Observable 对象，其他什么事都没做，明白了这点就理解了 Rxjava 流程中一条主要的流程线。</p><h3 id="3-产生订阅关系"><a href="#3-产生订阅关系" class="headerlink" title="3. 产生订阅关系"></a>3. 产生订阅关系</h3><p>Observable 对象通过 subscribe 与 Observer 产生调用关系。</p><p>Observable#subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 同样，我们可以认为直接返回 observer，对流程分析无影响 </span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">        ...</span><br><span class="line">        // 在此处 ObservableOnSubscribe#subscribeActual</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        ...</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在此时通过 ObservableOnSubscribe#subscribeActual 方法，从而使 Observer、Observable 分别与事件发生器发生关联。从上面知道 subscribeActual 中调用了 <code>source.subscribe(parent)</code>，其实为新建 ObservableOnSubscribe 对象的 subscribe 方法，从而完成回调 Rxjava 使用过程中自定义的事件发生器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    // source.subscribe(parent) 方法最终会回调到此处</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>产生订阅关系是 Rxjava 中的另外一条流程线，也是十分重要的，由于在第一步中只是创建了操作符下的 Observable 对象，执行流程方向为：上游到下游，而此时创建订阅关系是由最后一个 Observable 对象开始的，要想所有的 Observable 对象产生订阅链，那么订阅流程方向为：下游到上游。</p><h3 id="4-发布事件"><a href="#4-发布事件" class="headerlink" title="4. 发布事件"></a>4. 发布事件</h3><p>既然 Observer、Observable 分别和事件发生器(Emitter) 产生关联，并且通过回调来到事件发射现场，那么具体查看是如何发生事件，以及观察者如何对每个事件是如何调用的。</p><p>具体以 CreateEmitter 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static final class CreateEmitter&lt;T&gt;</span><br><span class="line">extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">implements ObservableEmitter&lt;T&gt;, Disposable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -3434801548987643227L;</span><br><span class="line"></span><br><span class="line">    final Observer&lt;? super T&gt; observer;</span><br><span class="line"></span><br><span class="line">    CreateEmitter(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        this.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(T t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            onError(new NullPointerException(&quot;onNext called with null.....&quot;));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            observer.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                observer.onComplete();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setDisposable(Disposable d) &#123;</span><br><span class="line">        DisposableHelper.set(this, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCancellable(Cancellable c) &#123;</span><br><span class="line">        setDisposable(new CancellableDisposable(c));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void dispose() &#123;</span><br><span class="line">        DisposableHelper.dispose(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isDisposed() &#123;</span><br><span class="line">        return DisposableHelper.isDisposed(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件发生器发射事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emitter.onNext(&quot;one&quot;);</span><br></pre></td></tr></table></figure><p>最终会调用到 CreateEmitter#onNext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 发生器与自定义 Observer 已经产生关联关系，那么此时就会回调 Observer 的 onNext，也就是我们自定义 Observer 中的而如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNext(String s) &#123;</span><br><span class="line">    System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 emitter.onComplete()，emitter.onError() 也是如上过程，只不过 onError 会首先判断 error 是否能够自己处理，否则就交给 RxJavaPlugins 处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onError(Throwable t) &#123;</span><br><span class="line">    if (!tryOnError(t)) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean tryOnError(Throwable t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        t = new NullPointerException(&quot;onError called with null. Null values are generally not allowed in 2.x operators an</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 最终会调用到自定义  Observer 的 onError 方法</span><br><span class="line">            observer.onError(t);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件发布就是 Rxjava 的第三条流程线了，根据产生的订阅链自上游到下游发布事件。</p><p>至此，Rxjava 的基本流程分析结束。</p><p>事件流可以而上而下进行下去，原因是 Observable 操作符 得到的还是 Observable，通过通过 Observable.subsribe 方法实现订阅关系。</p><h3 id="5-一个操作符：Map"><a href="#5-一个操作符：Map" class="headerlink" title="5. 一个操作符：Map"></a>5. 一个操作符：Map</h3><p>我们通过 map 操作符去理解 Rxjava 中数量众多的操作符的基本原理。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer apply(String s) throws Exception &#123;</span><br><span class="line">        return Integer.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        System.out.println(&quot;onSubscribe:&quot; + d.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer s) &#123;</span><br><span class="line">        System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;Throwable：&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        System.out.println(&quot;onComplete：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>map 操作符源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Function 对象 mapper 通过 ObservableMap 传给 ObservableMap，并完成相应的赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123;</span><br><span class="line">    final Function&lt;? super T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">        source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123;</span><br><span class="line">        final Function&lt;? super T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            // 将观察者对象 actual 赋值给 downstream</span><br><span class="line">            super(actual);</span><br><span class="line">            this.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(T t) &#123;</span><br><span class="line">            if (done) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sourceMode != NONE) &#123;</span><br><span class="line">                downstream.onNext(null);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            U v;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 调用 mapper.apply ，其实是自定义 Function 中的 apply 方法</span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 最终调用 Observer 的 onNext 方法</span><br><span class="line">            downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int requestFusion(int mode) &#123;</span><br><span class="line">            return transitiveBoundaryFusion(mode);</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的流程和 Rxjava 基本流程基本相同,执行产生订阅关系的方法 - subscribe 时调用 ObservableMap#subscribeActual：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    // 此处的 source 为调用 map 操作符的 Observable，即上一步通过 create 创建的 Observable </span><br><span class="line">    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">        ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook retu...);</span><br><span class="line">        // 由于多态的存在，此处的 subscribeActual 会调用 ObservableCreate 的subscribeActual</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t t</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的方法 subscribeActual 调用的为 ObservableCreate 的 subscribeActual 方法，接下来和基本流程一样会调用 ObservableCreate 的 subscribe 从而开启事件的分发，与 Rxjava 基本流程不同的是 map 操作符构建了 MapObserver，完成 MapObserver 的相关操作后，才会最终调用自定义的 Observer 对象。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>以 map 操作符为例，可以基本理清 Rxjava 中操作符的基本原理，<br>Rxjava <strong>整个事件流向的核心代码</strong> 如下：</p><p>xxxObservable#subscribeActual</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    source.subscribe(new XxxxObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observable#subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">    .... </span><br><span class="line">    subscribeActual(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 Observable 和 Observer 通过两个方法的往复调用，最终构建完整的事件流。</p><p><strong>下游的 Observable 对象持有上游 Observable 对象的引用，上游 Observer 对象持有下游 Observer 对象的引用，那么这就产生了 Obsever 是自下而上的说法，并且 Observerable 和 Observer 订阅关系的建立也是自下而上的，当然事件发布为自上而下的。</strong></p><p>如果把第一个构建的 Observable 标记为 A，把自定义的 Observer 标记为 Z，那么各种操作符会构建不同的 Observer 标记为 B、C、D ….,通过 subscribeActual、 subscribe 方法使 A、B、C、D … 、Z 形成链式关系，最终由 Observable 对象 A 开启事件分发，将事件通过操作符定义的 Observer 对象 B、C、D … 进行各自处理，最终传递到 Observer 对象 Z 中，这个事件流得以完成，其实这就是平时所说的 Rxjava 中 <strong>Observer 由下向上传递</strong>，其实这也是 observerOn 只能只能指定下游 Observer 的线程的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Rxjava 源码版本：Rxjava2.2.8 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Rxjava-的基本实现&quot;&gt;&lt;a href=&quot;#1-Rxjava-的基本实现&quot; class=&quot;headerlink&quot; title=&quot;1. Rxjava 的基本实现&quot;&gt;&lt;/a&gt;1. Rxjava 的基本实现&lt;/h3&gt;&lt;p&gt;首先看一下最简单的例子，具体查看其内部实现：&lt;br&gt;通过以下代码查看 Rxjava 的典型使用：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中的结构化并发是什么?</title>
    <link href="/2019/10/11/Kotlin-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>/2019/10/11/Kotlin-中的结构化并发是什么/</id>
    <published>2019-10-11T10:41:20.000Z</published>
    <updated>2019-10-18T06:46:03.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在接触到 Kotlin 的协程后，在官方文档知道，通过结构化的并发可以避免很多问题，具体参见官方文档 <a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">结构化的并发</a>，但是什么是结构化的并发呢？通过搜索引擎没有查询到有用的信息。此处只是记录自己通过网上博客的学习，为自己现阶段的记录和理解，这个话题也会持续更新。</p></blockquote><p>Kotlin 协程中如何实现结构化并发呢？ 先看一下官方文档中是基于什么问题使用结构化的并发？首先看一下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; // 启动一个新协程并保持对这个作业的引用</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">    job.join() // 等待直到子协程执行结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的启动总是全局的，一般是在程序的上下文启动的，对应协程，就如上面例子一样通过 GlobalScope 创建一个全局协程。不过官方文档上针对 GlobalScope 所阐述的确定，抱歉没看懂。。。</p><a id="more"></a><p>但是协程是可以 <strong>在指定作用域内启动协程的</strong>。协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中，外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束，此时就不用再像上面一样通过调用 join 来等待协程的执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun main() = runBlocking &#123; // this: CoroutineScope</span><br><span class="line">    launch &#123; // 在 runBlocking 作用域中启动一个新协程</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个例子似乎不太形象，在博客上存在这样一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image &#123; </span><br><span class="line">    val deferred1 = async &#123; loadImage(name1) &#125;</span><br><span class="line">    val deferred2 = async &#123; loadImage(name2) &#125;</span><br><span class="line">    return combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是 <a href="https://www.youtube.com/watch?v=_hfBv0a09Jc" target="_blank" rel="noopener">KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov</a>，但是这个例子目前自己没能实现(参看了原博文说是此例子有很多处错误，不知是否该例是伪代码))，但是有这个例子又能够延伸什么是结构化的并发，先放在这吧(我尽力了)。</p><p>首先在外部协程中调用函数，如果此操作被取消了，那么这两个 loadImage 动作是不会被取消的。</p><p>进一步改善的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image &#123; </span><br><span class="line">    val deferred1 = async(conroutineContext) &#123; loadImage(name1) &#125;</span><br><span class="line">    val deferred2 = async(conroutineContext) &#123; loadImage(name2) &#125;</span><br><span class="line">    return combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在父协程被取消后，子协程也会被取消。但是这样也存在一定的问题，如果 deferred1.await() 抛出异常，但是 deferred2 不会受到影响，这样是不符合逻辑的。</p><p>这时就可以使用结构化的并发了，将 deferred1、deferred2 置于同一个作用域上，作用域内的协程称为外部协程的子协程，那么当其中外部协程被取消或者子协程异常时，作用域中的所有子协程都会被取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image =</span><br><span class="line">    coroutineScope &#123; </span><br><span class="line">        val deferred1 = async &#123; loadImage(name1) &#125;</span><br><span class="line">        val deferred2 = async &#123; loadImage(name2) &#125;</span><br><span class="line">        combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>知识来源：</strong></p><p><a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">结构化的并发</a></p><p><a href="https://blog.csdn.net/weixin_33755847/article/details/91366063" target="_blank" rel="noopener">[译] Kotlin 、协程、结构化并发</a></p><p><a href="https://trio.discourse.group/t/structured-concurrency-kickoff/55" target="_blank" rel="noopener">Structured Concurrency Kickoff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在接触到 Kotlin 的协程后，在官方文档知道，通过结构化的并发可以避免很多问题，具体参见官方文档 &lt;a href=&quot;https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;结构化的并发&lt;/a&gt;，但是什么是结构化的并发呢？通过搜索引擎没有查询到有用的信息。此处只是记录自己通过网上博客的学习，为自己现阶段的记录和理解，这个话题也会持续更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kotlin 协程中如何实现结构化并发呢？ 先看一下官方文档中是基于什么问题使用结构化的并发？首先看一下这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fun main() = runBlocking &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val job = GlobalScope.launch &amp;#123; // 启动一个新协程并保持对这个作业的引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(1000L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;World!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&amp;quot;Hello,&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job.join() // 等待直到子协程执行结束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;线程的启动总是全局的，一般是在程序的上下文启动的，对应协程，就如上面例子一样通过 GlobalScope 创建一个全局协程。不过官方文档上针对 GlobalScope 所阐述的确定，抱歉没看懂。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin" scheme="/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(三)：协程的非阻塞式挂起是什么？</title>
    <link href="/2019/10/09/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%B8%89)%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%8C%82%E8%B5%B7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>/2019/10/09/Kotlin协程学习(三)：协程的非阻塞式挂起是什么/</id>
    <published>2019-10-09T07:51:42.000Z</published>
    <updated>2019-10-14T08:27:52.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin-协程的-非阻塞式挂起是什么？"><a href="#Kotlin-协程的-非阻塞式挂起是什么？" class="headerlink" title="Kotlin 协程的 非阻塞式挂起是什么？"></a>Kotlin 协程的 非阻塞式挂起是什么？</h3><p>什么事非阻塞式：不卡当前线程。</p><p>Kotlin 协程的非阻塞原因：</p><pre><code>因为使用挂起函数会切换线程，既然切换了线程，那么肯定就不卡当前线程了。</code></pre><h3 id="其实线程也是非阻塞式的"><a href="#其实线程也是非阻塞式的" class="headerlink" title="其实线程也是非阻塞式的"></a>其实线程也是非阻塞式的</h3><p>线程中的阻塞式是 <code>在单线程</code> 下，在单线程下执行耗时操作是会阻塞线程的，如果在<code>多线程</code>情况下，那么此时的线程也是非阻塞式的。</p><a id="more"></a><p>但是 Kotlin 协程在 <strong>单协程的情况下也是非阻塞式</strong> 的，因为它可以利用挂起函数来切换线程。</p><p>协程是一种 <code>看起来阻塞，但是其实是非阻塞</code> 的写法,因为它有挂起函数。</p><pre><code>看起来阻塞：是因为确实你没有看到相关线程切换的代码，为顺序执行的代码。其实是非阻塞：是因为挂起函数可以自动帮助我们完成线程切换。</code></pre><h3 id="协程和线程的关系"><a href="#协程和线程的关系" class="headerlink" title="协程和线程的关系"></a>协程和线程的关系</h3><p>在 Kotlin 中协程是 <strong>基于线程而实现的一套更上层的工具 API</strong>，为基于线程的上层框架，类似 Executors ，并且和 Executors 的性能也差不多，所以 “轻量级线程说法，比线程更高效” 这种说法有待商榷。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>协程：就是切线程<br>挂起：可以自动切回来的切线程<br>非阻塞：协程可以用看起来阻塞的代码写出非阻塞式的操作</p><p>。</p><hr><p><strong>知识链接</strong></p><p><a href="https://www.bilibili.com/video/av69354029" target="_blank" rel="noopener">到底什么是「非阻塞式」挂起？协程真的比线程更轻量级吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kotlin-协程的-非阻塞式挂起是什么？&quot;&gt;&lt;a href=&quot;#Kotlin-协程的-非阻塞式挂起是什么？&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 协程的 非阻塞式挂起是什么？&quot;&gt;&lt;/a&gt;Kotlin 协程的 非阻塞式挂起是什么？&lt;/h3&gt;&lt;p&gt;什么事非阻塞式：不卡当前线程。&lt;/p&gt;
&lt;p&gt;Kotlin 协程的非阻塞原因：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因为使用挂起函数会切换线程，既然切换了线程，那么肯定就不卡当前线程了。&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;其实线程也是非阻塞式的&quot;&gt;&lt;a href=&quot;#其实线程也是非阻塞式的&quot; class=&quot;headerlink&quot; title=&quot;其实线程也是非阻塞式的&quot;&gt;&lt;/a&gt;其实线程也是非阻塞式的&lt;/h3&gt;&lt;p&gt;线程中的阻塞式是 &lt;code&gt;在单线程&lt;/code&gt; 下，在单线程下执行耗时操作是会阻塞线程的，如果在&lt;code&gt;多线程&lt;/code&gt;情况下，那么此时的线程也是非阻塞式的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程官方文档学习(二)</title>
    <link href="/2019/10/07/Kotlin%20%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <id>/2019/10/07/Kotlin 协程官方文档学习(二)/</id>
    <published>2019-10-07T09:12:00.000Z</published>
    <updated>2019-10-21T07:21:34.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协程上下文和调度器"><a href="#1-协程上下文和调度器" class="headerlink" title="1. 协程上下文和调度器"></a>1. 协程上下文和调度器</h3><p>协程总是要运行在 CoroutineContext 类型为代表的协程上下文中，协程上下文是各种不同元素的集合，其中主元素为 Job，同事我们也会使用他的调度器。</p><h3 id="2-调度器与线程"><a href="#2-调度器与线程" class="headerlink" title="2. 调度器与线程"></a>2. 调度器与线程</h3><p>协程上下文包括了一个协程调度器，它确定了协程执行时使用的一个或多个线程。协程调度器可以指定协程运行在指定线程，也可以调度它运行在线程池中或不受限的运行。</p><p>所有的协程构建器(比如：launch、async) 会接收一个可选的 CoroutineContext 参数，它可以被显示的为一个新的协程或其他上下文元素指定一个调度器。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch &#123; // 运行在父协程的上下文中，即 runBlocking 主协程</span><br><span class="line">        println(&quot;main runBlocking      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // 不受限的——将工作在主线程中</span><br><span class="line">        println(&quot;Unconfined            : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; // 将会获取默认调度器</span><br><span class="line">        println(&quot;Default               : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // 将使它获得一个新的线程</span><br><span class="line">        println(&quot;newSingleThreadContext: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">Unconfined            : I&apos;m working in thread main</span><br><span class="line">Default               : I&apos;m working in thread DefaultDispatcher-worker-1</span><br><span class="line">newSingleThreadContext: I&apos;m working in thread MyOwnThread</span><br><span class="line">main runBlocking      : I&apos;m working in thread main</span><br></pre></td></tr></table></figure><h3 id="3-非受限调度器-vs-受限调度器"><a href="#3-非受限调度器-vs-受限调度器" class="headerlink" title="3. 非受限调度器 vs 受限调度器"></a>3. 非受限调度器 vs 受限调度器</h3><p>在上面的例子中有 Dispatchers.Unconfined ，此为非受限调度器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // 非受限的——将和主线程一起工作</span><br><span class="line">        println(&quot;Unconfined      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;Unconfined      : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; // 父协程的上下文，主 runBlocking 协程</span><br><span class="line">        println(&quot;main runBlocking: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">Unconfined      : I&apos;m working in thread main</span><br><span class="line">main runBlocking: I&apos;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor</span><br></pre></td></tr></table></figure><p>Dispatchers.Unconfined协程调度器会在程序运行到第一个挂起点时，在调用者线程中启动,所以日志打印为：<br><code>Unconfined      : I&#39;m working in thread main</code>,此时在主线程中挂起。</p><p>挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行，挂起函数 delay() 运行的线程为<br><code>Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor</code></p><p>。非受限调度器适合协程不消耗 CPU 时间也不更新任何限于特定线程的共享数据（如 UI）的情境。</p><h3 id="4-调试协程与线程"><a href="#4-调试协程与线程" class="headerlink" title="4. 调试协程与线程"></a>4. 调试协程与线程</h3><p>由上面可知协程可以在一个线程中挂挂起在另外一个线程中恢复。在单一线程中也难弄清楚协程在何时何地在做什么事，所以这时我们需要打印正在执行代码的线程名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val a = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing a piece of the answer&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    val b = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing another piece of the answer&quot;)</span><br><span class="line">        7</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;)    </span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure><p>可以很清楚的知道协程执行的线程以及协程上下文。</p><h3 id="5-在不同线程间切换"><a href="#5-在不同线程间切换" class="headerlink" title="5. 在不同线程间切换"></a>5. 在不同线程间切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</span><br><span class="line">            newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</span><br><span class="line">                    runBlocking(ctx1) &#123;</span><br><span class="line">                        log(&quot;Started in ctx1&quot;)</span><br><span class="line">                        withContext(ctx2) &#123;</span><br><span class="line">                            log(&quot;Working in ctx2&quot;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        log(&quot;Back to ctx1&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">打印日志：</span><br><span class="line">[Ctx1 @coroutine#1] Started in ctx1</span><br><span class="line">[Ctx2 @coroutine#1] Working in ctx2</span><br><span class="line">[Ctx1 @coroutine#1] Back to ctx1</span><br></pre></td></tr></table></figure><p>从打印日志中可知 可以为 runBlocking() 显式的设置线程上下文，同时可以使用 withContext 函数来改变协程的线程上下文，从每条日志的<code>@coroutine#1</code>知它们仍运行在相同的协程中，以上函数只是改变了协程运行的线程，但是并没有改变协程的执行。</p><h3 id="6-上下文中的-Job"><a href="#6-上下文中的-Job" class="headerlink" title="6. 上下文中的 Job"></a>6. 上下文中的 Job</h3><p>Job 是它上下文中的一部分，协程可以在它所属的上下文中使用 coroutineContext[Job] 表达式来获取 Job 实例对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val job: Job? = coroutineContext[Job]</span><br><span class="line">    println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;)</span><br><span class="line">    println(&quot;My job is $job&quot;)</span><br><span class="line">    println(&quot;Job is active?: $isActive&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">My job is BlockingCoroutine&#123;Active&#125;@5fa7e7ff</span><br><span class="line">My job is BlockingCoroutine&#123;Active&#125;@5fa7e7ff</span><br><span class="line">Job is active?: true</span><br></pre></td></tr></table></figure><p>进一步验证了 <code>coroutineContext[Job]</code> 取回的为所属上下文的 Job 对象。</p><p>CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。</p><h3 id="7-子协程"><a href="#7-子协程" class="headerlink" title="7. 子协程"></a>7. 子协程</h3><p>当一个协程被其它协程在 CoroutineScope 中启动的时候， 它将通过 CoroutineScope.coroutineContext 来承袭上下文，并且这个新协程的 Job 将会成为父协程的子 Job。<strong>当一个父协程被取消的时候，所有它的子协程也会被递归的取消</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    println(&quot;***[$&#123;Thread.currentThread().name&#125;] runBlocking above&quot;)</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        // 孵化了两个子作业, 其中一个通过 GlobalScope 启动</span><br><span class="line">        println(&quot;***[$&#123;Thread.currentThread().name&#125;] parent scope(父协程)&quot;)</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(&quot;job1: I run in GlobalScope and execute independently!&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;***[$&#123;Thread.currentThread().name&#125;] GlobalScope(全局协程)&quot;)</span><br><span class="line">            println(&quot;job1: I am not affected by cancellation of the request&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // 另一个则承袭了父协程的上下文</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(&quot;***[$&#123;Thread.currentThread().name&#125;] child scope(子协程)&quot;)</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;job2: I am a child of the request coroutine&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)// 由于父协程 cancel，所以子协程中断执行，该语句无法打印</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // 取消请求（request）的执行</span><br><span class="line">    delay(1000) // 延迟一秒钟来看看发生了什么</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">    println(&quot;***[$&#123;Thread.currentThread().name&#125;] runBlocking Blew&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">***[main @coroutine#1] runBlocking above(runBlocking 外层协程)</span><br><span class="line">***[main @coroutine#2] parent scope(父协程)</span><br><span class="line">job1: I run in GlobalScope and execute independently!</span><br><span class="line">***[main @coroutine#4] child scope(子协程)</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">***[DefaultDispatcher-worker-2 @coroutine#3] GlobalScope(全局协程)</span><br><span class="line">job1: I am not affected by cancellation of the request</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">***[main @coroutine#1] runBlocking Blew(runBlocking 外层协程)</span><br></pre></td></tr></table></figure><h3 id="8-父协程的职责"><a href="#8-父协程的职责" class="headerlink" title="8. 父协程的职责"></a>8. 父协程的职责</h3><p>父协程总是等待它所有的子协程全部执行完毕，父协程不必显式的跟踪所有子协程的启用，也不必使用 Job.join 在最后的时候等待它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // 启动少量的子作业</span><br><span class="line">                launch  &#123;</span><br><span class="line">                    delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间</span><br><span class="line">                    println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() // 等待请求的完成，包括其所有子协程</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">request: I&apos;m done and I don&apos;t explicitly join my children that are still active</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Coroutine 2 is done</span><br><span class="line">Now processing of the request is complete</span><br></pre></td></tr></table></figure><p>如果注释掉 request.join()，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // 启动少量的子作业</span><br><span class="line">                launch  &#123;</span><br><span class="line">                    delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间</span><br><span class="line">                    println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //request.join() // 等待请求的完成，包括其所有子协程</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">Now processing of the request is complete</span><br><span class="line">request: I&apos;m done and I don&apos;t explicitly join my children that are still active</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Coroutine 2 is done</span><br></pre></td></tr></table></figure><p>所以父协程不调用 join() 函数，也是会等待所有的子协程执行完毕。</p><h3 id="9-为协程命名"><a href="#9-为协程命名" class="headerlink" title="9. 为协程命名"></a>9. 为协程命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking(CoroutineName(&quot;runBlockingName&quot;)) &#123;</span><br><span class="line">    log(&quot;Started main coroutine&quot;)</span><br><span class="line">    // 运行两个后台值计算</span><br><span class="line">    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123;</span><br><span class="line">        delay(500)</span><br><span class="line">        log(&quot;Computing v1&quot;)</span><br><span class="line">        252</span><br><span class="line">    &#125;</span><br><span class="line">    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        log(&quot;Computing v2&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">[main @runBlockingName#1] Started main coroutine</span><br><span class="line">[main @v1coroutine#2] Computing v1</span><br><span class="line">[main @v2coroutine#3] Computing v2</span><br><span class="line">[main @runBlockingName#1] The answer for v1 / v2 = 42</span><br></pre></td></tr></table></figure><h3 id="10-协程作用域"><a href="#10-协程作用域" class="headerlink" title="10. 协程作用域"></a>10. 协程作用域</h3><p>在日常开发过程中，在 Activity 中我们需要开启多个协程来获取网络数据、后台绘制、执行动画等，这协程动作必须在 Activity 销毁时取消，否则就会引起内存泄漏。</p><p>可以手动绑定协程和Activity 的生命周期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Activity &#123;</span><br><span class="line">    private val mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续运行……</span><br></pre></td></tr></table></figure><p>也可以在这个 Activity 类中实现 CoroutineScope 接口，最好的方法是使用具有默认工厂函数的委托。 我们也可以将所需的调度器与作用域合并（我们在这个示例中使用 Dispatchers.Default）</p><p><strong>调度器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) &#123;</span><br><span class="line">    // 继续运行……</span><br></pre></td></tr></table></figure><p>完整执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) &#123;</span><br><span class="line"></span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        cancel() // Extension on CoroutineScope</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续运行……</span><br><span class="line"></span><br><span class="line">    // class Activity continues</span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        // 在示例中启动了 10 个协程，且每个都工作了不同的时长</span><br><span class="line">        repeat(10) &#123; i -&gt;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // Activity 类结束</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val activity = Activity()</span><br><span class="line">    activity.doSomething() // 运行测试函数</span><br><span class="line">    println(&quot;Launched coroutines&quot;)</span><br><span class="line">    delay(500L) // 延迟半秒钟</span><br><span class="line">    println(&quot;Destroying activity!&quot;)</span><br><span class="line">    activity.destroy() // 取消所有的协程</span><br><span class="line">    delay(1000) // 为了在视觉上确认它们没有工作    </span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">Launched coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-协程上下文和调度器&quot;&gt;&lt;a href=&quot;#1-协程上下文和调度器&quot; class=&quot;headerlink&quot; title=&quot;1. 协程上下文和调度器&quot;&gt;&lt;/a&gt;1. 协程上下文和调度器&lt;/h3&gt;&lt;p&gt;协程总是要运行在 CoroutineContext 类型为代表的协程上下文中，协程上下文是各种不同元素的集合，其中主元素为 Job，同事我们也会使用他的调度器。&lt;/p&gt;
&lt;h3 id=&quot;2-调度器与线程&quot;&gt;&lt;a href=&quot;#2-调度器与线程&quot; class=&quot;headerlink&quot; title=&quot;2. 调度器与线程&quot;&gt;&lt;/a&gt;2. 调度器与线程&lt;/h3&gt;&lt;p&gt;协程上下文包括了一个协程调度器，它确定了协程执行时使用的一个或多个线程。协程调度器可以指定协程运行在指定线程，也可以调度它运行在线程池中或不受限的运行。&lt;/p&gt;
&lt;p&gt;所有的协程构建器(比如：launch、async) 会接收一个可选的 CoroutineContext 参数，它可以被显示的为一个新的协程或其他上下文元素指定一个调度器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin 官方文档" scheme="/tags/Kotlin-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程官方文档学习(一)</title>
    <link href="/2019/10/07/Kotlin%20%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <id>/2019/10/07/Kotlin 协程官方文档学习(一)/</id>
    <published>2019-10-07T09:11:30.000Z</published>
    <updated>2019-10-21T07:21:48.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协程的基本介绍"><a href="#1-协程的基本介绍" class="headerlink" title="1. 协程的基本介绍"></a>1. 协程的基本介绍</h3><p>协程，本质上是轻量级的线程。</p><p>它们在某些 <code>CoroutineScope 上下文中</code> 与 <code>launch 协程构建器</code> 一起启动。</p><p>在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。</p><p>delay 是挂起函数不会造成线程阻塞，但是会挂起协程，并且挂起函数只能在协程中使用。</p><h3 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2. 阻塞与非阻塞"></a>2. 阻塞与非阻塞</h3><p>阻塞与非阻塞都是针对于是否阻塞主线程来说的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例 1</span><br><span class="line">fun main() &#123;</span><br><span class="line">    GlobalScope.launch &#123; // 在后台启动一个新的协程并继续</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello&quot;) // 主线程中的代码会立即执行</span><br><span class="line">    runBlocking &#123;     // 但是这个表达式阻塞了主线程</span><br><span class="line">        delay(2000L)  // 我们延迟 2 秒来保证 JVM 的存活</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上程序中 GlobalScope.launch{} 中的 delay(1000L) 只会阻塞协程，但是 <strong>不会阻塞主线程的执行</strong>，所以以上代码会首先打印: Hello ，然后打印: World!。</p><p>runBlocking{} 代码块为阻塞式的。</p><h3 id="3-定义-Job"><a href="#3-定义-Job" class="headerlink" title="3. 定义 Job"></a>3. 定义 Job</h3><p>示例 1 中通过阻塞主线程一段时间:<br><code>(runBlocking{delay(2000L)})</code>，从而等待协程的完成，这不是一个好的方式，可以通过 Job 来改善上述方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; // launch a new coroutine and keep a reference to its Job</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">    job.join() // wait until child coroutine completes    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>Job#join()</code> 主线程会一直阻塞，直到指定协程执行完毕。</p><h3 id="4-结构化并发"><a href="#4-结构化并发" class="headerlink" title="4. 结构化并发"></a>4. 结构化并发</h3><p>使用 GlobalScope.launch 会创建顶部协程，它会消耗一定的资源，如此的话启动多个协程会导致内存不足，此时使用 <strong>结构化并发</strong> 可以解决这个问题。</p><p>定义一个外部协程，在其内部也可以定义新的协程，包括外部协程在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中。 我们可以在这个作用域中启动协程而无需显式调用 join ，因为 <strong>外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; //this:CoroutineScope</span><br><span class="line"></span><br><span class="line">    // 在 runBlocking 作用域中启动一个新协程</span><br><span class="line">    launch &#123;// this: CoroutineScope</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line"></span><br><span class="line">        launch &#123;// this: CoroutineScope</span><br><span class="line">            delay(5000L)</span><br><span class="line">            println(&quot;hahahah&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-构建作用域"><a href="#5-构建作用域" class="headerlink" title="5. 构建作用域"></a>5. 构建作用域</h3><p>除了使用构建器(如: launch、async 等)提供协程作用域之外，还可以使用 coroutineScope 构建器声明自己的作用域。</p><p>使用  coroutineScope 可以构建协程作用域，<strong>构建的协程作用域在所有子协程执行完毕之前不会结束</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; // this: CoroutineScope</span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(200L)</span><br><span class="line">        println(&quot;Task from runBlocking&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; // 创建一个协程作用域</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(500L) </span><br><span class="line">            println(&quot;Task from nested launch&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(100L)</span><br><span class="line">        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(&quot;Coroutine scope is over&quot;) // 这一行在内嵌 launch 执行完毕后才输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为打印日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task from coroutine scope</span><br><span class="line">Task from runBlocking</span><br><span class="line">Task from nested launch</span><br><span class="line">Coroutine scope is over</span><br></pre></td></tr></table></figure><p>注意打印顺序，从打印顺序中可以看出协程的 <strong>非阻塞</strong>，因为 <code>Task from coroutine scope</code> 最先打印出来。</p><h3 id="协程的取消与超时"><a href="#协程的取消与超时" class="headerlink" title="协程的取消与超时"></a>协程的取消与超时</h3><p>协程是可以被取消的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;job: I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一段时间</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancel() // 取消该作业</span><br><span class="line">    job.join() // 等待作业执行结束</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&apos;m sleeping 0 ...</span><br><span class="line">job: I&apos;m sleeping 1 ...</span><br><span class="line">job: I&apos;m sleeping 2 ...</span><br><span class="line">main: I&apos;m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure><p>当协程中在执行计算任务是协程是不能被取消的。</p><p>超时 ：</p><p>withTimeout(1300L) {<br>    repeat(1000) { i -&gt;<br>            println(“I’m sleeping $i …”)<br>        delay(500L)<br>    }<br>}</p><p>在执行超过 1300ms 会报出错误。</p><h3 id="6-挂起函数"><a href="#6-挂起函数" class="headerlink" title="6. 挂起函数"></a>6. 挂起函数</h3><p>使用 <code>suspend</code> 修饰的函数，排列的挂起函数 <strong>默认顺序执行</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // 假设我们在这里做了一些有用的事</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // 假设我们在这里也做了一些有用的事</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val one = doSomethingUsefulOne()</span><br><span class="line">        val two = doSomethingUsefulTwo()</span><br><span class="line">        println(&quot;The answer is $&#123;one + two&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 2012 ms</span><br></pre></td></tr></table></figure><p>通过打印时间可以得知默认挂起函数为顺序执行的。</p><h3 id="7-lauch-、-async"><a href="#7-lauch-、-async" class="headerlink" title="7. lauch 、 async"></a>7. lauch 、 async</h3><p>async 与 lauch 一样，开启了一个单独的协程，与其他协程一起进行并行工作。<br>不同的 launch 返回一个 Job 不附带任何结果值，而 async 返回 Deffered ，它是一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 <strong>.await() 在一个延期的值上得到它的最终结果</strong>， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它 。</p><p>同样是上面的例子，我们使用 async 并发修饰函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">        val one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        val two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)// 使用 await() 函数获得他的最终结果</span><br><span class="line">    &#125;</span><br><span class="line">println(&quot;Completed in $time ms&quot;) </span><br><span class="line"></span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 1029 ms</span><br></pre></td></tr></table></figure><p>从执行时间可知使用 async 修饰函数为 <strong>并行执行</strong> 的。</p><h3 id="8-惰性-async"><a href="#8-惰性-async" class="headerlink" title="8. 惰性 async"></a>8. 惰性 async</h3><p>如果懒加载一样，惰性 async 只有在使用时才会执行，执行 start() 方法执行该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">    val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">    // 执行一些计算</span><br><span class="line">    one.start() // 启动第一个</span><br><span class="line">    two.start() // 启动第二个</span><br><span class="line">    println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;Completed in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 1017 ms</span><br></pre></td></tr></table></figure><p>以上 one、two 只是定义的两个协程，由于 <code>start = CoroutineStart.LAZY</code> 的存在没有真正的执行，只有在执行 start 方法后两个协程才会真正的执行</p><h3 id="9-async-风格函数"><a href="#9-async-风格函数" class="headerlink" title="9. async 风格函数"></a>9. async 风格函数</h3><p>在 Kotlin 中不推荐使用此类型的函数,故不详述.</p><h3 id="10-结构化-async-函数"><a href="#10-结构化-async-函数" class="headerlink" title="10. 结构化 async 函数"></a>10. 结构化 async 函数</h3><p>结构化 async 函数 <strong>就是使多个 async 函数执行时如果一个函数发生异常,则其他未执行的 async 函数也不会得到执行</strong>,此功能使用  coroutineScope 来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; catch (e: ArithmeticException) &#123;</span><br><span class="line">        println(&quot;Computation failed with ArithmeticException&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async&lt;Int&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // 模拟一个长时间的运算</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        delay(2000L)</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val three = async &#123;</span><br><span class="line">        println(&quot;Test third run or not&quot;)</span><br><span class="line">        12</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await() + three.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印日志&quot;</span><br><span class="line">Test third run or not</span><br><span class="line">Second child throws an exception</span><br><span class="line">First child was cancelled</span><br><span class="line">Computation failed with ArithmeticException</span><br></pre></td></tr></table></figure><p>如果在上面函数执行过程中 two 发生异常,那么此时正在等待执行的 one 将中断执行,但是之前的 three 则可以正常的执行。</p><hr><p><strong>知识链接</strong></p><p><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">Improve app performance with Kotlin coroutines</a></p><p><a href="https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb" target="_blank" rel="noopener">Coroutines on Android (part I): Getting the background</a></p><p><a href="https://blog.csdn.net/qq_32115439/article/details/74018755" target="_blank" rel="noopener">Kotlin-24.协程和线程(Coroutine &amp; Thread)</a></p><p><a href="https://github.com/hltj/kotlinx.coroutines-cn/blob/master/ui/coroutines-guide-ui.md" target="_blank" rel="noopener">使用协程进行 UI 编程指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-协程的基本介绍&quot;&gt;&lt;a href=&quot;#1-协程的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 协程的基本介绍&quot;&gt;&lt;/a&gt;1. 协程的基本介绍&lt;/h3&gt;&lt;p&gt;协程，本质上是轻量级的线程。&lt;/p&gt;
&lt;p&gt;它们在某些 &lt;code&gt;CoroutineScope 上下文中&lt;/code&gt; 与 &lt;code&gt;launch 协程构建器&lt;/code&gt; 一起启动。&lt;/p&gt;
&lt;p&gt;在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。&lt;/p&gt;
&lt;p&gt;delay 是挂起函数不会造成线程阻塞，但是会挂起协程，并且挂起函数只能在协程中使用。&lt;/p&gt;
&lt;h3 id=&quot;2-阻塞与非阻塞&quot;&gt;&lt;a href=&quot;#2-阻塞与非阻塞&quot; class=&quot;headerlink&quot; title=&quot;2. 阻塞与非阻塞&quot;&gt;&lt;/a&gt;2. 阻塞与非阻塞&lt;/h3&gt;&lt;p&gt;阻塞与非阻塞都是针对于是否阻塞主线程来说的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin 官方文档" scheme="/tags/Kotlin-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 泛型简单理解</title>
    <link href="/2019/10/07/Kotlin%20%E6%B3%9B%E5%9E%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>/2019/10/07/Kotlin 泛型简单理解/</id>
    <published>2019-10-07T07:50:47.000Z</published>
    <updated>2019-10-21T07:21:28.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java-中的泛型"><a href="#1-Java-中的泛型" class="headerlink" title="1. Java 中的泛型"></a>1. Java 中的泛型</h3><p>协变(covariance)：子类的泛型类型也属于泛型类型的子类。</p><p>由于 Java 中类型擦除的存在，所以 Java 不支持协变，Kotlin 继承了这种限制。在 Java 中可以通过使用通配符(?) 来解除这种限制。</p><p>这样的话有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用了通配符，就可以把子类的泛型类型对象赋值给父类的泛型类型声明了</span><br><span class="line">List&lt;? extends TextView&gt; textViews = new ArrayList&lt;Button&gt;();</span><br></pre></td></tr></table></figure><p>虽然这种写法解除了赋值的限制，但是却增加了另外一个限制：在使用这个引用的时候，不能调用它的参数包含类型参数的方法，也不能给它的包含类型参数的字段赋值(除了空值)。</p><p>限制：父类的泛型类型声明的实际值不能是子类的泛型类型对象</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private ArrayList&lt;? extends TextView&gt; mList = new ArrayList&lt;Button&gt;();</span><br><span class="line">//mList.add(textView); 此调用是错误的</span><br></pre></td></tr></table></figure><p>看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void showTexts(List&lt;TextView&gt; list)&#123;</span><br><span class="line">    for(TextView tv: list)&#123;</span><br><span class="line">        sout(tv.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Button&gt; buttons = ...;</span><br><span class="line">....</span><br><span class="line">showTexts(buttons);// 如此调用，编译期会报错</span><br></pre></td></tr></table></figure><p>做如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void showTexts(List&lt;? extends TextView&gt; list)&#123;</span><br><span class="line">    for(TextView tv: list)&#123;</span><br><span class="line">        sout(tv.getText());// getText() 的参数中不包含类型参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Button&gt; buttons = ...;</span><br><span class="line">....</span><br><span class="line">showTexts(buttons);// showTexts 方法做以上更改，无错</span><br></pre></td></tr></table></figure><p>当遇到只想使用不想修改的情况时，可以使用 ？ extends ，使不具有协变的 Java 支持协变。</p><p>同时，还存在 ？ super 可以使原本不具有 逆变 的 Java 具有 逆变的性质。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void addTextView(List&lt;TextView&gt; list)&#123;</span><br><span class="line">    TextView textView = ..&apos;;</span><br><span class="line">    list.add(textview);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;View&gt; views = new ArrayList&lt;View&gt;();</span><br><span class="line">addTextView(views);// 如此调用，编译期错误</span><br></pre></td></tr></table></figure><p>做如下更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void addTextView(List&lt;? super TextView&gt; list)&#123;</span><br><span class="line">    TextView textView = ..&apos;;</span><br><span class="line">    list.add(textview);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;View&gt; views = new ArrayList&lt;View&gt;();</span><br><span class="line">addTextView(views);// 如此更改，无错</span><br></pre></td></tr></table></figure><p>限制：只能修改，不能使用</p><p>？extents 、？super 的使用场景：</p><p>PECS 法则：Producer extends，Conssumer super。</p><h3 id="2-Kotlin-中的泛型"><a href="#2-Kotlin-中的泛型" class="headerlink" title="2. Kotlin 中的泛型"></a>2. Kotlin 中的泛型</h3><p>? extends –&gt; out:只能输出，不能输入，只能读不能写。</p><p>? super –&gt; in：只能输入不能输出，只能写不能读。</p><p>Kotlin 中的 in 和 out 不仅可以直接使用在变量和参数的声明里，还可以使用在泛型类型声明的类型参数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt;&#123;</span><br><span class="line">    fun producer():T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Consumer&lt;in T&gt;&#123;</span><br><span class="line">    fun consumer(t:T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示这个类型只能用来输入或输出。</p><h3 id="Kotlin-中的星号"><a href="#Kotlin-中的星号" class="headerlink" title="Kotlin 中的星号(*)"></a>Kotlin 中的星号(*)</h3><p>Kotlin 中 * 相当于 Java 中的 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Java</span><br><span class="line">List&lt;?&gt; list;</span><br><span class="line">等效于 </span><br><span class="line">List&lt;? extends Object&gt; list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Kotlin</span><br><span class="line"></span><br><span class="line">var list:List&lt;*&gt;</span><br><span class="line">等效于</span><br><span class="line">var list:List&lt;out Any&gt;</span><br></pre></td></tr></table></figure><p>如果类型声明已经有了 in 或者 out，那么这个限制在变量声明是也依然存在，不会被 * 去掉，如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Conter&lt;out T : Number&gt;&#123;</span><br><span class="line">    fun count(): T</span><br><span class="line">&#125;</span><br><span class="line">// 虽然变量在声明时类型参数为 *，但是其效果依旧是 out Numbuer</span><br><span class="line">var counter:Counter&lt;*&gt; =</span><br></pre></td></tr></table></figure><h3 id="4-Java-声明中的上界和下界"><a href="#4-Java-声明中的上界和下界" class="headerlink" title="4. Java 声明中的上界和下界"></a>4. Java 声明中的上界和下界</h3><p>Java 在类型声明时可以指定类型声明的上界,和 ？ extends 不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Bird&lt;T extends Animal &amp; Food&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bird&lt;T:Animal&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird&lt;T&gt; where T:Animal, T:Food&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Kotin-与-Java-的不同"><a href="#5-Kotin-与-Java-的不同" class="headerlink" title="5. Kotin 与 Java 的不同"></a>5. Kotin 与 Java 的不同</h3><p>Kotlin中有一个 Java 中没有的关键字： refield</p><p>Java 中的类型参数(比如说 T)，它不是一个真正的类型， 而仅仅是一个代号， 不能把它作为一个普通的类型来用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; void test(Object item)&#123;</span><br><span class="line">    if(item instanceof T)&#123;// 这样是不可以的</span><br><span class="line">        sout(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在 Kotlin 中这样也是不可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; test(item: Any)&#123;</span><br><span class="line">    if(item is T)&#123;// 这样不可以</span><br><span class="line">        sout(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 Kotlin 中只有添加一个 refield 关键字就可以解除以上限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;refield T&gt; test(item: Any)&#123;</span><br><span class="line">    if(item is T)&#123;// 这样不可以</span><br><span class="line">        sout(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 refield 自身有限制，只能用在 inline 函数上</p><hr><p><a href="https://www.bilibili.com/video/av66340216" target="_blank" rel="noopener">Kotlin 泛型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Java-中的泛型&quot;&gt;&lt;a href=&quot;#1-Java-中的泛型&quot; class=&quot;headerlink&quot; title=&quot;1. Java 中的泛型&quot;&gt;&lt;/a&gt;1. Java 中的泛型&lt;/h3&gt;&lt;p&gt;协变(covariance)：子类的泛型类型也属于泛型类型的子类。&lt;/p&gt;
&lt;p&gt;由于 Java 中类型擦除的存在，所以 Java 不支持协变，Kotlin 继承了这种限制。在 Java 中可以通过使用通配符(?) 来解除这种限制。&lt;/p&gt;
&lt;p&gt;这样的话有：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 使用了通配符，就可以把子类的泛型类型对象赋值给父类的泛型类型声明了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;? extends TextView&amp;gt; textViews = new ArrayList&amp;lt;Button&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;虽然这种写法解除了赋值的限制，但是却增加了另外一个限制：在使用这个引用的时候，不能调用它的参数包含类型参数的方法，也不能给它的包含类型参数的字段赋值(除了空值)。&lt;/p&gt;
&lt;p&gt;限制：父类的泛型类型声明的实际值不能是子类的泛型类型对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 泛型" scheme="/tags/Kotlin-%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(二):挂起函数</title>
    <link href="/2019/10/07/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%BA%8C):%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/"/>
    <id>/2019/10/07/Kotlin协程学习(二):挂起函数/</id>
    <published>2019-10-07T07:46:13.000Z</published>
    <updated>2019-10-09T10:55:21.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对 <a href="https://www.bilibili.com/video/av68241619" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a> 的文字记录，确实香啊！</p></blockquote><h3 id="1-Kotlin-协程挂起的基本了解"><a href="#1-Kotlin-协程挂起的基本了解" class="headerlink" title="1. Kotlin 协程挂起的基本了解"></a>1. Kotlin 协程挂起的基本了解</h3><blockquote><p>Q:Kotlin 协程中挂起的是什么？ </p></blockquote><p>A:挂起的是协程。</p><blockquote><p>Q:那什么是协程？</p></blockquote><p>A:kotlin 协程为 launch()、async() 等中的代码。</p><p>launch 在创建的一个协程，在执行到某一个 suspend 函数(挂起函数)时，这个协程会被 suspend(被挂起)。</p><blockquote><p>Q:从哪挂起？</p></blockquote><p>A:从当前线程挂起，就是这个协程从正在执行它的线程上脱离了，注意不是协程停下来了，而是协程所在的线程从这行代码开始不再运行这个协程了(意思就是挂起函数将由自己指定的线程运行，挂起可以理解为将协程挂到指定的线程中去执行)，那么分离了的线程和协程会各自发生什么？</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    ...</span><br><span class="line">    //suspendingGetImage 为挂起函数</span><br><span class="line">    val image = suspendingGetImage(imageId)</span><br><span class="line">    imageIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离了的线程和协程将如何执行？线程和协程分离了，具体到代码是什么意思？</p><h3 id="2-分离后的线程"><a href="#2-分离后的线程" class="headerlink" title="2.分离后的线程"></a>2.分离后的线程</h3><p>协程的代码块，在线程中到了 suspend 函数的时候，突然执行完毕了，返回了，完毕之后线程该干嘛呢？当然该干嘛干嘛去。</p><ul><li>线程为后台线程<br>如果线程是后台线程，那么接下来该线程就没有事或者去执行其他的后台任务，和 Java 中的线程池中线程做完工作是一样的，要么回收掉，要么再利用；</li></ul><ul><li>线程为主线程<br>如果是 Android 中的主线程，那么它会继续执行接下来的工作。<br>以上代码相当于：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handler.post&#123;</span><br><span class="line">    ...</span><br><span class="line">    val image = suspendingGetImage(imageId)</span><br><span class="line">    imageIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时挂起就相当于 post 的这个任务提前结束了。</p><h3 id="3-分离后的协程"><a href="#3-分离后的协程" class="headerlink" title="3. 分离后的协程"></a>3. 分离后的协程</h3><p>函数的代码在执行到挂起函数的时候被掐断了，所以接下来，它会在指定线程中从这个挂起函数开始向下执行，那么这个线程是谁指定的？当然是挂起函数指定的。在上面的例子钟就是 suspendingGetImage 这个函数中通过 withContext 指定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun suspendingGetImage(imageId:String)&#123;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getImage(imageId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在此例中，所指定的线程为函数内部的 withContext() 所指定的 IO 线程。</p><p>在挂起函数执行完毕后，它 <strong>会自动把线程再切回来</strong>。</p><p>在上面的例子中，在挂起函数执行完毕后，协程会再 post 一个任务，<strong>让剩下的代码继续回到主线程中去执行</strong>。</p><p>这也就是为什么协程中指定线程的参数不是 Thread ，而是 Dispatchers(调度器)，调度器不止能指定协程执行的线程，还能在 suspend 挂起函数执行完毕后再自动切回来，当然也可以指定特殊的 Dispatchers ，在指定挂起函数后不切换回来。</p><p>挂起的含义就是：<strong>暂时切走，稍后在切回来</strong>。<strong>就是切换线程，不过在执行完毕会切换回来</strong>，这个切回来的动作在协程中称为 <em>resume (恢复)*</em>。</p><h3 id="4-为什么挂起函数只能在协程里或者另一个挂起函数中调用？"><a href="#4-为什么挂起函数只能在协程里或者另一个挂起函数中调用？" class="headerlink" title="4. 为什么挂起函数只能在协程里或者另一个挂起函数中调用？"></a>4. 为什么挂起函数只能在协程里或者另一个挂起函数中调用？</h3><p>首先，挂起之后是需要恢复的，也就是把线程给切回来，而恢复这个动作是协程的，所以一个挂起函数不在协程/另一个挂起函数中被调用，那么这个恢复的动作是不能实现的。</p><h3 id="5-挂起是怎么做到的"><a href="#5-挂起是怎么做到的" class="headerlink" title="5. 挂起是怎么做到的"></a>5. 挂起是怎么做到的</h3><p>在 挂起函数中使用 withContext 指定切换的线程。</p><p>其实 suspend 关键字并不能起到挂起函数的作用，并不是因为使用 suspend 修饰，函数就可以实现挂起动作，而真正想要挂起协程，还需要在挂起函数里面去调用另外一个挂起函数，而里面的这个挂起函数需要是协程自带的、内部实现了协程挂起代码的，或者它的内部直接或间接的调用了某一个自带的挂起函数，最终需要调用一个协程自带的挂起函数，让它来做真正的挂起，实现线程切换的工作。</p><h3 id="6-suspend-真正的作用：提醒"><a href="#6-suspend-真正的作用：提醒" class="headerlink" title="6. suspend 真正的作用：提醒"></a>6. suspend 真正的作用：提醒</h3><p>既然 suspend 不能真正的做到挂起函数，那么 suspend 的作用是什么呢?</p><p>在语法上 suspend 的作用：它其实是一个 <strong>提醒</strong>，函数的创建者对函数的调用者的提醒：我是一个耗时函数，因此我被我的创建者用挂起函数的方式放到了后台运行，所以请在协程中调用我。</p><p>提醒调用者该函数为耗时操作，那么这个提醒有什么作用呢？</p><p>这个提醒有效避免主线程的卡顿，因为一旦不小心在主线程调用了一个耗时操作，那么主线程会产生卡顿。而协程通过挂起函数这种形式，把耗时任务切换线程的工作交给了函数的创建者而不是调用者，对于调用者会十分的简单，他看到 suspend 这个关键字就明白了应该在协程中调用，从而避免了调用者不熟悉调用的函数的情况下在主线程调用耗时操作的行为。</p><p>所以创建一个挂起函数，一定要在内部调用别的挂起函数，否则这个挂起函数就是没有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 这个挂起函数是没有意义的</span><br><span class="line">suspend fun test(str:String)&#123;</span><br><span class="line">    sout(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-自定义挂起函数"><a href="#7-自定义挂起函数" class="headerlink" title="7. 自定义挂起函数"></a>7. 自定义挂起函数</h3><ul><li><p>什么时候需要自定义挂起函数</p><ul><li>原则：耗时(特殊：等待)</li></ul></li></ul><p>如果某个函数比较耗时，两类：</p><ul><li>I/O 操作</li><li>计算工作</li></ul><p>比如文件读写、网络交互、图片操作等，还有在等待情况下，比如等待 5s 后继续操作，这些都可以写在挂起函数中。</p><ul><li>怎么写</li></ul><p>函数添加关键字 suspend，内部代码使用 withContext获取他挂起函数包裹。</p><hr><p><strong>知识链接</strong></p><p><a href="https://www.bilibili.com/video/av68241619" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;https://www.bilibili.com/video/av68241619&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了&lt;/a&gt; 的文字记录，确实香啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Kotlin-协程挂起的基本了解&quot;&gt;&lt;a href=&quot;#1-Kotlin-协程挂起的基本了解&quot; class=&quot;headerlink&quot; title=&quot;1. Kotlin 协程挂起的基本了解&quot;&gt;&lt;/a&gt;1. Kotlin 协程挂起的基本了解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Q:Kotlin 协程中挂起的是什么？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:挂起的是协程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:那什么是协程？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:kotlin 协程为 launch()、async() 等中的代码。&lt;/p&gt;
&lt;p&gt;launch 在创建的一个协程，在执行到某一个 suspend 函数(挂起函数)时，这个协程会被 suspend(被挂起)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:从哪挂起？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:从当前线程挂起，就是这个协程从正在执行它的线程上脱离了，注意不是协程停下来了，而是协程所在的线程从这行代码开始不再运行这个协程了(意思就是挂起函数将由自己指定的线程运行，挂起可以理解为将协程挂到指定的线程中去执行)，那么分离了的线程和协程会各自发生什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(一):协程的基本了解</title>
    <link href="/2019/10/07/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
    <id>/2019/10/07/Kotlin协程学习(一):协程的基本了解/</id>
    <published>2019-10-07T07:45:22.000Z</published>
    <updated>2019-10-09T07:56:42.052Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协程是什么"><a href="#1-协程是什么" class="headerlink" title="1. 协程是什么"></a>1. 协程是什么</h3><ul><li>其实是一套由 Kotlin 官方提供的 <strong>线程 API</strong></li></ul><p>可以理解为一个线程框架，它的好处是方便，最大的好处是 <strong>可以在同一个代码块中进行多次线程切换</strong>。</p><h3 id="2-协程的好处"><a href="#2-协程的好处" class="headerlink" title="2. 协程的好处"></a>2. 协程的好处</h3><p>更方便。</p><a id="more"></a><p>使用 Kotlin 协程可以用看起来同步的方式写出异步代码，这就是 Kotlin 著名的 <strong>非阻塞式挂起</strong>。</p><h3 id="3-使用-Kotlin-协程"><a href="#3-使用-Kotlin-协程" class="headerlink" title="3. 使用 Kotlin 协程"></a>3. 使用 Kotlin 协程</h3><ul><li>基本功能：并发(多线程)</li></ul><p>例如可以把任务切换到后台或前台执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    doSomething(data)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    updateUI(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最大好处</li></ul><p>Kotlin 最大的好处在于可以把：运行在不同线程的代码，写在同一个代码块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;// 开始：主线程</span><br><span class="line">    val user = api.getUser()// 网络请求：后台线程</span><br><span class="line">    name.text = user.name// 更新 UI：主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程和主线程使用 Kotlin 协程，可以消除了 Java 中的回调，避免回调地狱。</p><p>存在这么一个需要：需要合并两个独处接口的结果，然后操作。此时 Java 中传统的回调并不能很好的完成任务，此时很大可以会采用两次串行请求，然后合并进行操作，这样的两个独立的接口原本可以并行请求，现在只能串行请求，很明显网络的等待时间长了一倍，性能也差了一倍。而使用 Kotlin 协程则可以很好的解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    val avatar = async &#123;api.getAvatar(user)&#125;</span><br><span class="line">    val logo = async &#123; api.getLogo(user)&#125;</span><br><span class="line">    val merge = suspendingMerge(avatar,logo)</span><br><span class="line">    show(merge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程消除了并发任务之间的协作难度，轻松写出复杂的并发代码。</p><p>这些才是协程的优势。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul><li>简单</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    doSomething(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launch 的具体含义是：创建一个新的协程，并在指定线程上运行它。</p><p>被创建、被运行的协程是什么？就是传给 launch 的代码，如 <code>doSomething(data)</code>，这一段连续代码称为协程。</p><p>当需要切换线程或者指定线程的时候，可以使用 协程。</p><h3 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lauch(Dispatchers.IO)&#123;</span><br><span class="line">    val image = api.getImage()</span><br><span class="line">    launch(Dispatchers.Main)&#123;</span><br><span class="line">        image.setImageBitmap(image) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是仅仅使用 launch 并不能避免回调地狱，在协程中有一个函数： withContext()，这个函数可以指定线程来执行代码，并且在执行之后,<strong>自动把线程切回来</strong>，继续执行代码，使用 withContext 后，以上代码可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    // 在 Dispatchers.IO 线程中执行相关代码，执行完毕后切换后 Dispatchers.Main 线程</span><br><span class="line">    val image = withContext(Dispatchers.IO)&#123;</span><br><span class="line">        api.getImage()</span><br><span class="line">    &#125;</span><br><span class="line">    image.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程消除了并发代码在协作时的嵌套，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    ...</span><br><span class="line">    launch(Dispatchers.Main)&#123;</span><br><span class="line">        ...</span><br><span class="line">        launch(Dispatchers.IO)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 withContext 可以吧以上的嵌套关系直接写成上下关系的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suspend-函数"><a href="#suspend-函数" class="headerlink" title="suspend 函数"></a>suspend 函数</h3><p>有 suspend 修饰符的函数，称为 suspend 函数，挂起函数。</p><p>代码执行到 suspend 函数的时候会被 suspend(挂起)，并且这个 “挂起” 是 非阻塞式的，它不会阻挡你的线程。</p><hr><p><strong>知识来源：</strong></p><p><a href="https://www.bilibili.com/video/av67107689" target="_blank" rel="noopener">【码上开学】学不会协程？很可能因为你看过的教程都是错的——Kotlin 的协程「用力瞥一眼」</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-协程是什么&quot;&gt;&lt;a href=&quot;#1-协程是什么&quot; class=&quot;headerlink&quot; title=&quot;1. 协程是什么&quot;&gt;&lt;/a&gt;1. 协程是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;其实是一套由 Kotlin 官方提供的 &lt;strong&gt;线程 API&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以理解为一个线程框架，它的好处是方便，最大的好处是 &lt;strong&gt;可以在同一个代码块中进行多次线程切换&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-协程的好处&quot;&gt;&lt;a href=&quot;#2-协程的好处&quot; class=&quot;headerlink&quot; title=&quot;2. 协程的好处&quot;&gt;&lt;/a&gt;2. 协程的好处&lt;/h3&gt;&lt;p&gt;更方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal(Jdk1.8) 使用及源码分析</title>
    <link href="/2019/09/19/ThreadLocal(Jdk1.8)%20%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2019/09/19/ThreadLocal(Jdk1.8) 使用及源码分析/</id>
    <published>2019-09-19T06:30:16.000Z</published>
    <updated>2019-11-22T06:19:43.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-ThreadLocal-简介"><a href="#0x0001-ThreadLocal-简介" class="headerlink" title="0x0001 ThreadLocal 简介"></a>0x0001 ThreadLocal 简介</h3><p>使用 ThreadLocal 对象存储 <strong>线程相关</strong> 的变量，只能有存储动作执行所在线程内才能够获取相应变量。</p><h3 id="0x0002-ThreadLocal-中相关类简介"><a href="#0x0002-ThreadLocal-中相关类简介" class="headerlink" title="0x0002 ThreadLocal 中相关类简介"></a>0x0002 ThreadLocal 中相关类简介</h3><h4 id="1-ThreadLocal-ThreadLocalMap"><a href="#1-ThreadLocal-ThreadLocalMap" class="headerlink" title="1.ThreadLocal#ThreadLocalMap"></a>1.ThreadLocal#ThreadLocalMap</h4><p>ThreadLocalMap 是 ThreadLocal 中一个自定义的哈希映射，仅适用于维护线程本地值。不会在 ThreadLocal 类之外导出任何操作。该类是包私有的，允许在 Thread 类中声明字段。为了帮助处理非常大且长期使用的用法，哈希表条目使用WeakReferences 作为键。但是，由于未使用引用队列，因此只有在表开始空间不足时才能保证删除过时条目。</p><a id="more"></a><p>虽然从 ThreadLocalMap 类名来看它是一个 Map 类型的数据，但是它并不是一个 Map，它内部维护的是一个初始长度为 16 的数组，而该数组的元素 Entry 更像是一个维护 key-value 的实体类，可以理解为一个 Map。</p><h4 id="2-ThreadLocalMap-中的-Entry"><a href="#2-ThreadLocalMap-中的-Entry" class="headerlink" title="2. ThreadLocalMap 中的 Entry"></a>2. ThreadLocalMap 中的 Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中以下是对 Entry 的介绍：</p><blockquote><p>The entries in this hash map extend WeakReference, using<br>its main ref field as the key (which is always a<br>ThreadLocal object).  Note that null keys (i.e. entry.get()<br>== null) mean that the key is no longer referenced, so the<br>entry can be expunged from table.  Such entries are referred to<br>as “stale entries” in the code that follows.</p></blockquote><blockquote><p>Entry 继承了 WeakReference，使用 Entry 对象的引用作为 ThreadLocalMap 存储元素的 key。当通过 entry.get() 获得为 null 时，说明不再引用该 key，因此可以从表中删除该条目。</p></blockquote><h3 id="0x0003-ThreadLocal-实现的关键"><a href="#0x0003-ThreadLocal-实现的关键" class="headerlink" title="0x0003 ThreadLocal 实现的关键"></a>0x0003 ThreadLocal 实现的关键</h3><p>这也是 ThreadLocal 可以存储线程相关的变量的关键，这是 <strong>因为 ThreadLocalMap 的对象是在 Thread 中维护的</strong>。</p><p>在通过 set 存储变量时：</p><ol><li>首先会获得所在线程对象</li><li>接着可以获取线程的属性 ThreadLocalMap 对象</li><li>从而实现以 ThreadLocal 为 key 的变量存储在 ThreadLocalMap 对象中，这一步就实现了存储线程相关的变量。</li></ol><p>在通过 get 获取变量时：</p><ol><li>首先获得所在线程对象，</li><li>接着那么就自然可以获得其属性值 – ThreadLocalMap 对象，</li><li>以当前 ThreadLocal 对象为 key 自然可以获得其中存储的变量。</li></ol><p>当然这只是大致步骤，其中还是有许多细节的。</p><h3 id="0x0004-ThreadLocal-set-方法"><a href="#0x0004-ThreadLocal-set-方法" class="headerlink" title="0x0004 ThreadLocal#set 方法"></a>0x0004 ThreadLocal#set 方法</h3><p>ThreadLocal#set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    // 步骤一：获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 步骤二：获取当前线程的属性值 -- ThreadLocalMap 对象</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    // 步骤三：存储变量值，其中 key 为当前 ThreadLocal 对象</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为步骤二的具体代码，可以看到线程维护了 ThreadLocalMap 对象，为 ThreadLocal 能够存储线程相关的变量提供可能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap#set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">    // We don&apos;t use a fast path as with get() because it is at</span><br><span class="line">    // least as common to use set() to create new entries as</span><br><span class="line">    // it is to replace existing ones, in which case, a fast</span><br><span class="line">    // path would fail more often than not.</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 更新 key 对应的 value</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            // 经过一系列算法操作，添加 value</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 ThreadLocal 对象 key 经过一系列的算法，获得该对象的对应的 value 在数组中的索引值，然后对数组中该索引值下元素进行操作。</p><p>数组的操作：</p><ul><li>更新：如果指定索引的位置存在元素，那么就对该位置元素进行更新。</li><li>添加：如果指定索引的位置不存在元素，那么就将 value 添加到该位置。 </li></ul><p><strong>总结一下：</strong></p><p>现在我们可以看到的关系是：一个 Thread 对应一个 ThreadLocalMap， 在 ThreadLocalMap 内部维护 Entry 数组，这个数组的索引由 ThreadLocal 对象经过一系列计算得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i = key.threadLocalHashCode &amp; (len-1);</span><br></pre></td></tr></table></figure><p>在通过 ThreadLocal 对象 set 值时，其实是通过一系列的算法，用来初始化、添加或者更新数组中指定索引的元素。</p><h3 id="0x0005-ThreadLocal-get-方法"><a href="#0x0005-ThreadLocal-get-方法" class="headerlink" title="0x0005 ThreadLocal#get 方法"></a>0x0005 ThreadLocal#get 方法</h3><p>ThreadLocal#get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前线程相关的 threadlocal 中变量，如果变量为 null，则返回 setInitialValue() 线程相关的初始值(null)。</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;  </span><br><span class="line">        // 很明显，通过 key 获取 Map 中的 value</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            // 返回相应的 value</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 线程相关的变量，返回初始化值</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果获取到的 ThreadLocalMap 对象 map 为 null ，会进行如下操作：</li></ul><p>ThreadLocal#setInitialValue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果获取到的 ThreadLocalMap 对象 map 为 null ，会进行如下步骤，获取对应的 ThreadLocalMap.Entry 对象：</li></ul><p>ThreadLocalMap#getEntry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    // </span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        // 通过散列的 hash 索引获取不到值的话，那么就需要变量 ThreadLocalMap 中的数组进行遍历。</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap#getEntryAfterMiss</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 通过遍历 table 中元素，寻找对对应的 Entry 对象</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i,  Entrye) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Entry 对象就可以获得具体的变量值。</p><h3 id="0x0006-多线程与同一个-ThreadLocal-对象"><a href="#0x0006-多线程与同一个-ThreadLocal-对象" class="headerlink" title="0x0006 多线程与同一个 ThreadLocal 对象"></a>0x0006 多线程与同一个 ThreadLocal 对象</h3><p>对 ThreadLocal 的原理有一定的理解，那么以下两个场景理解就十分容易了。</p><ul><li>情景一：同一个 ThreadLocal 对象，维护不同线程的变量</li></ul><p>明白了 ThreadLocal 原理，这个问题就不难理解了，因为每一个线程都维护者自己的 ThreadLocalMap 对象，不同所存储的变量在各自 ThreadLocalMap 对象中，所以即使同一个 ThreadLocal 对象，在不同线程中会多次存储，所以可以实现在各自线程获取属于各自存储的变量。</p><p>在存储元素时，ThreadLocalMap 内部维护一个数组，以 ThreadLocal 对象的哈希值(一系列操作的 hash)经过一系列算法后得出的 index 索引，将 value 存储在数组中的索引处，所以在同一个线程中对同一个 ThreadLocal 对象进行多次 set 的调用，那么会对值进行覆盖。</p><ul><li>情景二：同一线程下，使用多个 ThreadLocal 对象进行变量存储</li></ul><p>同样根据对象计算的索引值是唯一的，所以多个 ThreadLocal 对象获取的变量一定是自己存储的。</p><h3 id="0x0007-使用场景"><a href="#0x0007-使用场景" class="headerlink" title="0x0007 使用场景"></a>0x0007 使用场景</h3><h4 id="1-线程内单例"><a href="#1-线程内单例" class="headerlink" title="1. 线程内单例"></a>1. 线程内单例</h4><p>我们平时使用到的单例为进程为单例，而通过 ThreadLocal 可实现线程内同步，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private static ThreadLocal&lt;User&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static User getInstance() &#123;</span><br><span class="line">        User instance = threadLocal.get();</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new User();</span><br><span class="line">            threadLocal.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量的作用域为线程"><a href="#2-变量的作用域为线程" class="headerlink" title="2. 变量的作用域为线程"></a>2. 变量的作用域为线程</h4><p>当一些数据是以线程为作用域，并且不同线程拥有数据的不同副本的时候，就可以考虑使用 ThreadLocal。</p><p>在子线程中初始化 Handler 需要手动的创建 Looper，因为 Looper 是线程相关的，那么 Looper 是怎样实现线程相关的呢？本质就是使用了 ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler;</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();//Looper初始化</span><br><span class="line">        //Handler初始化 需要注意, Handler初始化传入Looper对象是子线程中缓存的Looper对象</span><br><span class="line">        mHandler = new Handler(Looper.myLooper());</span><br><span class="line">        Looper.loop();//死循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>具体看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果不执行 <code>Looper.prepare()</code> ，则 <code>Looper.myLooper()</code> 就无法获取到线程相关的 Looper 实例对象。</p><p>当然 Android 给了更为简单的实现方式： HandlerThread，但是本质还是 ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = new HandlerThread(&quot;HandlerThread&quot;);</span><br><span class="line">handlerThread.start();</span><br><span class="line">Handler mHandler = new Handler(handlerThread.getLooper())&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">        Log.d(&quot;Log&quot;,&quot;current thread is &quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mHandler.sendEmptyMessage(1);</span><br></pre></td></tr></table></figure><h4 id="3-复杂逻辑下的对象传递"><a href="#3-复杂逻辑下的对象传递" class="headerlink" title="3. 复杂逻辑下的对象传递"></a>3. 复杂逻辑下的对象传递</h4><p>有时候一个线程的逻辑过于复杂，导致函数的调用栈比较深，而这时候我们需要监视器能够贯穿整个线程的执行过程，这是就可以使用 ThreadLocal 。使用 ThreadLocal 存储监视器，这样就可以在线程中获得监视器对象。</p><p>其他能够想到的两种方式：</p><ol><li><p>将监视器对象通过参数的方式传递</p><p>这种方式当调用栈过深时，会让整个逻辑更加复杂、难懂。</p></li><li><p>将监视器作为静态变量供线程访问 </p><p> 这种方式是可以接受的，但是这种方式是不具有扩充性，如果有两个线程在执行，那么就需要提供两个静态的监听对象。如果是更多的线程呢？这无疑是代码中的”坏味道“。</p></li></ol><p>而使用 ThreadLocal 则完全不会遇到上面问题。</p><hr><p><strong>知识链接</strong></p><p><a href="https://item.jd.com/11760209.html" target="_blank" rel="noopener">Android 开发艺术探索</a></p><p><a href="https://www.jianshu.com/p/4167d7ff5ec1" target="_blank" rel="noopener">带你了解源码中的 ThreadLocal</a></p><p><a href="https://www.bilibili.com/video/av7592261?from=search&seid=7861472405873308618" target="_blank" rel="noopener">ThreadLocal类及应用技巧</a> : 视频建议 2 倍速看完，没什么营养，但可以向你展示如何使用 ThreadLocal </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-ThreadLocal-简介&quot;&gt;&lt;a href=&quot;#0x0001-ThreadLocal-简介&quot; class=&quot;headerlink&quot; title=&quot;0x0001 ThreadLocal 简介&quot;&gt;&lt;/a&gt;0x0001 ThreadLocal 简介&lt;/h3&gt;&lt;p&gt;使用 ThreadLocal 对象存储 &lt;strong&gt;线程相关&lt;/strong&gt; 的变量，只能有存储动作执行所在线程内才能够获取相应变量。&lt;/p&gt;
&lt;h3 id=&quot;0x0002-ThreadLocal-中相关类简介&quot;&gt;&lt;a href=&quot;#0x0002-ThreadLocal-中相关类简介&quot; class=&quot;headerlink&quot; title=&quot;0x0002 ThreadLocal 中相关类简介&quot;&gt;&lt;/a&gt;0x0002 ThreadLocal 中相关类简介&lt;/h3&gt;&lt;h4 id=&quot;1-ThreadLocal-ThreadLocalMap&quot;&gt;&lt;a href=&quot;#1-ThreadLocal-ThreadLocalMap&quot; class=&quot;headerlink&quot; title=&quot;1.ThreadLocal#ThreadLocalMap&quot;&gt;&lt;/a&gt;1.ThreadLocal#ThreadLocalMap&lt;/h4&gt;&lt;p&gt;ThreadLocalMap 是 ThreadLocal 中一个自定义的哈希映射，仅适用于维护线程本地值。不会在 ThreadLocal 类之外导出任何操作。该类是包私有的，允许在 Thread 类中声明字段。为了帮助处理非常大且长期使用的用法，哈希表条目使用WeakReferences 作为键。但是，由于未使用引用队列，因此只有在表开始空间不足时才能保证删除过时条目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Java 强引用、软引用、弱引用、虚引用及回收机制简单解析</title>
    <link href="/2019/09/18/Java-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90/"/>
    <id>/2019/09/18/Java-引用类型及回收机制简单解析/</id>
    <published>2019-09-18T09:23:11.000Z</published>
    <updated>2019-12-04T10:20:57.377Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-什么是引用"><a href="#0x0001-什么是引用" class="headerlink" title="0x0001 什么是引用"></a>0x0001 什么是引用</h3><p>在 JDK1.2 以前对引用的定义为：<br>    如果 reference 类型的数据中存储的数值代表另外一块内存的起始地址，那么就称这块内存代表一个引用。</p><p>此定义将一个对象分为被引用或者没有被引用的两种状态，但是如果内存不足时,被引用的对象由于不能被释放，自然就会导致 OOM。</p><p>所以我们需要定义一类这样的对象：当内存空间足够时，我们希望对象继续保存在内存中，如果内存不够时，我们可以回收这些对象。</p><p>所以在 JDK1.2 之后就对 Java 引用的概念进行了扩充，将引用细分为</p><ul><li>强引用(Strong Reference)</li><li>软引用(Soft Reference)</li><li>弱引用(Weak Reference)</li><li>虚引用(Phantom Reference)</li></ul><h3 id="0x0002-不同引用类型的回收机制"><a href="#0x0002-不同引用类型的回收机制" class="headerlink" title="0x0002 不同引用类型的回收机制"></a>0x0002 不同引用类型的回收机制</h3><p><strong>强引用</strong></p><p><strong>永远不会被回收</strong>，即使系统 OOM 也不会被回收，就是这么刚。</p><p>对于一个普通的而对象，如果没有其他引用关系，只要超过了引用的作用域或者显式的将相应的引用赋值为 null，就可以被 GC 回收了。</p><p><strong>软引用(SoftReference)</strong></p><p>用来描述一些还有用并非必需的对象，对于软引用的关联的对象，在系统将要发生 <strong>OOM 之前</strong>，将会把这些对象列入回收范围内，进行第二次回收，如果此时内存还是不够，才会报出 OOM。</p><p>软引用通常用来实现内存敏感的内存，<strong>如果还有空闲内存，就可以暂时保留缓存。当内存不足时才会清理掉</strong>，这样就保证了使用缓存的同时，不会耗尽内存。</p><p><strong>弱引用(WeakReference)</strong></p><p>弱引用也用了描述非必需的对象，但是它的强度比弱引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时(执行 GC)，无论当前的内存是否够用，都会回收掉只被弱引用关联的对象</strong>。</p><p>弱引用仅仅是提供一种访问在弱引用状态下对象的途径，这样就可以构建一种没有特定约束的关系，比如维护一种非强制的映射关系，如果试图获取时该对象还在，就是用它，否则就重新实例化。</p><p>和软引用一样，弱引用也是很多缓存实现的选择。</p><p><strong>虚引用(PhantomReference)</strong></p><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象实例。</p><p>为一个对象设置虚引用关联的唯一目的就是<strong>能在这个对象被垃圾回收器回收时收到一个系统通知</strong>。</p><h3 id="0x0003-Reference"><a href="#0x0003-Reference" class="headerlink" title="0x0003 Reference"></a>0x0003 Reference</h3><p>所有的引用类型，都是抽象类 java.lang.ref.Reference 的子类，它提供了 get() 方法，除了幻象引用( get() 获得的永远是 null)，如果对象还没有被销毁，都可以通过 get 方法获得原有的对象，这就意味着，可以利用软引用和弱引用将访问的对象重新指向强引用，所以引用类型之间是可以转换的。</p><p>但是如果我们将通过弱引用或软引用获得对象 (get() 方法) 指向错误的强引用(比如说 static 变量)，那么这个对象就不可能再变回之前的弱引用或软引用的状态的了，就导致产生内存泄漏。所以检查弱引用指向的对象有没有被 GC，这是检查特定对象是否引起内存泄漏的思路。</p><h3 id="0x0004-引用队列-ReferenceQueue-的使用"><a href="#0x0004-引用队列-ReferenceQueue-的使用" class="headerlink" title="0x0004 引用队列(ReferenceQueue)的使用"></a>0x0004 引用队列(ReferenceQueue)的使用</h3><p>使用SoftReference，WeakReference，PhantomReference 的时候，可以关联一个ReferenceQueue。那么当垃圾回收器回收(虚引用在准备回收时)一个被引用包装的对象时，该引用会被加入到关联的 <code>ReferenceQueue</code>。程序可以通过判断引用队列中是否已经加入引用,来了解被引用的对象是否被 GC 回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x0001-什么是引用&quot;&gt;&lt;a href=&quot;#0x0001-什么是引用&quot; class=&quot;headerlink&quot; title=&quot;0x0001 什么是引用&quot;&gt;&lt;/a&gt;0x0001 什么是引用&lt;/h3&gt;&lt;p&gt;在 JDK1.2 以前对引用的定义为：&lt;br&gt;    如果 
      
    
    </summary>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
      <category term="《深入理解 Java 虚拟机》读书笔记" scheme="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 线程模式</title>
    <link href="/2019/09/12/EventBus-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>/2019/09/12/EventBus-线程模式/</id>
    <published>2019-09-12T03:37:55.000Z</published>
    <updated>2019-11-05T06:32:43.860Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus 可以处理 Android 中的线程切换的问题：事件发布的线程可以与线程处理的线程不同。以下几种模式为事件处理的线程。EventBus 可以帮助使用者子线程与主线程的同步问题。</p><h3 id="ThreadMode-POSTING-default"><a href="#ThreadMode-POSTING-default" class="headerlink" title="ThreadMode:POSTING (default)"></a>ThreadMode:POSTING (default)</h3><p>订阅者将在同一个线程中发布事件,这是默认情况。订阅者将在事件发布者的线程中响应事件，这是默认情况。事件传送将<code>同步</code>完成，一旦发布完成，所有订阅者就会被调用。这种 ThreadMode 避免了线程间的切换，因此所需的开销最小。因此，当任务简单、所需时间短、不需要占用主线程时，这种 ThreadMode 是推荐使用的。但由于事件分发可能发生在主线程，所以使用此模式的事件处理程序应该快速返回，以避免阻塞发布线程。处理函数中禁止更新UI操作。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Called in the same thread (default)</span><br><span class="line">// ThreadMode is optional here</span><br><span class="line">@Subscribe(threadMode = ThreadMode.POSTING)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">    log(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-MAIN"><a href="#ThreadMode-MAIN" class="headerlink" title="ThreadMode: MAIN"></a>ThreadMode: MAIN</h3><p>订阅者将在主线程中响应事件。如果发布线程为主线程，那么订阅者事件将会直接响应（像 ThreadMode.POSTING 线程模式进行事件同步）。订阅者响应事件必须快速处理完自己方法内的业务以避免阻塞主线程。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">textField.setText(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-MAIN-ORDERED"><a href="#ThreadMode-MAIN-ORDERED" class="headerlink" title="ThreadMode: MAIN_ORDERED"></a>ThreadMode: MAIN_ORDERED</h3><p> 在这种模式下，订阅者会在主线程中执行。该模式下，事件总是排队等待以后发送给订阅者，因此对 post 的调用将立即返回。这使事件处理更加严格且更加一致（因此名称为MAIN_ORDERED）。与 ThreadMode: MAIN 不同的是，此模式下发送的事件会被添加到事件序列中，通过从时间序列中获取事件，从而完成事件的处理，而 ThreadMode: MAIN 模式下，如果执行长时间事件操作，那么此时通过 post 操作发布事件执行事件的操作将会被阻塞，直到前一个事件执行完毕，所以 ThreadMode: MAIN 模式下，事件处理应该避免耗时操作。</p><p>由于在主线程中执行，则应避免耗时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">    textField.setText(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-BACKGROUD"><a href="#ThreadMode-BACKGROUD" class="headerlink" title="ThreadMode: BACKGROUD"></a>ThreadMode: BACKGROUD</h3><p>在这种模式下，订阅者将会在非UI线程中被调用。如果事件发布所在非UI线程，那么订阅者将会在该线程中被直接调用。反之，EventBus使用单个后台线程，它将顺序地处理响应事件。在这种模式下，订阅者快速处理完自己方法内的业务以避免阻塞线程。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in the background thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessage(MessageEvent event)&#123;</span><br><span class="line">    saveToDisk(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThradMode-ASYNC"><a href="#ThradMode-ASYNC" class="headerlink" title="ThradMode: ASYNC"></a>ThradMode: ASYNC</h3><p>事件处理方法会在单独的线程中被调用，这个线程与主线程、事件发布线程相互独立。在这种模式下，事件发布不需要等待事件处理方法。当事件处理方法需要进行耗时操作，比如：网络请求等，这是需要使用这种模式。为了限制并发线程的数量，应避免同时触发大量长时间运行的异步处理操作。EventBus通过线程池通过重用，使用线程池从完成的异步事件处理程序通知中有效地重用线程。<br>EventBus 通过重用线程池中已经完成异步事件的线程来达到线程的高效复用。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in a separate thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.ASYNC)</span><br><span class="line">public void onMessage(MessageEvent event)&#123;</span><br><span class="line">    backend.send(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        case POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        case MAIN:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MAIN_ORDERED:</span><br><span class="line">            if (mainThreadPoster != null) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case BACKGROUND:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码有以下结论：<br>POSTING 模式下只有一种执行方式：在事件发布的线程执行。<br>MAIN、MAIN_ORDERED、MAIN_ORDERED、BACKGROUND：这四种模式都会根据发布事件所在的线程是否为主线程而执行不同的方式。<br>ASYNC：不管发布事件的线程是否为主线程，均在子线程中执行相关动作。</p><hr><p><strong>知识链接</strong></p><p><a href="http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/" target="_blank" rel="noopener">官方地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus 可以处理 Android 中的线程切换的问题：事件发布的线程可以与线程处理的线程不同。以下几种模式为事件处理的线程。EventBus 可以帮助使用者子线程与主线程的同步问题。&lt;/p&gt;
&lt;h3 id=&quot;ThreadMode-POSTING-default&quot;&gt;&lt;a href=&quot;#ThreadMode-POSTING-default&quot; class=&quot;headerlink&quot; title=&quot;ThreadMode:POSTING (default)&quot;&gt;&lt;/a&gt;ThreadMode:POSTING (default)&lt;/h3&gt;&lt;p&gt;订阅者将在同一个线程中发布事件,这是默认情况。订阅者将在事件发布者的线程中响应事件，这是默认情况。事件传送将&lt;code&gt;同步&lt;/code&gt;完成，一旦发布完成，所有订阅者就会被调用。这种 ThreadMode 避免了线程间的切换，因此所需的开销最小。因此，当任务简单、所需时间短、不需要占用主线程时，这种 ThreadMode 是推荐使用的。但由于事件分发可能发生在主线程，所以使用此模式的事件处理程序应该快速返回，以避免阻塞发布线程。处理函数中禁止更新UI操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="EventBus" scheme="/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>线程的 wait、sleep、join、yeild 方法</title>
    <link href="/2019/09/05/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>/2019/09/05/Java 多线程线程的几个方法/</id>
    <published>2019-09-05T07:53:17.000Z</published>
    <updated>2020-02-26T02:54:06.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-wait"><a href="#0x0001-wait" class="headerlink" title="0x0001 wait()"></a>0x0001 wait()</h3><p>首先，需要明确的是 wait() 方法为 Object 类中的方法，所以 Object 对象才可以执行 wait() 方法，但是该方法和线程的各个状态息息相关。</p><p>当一个线程执行到 wait() 方法时，它就进入到一个 <strong>和该对象相关的等待池</strong> 中，同时 <strong>该线程失去(释放)对象所持有的锁</strong>，使得其他线程可以访问。用户可以使用 notify、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>需要注意的是：wait()、notify()、notifyAll() 必须放在 synchronized block 中，否则会抛出异常。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Object mLockObject = new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        waitAndNotifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void waitAndNotifyAll()&#123;</span><br><span class="line">        System.out.println(&quot;主线程执行&quot;);</span><br><span class="line">        Thread thread = new WaitThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        synchronized (mLockObject)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;主线程等待&quot;);</span><br><span class="line">                mLockObject.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long timsMs = System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(&quot;主线程继续 -&gt; 等待耗时：&quot;  + timsMs + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class WaitThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            synchronized (mLockObject)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;子线程执行,3s 后执行 notifyAll&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    mLockObject.notifyAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程执行</span><br><span class="line">主线程等待</span><br><span class="line">子线程执行,3s 后执行 notifyAll</span><br><span class="line">主线程继续 -&gt; 等待耗时：3007 ms</span><br></pre></td></tr></table></figure><p>可以看到在主线程在执行 mLockObject 的 wait() 方法后就进入到等待状态，在子线程中执行 mLockObject 的 notifyAll() 方法来唤醒等待池中睡眠的主线程，使主线程继续执行。</p><h3 id="0x0002-sleep"><a href="#0x0002-sleep" class="headerlink" title="0x0002 sleep"></a>0x0002 sleep</h3><p>该方法时 Thread 的静态方法，作用是 <strong>使调用线程进入睡眠状态</strong>。因为 sleep 方法时 Thread 的静态方法，因此它 <strong>不能改变对象所持有的锁</strong>，所以当在一个 synchronized 块中调用 sleep 方法时，虽然线程休眠了，但是所持有的对象锁并不会被释放，其他线程也无法访问这个对象(睡着也要霸占锁的主)。</p><h3 id="0x003-join"><a href="#0x003-join" class="headerlink" title="0x003 join"></a>0x003 join</h3><p>等待目标线程 <strong>执行完成后</strong>， 再继续执行，即 <strong>获得插队执行的权利</strong>。</p><p>阻塞当前调用 join() 方法时 <strong>所在的线程</strong>，直到目标线程(调用 join 方法的线程)执行完毕，阻塞的线程得以继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static void joinTest() &#123;</span><br><span class="line">    // 目标线程 1</span><br><span class="line">    Worker worker1 = new Worker(&quot;worker-1&quot;);</span><br><span class="line">    // 目标线程 2</span><br><span class="line">    Worker worker2 = new Worker(&quot;worker-2&quot;);</span><br><span class="line">    worker1.start();</span><br><span class="line"></span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;启动线程 1&quot;);</span><br><span class="line">        // 调用 worker1 中的 join 函数，主线程会阻塞直到 worker1 执行完成</span><br><span class="line">        worker1.join();</span><br><span class="line">        System.out.println(&quot;启动线程 2&quot;);</span><br><span class="line">        // 启动线程2 ，调用 worker2 中的 join 函数，主线程会阻塞直到 worker2 执行完成</span><br><span class="line">        worker2.start();</span><br><span class="line">        worker2.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;主线程继续执行&quot;);</span><br><span class="line">    System.out.println(&quot;主线程等待线程 1 和线程 2 的时间为：&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static class Worker extends Thread &#123;</span><br><span class="line">    public Worker(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Work in: &quot; + getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">启动线程 1</span><br><span class="line">Work in: worker-1</span><br><span class="line">启动线程 2</span><br><span class="line">Work in: worker-2</span><br><span class="line">主线程继续执行</span><br><span class="line">主线程等待线程 1 和线程 2 的时间为：4010 ms</span><br></pre></td></tr></table></figure><p>可以看到在开启线程后(执行 start() 方法)，执行指定线程的 join() 方法，主线程会一直阻塞，直到目标线程执行完毕后，主线程才得以执行执行。</p><h3 id="0x0004-yield"><a href="#0x0004-yield" class="headerlink" title="0x0004 yield"></a>0x0004 yield</h3><p>线程礼让。</p><p>使调用该函数的线程让出执行时间给其他已经处于就绪状态的线程。</p><p>目标线程有由 <strong>运行状态</strong> 转换为 <strong>就绪状态</strong>，让出执行权限，让其他线程得以优先执行，但是其他线程是否能够优先执行是位置的， 由 CPU 时间分片决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static void yieldTest()&#123;</span><br><span class="line">    YieldThread yieldThread1 = new YieldThread(&quot;thread-1&quot;);</span><br><span class="line">    YieldThread yieldThread2 = new YieldThread(&quot;thread-2&quot;);</span><br><span class="line">    yieldThread1.start();</span><br><span class="line">    yieldThread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class YieldThread extends Thread &#123;</span><br><span class="line">    </span><br><span class="line">    public YieldThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%s 优先级为：%d ---&gt; %d\n&quot;, this.getName(), this.getPriority(), i);</span><br><span class="line">            // 当 i = 2 时，调用当前线程执行 yield 函数</span><br><span class="line">            if (i == 2) &#123;</span><br><span class="line">                System.out.printf(&quot;%s 进入到就绪状态 ---&gt; %d %s \n&quot;, this.getName(), i,this.getName());</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                System.out.printf(&quot;%s 重新回到运行状态 ---&gt; %d  %s \n&quot;, this.getName(), i, this.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">thread-1 优先级为：5 ---&gt; 0</span><br><span class="line">thread-1 优先级为：5 ---&gt; 1</span><br><span class="line">thread-1 优先级为：5 ---&gt; 2</span><br><span class="line">thread-2 优先级为：5 ---&gt; 0</span><br><span class="line">thread-2 优先级为：5 ---&gt; 1</span><br><span class="line">thread-2 优先级为：5 ---&gt; 2</span><br><span class="line">thread-2 进入到就绪状态 ---&gt; 2 thread-2 </span><br><span class="line">thread-1 进入到就绪状态 ---&gt; 2 thread-1 </span><br><span class="line">thread-2 优先级为：5 ---&gt; 3</span><br><span class="line">thread-2 重新回到运行状态 ---&gt; 3  thread-2 </span><br><span class="line">thread-2 优先级为：5 ---&gt; 4</span><br><span class="line">thread-1 优先级为：5 ---&gt; 3</span><br><span class="line">thread-1 重新回到运行状态 ---&gt; 3  thread-1 </span><br><span class="line">thread-1 优先级为：5 ---&gt; 4</span><br></pre></td></tr></table></figure><p>以上日志打印情况只是众多情况中的一种，此时所说的众多情况是在 i = 2 之前，因为线程获得 CPU 时间分片是随机的，所以这是众线程的执行顺序可以说是零乱的，但是当一个线程中执行 yield(),那么该线程就处于就绪状态，需要等待其他线程执行完毕后才可以继续执行。</p><p>此例中，<br>当 thread-2 执行到 i = 2 时：<br>    thread-2 处于就绪状态，thread-1 进入运行状态<br>当 thread-1 执行到 i = 2 时：<br>    thread-1 处于就绪状态，thread-2 进入运行状态，此时 thread-2 的状态不会再改变，会一直执行，直到结束。<br>当 thread-2 执行完毕时：<br>    thread-1 继续执行，直到结束。</p><p>当一个线程中执行 yield)() 方法，同时存在处于 yield  就绪状态的线程和正常就绪状态的线程，那么正常状态的线程会得到优先执行权利，直到所有的线程均处于 yield 就绪状态，那么 yield 状态的线程会按照进入此状态的顺序恢复正常状态，好绕啊，具体验证可以查看 <a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/methods/Main.java" target="_blank" rel="noopener">GitHub 代码</a> 中 yieldTest 方法以及注释。</p><p>可以看到 join 方法和 yield 方法的作用完全相反：</p><ul><li>调用 join 方法的线程，将成功 <strong>抢夺</strong> 线程执行的权利</li><li>调用 yield 方法的线程，将 <strong>让出</strong> 自己线程执行的权利</li></ul><hr><p><strong>知识链接</strong></p><p><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="noopener">Android 开发进阶:从小工到专家</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-wait&quot;&gt;&lt;a href=&quot;#0x0001-wait&quot; class=&quot;headerlink&quot; title=&quot;0x0001 wait()&quot;&gt;&lt;/a&gt;0x0001 wait()&lt;/h3&gt;&lt;p&gt;首先，需要明确的是 wait() 方法为 Object 类中的方法，所以 Object 对象才可以执行 wait() 方法，但是该方法和线程的各个状态息息相关。&lt;/p&gt;
&lt;p&gt;当一个线程执行到 wait() 方法时，它就进入到一个 &lt;strong&gt;和该对象相关的等待池&lt;/strong&gt; 中，同时 &lt;strong&gt;该线程失去(释放)对象所持有的锁&lt;/strong&gt;，使得其他线程可以访问。用户可以使用 notify、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。&lt;/p&gt;
&lt;p&gt;需要注意的是：wait()、notify()、notifyAll() 必须放在 synchronized block 中，否则会抛出异常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thread" scheme="/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从缓存文件的角度帮你理解 Okhttp3 缓存原理</title>
    <link href="/2019/08/19/%E4%BB%8E%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%92%E5%BA%A6%E5%B8%AE%E4%BD%A0%E7%90%86%E8%A7%A3-Okhttp3-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
    <id>/2019/08/19/从缓存文件的角度帮你理解-Okhttp3-缓存原理/</id>
    <published>2019-08-19T08:07:38.000Z</published>
    <updated>2019-08-19T08:12:43.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以一个不同的角度来解读 Okhttp3 实现缓存功能的思路，即：对于对于的缓存空间(文件夹)中的缓存文件的生成时机、不同时期下个文件的状态、不同时期下日志文件读写。通过这些方法来真正理解 Okhttp3 的缓存功能。如果你理解 DiskLrcCache 开源库的设计，那么对于 Okhttp3 的缓存实现你就已经掌握了，因为前者以后者为基础，你甚至没有看本文的必要。</p></blockquote><h1 id="1-需要了解的概念"><a href="#1-需要了解的概念" class="headerlink" title="1. 需要了解的概念"></a>1. 需要了解的概念</h1><p>缓存功能的实现，理所当然的涉及文件的读写操作、缓存机制方案的设计。Okhttp3 缓存功能的实现涉及到 Okio 和 DiskLruCache，在阐述具体缓存流程之前，我们需要了解两者的一些基本概念。</p><a id="more"></a><h2 id="1-2-Okio"><a href="#1-2-Okio" class="headerlink" title="1.2 Okio"></a>1.2 Okio</h2><p>Okio 中有两个关键的接口: <strong>Sink</strong> 和 <strong>Source</strong> ，对比 Java 中 I/O 流概念，我们可以把 Sink 看作 OutputStream , 把 Source 看作 InputStream 。</p><p>其具体实现非本文重点，有兴趣自己可以查看源码。</p><h2 id="1-1-DiskLruCache"><a href="#1-1-DiskLruCache" class="headerlink" title="1.1 DiskLruCache"></a>1.1 DiskLruCache</h2><p>Okhttp3 中 DiskLruCache 与JakeWharton 大神的 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a> 指导思想一致，但是具体细节不同，比如前者使用 Okio 进行 IO 操作，更加高效。</p><p>在 DiskLruCache 有几个重要概念，了解它们，才能对 DiskLruCache 的实现原理有基本的认识。</p><p>为了能够表达的更加直观，我们看一下一张图片进行缓存时缓存文件的具体内容：<br><img src="https://upload-images.jianshu.io/upload_images/1969719-74b5b0b5c7ff7db3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="在这里插入图片描述"></p><h3 id="1-2-1-日志文件-journal"><a href="#1-2-1-日志文件-journal" class="headerlink" title="1.2.1 日志文件 journal"></a>1.2.1 日志文件 journal</h3><p>该文件为 DiskLruCache 内部的日志文件，对 cache 的每一次操作都对应一条日志，并写入到 journal 文件中，同时也可以通过 journal 文件的分析创建 cache。</p><p>打开上图中 journal 文件，具体内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache</span><br><span class="line">1</span><br><span class="line">201105</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">DIRTY 0e39614b6f9e1f83c82cf663e453a9d7</span><br><span class="line">CLEAN 0e39614b6f9e1f83c82cf663e453a9d7 4687 14596</span><br></pre></td></tr></table></figure><p>在 DiskLruCache.java 类中，我们可以看到对 journal 文件内容的描述，在这里自己对其简单翻译，有兴趣的朋友可以看 JakeWharton 的描述: <a href="https://github.com/JakeWharton/DiskLruCache/blob/master/src/main/java/com/jakewharton/disklrucache/DiskLruCache.java" target="_blank" rel="noopener">DiskLruCache</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">文件的前五行构成头部，格式一般固定。</span><br><span class="line">第一行: 常量 -- libcore.io.DiskLruCache ；</span><br><span class="line">第二行: 硬盘缓存版本号 --  1</span><br><span class="line">第三行: 应用版本号 -- 201105</span><br><span class="line">第四行: 一个有意义的值 -- 2</span><br><span class="line">第五行: 空白行</span><br><span class="line"></span><br><span class="line">头部后的每一行都是 Cache 中 Entry 状态的一条记录。</span><br><span class="line">每条记录的信息包括: 状态值(DIRTY CLEAN READ REMOVE) 缓存信息entry的key值 状态相关的值(可选)。 </span><br><span class="line"></span><br><span class="line">下面对记录的状态进行说明：</span><br><span class="line">DIRTY: 该状态表明一个 entry 正在被创建或更新。每一个成功的 DIRTY 操作记录后应该 CLEAN 或 REMOVE 操作记录，否则被临时创建的文件会被删除。</span><br><span class="line">CLEAN: 该状态表明一个 entry 已经被成功的创建，并且可以被读取，后面记录了对应两个文件文件(具体哪两个文件后面会谈到)的字节数。</span><br><span class="line">READ: 该状态表明正在跟踪 LRU 的访问。</span><br><span class="line">REMOVE: 该状态表明entry被删除了。</span><br></pre></td></tr></table></figure><p>需要注意的是在这里 DIRTY 并不是 “脏”、“脏数据” 的意思，而是这个数据的状态不为最终态、稳定态，该文件现在正在被操作，<br>而 CLEAN 并不是数据被清除，而是表示该文件的操作已经完成。同时在后续的 dirtyFiles 和 cleanFiles 也表示此含义。 </p><p>关于日志文件在整个缓存系统中的作用，在后续过程中用到它的时候在具体阐述。</p><h3 id="1-2-2-DiskLruCache-Entry"><a href="#1-2-2-DiskLruCache-Entry" class="headerlink" title="1.2.2 DiskLruCache.Entry"></a>1.2.2 DiskLruCache.Entry</h3><p>每个 DiskLruCache.Entry 对象代表对每一个 URl 在缓存中的操作对象，该类成员变量的具体含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final class Entry &#123;</span><br><span class="line">        final String key; // Entry 的 key</span><br><span class="line">        final long[] lengths; // key.0 key.1 文件字节数的数组</span><br><span class="line">        final File[] cleanFiles; // 稳定的文件数组</span><br><span class="line">        final File[] dirtyFiles;// 正在执行操作的文件数组</span><br><span class="line">        boolean readable;// 如果该条目被提交了，为 true</span><br><span class="line">        Editor currentEditor;// 正在执行的编辑对象，在没有编辑时为 null</span><br><span class="line">        long sequenceNumber;// 编辑条目的最近提交的序列号</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作在缓存实现流程中阐述。</p><h3 id="1-2-3-DiskLruCache-SnapShot"><a href="#1-2-3-DiskLruCache-SnapShot" class="headerlink" title="1.2.3 DiskLruCache.SnapShot"></a>1.2.3 DiskLruCache.SnapShot</h3><p>此类为缓存的快照，为缓存空间中特定时刻的缓存的状态、内容，该类成员变量的具体含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Snapshot implements Closeable &#123;</span><br><span class="line">        private final String key;</span><br><span class="line">        private final long sequenceNumber; // 编辑条目的最近提交的序列号</span><br><span class="line">        private final Source[] sources;// 缓存中 key.0 key.1 文件的 Okio 输入流</span><br><span class="line">        private final long[] lengths;// 对应 Entry 中的 lengths，为文件字节大小</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-DiskLruCache-Editor"><a href="#1-2-3-DiskLruCache-Editor" class="headerlink" title="1.2.3 DiskLruCache.Editor"></a>1.2.3 DiskLruCache.Editor</h3><p>该类为 DiskLruCache 的编辑器，顾名思义该类是对 DiskLruCache 执行的一系列操作，如：abort() 、 commit() 等。</p><p><strong>Entry publish 的含义是什么？？？？？</strong></p><h1 id="2-缓存实现的有关流程"><a href="#2-缓存实现的有关流程" class="headerlink" title="2. 缓存实现的有关流程"></a>2. 缓存实现的有关流程</h1><p>简单介绍了几个概念，在这一节具体查看一下缓存实现的具体流程。在这之前我们需要明确一下几个前提：</p><ol><li>OkhttpClient 设置支持缓存。</li><li>网络请求头部中的字段设置为支持缓存(Http 协议首部字段值对缓存的实现有影响，具体看参见 <a href="https://item.jd.com/11449491.html" target="_blank" rel="noopener">图解 HTTP</a>、<a href="https://item.jd.com/11056556.html" target="_blank" rel="noopener">HTTP 权威指南</a>)。</li></ol><p><strong>由多个拦截器构成的拦截器链是 Okhttp3 网络请求的执行关键，可以说整个网络请求能够正确的执行是有整个链驱动的 (责任链模式)。仿照 RxJava 是事件驱动的，那么 Okhttp3 是拦截器驱动的。</strong></p><p>关于缓存功能实现的拦截器为 <strong>CacheInterceptor</strong>, CacheInterceptor 位于拦截器链中间位置，那么以执行下一个拦截器为界将缓存流程分为两部分：</p><ol><li>触发之后拦截器之前的操作</li><li>触发之后拦截器之后的操作</li></ol><p>即以 <code>networkResponse = chain.proceed(networkRequest);</code> 为分界</p><h3 id="1-触发之后拦截器之前的操作"><a href="#1-触发之后拦截器之前的操作" class="headerlink" title="1. 触发之后拦截器之前的操作"></a>1. 触发之后拦截器之前的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize()</span><br><span class="line">                : null;//本地缓存</span><br><span class="line"></span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        // 缓存策略</span><br><span class="line">        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">        //策略中的请求</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        ////策略中的响应</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">        if (cache != null) &#123;</span><br><span class="line">            cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //缓存和网络皆为空，返回code 为504 的响应</span><br><span class="line">        // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return new Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(504)</span><br><span class="line">                    .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-1L)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we don&apos;t need the network, we&apos;re done.  缓存策略请求为null，则使用缓存</span><br><span class="line">        if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder()</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-日志文件的初始化"><a href="#1-1-日志文件的初始化" class="headerlink" title="1.1 日志文件的初始化"></a>1.1 日志文件的初始化</h4><p>当执行如下代码时会按照调用链执行相关逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize()</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><p>首先检查在缓存中是否存在该 request 对应的缓存数据，如果有的话就返回 Response，如果没有就置 null。</p><p>调用链来到以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">Response get(Request request) &#123;</span><br><span class="line">    String key = key(request.url());</span><br><span class="line">    DiskLruCache.Snapshot snapshot;</span><br><span class="line">    Entry entry;</span><br><span class="line">    try &#123;</span><br><span class="line">        snapshot = cache.get(key);// 在这里会执行 </span><br><span class="line">        ...</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>snapshot = cache.get(key);</code> 处执行相应的初始化操作。</p><p>在此过程中执行一个特别重要的操作，需要对缓存中的 journal 系列日志文件(包括 journal journal.bak) 进行新建、重建、读取等操作，具体查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// DiskLruCache#initialize()</span><br><span class="line">public synchronized void initialize() throws IOException &#123;</span><br><span class="line">        assert Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">        if (initialized) &#123;// 代码 1 </span><br><span class="line">            return; // Already initialized.</span><br><span class="line">        &#125;</span><br><span class="line">        // If a bkp file exists, use it instead. journal文件备份是否存在</span><br><span class="line">        if (fileSystem.exists(journalFileBackup)) &#123;// 代码 2</span><br><span class="line">            // If journal file also exists just delete backup file.</span><br><span class="line">            if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">                fileSystem.delete(journalFileBackup);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileSystem.rename(journalFileBackup, journalFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Prefer to pick up where we left off.</span><br><span class="line">        if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                readJournal();// 代码 3</span><br><span class="line">                processJournal(); // 代码 4</span><br><span class="line">                initialized = true; // 代码 5</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (IOException journalIsCorrupt) &#123;</span><br><span class="line">                Platform.get().log(WARN, &quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot;</span><br><span class="line">                        + journalIsCorrupt.getMessage() + &quot;, removing&quot;, journalIsCorrupt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">            // we&apos;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">            try &#123;</span><br><span class="line">                delete();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                closed = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rebuildJournal();// 代码 6</span><br><span class="line">        initialized = true;// 代码 7</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="1-App-启动后的初始化"><a href="#1-App-启动后的初始化" class="headerlink" title="1. App 启动后的初始化"></a>1. App 启动后的初始化</h5><p>在启动 App 是标志位 <code>initialized = false</code>，那么由 <code>代码 1</code> 可知此时需要执行初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (initialized) &#123;// 代码 1 </span><br><span class="line">    return; // Already initialized.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-1-若-journal-日志文件存在"><a href="#1-1-若-journal-日志文件存在" class="headerlink" title="1.1  若 journal 日志文件存在"></a>1.1  若 journal 日志文件存在</h6><p>如果存在 journal.bak 那么将该文件重命名为 journal。</p><p>接下来对 journal 日志文件所做的操作如 <code>代码 3、4 、5</code>  所示，具体作用做如下阐述。<code>代码 3</code> 要做的是读取日志文件 journal 并根据日志内容初始化 <code>LinkedHashMap&lt;String, Entry&gt; lruEntries</code> 中的元素，DiskLruCache 正是通过 LinkedHashMap 来实现 LRU 功能的。我们看一下 readJournal() 的具体代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void readJournal() throws IOException &#123;</span><br><span class="line">        BufferedSource source = Okio.buffer(fileSystem.source(journalFile));</span><br><span class="line">        try &#123;</span><br><span class="line">            String magic = source.readUtf8LineStrict();</span><br><span class="line">            String version = source.readUtf8LineStrict();</span><br><span class="line">            String appVersionString = source.readUtf8LineStrict();</span><br><span class="line">            String valueCountString = source.readUtf8LineStrict();</span><br><span class="line">            String blank = source.readUtf8LineStrict();</span><br><span class="line">            if (!MAGIC.equals(magic)</span><br><span class="line">                    || !VERSION_1.equals(version)</span><br><span class="line">                    || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">                    || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">                    || !&quot;&quot;.equals(blank)) &#123;</span><br><span class="line">                throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot;</span><br><span class="line">                        + valueCountString + &quot;, &quot; + blank + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int lineCount = 0;</span><br><span class="line">            while (true) &#123;// 不断执行如下操作，直到文件尾部，结束如下操作</span><br><span class="line">                try &#123;</span><br><span class="line">                    readJournalLine(source.readUtf8LineStrict());</span><br><span class="line">                    lineCount++;</span><br><span class="line">                &#125; catch (EOFException endOfJournal) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">            // If we ended on a truncated line, rebuild the journal before appending to it.</span><br><span class="line">            if (!source.exhausted()) &#123;</span><br><span class="line">                rebuildJournal();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                journalWriter = newJournalWriter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Util.closeQuietly(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在方法的开始读取 journal 日志文件的头部做基本的判断，如不满足要求则抛出异常。接下来在 该方法中通过方法 – <code>readJournalLine(source.readUtf8LineStrict());</code> 读取 journal 日志文件的每一行，根据日志文件的每一行生成 Entry 存入 lruEntries 中用来实现 LRU 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void readJournalLine(String line) throws IOException &#123;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">      // 一顿操作得到 key 的值</span><br><span class="line">      </span><br><span class="line">      // 根据日志文件中 key 值获得或者生成 Entry，存入 lruEntries 中</span><br><span class="line">      Entry entry = lruEntries.get(key);</span><br><span class="line">      if (entry == null) &#123;</span><br><span class="line">          entry = new Entry(key);</span><br><span class="line">          lruEntries.put(key, entry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">          String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);</span><br><span class="line">          entry.readable = true;</span><br><span class="line">          entry.currentEditor = null;</span><br><span class="line">          entry.setLengths(parts);</span><br><span class="line">      &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">          entry.currentEditor = new Editor(entry);</span><br><span class="line">      &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">          // This work was already done by calling lruEntries.get().</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>readJournal() 执行完毕后相当于对 lruEntries 进行初始化。lruEntries 元素的个数等于该 App 在此缓存文件夹下缓存文件的个数。在此过程中如果 lruEntries 中没有此行日志中的 key 对应的 Entry 对象，因为现在为进入 App 中的对缓存空间的初始化，所以都需要新建该类的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据日志文件中 key 值获得或者生成 Entry，存入 lruEntries 中</span><br><span class="line">   Entry entry = lruEntries.get(key);</span><br><span class="line">       if (entry == null) &#123;</span><br><span class="line">       entry = new Entry(key);</span><br><span class="line">       lruEntries.put(key, entry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新建 Entry 对象的过程对于整个缓存体系的构建也十分重要，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Entry(String key) &#123;</span><br><span class="line">    this.key = key;</span><br><span class="line"></span><br><span class="line">    lengths = new long[valueCount];</span><br><span class="line">    cleanFiles = new File[valueCount];</span><br><span class="line">    dirtyFiles = new File[valueCount];</span><br><span class="line"></span><br><span class="line">    // The names are repetitive so re-use the same builder to avoid allocations.</span><br><span class="line">    //名称是重复的，所以要重复使用相同的构建器以避免分配</span><br><span class="line">    StringBuilder fileBuilder = new StringBuilder(key).append(&apos;.&apos;);</span><br><span class="line">    int truncateTo = fileBuilder.length();</span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        fileBuilder.append(i);</span><br><span class="line">        cleanFiles[i] = new File(directory, fileBuilder.toString()); // key.0 key.1</span><br><span class="line">        fileBuilder.append(&quot;.tmp&quot;);</span><br><span class="line">        dirtyFiles[i] = new File(directory, fileBuilder.toString());// key.0.tmp key.1.tmp</span><br><span class="line">        fileBuilder.setLength(truncateTo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新建对象过程中会根据 valueCount = 2; 的值定义缓存文件分别为 key.0、key.1、key.0.tmp、key.1.tmp ,其中 key.0 为稳定状态下的请求的 mate 数据，key.1 为稳定状态下的缓存数据，而 key.0.tmp、key.1.tmp 分别为 mate 数据和缓存数据的临时文件,此时并不会真正的新建文件。</p><p><strong>在这里需要明确的是 cleanFiles 和 dirtyFiles 都是 Entry 的成员变量，也就是说是通过 Entry 的对象对两者进行读取并进行相关操作的。</strong></p><p>processJournal() 方法实现了缓存文件夹下删除无用的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void processJournal() throws IOException &#123;</span><br><span class="line">    fileSystem.delete(journalFileTmp);</span><br><span class="line">    for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        Entry entry = i.next();</span><br><span class="line">        if (entry.currentEditor == null) &#123;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                size += entry.lengths[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            entry.currentEditor = null;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                fileSystem.delete(entry.cleanFiles[t]);</span><br><span class="line">                fileSystem.delete(entry.dirtyFiles[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>何为无用的文件 ？</strong></p><p>如果文件夹下存在 <code>entry.currentEditor != null;</code> 的文件，说明此文件为处在编辑状态下，但是此时的时机为刚打开 App 后的初始化状态，所有的文件均不应该处在编辑状态，所以此状态下的文件即为无用的文件，需要被删除。</p></blockquote><p>执行完毕后标志位 initialized 置位为 true 并中断执行 (return;) 返回操作去执行其他操作。</p><h6 id="1-2-若-journal-日志文件不存在"><a href="#1-2-若-journal-日志文件不存在" class="headerlink" title="1.2  若 journal 日志文件不存在"></a>1.2  若 journal 日志文件不存在</h6><p>若 journal 日志文件不存在，那么不会执行 代码 2、3、4、5 直接执行代码 6 –  rebuildJournal() ，具体执行操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">synchronized void rebuildJournal() throws IOException &#123;</span><br><span class="line">        if (journalWriter != null) &#123;</span><br><span class="line">            journalWriter.close();</span><br><span class="line">        &#125;</span><br><span class="line">        //产生 journal.tmp 文件</span><br><span class="line">        BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));</span><br><span class="line">        try &#123;// 写入 journal 文件内容</span><br><span class="line">            writer.writeUtf8(MAGIC).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeUtf8(VERSION_1).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeDecimalLong(appVersion).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeDecimalLong(valueCount).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeByte(&apos;\n&apos;);</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             *  将 lruEntries 的值重新写入 journal 文件</span><br><span class="line">             */</span><br><span class="line">            for (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">                if (entry.currentEditor != null) &#123; // 当前的 editor 不为 null 说明当前 journal 为非稳定态</span><br><span class="line">                    writer.writeUtf8(DIRTY).writeByte(&apos; &apos;);</span><br><span class="line">                    writer.writeUtf8(entry.key);</span><br><span class="line">                    writer.writeByte(&apos;\n&apos;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    writer.writeUtf8(CLEAN).writeByte(&apos; &apos;);</span><br><span class="line">                    writer.writeUtf8(entry.key);</span><br><span class="line">                    entry.writeLengths(writer);</span><br><span class="line">                    writer.writeByte(&apos;\n&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">        // journal.tmp --&gt; journal</span><br><span class="line">        if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">            fileSystem.rename(journalFile, journalFileBackup);</span><br><span class="line">        &#125;</span><br><span class="line">        fileSystem.rename(journalFileTmp, journalFile);</span><br><span class="line">        fileSystem.delete(journalFileBackup);</span><br><span class="line"></span><br><span class="line">        journalWriter = newJournalWriter();</span><br><span class="line">        hasJournalErrors = false;</span><br><span class="line">        mostRecentRebuildFailed = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>十分重要的操作为 ： Okio.buffer(fileSystem.sink(journalFileTmp)); ,因为此时 journal 不存在，那么此行代码执行的操作正是新建journal 临时文件 –  journal.tmp ,写入文件头部文件后将 journal.tmp 重命名为 journal 。前文解析 journal 文件内容的含义，此处代码正好可以作为印证。</p><h4 id="1-2-初始化后"><a href="#1-2-初始化后" class="headerlink" title="1.2 初始化后"></a>1.2 初始化后</h4><p>经过初始化后最终获取 DiskLruCache 快照 DiskLruCache$Snapshot 对象，并进行相关包装返回 Response 对象为缓存中的Response 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   Response get(Request request) &#123;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">       try &#123;</span><br><span class="line">           snapshot = cache.get(key);// 在这里会执行 initialize(),进行一次初始化</span><br><span class="line">           if (snapshot == null) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">       Response response = entry.response(snapshot);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       return response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此,以上即为进入 CacheInterceptor 后的第一步操作，说实话工作量真是大，开启了 Debug 模式 n 遍才稍微把基本流程搞明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize() ，会对 journal 文件进行一些操作</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h4 id="1-3-缓存策略"><a href="#1-3-缓存策略" class="headerlink" title="1.3 缓存策略"></a>1.3 缓存策略</h4><p>缓存策略的获取主要涉及代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><p>具体执行代码位置：<br><code>CacheStrategy#getCandidate()</code>，由于具体业务逻辑比较容易理解，根据缓存响应、请求中头部关于缓存的字段进行相关判断，得出缓存策略，在这里不做过多阐释。</p><h3 id="2-触发之后拦截器之后的操作"><a href="#2-触发之后拦截器之后的操作" class="headerlink" title="2. 触发之后拦截器之后的操作"></a>2. 触发之后拦截器之后的操作</h3><p>触发之后的拦截器后，进行相关的一系列操作，根据责任链模式逻辑还是会最终回来，接着此拦截器的逻辑继续执行。此时整个请求的状态为已经成功得到网络响应，那么我们要做的就是对网络响应进行缓存，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);// 将 response 写入内存中，此时进行的步骤： 创建 0.tmp(已经写入数据) 和 1.tmp(尚未写入数据)</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">            // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随 CacheRequest cacheRequest = cache.put(response); 执行如下逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CacheRequest put(Response response) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //由Response对象构建一个Entry对象,Entry是Cache的一个内部类</span><br><span class="line">        Entry entry = new Entry(response);</span><br><span class="line">        DiskLruCache.Editor editor = null;// disk 缓存的编辑</span><br><span class="line">        try &#123;</span><br><span class="line">            editor = cache.edit(key(response.request().url()));// key(response.request().url()) 根据 URL生成唯一 key</span><br><span class="line">            if (editor == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //把这个entry写入</span><br><span class="line">            //方法内部是通过Okio.buffer(editor.newSink(ENTRY_METADATA));获取到一个BufferedSink对象，随后将Entry中存储的Http报头数据写入到sink流中。</span><br><span class="line">            entry.writeTo(editor);// 触发生成 0.tmp</span><br><span class="line">            //构建一个CacheRequestImpl对象，构造器中通过editor.newSink(ENTRY_BODY)方法获得Sink对象</span><br><span class="line">            return new CacheRequestImpl(editor);// 触发生成 1.tmp</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            abortQuietly(editor);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Cache#writeTo()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写入 0.tmp 数据 // 写入 的dirtyfile 文件的 buffersink 输出流</span><br><span class="line">public void writeTo(DiskLruCache.Editor editor) throws IOException &#123;</span><br><span class="line">    BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));//新建 key.0.tmp</span><br><span class="line">    // TODO: 在这里出现了 0.tmp</span><br><span class="line">    sink.writeUtf8(url)</span><br><span class="line">            .writeByte(&apos;\n&apos;);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常明显的操作在此处创建了 key.0.tmp 文件，并写入数据，此处写入的数据为 mate 数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CacheRequestImpl(final DiskLruCache.Editor editor) &#123;</span><br><span class="line">    this.editor = editor;</span><br><span class="line">    this.cacheOut = editor.newSink(ENTRY_BODY);// 在这里生成 1.tmp</span><br><span class="line">    this.body = new ForwardingSink(cacheOut) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void close() throws IOException &#123;</span><br><span class="line">            synchronized (Cache.this) &#123;</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                done = true;</span><br><span class="line">                writeSuccessCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            super.close();</span><br><span class="line">            editor.commit();//最终调用了此函数，0.tmp 1.tmp --》 key.0  key.1 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化 CacheRequestImpl 对象时创建了 key.1.tmp 文件。</p><p>执行如上操作后回到 CacheInterceptor 执行 cacheWritingResponse() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        // Some apps return a null body; for compatibility we treat that like a null cache request.</span><br><span class="line">        if (cacheRequest == null) return response;</span><br><span class="line">        Sink cacheBodyUnbuffered = cacheRequest.body();</span><br><span class="line">        if (cacheBodyUnbuffered == null) return response;</span><br><span class="line"></span><br><span class="line">        final BufferedSource source = response.body().source();</span><br><span class="line">        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"></span><br><span class="line">        Source cacheWritingSource = new Source() &#123;</span><br><span class="line">            boolean cacheRequestClosed;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class="line">                long bytesRead;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bytesRead = source.read(sink, byteCount);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheRequest.abort(); // Failed to write a complete cache response.</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (bytesRead == -1) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheBody.close(); // The cache response is complete!</span><br><span class="line">                    &#125;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">                cacheBody.emitCompleteSegments();</span><br><span class="line">                return bytesRead;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Timeout timeout() &#123;</span><br><span class="line">                return source.timeout();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line">                if (!cacheRequestClosed</span><br><span class="line">                        &amp;&amp; !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                    cacheRequestClosed = true;</span><br><span class="line">                    cacheRequest.abort();</span><br><span class="line">                &#125;</span><br><span class="line">                source.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        return response.newBuilder()</span><br><span class="line">                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>执行一系列操作，使用 Okio 这个库不断的向 key.1.tmp 写入数据，具体操作过程实在是太过繁杂，而且牵涉到 Okio 库原理，自己在这么短时间无法理清具体流程。</p><p><strong>对于数据写入的切入点自己还没有很好的认识，在何处真正进行写文件操作自己只能够通过 Debug 知道其走向，但是对其原理还没有理解。</strong></p><p>最后会执行 CacheRequestImpl 对象的close 方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CacheRequestImpl(final DiskLruCache.Editor editor) &#123;</span><br><span class="line">            this.editor = editor;</span><br><span class="line">            this.cacheOut = editor.newSink(ENTRY_BODY);//在这里生成 1.tmp</span><br><span class="line">            this.body = new ForwardingSink(cacheOut) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void close() throws IOException &#123;</span><br><span class="line">                    synchronized (Cache.this) &#123;</span><br><span class="line">                        if (done) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        done = true;</span><br><span class="line">                        writeSuccessCount++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    super.close();</span><br><span class="line">                    editor.commit();// 最终调用了此函数，0.tmp 1.tmp -&gt; key.0  key.1 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行 editor.commit(); 该方法会调用的 completeEdit()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</span><br><span class="line">        Entry entry = editor.entry;</span><br><span class="line">        if (entry.currentEditor != editor) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If this edit is creating the entry for the first time, every index must have a value.</span><br><span class="line">        if (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">            for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">                if (!editor.written[i]) &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                    throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!fileSystem.exists(entry.dirtyFiles[i])) &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // key.0.tmp key.1.tmp --&gt; key.0 key.1</span><br><span class="line">        for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">            File dirty = entry.dirtyFiles[i];</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                if (fileSystem.exists(dirty)) &#123;</span><br><span class="line">                    File clean = entry.cleanFiles[i];</span><br><span class="line">                    fileSystem.rename(dirty, clean);</span><br><span class="line">                    long oldLength = entry.lengths[i];</span><br><span class="line">                    long newLength = fileSystem.size(clean);</span><br><span class="line">                    entry.lengths[i] = newLength;</span><br><span class="line">                    size = size - oldLength + newLength;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileSystem.delete(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法中最终会将 key.0.tmp 、key.1.tmp 分别 重命名为 key.0 、key.1 ，这两个文件分别为两个文件的稳定状态，同时更新 journal 日志记录。</p><hr><p>至此 Okhttp3 实现缓存功能的大致流程基本结束，但是其中还是有很多的逻辑和细节是自己没有发现和不能理解的，其源码还是需要不断的去阅读去理解，需要对其中的实现、思想有进一步的体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文以一个不同的角度来解读 Okhttp3 实现缓存功能的思路，即：对于对于的缓存空间(文件夹)中的缓存文件的生成时机、不同时期下个文件的状态、不同时期下日志文件读写。通过这些方法来真正理解 Okhttp3 的缓存功能。如果你理解 DiskLrcCache 开源库的设计，那么对于 Okhttp3 的缓存实现你就已经掌握了，因为前者以后者为基础，你甚至没有看本文的必要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-需要了解的概念&quot;&gt;&lt;a href=&quot;#1-需要了解的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 需要了解的概念&quot;&gt;&lt;/a&gt;1. 需要了解的概念&lt;/h1&gt;&lt;p&gt;缓存功能的实现，理所当然的涉及文件的读写操作、缓存机制方案的设计。Okhttp3 缓存功能的实现涉及到 Okio 和 DiskLruCache，在阐述具体缓存流程之前，我们需要了解两者的一些基本概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Okhttp3" scheme="/tags/Okhttp3/"/>
    
      <category term="Okhttp3 缓存文件" scheme="/tags/Okhttp3-%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(四):静态同步synchronize方法与synchronize(class)代码块</title>
    <link href="/2019/08/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9B%9B-%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5synchronize%E6%96%B9%E6%B3%95%E4%B8%8Esynchronize-class-%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>/2019/08/19/Java-多线程-四-静态同步synchronize方法与synchronize-class-代码块/</id>
    <published>2019-08-19T07:12:45.000Z</published>
    <updated>2019-08-19T07:31:30.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态同步-synchronize-方法"><a href="#静态同步-synchronize-方法" class="headerlink" title="静态同步 synchronize 方法"></a>静态同步 synchronize 方法</h3><p>关键字 synchronize 可以添加到静态方法上，这样的写法是对所属的 Class 进行加锁，从而可以实现同步效果。</p><p>虽然静态同步 synchronize 方法 和 非同步 synchronize 方法 的同步效果是一样的，但是其本质是不同的：</p><pre><code>静态同步 synchronize 方法为添加在 static 方法的上，是给 Class 类上锁。非静态同步 synchronize 方法是给对象加锁。</code></pre><p>Class 锁可以对类的所有对象实例起作用，多线程中其所有该类的实例对象调用 <strong>静态同步 synchronize 方法</strong> 都是同步的，但是与非静态同步 synchronize 方法间是异步的。</p><a id="more"></a><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/StaticSynchronziedMethodMain.kt" target="_blank" rel="noopener">StaticSynchronziedMethodMain</a> 的验证方法：</p><pre><code>one:验证同步方法与同步静态方法间的异步性two:同一个对象的同步静态方法的同步性three:多对象间的静态同步方法的同步性</code></pre><h3 id="synchronize-class-代码块"><a href="#synchronize-class-代码块" class="headerlink" title="synchronize(class)代码块"></a>synchronize(class)代码块</h3><p>synchronize(class)代码块与静态同步 synchronize 方法的作用是一样的。</p><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/StaticSynchronziedMethodMain.kt" target="_blank" rel="noopener">StaticSynchronziedMethodMain</a> 的验证方法：</p><pre><code>four:验证同一个对象 synchronize(class)代码块 间的同步性five:验证多个对象 synchronize(class)代码块 间的同步性</code></pre><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;静态同步-synchronize-方法&quot;&gt;&lt;a href=&quot;#静态同步-synchronize-方法&quot; class=&quot;headerlink&quot; title=&quot;静态同步 synchronize 方法&quot;&gt;&lt;/a&gt;静态同步 synchronize 方法&lt;/h3&gt;&lt;p&gt;关键字 synchronize 可以添加到静态方法上，这样的写法是对所属的 Class 进行加锁，从而可以实现同步效果。&lt;/p&gt;
&lt;p&gt;虽然静态同步 synchronize 方法 和 非同步 synchronize 方法 的同步效果是一样的，但是其本质是不同的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;静态同步 synchronize 方法为添加在 static 方法的上，是给 Class 类上锁。

非静态同步 synchronize 方法是给对象加锁。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Class 锁可以对类的所有对象实例起作用，多线程中其所有该类的实例对象调用 &lt;strong&gt;静态同步 synchronize 方法&lt;/strong&gt; 都是同步的，但是与非静态同步 synchronize 方法间是异步的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(三):同步代码块</title>
    <link href="/2019/08/19/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89):%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>/2019/08/19/Java 多线程(三):同步代码块/</id>
    <published>2019-08-19T07:12:40.000Z</published>
    <updated>2019-08-19T07:31:23.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synchronize-this-同步代码块"><a href="#synchronize-this-同步代码块" class="headerlink" title="synchronize(this) 同步代码块"></a>synchronize(this) 同步代码块</h3><p>synchronize 同步方法在某些情况下会有一些弊端：比如 A 线程调用同步方法执行一个长时间的任务，那么 B 线程必须等待比较长的时间才可以获得对象锁。在这种情况下可以使用 synchronize 同步代码块可以解决。</p><p><strong>synchronize 方法</strong>是对 <strong>当前对象</strong> 进行加锁，而 <strong>synchronize 代码块</strong> 是对 <strong>某一个对象</strong> 进行加锁。</p><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlock.kt" target="_blank" rel="noopener">SynchronizedMethodBlock</a> 中的方法 one、two、three 分别展示了非同步情况、同步方法、同步代码块，通过日志打印可知同步代码块可以有效的避免同步方法执行的低效率。</p><a id="more"></a><p>在执行同步代码块时需要注意将相应的代码放入代码块中，用来实现响应实例变量的同步性。</p><p>同样的，<strong>同步代码块 synchronize(this) 持有的是当前调用对象的锁</strong>，具体验证可以查看代码：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTest.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTest</a> 中可以验证该结论。</p><h3 id="synchronize-this-同步代码块间的同步性"><a href="#synchronize-this-同步代码块间的同步性" class="headerlink" title="synchronize(this) 同步代码块间的同步性"></a>synchronize(this) 同步代码块间的同步性</h3><p>在使用同步 <code>synchronize(this)</code> 同步代码块需要注意的是，当一个线程访问 object 的一个 <code>synchronize(this)</code> 同步代码块时，其他线程对 <strong>同一个 object</strong> 中的所有其他 <code>synchronize(this)</code> 同步代码块的访问将被阻塞，这说明 synchronize 使用的 “对象监视器“ 是一个。<br>代码验证：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTestTwo.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTestTwo</a>。</p><h3 id="synchronized-同步方法与synchronzied-this-同步代码块的同步性"><a href="#synchronized-同步方法与synchronzied-this-同步代码块的同步性" class="headerlink" title="synchronized 同步方法与synchronzied(this) 同步代码块的同步性"></a>synchronized 同步方法与synchronzied(this) 同步代码块的同步性</h3><p>多个线程调用同一个对象中的不同名称的 synchronized 同步方法或 synchronzied(this) 同步代码块时，为同步执行，阻塞执行的。</p><p>这说明 synchronized 同步方法或 synchronized(this) 同步代码块分别有两种作用：</p><p>synchronized 同步方法：</p><ol><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块调用呈阻塞状态。</li><li>同一时间只有一个线程可以执行 synchronize 同步方法中的代码。</li></ol><p>synchronized(this) 同步代码块：</p><ol><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块调用呈阻塞状态</li><li>同一时间只有一个线程可以执行 synchronized(this) 同步代码块中的代码。</li></ol><h3 id="将任意对象作为同步代码块的对象监视器"><a href="#将任意对象作为同步代码块的对象监视器" class="headerlink" title="将任意对象作为同步代码块的对象监视器"></a>将任意对象作为同步代码块的对象监视器</h3><p>Java 支持将任意对象作为 对象监视器，任意参数一般为实例变量或者是方法的参数，使用格式为：synchronzied(非 this 对象)。</p><p>synchronzied(非 this 对象) 同步代码块的作用为：</p><pre><code>在多个线程持有对象监视器为同一个对象的前提下，同一时间只有一个线程可以执行synchronzied(非 this 对象) 同步代码块中的代码。</code></pre><p>验证：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTestThree.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTestThree</a> 中 two 方法展示synchronzied(非 this 对象) 的同步效果。</p><p>同样的，synchronzied(非 this 对象) 同步代码块也是对象锁，否则不能达到同步效果。</p><p>对于 synchronize(非this对象x)，有以下结论：</p><ul><li>当多个线程同时执行 synchronize(非this对象x){} 同步代码块时，呈同步效果。</li><li>当多个线程 x 对象中的 synchronize同步方法时，呈同步效果。</li><li>当多个线程 x 对象中的 synchronize(this)同步代码方法时，呈同步效果。</li></ul><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synchronize-this-同步代码块&quot;&gt;&lt;a href=&quot;#synchronize-this-同步代码块&quot; class=&quot;headerlink&quot; title=&quot;synchronize(this) 同步代码块&quot;&gt;&lt;/a&gt;synchronize(this) 同步代码块&lt;/h3&gt;&lt;p&gt;synchronize 同步方法在某些情况下会有一些弊端：比如 A 线程调用同步方法执行一个长时间的任务，那么 B 线程必须等待比较长的时间才可以获得对象锁。在这种情况下可以使用 synchronize 同步代码块可以解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronize 方法&lt;/strong&gt;是对 &lt;strong&gt;当前对象&lt;/strong&gt; 进行加锁，而 &lt;strong&gt;synchronize 代码块&lt;/strong&gt; 是对 &lt;strong&gt;某一个对象&lt;/strong&gt; 进行加锁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlock.kt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SynchronizedMethodBlock&lt;/a&gt; 中的方法 one、two、three 分别展示了非同步情况、同步方法、同步代码块，通过日志打印可知同步代码块可以有效的避免同步方法执行的低效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(二):多线程并发</title>
    <link href="/2019/08/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-%E5%B9%B6%E5%8F%91/"/>
    <id>/2019/08/19/Java-多线程-二-并发/</id>
    <published>2019-08-19T07:12:35.000Z</published>
    <updated>2019-11-25T12:55:06.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synchronized-同步方法"><a href="#synchronized-同步方法" class="headerlink" title="synchronized 同步方法"></a>synchronized 同步方法</h3><p>多个线程同时访问 <strong>同一个对象</strong> 的实例变量，则很有可能发生“非线程安全”问题。</p><p>在操作实例变量的方法前添加关键字 synchronize 关键字，则可以使原本“非线程安全” 变为 “线程安全”。</p><p>在 method 方法前添加 synchronize 关键字，使得多个线程在执行该方法时，以排队的方法进行处理。当一个线程执行 method 方法前，首先判断该方法有没有被上锁，如果上锁，说明有其他线程在调用 method 方法，必须等其他线程对 method 方法调用结束后才可以继续调用 method 方法。这样实现了排队调用 method 方法的目的，达到了顺序操作实例变量的目的。</p><a id="more"></a><p>synchronized 可以在任意对象及方法上加锁，而加锁的这段代码被称为“互斥区” 或 “临界区”。</p><p>当一个线程想要执行同步方法中的代码时，线程首先尝试去获得方法上的锁，如果能够拿到这把锁，那么这个线程就可以执行 synchronized 里面的代码。如果拿不到，那么这个线程就会不断的尝试去拿这把锁，直到拿到为止，而且有可能是多个线程同时去争抢这把锁。</p><h3 id="synchronized-同步方法中的锁属于谁？"><a href="#synchronized-同步方法中的锁属于谁？" class="headerlink" title="synchronized 同步方法中的锁属于谁？"></a>synchronized 同步方法中的锁属于谁？</h3><p>同步方法中关键字 synchronized 取得的锁都是 <strong>对象锁</strong>，哪一个线程先执行带有 synchronized 关键字的方法，哪一个线程就持有该方法 <strong>所属对象</strong> 的锁 Lock，那么其他对线程只能呈等待状态，前提是 <strong>多个线程访问的是同一个对象</strong>。</p><p>如果多个线程访问不同对象，那么 JVM 会创建多个锁。如果多个线程访问多个对象，那么执行结果显示为异步的。通过 <a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethod.kt" target="_blank" rel="noopener">代码</a> 中的 one()、two() 的对比可得到此结论，结论：<strong>多个对象多个锁</strong>。</p><p>那么什么时候需要对方法进行同步操作呢？</p><blockquote><p>只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本不需要进行同步操作。</p></blockquote><p>既然同步方法的中的锁为对象锁，那么很自然的，<strong>当多个线程访问同一个对象中的多个同步方法时，同样呈现同步效果</strong>，那么当多个线程访问同一个对象中的 <strong>其他非同步方法</strong> 时，呈现异步效果。</p><h3 id="synchronized-锁重入"><a href="#synchronized-锁重入" class="headerlink" title="synchronized 锁重入"></a>synchronized 锁重入</h3><p>关键字 synchronize 用于锁重入的功能，也就是当一个线程得到一个对象锁之后，再次请求此对象锁时是可以再次得到该对象的锁的。</p><p>具体表现：synchronize 方法/块的内部调用 <strong>本类</strong> 的其他 synchronize 方法/块时，是永远可以获得锁的。</p><p><strong>自己可以再次获取自己的内部锁</strong>。</p><p>可重入锁也 <strong>支持在父子继承关系</strong> 的环境中。</p><h3 id="出现异常，锁自动释放"><a href="#出现异常，锁自动释放" class="headerlink" title="出现异常，锁自动释放"></a>出现异常，锁自动释放</h3><p>当一个线程执行代码时出现异常，其所持有的锁会自动释放。</p><h3 id="同步不支持继承性"><a href="#同步不支持继承性" class="headerlink" title="同步不支持继承性"></a>同步不支持继承性</h3><p>子类继承父类中的同步方法，则子类中的该方法不具有可同步性。</p><hr><p>需要明确的一点：<br>线程的同步性最终是体现在对象的同步方法上，即执行该方法的同步性，是线程中的一次执行动作的同步性，而不是线程的 run 方法上。比如这样一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class CustomThreadA extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private Task task;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">           task.doSomething(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomThreadB extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private Task task;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">           task.doSomething(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的两个线程执行 Task 中的方法，并不是当线程 CustomThreadB 抢到 doSomething 的锁就会将 run 方法中的动作执行完毕，而是线程 CustomThreadB 只拿到了一次执行 doSomething 的锁，执行结束后，会释放锁，下一次 CustomThreadB 、CustomThreadA 会同时争抢锁，从而执行自己 run 方法中的下一次循环。</p><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synchronized-同步方法&quot;&gt;&lt;a href=&quot;#synchronized-同步方法&quot; class=&quot;headerlink&quot; title=&quot;synchronized 同步方法&quot;&gt;&lt;/a&gt;synchronized 同步方法&lt;/h3&gt;&lt;p&gt;多个线程同时访问 &lt;strong&gt;同一个对象&lt;/strong&gt; 的实例变量，则很有可能发生“非线程安全”问题。&lt;/p&gt;
&lt;p&gt;在操作实例变量的方法前添加关键字 synchronize 关键字，则可以使原本“非线程安全” 变为 “线程安全”。&lt;/p&gt;
&lt;p&gt;在 method 方法前添加 synchronize 关键字，使得多个线程在执行该方法时，以排队的方法进行处理。当一个线程执行 method 方法前，首先判断该方法有没有被上锁，如果上锁，说明有其他线程在调用 method 方法，必须等其他线程对 method 方法调用结束后才可以继续调用 method 方法。这样实现了排队调用 method 方法的目的，达到了顺序操作实例变量的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(一):基本概念</title>
    <link href="/2019/08/19/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/08/19/Java 多线程一-基本概念/</id>
    <published>2019-08-19T07:12:30.000Z</published>
    <updated>2019-08-19T07:36:52.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程可以理解为在进程中独立运行的子任务，使用多线程后可以最大限度的利用 CPU 的空闲时间来处理其他任务。</p><p>多线程的执行是异步的。</p><h3 id="Thread-的常用-API"><a href="#Thread-的常用-API" class="headerlink" title="Thread 的常用 API"></a>Thread 的常用 API</h3><p>currentThread()(静态方法)</p><blockquote><p>currentThread() 方法返回的 <strong>代码段正在被哪个线程调用</strong>。</p></blockquote><p>getName()：获得线程的 Name</p><p>注意 <code>currentThread().getName()</code> 与 <code>getName()</code> 的不同。</p><a id="more"></a><p>isAlive()：判断当前线程是否处于活动状态。</p><p>sleep():在指定的毫秒内让当前“正在执行的线程” 休眠，这个 “正在执行的线程” 的是指 <code>currentThread()</code> 返回的线程。</p><h3 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h3><ul><li>继承 Thread</li><li>实现 Runnable</li></ul><p>继承 Thread 最大的局限就是不支持多继承，为了实现多继承可以通过实现 Runnable 的方式，但是两者本质上没有区别。</p><h3 id="线程调用"><a href="#线程调用" class="headerlink" title="线程调用"></a>线程调用</h3><p><strong>随机性</strong></p><p>使用多线程技术时，<strong>代码的运行的结果与代码的执行顺序或者调用顺序无关的</strong>，即 Thread 对象调用 start 的顺序并不代表 run 方法的执行顺序。线程是一个子任务， CPU 以不确定的方式，或者以随机的时间调用线程中的 run 方法。</p><p><strong>线程的调用</strong></p><p>Thread 类中的 start() 方法通知 “线程规划器” 此线程已经准备就绪，等待调用线程对象的 run 方法。</p><p>线程的执行其实是让系统安排一个时间来调用 run 方法，但是系统何时执行是随机的，也就印证了线程调用的随机性。</p><h3 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h3><p><strong>当多个线程可以同时访问一个变量时，容易发生数据线程安全问题。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 5;</span><br><span class="line">    public MyThread() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread 当前的 Thread 的 name: &quot; + this.getName());</span><br><span class="line">        System.out.println(&quot;MyThread 代码执行的 Thread：&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        System.out.println(&quot;代码调用的 Thread&quot; + currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前的 Thread 的 Name  &quot; + this.getName());</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(&quot;Thread is：&quot; + currentThread().getName()+&quot;,计算结果是：&quot; + &quot;count is &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用过程如下(过滤无用信息)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> MyThread mMyThread = new MyThread();</span><br><span class="line">Thread a = new Thread(mMyThread, &quot;A&quot;);</span><br><span class="line">Thread b = new Thread(mMyThread, &quot;B&quot;);</span><br><span class="line">Thread c = new Thread(mMyThread, &quot;C&quot;);</span><br><span class="line">Thread d = new Thread(mMyThread, &quot;D&quot;);</span><br><span class="line">Thread e = new Thread(mMyThread, &quot;E&quot;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">d.start();</span><br><span class="line">e.start();</span><br></pre></td></tr></table></figure><p>打印日志的一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread is：A,计算结果是：count is 3</span><br><span class="line">Thread is：B,计算结果是：count is 3</span><br><span class="line">Thread is：C,计算结果是：count is 2</span><br><span class="line">Thread is：D,计算结果是：count is 1</span><br><span class="line">Thread is：E,计算结果是：count is 0</span><br></pre></td></tr></table></figure><p>很明显，线程 A 和 B 同时对 count 进行处理，获得了相同的打印 count，这是不想得到的结果，这就是所谓的 “非线程安全” 问题。</p><p>在本例中，产生线程不安全的原因为: <code>count--</code>:</p><p>在虚拟机中 count– 分为以下 3 步：</p><pre><code>1. 取得 count。2. 计算 count - 1。3. 对 count 赋值。</code></pre><p>以上 3 个步骤中，如果有多个线程同时访问，容易产生线程安全问题。</p><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>什么是非线程安全？</p><blockquote><p>非线程安全是指 <strong>多个线程</strong> 对 <strong>同一个对象</strong> 中的 <strong>同一个实例变量</strong> 进行操作时会出现值被更改、值不同步的情况，影响程序的正常执行。</p></blockquote><p>上面这种一个线程在操作中读取实例变量时，此值已经被其他线程更改过的情况被称为 <strong>脏读</strong>。</p><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;p&gt;线程可以理解为在进程中独立运行的子任务，使用多线程后可以最大限度的利用 CPU 的空闲时间来处理其他任务。&lt;/p&gt;
&lt;p&gt;多线程的执行是异步的。&lt;/p&gt;
&lt;h3 id=&quot;Thread-的常用-API&quot;&gt;&lt;a href=&quot;#Thread-的常用-API&quot; class=&quot;headerlink&quot; title=&quot;Thread 的常用 API&quot;&gt;&lt;/a&gt;Thread 的常用 API&lt;/h3&gt;&lt;p&gt;currentThread()(静态方法)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;currentThread() 方法返回的 &lt;strong&gt;代码段正在被哪个线程调用&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;getName()：获得线程的 Name&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;currentThread().getName()&lt;/code&gt; 与 &lt;code&gt;getName()&lt;/code&gt; 的不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>浅析 Java 对象拷贝</title>
    <link href="/2019/08/08/Java-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <id>/2019/08/08/Java-对象拷贝/</id>
    <published>2019-08-08T10:02:13.000Z</published>
    <updated>2019-11-25T10:42:27.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。</p><p>在对象属性复制过程中不同的是：</p><ul><li>如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；</li><li>如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。</li></ul><p>也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。</p><a id="more"></a><p><img src="/../images/2019_07_03_01.jpg" alt="图例"></p><h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><p>实现 Cloneable 接口：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/Student.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><p><a href></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(1, &quot;杰克&quot;);</span><br><span class="line">        Student copyStudent = (Student) student.clone();</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        student.setName(&quot;再见杰克&quot;);</span><br><span class="line">        student.setAge(2);</span><br><span class="line">        student.getSubject().setName(&quot;Subject Rename Origin Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        copyStudent.setAge(3);</span><br><span class="line">        copyStudent.setName(&quot;幻觉&quot;);</span><br><span class="line">        copyStudent.getSubject().setName(&quot;Subject Rename Copy Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printMessage(Student originStudent, Student copiedStudent) &#123;</span><br><span class="line">        System.out.println(&quot;student Name is:&quot; + originStudent.getName() + &quot; ,age is &quot; + originStudent.getAge() + &quot; , subject Name is &quot; + originStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;copyStudent Name is:&quot; + copiedStudent.getName() + &quot; ,age is &quot; + copiedStudent.getAge() + &quot; , subject Name is &quot; + copiedStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">student Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Origin Change</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject Rename Origin Change</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Copy Change</span><br><span class="line">copyStudent Name is:幻觉 ,age is 3 , subject Name is Subject Rename Copy Change</span><br><span class="line">================</span><br></pre></td></tr></table></figure><p>可以很明显的看出，如果对象的属性为对象引用时，原对象和拷贝对象指向的为同一块内存地址，当任何一个对象改变该属性时，另外一个对象的相应属性也会发生改变。</p><p><a href="https://github.com/leeGYPlus/JavaCode/tree/master/src/copy/Main.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝会赋值所有的属性，属性为基本数据类型时，直接拷贝属性值；当属性为对象引用时会同时拷贝其所指向的内存。相较于浅拷贝，深拷贝拷贝速度更慢花销会更大。</p><p>深拷贝只是借助源对象在堆中产生一份源对象的复制，自此两者互不干涉。</p><p><img src="/../images/2019_07_03_04.jpg" alt="图例"></p><h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/DeepMain.kt" target="_blank" rel="noopener">GitHub 完整代码</a></p><p>打印日志发现，对两个对象的任何操作都只对自己的对象有影响。</p><h3 id="通过序列化实现深拷贝"><a href="#通过序列化实现深拷贝" class="headerlink" title="通过序列化实现深拷贝"></a>通过序列化实现深拷贝</h3><p>序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。</p><p>需要类实现序列化相关接口。详细内容可参见序列化相关内容。</p><h3 id="如何选择拷贝类型"><a href="#如何选择拷贝类型" class="headerlink" title="如何选择拷贝类型"></a>如何选择拷贝类型</h3><p>如果对象的属性全是基本类型的，那么可以使用浅拷贝，但是如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。我的意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。</p><hr><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad" target="_blank" rel="noopener">Android Road</a></p><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/copy.html" target="_blank" rel="noopener">Java 对象的浅拷贝和深拷贝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;p&gt;浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。&lt;/p&gt;
&lt;p&gt;在对象属性复制过程中不同的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；&lt;/li&gt;
&lt;li&gt;如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="对象拷贝" scheme="/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>AIDL 浅析</title>
    <link href="/2019/08/07/AIDL-%E6%B5%85%E6%9E%90/"/>
    <id>/2019/08/07/AIDL-浅析/</id>
    <published>2019-08-07T10:01:49.000Z</published>
    <updated>2019-12-10T02:53:36.999Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL 是理解 Android 系统不可避免的知识点。</p><h3 id="0x0001-自定义-AIDL"><a href="#0x0001-自定义-AIDL" class="headerlink" title="0x0001 自定义 AIDL"></a>0x0001 自定义 AIDL</h3><p>为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。</p><p>自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。</p><a id="more"></a><ol><li>建立 java 同级目录 aidl：</li></ol><img src="/../images/2019_08_06_01.png" width="50%" height="50%"><ol><li>自定义 Aidl 文件</li></ol><p>建立与 java 目录相同的包层级结构。</p><p>定义该该过程使用到的 Java 实体类，由于类对象会在 IPC 中使用，所以 <strong>类需要实现序列化</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line">    private int bookId;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Book.aidl(需要保证 Book.java 和 Book.aidl 在相同的包层级结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure><p>定义 IBookManager.aidl 文件，添加相关方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IBookManager &#123;</span><br><span class="line">    List&lt;Book&gt; getBookList();</span><br><span class="line">    void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 aidl 的文件目录如下：</p><img src="/../images/2019_08_06_02.png" width="50%" height="50%"><ol start="3"><li>AS build 目录下生成对应的 Java 文件</li></ol><p>此处不会生成 Book.aidl 的 Java 文件，因为已经有 Book 类。</p><img src="/../images/2019_08_06_03.png" width="50%" height="50%"><p>将 build 文件中的 IBookManager.java 拷贝出来,新建 IBookManager2.java，源码如下:<a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/server/IBookManager2.java" target="_blank" rel="noopener">IBookManager.java</a></p><p>IBookManager 的内部层级结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IBookManager extends android.os.IInterface &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IBookManager 的成员方法如下：</p><img src="/../images/2019_08_08_01.png" width="50%" height="50%"><h3 id="0X0002-流程分析"><a href="#0X0002-流程分析" class="headerlink" title="0X0002 流程分析"></a>0X0002 流程分析</h3><p>为什么不生成 3 个文件(一个接口、两个类)，而是放在了一个文件中，这是因为当多个 AIDL 类时， Stub 和  Proxy 就会重名或者多个类会显得比较繁杂，而把它们放在各自的 AIDL 类中，就会比较容易区分。</p><p>下面分析如何进行跨进程通信。</p><p>起决定性作用的是 Stub 的 asInterface 方法和 onTranscact 方法，首先通过一个示意图大致了解其过程。</p><img src="/../images/2019_08_08_02.png" width="80%" height="80%"><ol><li>对于 Client 端，作为 AIDL 的使用端，调用相关方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBookManager.asInterface(IBinder 对象).addBook(Book(countId, &quot;Book $countId&quot;))</span><br></pre></td></tr></table></figure><blockquote><p>这个 Binder 对象就是在 bindService 时 Service 中的 onBinder 方法返回的 IBinder 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  override fun onBind(intent: Intent?): IBinder? &#123;</span><br><span class="line">&gt;      return mBinder</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>该方法用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.Proxy 。</p><p>asInterface 方法主要是判断参数，也就是 IBinder 对象，<strong>是和与自己同处一个进程</strong>：</p><ul><li>是，则直接转换、直接使用，则接下来的操作与 Binder 跨进程无关。</li><li>否，则会把这个 IBinder 对象包装成一个 Proxy 对象，这时调用的 Stub 的方法，间接调用 Proxy 的相应方法。</li></ul><p>此处为两者位于不同进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static IBookManager2 asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">    if ((obj == null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    if (((iin != null) &amp;&amp; (iin instanceof IBookManager2))) &#123;</span><br><span class="line">        return ((IBookManager2) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Proxy 中调用相关的方法，会使用 Pracelable 数据来准备数据，把函数名、函数的参数都写入 _data,使用 _reply 来接收函数的返回值，使用 Binder 的 transact 方法，把数据传给 Binder 的 Server 端。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void addBook(com.mk.aidldemo.Book book) throws android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    try &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        if ((book != null)) &#123;</span><br><span class="line">            _data.writeInt(1);</span><br><span class="line">            book.writeToParcel(_data, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;process proxy add&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">        // mRemote 对象为构建 Proxy 对象时传入，最终会调用 onTransact 方法</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Server 端通过 onTransact 方法来接收 Client 传过来的数据(包括函数名称、函数的参数、函数的标识)，找到指定的函数，就相应的数据传入，得到结果并将结果写回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 运行在 Binder 线程池</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteExcepti</span><br><span class="line">    String descriptor = DESCRIPTOR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(descriptor);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_getBookList: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            // 此处的 getBookList 为 Server 端中 Binder 对象中的 getBookList</span><br><span class="line">            java.util.List&lt;com.mk.aidldemo.Book&gt; _result = this.getBookList();</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            Log.e(&quot;process onTransact list&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">            // 将结果写入到 reply 中，reply 会回传到另外的进程，读取 reply 中的数据，从而完成跨进程通信</span><br><span class="line">            reply.writeTypedList(_result);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_addBook: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            com.mk.aidldemo.Book _arg0;</span><br><span class="line">            if ((0 != data.readInt())) &#123;</span><br><span class="line">                _arg0 = com.mk.aidldemo.Book.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _arg0 = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // Service 中 onBinder 方法中返回的 Binder 对象值。</span><br><span class="line">            this.addBook(_arg0);</span><br><span class="line">            Log.e(&quot;process onTransact add&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-具体分析"><a href="#0x0003-具体分析" class="headerlink" title="0x0003 具体分析"></a>0x0003 具体分析</h3><p>针对 Binder 跨进程通信机制，在每次通信过程中都需要有 Binder Client 端和 Binder Server 端。</p><p>在上面例子中应用程序进程(<code>com.mk.aidldemo</code>)为 Binder Client 端，用来发起请求，而新进程(<code>com.mk.aidldemo:remote</code>)为 Binder Server 端，用以处理请求。</p><p>在上文的流程图中，可以看到  Stub 为相应的 Binder Server 端，即为 Service 所在的进程中，我们通过加入 Log 日志，查看相应的操作执行哪个进程。</p><p>具体 Log 打点查看源码: <a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/MainActivity.kt" target="_blank" rel="noopener">GitHub 源码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/process binderService: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line"></span><br><span class="line">E/process service addBook: com.mk.aidldemo:remote</span><br><span class="line">E/process onTransact add: com.mk.aidldemo:remote</span><br></pre></td></tr></table></figure><p>可以看到在进程 <code>com.mk.aidldemo:remote</code> 中执行的操作有：onTransact 和 Server 中实例化 Binder 中的方法，即为 Binder Server 端，其他均处于 Binder Client 端。</p><p>这其中的关键方法有 mRemote.transact  和 onTransact。</p><p><strong>onTransact</strong></p><p>这个方法运行在 <strong>服务端中的 Binder线程池</strong> 中，当客户端发起跨进程请求时，远程请求会通过 <code>系统底层封装(主要是经过 binder 驱动)</code> 后交由此方法来处理。该方法的原型为<code>publicBooleanonTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>。</p><p>具体流程：</p><ol><li>服务端通过 code 可以确定客户端所请求的目标方法是什么。</li><li>从 data 中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。</li><li>当目标方法执行完毕后，就向 reply 中写入返回值（如果目标方法有返回值的话）。</li></ol><p>onTransact 方法的执行过程就是这样的。需要注意的是，如果此方法返回 false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p><p><strong>transact</strong></p><p><code>Proxy#getBookList、Proxy#addBook</code> 这个方法运行在 <strong>客户端</strong>，当客户端远程调用此方法时，它的内部实现是这样的：</p><ol><li>首先创建该方法所需要的输入型 Parcel 对象_data、输出型Parcel对象 _reply 和返回值对象 List；</li><li>然后把该方法的参数信息写入 _data 中（如果有参数的话）；</li><li><strong>接着调用 transact 方法来发起 RPC（远程过程调用）请求，同时当前线程挂起</strong>； </li><li><strong>服务端的onTransact 方法会被调用</strong>，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据。</li><li>从 _reply 获取数据，从而完成了跨进程通信。</li></ol><p>这两个方法都为 Binder 的方法，至于底层是如何实现 RPC 实现了，需学习相关细节，期待学习，关于其基本原理可以查看：<a href="https://leegyplus.github.io/2019/06/05/Binder%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#more" target="_blank" rel="noopener">Binder 基本原理</a>。</p><hr><p>知识链接：</p><p><a href="http://product.dangdang.com/25325752.html" target="_blank" rel="noopener">Android 插件化开发指南</a></p><p><a href="http://product.dangdang.com/23766472.html" target="_blank" rel="noopener">Android 开发艺术探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIDL 是理解 Android 系统不可避免的知识点。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-自定义-AIDL&quot;&gt;&lt;a href=&quot;#0x0001-自定义-AIDL&quot; class=&quot;headerlink&quot; title=&quot;0x0001 自定义 AIDL&quot;&gt;&lt;/a&gt;0x0001 自定义 AIDL&lt;/h3&gt;&lt;p&gt;为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。&lt;/p&gt;
&lt;p&gt;自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="/tags/Android/"/>
    
      <category term="AIDL" scheme="/tags/AIDL/"/>
    
  </entry>
  
  <entry>
    <title>浮点型数据的精度问题</title>
    <link href="/2019/08/01/%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>/2019/08/01/浮点型数据的精度问题/</id>
    <published>2019-08-01T10:05:17.000Z</published>
    <updated>2019-08-01T10:21:52.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何表示定点数"><a href="#如何表示定点数" class="headerlink" title="如何表示定点数"></a>如何表示定点数</h3><p>使用二进制来表示十进制的编码称为 <strong>BCD 编码</strong>。这种编码方式把小数点固定在某一位，所以其表示的数称为 <strong>定点数</strong>。</p><p>那么 4 个比特最大的表示是十进制数为 9 (1001)。</p><p>32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。</p><a id="more"></a><p>缺点：</p><ul><li>极大的浪费。本来 4 bit 可以表示 0-15，现在只可以表示 0-9。</li><li>无法表示很大和很小的数。</li></ul><h3 id="如何表示浮点数"><a href="#如何表示浮点数" class="headerlink" title="如何表示浮点数"></a>如何表示浮点数</h3><ul><li>32 bit 表示单精度的浮点数，float 或 float32。</li><li>64 bit 表示双精度的浮点数，double 或 float64。</li></ul><p>以单精度为准看如何表示浮点数</p><table><thead><tr><th>s:符号位</th><th>e:指数位</th><th>f:有效数位</th></tr></thead><tbody><tr><td>1 bit</td><td>8 bit</td><td>23 bit</td></tr></tbody></table><p>e:8 bit 组成的指数位，表示整数范围 0<del>254,其中 1</del>254 映射到带符号的整数 -126~127，这样浮点数不仅可以表示很大的数，也可以表示很小的数。</p><p>最终浮点数表示为：<br>(-1)^s×1.f×2^e (e = 指数位对应的整数 -127)</p><p>关于 e 为什么要这样计算查看 <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示–阮一峰</a> 中关于 IEEE-754 的相关内容。</p><p>以 0.5 为准：</p><p>0.5=(−1)^0×1.0×2^−1=0.5</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><h3 id="浮点数的二进制表示"><a href="#浮点数的二进制表示" class="headerlink" title="浮点数的二进制表示"></a>浮点数的二进制表示</h3><p>十进制浮点数二进制表示：9.1</p><p>9：1001</p><p>小数部分转换成二进制使用乘法操作，就是乘以 2，然后看看是否超过 1。如果超过 1，我们就记下 1，并把结果减去 1，进一步循环操作。</p><p><img src="https://static001.geekbang.org/resource/image/f9/ae/f9213c43f5fa658a2192a68cd26435ae.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.1：000110011...(0011 无限循环)</span><br><span class="line"></span><br><span class="line">9.1:1001.000110011，使用科学计数法，将小数点向左移三位，表示如下：</span><br><span class="line"></span><br><span class="line">1.001000110011..x2^3</span><br></pre></td></tr></table></figure><p>匹配浮点数表示的公式：(-1)^s×1.f×2^e </p><p>s=0、f=001000110011( 0011 循环至23位)、e=3 (根据指数位计算方式 指数位对于的十进制整数为 +3+127 = 130，对应二进制为 01111110)，所以 9.1 在 32bit 下的二进制表示为：</p><p><img src="https://static001.geekbang.org/resource/image/9a/27/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg" alt></p><p>在一位的小数中，只有 0.5 可以精确表示：</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><p>其他均为近似表示，这就是为什么浮点数计算出现精度问题的原因。</p><h3 id="浮点数的加法与精度丢失"><a href="#浮点数的加法与精度丢失" class="headerlink" title="浮点数的加法与精度丢失"></a>浮点数的加法与精度丢失</h3><p>浮点数的加法规则：<strong>先对齐，再计算</strong>。</p><p>其中对齐是将两个浮点数的指数位对齐，即通过位移使指数位相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.5 + 0.125：</span><br><span class="line"></span><br><span class="line">0.5：1.0x2^(-1)</span><br><span class="line">0.125: 1.0x2^(-3)=0.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.0x2^(-1) + 0.01x2^(-1) = 1.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.01x2^(-1) 的十进制表示为 0.625</span><br></pre></td></tr></table></figure><p>在加法前，浮点型数据的二进制表示就可能会发生精度丢失，如果相加的两个数相差比较大，那么在指数对齐过程中，有可能会丢失有效位，位移就会越大，那么丢失的精度就越大，那么产生的误差也会越大。但是如果丢失的全为 0 ，那么加法的数值不会有精度丢失。</p><h3 id="如何避免精度损失"><a href="#如何避免精度损失" class="headerlink" title="如何避免精度损失"></a>如何避免精度损失</h3><p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm" target="_blank" rel="noopener"><strong>Kahan Summation 算法</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class KahanSummation &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    float sum = 0.0f;</span><br><span class="line">    float c = 0.0f;</span><br><span class="line">    for (int i = 0; i &lt; 20000000; i++) &#123;</span><br><span class="line">    float x = 1.0f;</span><br><span class="line">    float y = x - c;</span><br><span class="line">    float t = sum + y;</span><br><span class="line">    c = (t-sum)-y;</span><br><span class="line">    sum = t;    </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sum is &quot; + sum);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 BigDecimal</strong></p><p>BigDecimal 是专门为弥补浮点数无法精确计算的缺憾而设计的，它本身提供了加减乘除。</p><p><strong>使用整型</strong></p><p>如果保留小数点后 2 位，那么将参与运算的值扩大 100 倍 并转换为整型，在展示时再缩小 100 倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何表示定点数&quot;&gt;&lt;a href=&quot;#如何表示定点数&quot; class=&quot;headerlink&quot; title=&quot;如何表示定点数&quot;&gt;&lt;/a&gt;如何表示定点数&lt;/h3&gt;&lt;p&gt;使用二进制来表示十进制的编码称为 &lt;strong&gt;BCD 编码&lt;/strong&gt;。
这种编码方式把小数点固定在某一位，所以其表示的数称为 &lt;strong&gt;定点数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么 4 个比特最大的表示是十进制数为 9 (1001)。&lt;/p&gt;
&lt;p&gt;32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="极客时间笔记" scheme="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浮点型精度问题" scheme="/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hprof 拾遗</title>
    <link href="/2019/07/09/Hprof-%E6%8B%BE%E9%81%97/"/>
    <id>/2019/07/09/Hprof-拾遗/</id>
    <published>2019-07-09T09:43:11.000Z</published>
    <updated>2019-07-09T09:45:56.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-引用一"><a href="#0x0001-引用一" class="headerlink" title="0x0001 引用一"></a>0x0001 引用一</h3><p>以下内容来自：<a href="https://www.baeldung.com/java-heap-dump-capture" target="_blank" rel="noopener">Different Ways to Capture Java Heap Dumps</a></p><p>A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. <strong>Heap dumps are usually stored in binary format hprof files.</strong> </p><a id="more"></a><h3 id="0x0002-引用二"><a href="#0x0002-引用二" class="headerlink" title="0x0002 引用二"></a>0x0002 引用二</h3><p>以下内容来自：<a href="https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/heapdump.html" target="_blank" rel="noopener">Understanding heap dumps</a></p><p><strong>A heap dump is a snapshot of the memory of a Java™ process</strong>.</p><p>The snapshot contains information about the Java objects and classes in the heap at the moment the snapshot is triggered. Because there are different formats for persisting this data, there might be some differences in the information provided. Typically, a full garbage collection is triggered before the heap dump is written, so the dump contains information about <strong>the remaining objects in the heap</strong>.</p><p>The Memory Analyzer works with HPROF binary heap dumps, IBM® system dumps, and IBM portable heap dumps (PHD) from various platforms. See Supported dump file types.</p><p>Typical information in a heap dump, depending on the heap dump type, includes(堆转储文件中包含的信息):</p><p><strong>All Objects</strong></p><pre><code>Class, fields, primitive values, and references.</code></pre><p><strong>All Classes</strong></p><pre><code>Class loader, name, super class, and static fields.</code></pre><p><strong>Garbage collection roots</strong></p><pre><code>Objects defined to be reachable by the JVM.</code></pre><p><strong>Thread Stacks and Local Variables</strong></p><pre><code>Call-stacks of threads at the moment of the snapshot, and information about local objects on a frame by frame basis.</code></pre><h3 id="0x0003-Android-中的-Hprof"><a href="#0x0003-Android-中的-Hprof" class="headerlink" title="0x0003 Android 中的 Hprof"></a>0x0003 Android 中的 Hprof</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.dumpHprofData(String filePath);</span><br></pre></td></tr></table></figure><p>在 Android 中使用以上代码将对转储文件生成到指定的文件上。</p><p>在 AS 中如何分析 Hprof 见官方文档：<a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-引用一&quot;&gt;&lt;a href=&quot;#0x0001-引用一&quot; class=&quot;headerlink&quot; title=&quot;0x0001 引用一&quot;&gt;&lt;/a&gt;0x0001 引用一&lt;/h3&gt;&lt;p&gt;以下内容来自：&lt;a href=&quot;https://www.baeldung.com/java-heap-dump-capture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Different Ways to Capture Java Heap Dumps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. &lt;strong&gt;Heap dumps are usually stored in binary format hprof files.&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Hprof" scheme="/tags/Hprof/"/>
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 LeakCanary(1.6.3之前版本) 寻找内存泄漏位置</title>
    <link href="/2019/07/04/LeakCanary-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>/2019/07/04/LeakCanary-是如何工作的/</id>
    <published>2019-07-04T07:40:01.000Z</published>
    <updated>2019-07-10T03:16:54.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何使用-Leakmemory-泄漏链路-Trace-图"><a href="#如何使用-Leakmemory-泄漏链路-Trace-图" class="headerlink" title="如何使用 Leakmemory 泄漏链路(Trace 图)"></a>如何使用 Leakmemory 泄漏链路(Trace 图)</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.</p></blockquote><a id="more"></a><blockquote><p>[个人译] 如果你知道在 Trace 图中出现的对象是否应该存在于内存中，这会帮助你很好的分析内存泄漏位置。如果对象不应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象上面的位置；如果对象应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象下面的位置。</p></blockquote><blockquote><p>[12:37] Method:<br>Find an object and ask should this object should be alive or should be in garbage collection?</p></blockquote><h3 id="如何使用-package-leakmomory-进程进行问题定位"><a href="#如何使用-package-leakmomory-进程进行问题定位" class="headerlink" title="如何使用 package:leakmomory 进程进行问题定位"></a>如何使用 package:leakmomory 进程进行问题定位</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[15：00] Should this object should be alive at this point in time? how we know that?</p></blockquote><p>不只是根据 leakcanary 在手机上的 Trace 图，leakcanary 可以在 package:leakmomory 进程显示详细的 Trace 日志。其实现在手机上的 Trace 图也可以显示出关键的 Trace 日志，只是手机品牌不同显示的详细程度不同，如果手机上信息语言简略，推荐查看 AS 中 package:leakmomory 中的相关日志。</p><!-- ![展示](/../images/2019_07_03_05.jpg) --><p><strong>package:leakmomory 中关于对象的详细信息</strong>：</p><img src="/../images/2019_07_03_05.jpg" height="70%" width="70%"><p>图中包名显示为 package:leakmomory 线程，以下为 Trace 的详细信息。</p><blockquote><p>[16：00] We will dump the states of every singleInstance and that’s where you can find the problem.</p></blockquote><p>可以在这里可以根据实例对象或其属性值判断每个实例是否应该被回收，当然这需要相应有关该类的一些知识。如果该实例对象应该被回收，那么说明内存泄漏的对象在上面。</p><p>在上面的视频中的一个例子：</p><pre><code>根据 LeakCanary 的内存泄漏 Trace 图，发现存在 ChangeHandlerFramLayout 对象存在泄漏链路中，在 leakmomory 进程中可以详细获知该对象的各个属性值，从而可以判断该对象的状态。在此处中 ChangeHandlerFramLayout 对象的 mAttachInfo = null，说明该对象不再与屏幕关联，该对象在此时应该被 GC 回收掉，不应该存活，说明内存泄漏是 Trace 图上面的对象引起的，进一步定位内存泄漏位置。</code></pre><!-- ![Trace 图](/../images/2019_07_05_01.jpg) --><p><strong>Trace</strong> 图：</p><img src="/../images/2019_07_05_01.jpg" height="50%" width="50%"><!-- ![ChangeHandlerFramLayout 对象](/../images/2019_07_05_02.png) --><p><strong>ChangeHandlerFramLayout</strong> 对象：</p><img src="/../images/2019_07_05_02.png" height="70%" width="70%"><!-- ![ChangeHandlerFramLayout 对象的 mAttachInfo 值](/../images/2019_07_05_03.png) --><p><strong>ChangeHandlerFramLayout 对象的 mAttachInfo 值</strong>：</p><img src="/../images/2019_07_05_03.png" height="70%" width="70%"><p>接下来分析了位于 ChangeHandlerFramLayout 上的 MainActivity 实例对象，同理，在 leakmomory 查看该实例的状态，与ChangeHandlerFramLayout 对象不同的是此时我们关注属性值为 mDestoryed = true，说明 MainActivity 对象已经销毁，说明该对象也应该被 GC 回收。</p><p>如此往复，结合 trace 图和 leakmomory 进程信息，判断对象是否应该存在，<strong>不过根据对象的不同，判断该对象是否应该存活标准不同</strong>，如例子中的 mAttachInfo、mDestoryed。</p><h3 id="LeakCanary-实践一"><a href="#LeakCanary-实践一" class="headerlink" title="LeakCanary 实践一"></a>LeakCanary 实践一</h3><p>使用官方 <a href="https://github.com/square/leakcanary/tree/v1.6.3" target="_blank" rel="noopener">LeakCanary 1.6.3 </a> 库的 demo 进行展示如何定位内存泄漏。此处演示的为 LeakCanary 1.6.3 ，master 分支已于 2019-05-21 变更为 由 1.x 变更为 2.x ，具体查看 <a href="https://github.com/square/leakcanary/blob/4bbc0f6f2e3c9a25ca890ece6770f81cf9059510/docs/changelog.md" target="_blank" rel="noopener">Chnage Log</a>。</p><p>LeakCanary 2.x 功能更加全面，定位难度更加简单，但是方法基本一致，这里以 1.6.3 版本为主展示如何寻找内存泄漏位置。</p><!-- ![Trace 图](/../images/2019_07_05_04.png) --><p><strong>Demo 的 Trace 图为</strong>：</p><img src="/../images/2019_07_05_04.png" height="50%" width="50%"><!-- ![MainActivity 相关信息](/../images/2019_07_05_05.png) --><p>点击 MainActivity 所在行，显示详细信息。<br><strong>详细信息</strong>：</p><img src="/../images/2019_07_05_05.png" height="50%" width="50%"><p>可以发现 MainActivity 的 mDestoryed = true,说明 MainActivity 应该被 GC 回收，那么内存泄漏的应该发生在 <strong>之上</strong>。</p><!-- ![MainActivity$2.this.0 相关信息](/../images/2019_07_05_06.png) --><p>点击 <code>MainActivity$2.this$0</code> 显示具体信息:</p><img src="/../images/2019_07_05_06.png" height="70%" width="70%"><p>从图中得知 <code>MainActivity$2.this$0</code> 为 <strong>anonymous implent Runnable(继承 Runnble 的匿名对象)</strong> 。从截图中值 <code>this$0</code> 为 <code>com.example.MainActivity</code> 实例对象,此时 <code>this$0</code> 所指向的 MainActivity 在旋转屏幕后会被销毁、被回收，但是 <code>Runnable 对象</code> 执行后台任务导致 <code>MainActivity$2</code> 对象依旧存在,即该对象此时应该存在于内存中，那么导致其所持有的 MainActivity 引用不能被回收，从而导致了 MainActivity 对象的泄漏。</p><p>匿名对象的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable work = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>这在 Java 中是一个经典的内存泄漏的案例，原因是匿名对象持有外部类的引用引起的，我们要做的就是将匿名对象静态化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class CustomRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CustomRunnable work = new CustomRunnable();</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>针对匿名内部类具体分析一下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line"></span><br><span class="line">        Runnable work = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // Do some slow work in background</span><br><span class="line">//                SystemClock.sleep(20000</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(work).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Java 命令编译该 Java 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>编译出两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Main.class</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public Main() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        Runnable var1 = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        (new Thread(var1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Main$1.class</span><br><span class="line">class Main$1 implements Runnable &#123;</span><br><span class="line">    Main$1(Main var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>this$0</code> 就为上面截图中的 <code>com.example.MainActivity</code> 实例对象，所以匿名内部类持有外部类的引用。</p><h3 id="LeakCanary-实践二"><a href="#LeakCanary-实践二" class="headerlink" title="LeakCanary 实践二"></a>LeakCanary 实践二</h3><p>这个例子更能够体现一步一步寻找内存泄漏点：</p><p>首先此次内存泄漏产生的 Trace 图如下：</p><!-- ![Trace 图](/../images/2019_07_06_01.png) --><p><strong>步骤一： Trace 图</strong></p><img src="/../images/2019_07_06_01.png" height="50%" width="50%"><p>首先我们通过截图 Title( MainActivity Leaked)明确 <strong>产生泄漏的对象为 MainActivity 的实例对象</strong>，Title 下面展示产生泄漏的 Trace 图。</p><p>我们根据 Trace 图一步一步分析:</p><p><strong>步骤二</strong>：</p><img src="/../images/2019_07_06_02.png" height="50%" width="50%"><p><strong>步骤三</strong>：</p><img src="/../images/2019_07_06_03.png" height="50%" width="50%"><p><strong>步骤四</strong>：</p><img src="/../images/2019_07_06_04.png" height="50%" width="50%"><p><strong>步骤五</strong>：</p><img src="/../images/2019_07_06_05.png" height="50%" width="50%"><p><strong>步骤六</strong>：</p><img src="/../images/2019_07_06_06.png" height="50%" width="50%"><!-- ![步骤一](/../images/2019_07_06_02.png) --><!-- ![步骤二](/../images/2019_07_06_03.png) --><!-- ![步骤三](/../images/2019_07_06_04.png) --><!-- ![步骤四](/../images/2019_07_06_05.png) --><!-- ![步骤五](/../images/2019_07_06_06.png) --><p>通过以上步骤，我们知道由于反转屏幕后 MainActivity 中的 Button 实例对象需要被回收，但是由于 HttpRequestHelper 对象在反转屏幕后继续存在，同时 HttpRequestHelper 实例对象持有 Button 对象的引用，所以 Button 不能成功被回收，导致 Button 持有的 MainActivity 实例对象在  Destory 后不能成功销毁，从而导致了 MainActivity 内存泄漏。</p><p>为了验证以上结论，我们可以继续向上查看 Trace：</p><!-- ![验证一](/../images/2019_07_06_07.png)![验证二](/../images/2019_07_06_08.png) --><img src="/../images/2019_07_06_07.png" height="50%" width="50%"><p><strong>实例对象详细信息</strong>：</p><img src="/../images/2019_07_06_08.png" height="50%" width="50%"><hr><p><strong>有用的资源：</strong></p><p><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">leakcanary 官方网站</a></p><p><a href="https://square.github.io/leakcanary/fundamentals/" target="_blank" rel="noopener">leakcanary 基本原理</a></p><p><a href="https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745" target="_blank" rel="noopener">Detect all memory</a></p><p><a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><p><a href="https://www.youtube.com/watch?v=LEX8dn4BLUw" target="_blank" rel="noopener">LeakCanary 2: Leaner, Better, Faster, Kotliner! by Pierre-Yves Ricau, Square, Inc EN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何使用-Leakmemory-泄漏链路-Trace-图&quot;&gt;&lt;a href=&quot;#如何使用-Leakmemory-泄漏链路-Trace-图&quot; class=&quot;headerlink&quot; title=&quot;如何使用 Leakmemory 泄漏链路(Trace 图)&quot;&gt;&lt;/a&gt;如何使用 Leakmemory 泄漏链路(Trace 图)&lt;/h3&gt;&lt;p&gt;以下英文部分摘自 &lt;a href=&quot;https://www.youtube.com/watch?v=KwArTJHLq5g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="LeakCanary" scheme="/tags/LeakCanary/"/>
    
      <category term="内存优化" scheme="/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>刷机资源</title>
    <link href="/2019/06/26/%E5%88%B7%E6%9C%BA%E8%B5%84%E6%BA%90/"/>
    <id>/2019/06/26/刷机资源/</id>
    <published>2019-06-26T09:42:53.000Z</published>
    <updated>2020-02-26T02:54:06.698Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-TWRP"><a href="#1-TWRP" class="headerlink" title="1.TWRP"></a>1.TWRP</h3><p><a href="https://twrp.me/Devices/" target="_blank" rel="noopener">TeamWin - TWRP</a></p><h3 id="2-SuperSu"><a href="#2-SuperSu" class="headerlink" title="2.SuperSu"></a>2.SuperSu</h3><p><a href="http://www.supersu.com/download" target="_blank" rel="noopener">SuperSu</a></p><p>2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。</p><a id="more"></a><h3 id="3-Magisk"><a href="#3-Magisk" class="headerlink" title="3.Magisk"></a>3.Magisk</h3><p><a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445" target="_blank" rel="noopener">Magisk</a></p><p><a href="https://github.com/topjohnwu/Magisk" target="_blank" rel="noopener">Magisk-Github</a></p><p><a href="https://github.com/topjohnwu/Magisk/releases" target="_blank" rel="noopener">Magisk App 下载地址</a></p><p><a href="https://www.technobuzz.net/download-and-install-magisk-manager/" target="_blank" rel="noopener">android 9.0 Magisk 实现 root  </a></p><!-- ### Xposed Framework --><p><a href="https://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">Xposed</a></p><h3 id="4-Rom-资源"><a href="#4-Rom-资源" class="headerlink" title="4.Rom 资源"></a>4.Rom 资源</h3><p><a href="https://www.lineageos.org/" target="_blank" rel="noopener">LineageOS</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/lineage-rom/full/" target="_blank" rel="noopener">LineageOS 清华源</a></p><p><a href="https://download.pixelexperience.org/" target="_blank" rel="noopener">xda room 资源</a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>开机状态下：<br>adb reboot fastboot   命令进入fastboot模式<br>adb reboot recovery　命令行进recovery模式<br>power +　音量下　recovery 模式</p><p>关机状态下：<br>power + 音量下 recovery 模式<br>power + 音量上 fastboot 模式<br>recovery 模式下可以选择进入fastboot 模式</p><p><a href="https://blog.csdn.net/u012169524/article/details/51222859" target="_blank" rel="noopener">Fastboot烧机命令详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-TWRP&quot;&gt;&lt;a href=&quot;#1-TWRP&quot; class=&quot;headerlink&quot; title=&quot;1.TWRP&quot;&gt;&lt;/a&gt;1.TWRP&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://twrp.me/Devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TeamWin - TWRP&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-SuperSu&quot;&gt;&lt;a href=&quot;#2-SuperSu&quot; class=&quot;headerlink&quot; title=&quot;2.SuperSu&quot;&gt;&lt;/a&gt;2.SuperSu&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.supersu.com/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SuperSu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android 刷机" scheme="/tags/Android-%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>灵感来源</title>
    <link href="/2019/06/12/%E7%81%B5%E6%84%9F%E6%9D%A5%E6%BA%90/"/>
    <id>/2019/06/12/灵感来源/</id>
    <published>2019-06-12T10:54:16.000Z</published>
    <updated>2019-06-12T10:54:16.689Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/" target="_blank" rel="noopener">GayHub 交友社区</a></p><p><a href="https://www.ctolib.com/article/compares/53292" target="_blank" rel="noopener">CTOLib码库</a></p><p><a href="https://p.codekk.com/" target="_blank" rel="noopener">CodeKK</a></p><p><a href="https://www.diycode.cc/categories/Android" target="_blank" rel="noopener">diycode</a></p><p><a href="https://android-arsenal.com/" target="_blank" rel="noopener"> Android Arsenal</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GayHub 交友社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctolib.com/article/compares/5329
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化之优化 App 启动速度</title>
    <link href="/2019/06/11/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BC%98%E5%8C%96-App-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    <id>/2019/06/11/性能优化之优化-App-启动速度/</id>
    <published>2019-06-11T09:13:48.000Z</published>
    <updated>2019-06-11T09:13:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>主要面临的问题：<br> APP 冷启动白屏。</p><p>针对于这个问题，基本上主流的解决方法存在两个：</p><pre><code>1. 主题替换。2. 减少冷启动时主线程的工作量。</code></pre><p>本文的重点不在解决问题方法，而在于解决问题的过程，包括影响启动速度的因素、时间统计工具、解决思路。</p><p>优化 App 启动速度主要是优化冷启动时的 App 启动速度，官方文档 (<a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a>) 中指出优化冷启动方式的同时，温启动和热启动也会得到改善。</p><p>在分析过程之前，首先了解启动方式。</p><h3 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h3><ul><li><p>冷启动</p><p>App 安装后第一次启动或者杀死 App 进程后重新启动称为冷启动。冷启动的启动成本较高，一切都要重新建立，包括新建应用进程、初始化应用以及首页的布局、渲染等操作。</p></li></ul><ul><li><p>热启动</p><p>  App 所在进程存活，并且所有 Activity 均未被销毁，热启动做的只是把应用从后台切换至前台，如果 Activity 实例中的被回收的实例变量会重新创建。</p><p>  具体场景为在微信中切换到桌面，后马上回到微信。</p></li><li><p>温启动</p><p>  Activity 被杀死但是 App 所在的进程在内存中依然存在。</p></li></ul><h4 id="启动时间组成"><a href="#启动时间组成" class="headerlink" title="启动时间组成"></a>启动时间组成</h4><p>很多时候解决问题需要我们拥有上帝视角，全面把控事态的发展，跳出事件本身，以俯视的角度看待整个流程，找出问题的关键点。总的来说我们需要纵观全局来看待问题、解决问题。</p><p>从在 Launcher 中点击 App 的 icon 到 App 的第一面展示的时间差称为冷启动时间，那么这段时间整个系统都经历了什么。用上帝之眼看待整个流程，从而寻找解决问题的切入点，首先我们分析一下整个过程都经历了什么。</p><p>在 Launcher 中我们点击 App 图标，经过一系列过程，涉及 AMS、 Binder、IPC 等组件和过程。</p><p>在启动 App 的主页面之前，系统操作如下：</p><ol><li>创建并启动 App 所在应用</li><li>启动 App 后会马上展示系统的 start window</li><li>创建 App 进程</li></ol><p>在系统创建完成 App 所在的进程后，App 进程负责完成下列一系列步骤：</p><ol><li>创建 App 对象</li><li>启动 App 主线程</li><li>创建主 Activity</li><li>加载 View 视图</li><li>布局屏幕</li><li>执行初始化绘制 View</li></ol><p>在 App 进程完成第一帧的绘制后，start window 会被替换，此时在屏幕上展示的就是在主 Activity 加载的布局。</p><p><img src="/../images/2019_06_01_01.png" alt="App 页面替换"></p><p>根据 <a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Colt McAnlis</a> 在 Yutobe 上的关于 App 启动时间的描述，以上过程可以形象的图形化表示如下：</p><p><img src="/../images/2019_06_01_02.png" alt="App 启动时间"></p><h4 id="为什么是白屏或黑屏"><a href="#为什么是白屏或黑屏" class="headerlink" title="为什么是白屏或黑屏"></a>为什么是白屏或黑屏</h4><p>在清单文件中我们需要设置 Application 的 Theme，比如自己设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        ...</span><br><span class="line">        android:theme=&quot;@style/sixcatTheme&quot;&gt;</span><br></pre></td></tr></table></figure><p>我们需要查看 sixcatTheme 主题的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;style name=&quot;sixcatTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">2. &lt;style name=&quot;Theme.AppCompat.Light&quot; parent=&quot;Base.Theme.AppCompat.Light&quot;/&gt;</span><br><span class="line"></span><br><span class="line">3. &lt;style name=&quot;Base.Theme.AppCompat.Light&quot; parent=&quot;Base.V7.Theme.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">4. &lt;style name=&quot;Base.V7.Theme.AppCompat.Light&quot; parent=&quot;Platform.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">5. &lt;style name=&quot;Platform.AppCompat.Light&quot; parent=&quot;android:Theme.Holo.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">6. &lt;style name=&quot;Theme.Holo.Light&quot; parent=&quot;Theme.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. &lt;style name=&quot;Theme.Light&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">8. &lt;style name=&quot;Theme&quot;&gt;</span><br></pre></td></tr></table></figure><p>层级自 1~8 自上而下具有继承关系。</p><p>可以看到在第 7 层中存在 windowBackground 属性，这是一路下来与背景唯一相关属性。</p><p>看一下 windowBackground 的 drawable 显示如何：</p><p><img src="/../images/2019_06_11_01.jpg" alt="drawable"></p><p>事实证明确实是这个属性决定着点击 App 后显示的白屏或黑屏，当然这也为解决此问题提供了一个思路。</p><p>官方图</p><p>拆解为两部分。</p><p>分析、找出优化点</p><h4 id="启动时间统计"><a href="#启动时间统计" class="headerlink" title="启动时间统计"></a>启动时间统计</h4><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>更换主题</p><p>截图 + 解决方法 + 截图</p><p>延时加载</p><p>CPU profile<br>trace 文件<br>命令行<br>Displayed Time</p><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>在原来的 MainActivity 设定的主题中添加以上代码。</p><p>带来的效果：<br>透明效果，即点击 App icon 后的白屏时间变为 透明 状态，避免了白屏，但是两者的时间几乎相同。给人的错觉时点击 icon 后一段时间后，app 才调起，给人的印象不好。</p><p>方法二 主题替换</p><p>在 App 启动时</p><hr><p>App 启动时间统计</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W package/activity</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Google Developer</a></p><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Youtube 性能优化视频</a></p><p><a href="https://www.zhihu.com/question/35487841" target="_blank" rel="noopener">https://www.zhihu.com/question/35487841</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要面临的问题：&lt;br&gt; APP 冷启动白屏。&lt;/p&gt;
&lt;p&gt;针对于这个问题，基本上主流的解决方法存在两个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 主题替换。
2. 减少冷启动时主线程的工作量。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文的重点不在解决问题方法，而在于解决问题的过程，
      
    
    </summary>
    
    
      <category term="性能优化" scheme="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binder基本原理</title>
    <link href="/2019/06/05/Binder%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>/2019/06/05/Binder基本原理/</id>
    <published>2019-06-05T05:33:02.000Z</published>
    <updated>2019-12-10T03:02:10.482Z</updated>
    
    <content type="html"><![CDATA[<p>Binder 机制是 Android 特有的跨进程通信机制，本文为 <a href>Android 插件化开发</a> 相关章节的阅读笔记。</p><h4 id="00x01"><a href="#00x01" class="headerlink" title="00x01"></a>00x01</h4><p>Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。</p><h4 id="00x02"><a href="#00x02" class="headerlink" title="00x02"></a>00x02</h4><p>Binder 组成：</p><ul><li>Client</li><li>Server</li><li>ServerManager(管理 Server )</li></ul><a id="more"></a><h4 id="00x03"><a href="#00x03" class="headerlink" title="00x03"></a>00x03</h4><p>为了更好的帮助读者理解，我们可以看一个场景：<strong>打电话</strong>。</p><ul><li>ServerManager: 相当于电话局，储存每个用户的电话。</li><li>Client: 用户 A</li><li>Server: 用户 B</li></ul><p><code>用户 A 向用户 B 拨打电话</code></p><ol><li>A 拨打电话</li><li>电话会被转接到电话局</li><li>电话局查询 A 拨打的电话，若电话存在，则接通电话；若电话不存在，则提示该号码不存在。</li></ol><p>在这个过程中还有一个十分重要的角色：<strong>接线员</strong>，它做了很多事情，承担了十分重要的角色，映射到 Binder 机制，接线员相当于 <strong>Binder 驱动</strong>。</p><h4 id="00x04"><a href="#00x04" class="headerlink" title="00x04"></a>00x04</h4><p>Binder 基本运行机制如下图：</p><p><img src="/../images/2019_06_05_01.jpg" alt="Binder 运行机制"></p><h4 id="00x05-Binder-的通信过程"><a href="#00x05-Binder-的通信过程" class="headerlink" title="00x05 Binder 的通信过程"></a>00x05 Binder 的通信过程</h4><p>假如 Client 进程调用 Server 进程中的方法 add(),因为两者隶属于不同进程，此时需要在 Binder 的协助下完成 IPC(Inter-process Communication) 通信。</p><ol><li>Server 端在 SM(ServerManager) 中完成注册。</li><li>Client 要想调用 Server 的 add 方法，必须获得 Server 对象，但是 SM 不会吧真正的 Server 对象返回给 Client，而是把 Server 的代理对象 Proxy 返回给 Client。</li><li>Client 调用 Proxy 中的 add 方法，SM 会帮助它调用 Server 的 add 方法，并把结果返回给 Client。</li></ol><p>此时 Client 和 Server 实现了进程间通信，在此过程中 Binder 驱动做了许多事情，但是我们目前不需要关心。</p><p><img src="/../images/2019_06_05_02.png" alt="Binder 通信过程"></p><p>来自 Gityuan 的一张特别形象的 Binder IPC 流程图：</p><p><img src="http://gityuan.com/images/android-arch/IPC-Binder.jpg" alt="Binder IPC通信过程"></p><h4 id="00x06"><a href="#00x06" class="headerlink" title="00x06"></a>00x06</h4><p>在研究系统框架或第三方库时，我们不要陷入细节中，要先熟悉基本的运行机制、运行流程，根据自我需求，选择性的查看实现细节，但是需要注意的还是不能陷入细节，要有的放矢的跳出细节，把控全局。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binder 机制是 Android 特有的跨进程通信机制，本文为 &lt;a href&gt;Android 插件化开发&lt;/a&gt; 相关章节的阅读笔记。&lt;/p&gt;
&lt;h4 id=&quot;00x01&quot;&gt;&lt;a href=&quot;#00x01&quot; class=&quot;headerlink&quot; title=&quot;00x01&quot;&gt;&lt;/a&gt;00x01&lt;/h4&gt;&lt;p&gt;Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。&lt;/p&gt;
&lt;h4 id=&quot;00x02&quot;&gt;&lt;a href=&quot;#00x02&quot; class=&quot;headerlink&quot; title=&quot;00x02&quot;&gt;&lt;/a&gt;00x02&lt;/h4&gt;&lt;p&gt;Binder 组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;ServerManager(管理 Server )&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Binder" scheme="/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 资源网站集</title>
    <link href="/2019/05/30/Kindle-%E8%B5%84%E6%BA%90%E9%9B%86/"/>
    <id>/2019/05/30/Kindle-资源集/</id>
    <published>2019-05-30T02:28:29.000Z</published>
    <updated>2020-02-26T02:54:06.366Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kaka3.com/" target="_blank" rel="noopener">kaka</a></p><p><a href="http://www.ireadweek.com/index.php/Index/index.html" target="_blank" rel="noopener">行行</a></p><a id="more"></a><p><a href="http://www.tushugu.com/" target="_blank" rel="noopener">图书馆</a></p><p><a href="https://book.shuyuzhe.com/" target="_blank" rel="noopener">书语者</a></p><p><a href="https://bookset.me/" target="_blank" rel="noopener">Bookset</a></p><p><a href="https://kgbook.com/" target="_blank" rel="noopener">苦瓜书盘</a></p><p><a href="http://mebook.cc/" target="_blank" rel="noopener">我的小书屋</a></p><p><a href="https://www.itpanda.net/book/" target="_blank" rel="noopener">IT熊猫</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.kaka3.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kaka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ireadweek.com/index.php/Index/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;行行&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kindle" scheme="/tags/Kindle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合工具类--Collections</title>
    <link href="/2019/05/29/Java%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/"/>
    <id>/2019/05/29/Java集合工具类-Collections/</id>
    <published>2019-05-29T09:17:24.000Z</published>
    <updated>2019-12-03T03:41:50.857Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的</strong>，如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 <strong>线程同步问题</strong>。</p><p>Java 提供了 Collections 工具类，使用 synchronizedxxx()  方法可以将集合类包装成线程安全的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections collections = Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"></span><br><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br><span class="line"></span><br><span class="line">Set set = Collections.synchronizedSet(new HashSet());</span><br><span class="line"></span><br><span class="line">Map map = Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure><p>同时 Collections 还提供了排序、查找、替换、设置不可变集合等功能，有空自己看 API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的&lt;/strong&gt;，
如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 &lt;strong&gt;线程同步问
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Collections" scheme="/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础学习五--条件判断</title>
    <link href="/2019/05/25/Shell-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%BA%94-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <id>/2019/05/25/Shell-基础学习五-条件判断/</id>
    <published>2019-05-25T12:58:50.000Z</published>
    <updated>2019-11-25T13:02:19.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两种判断格式"><a href="#1-两种判断格式" class="headerlink" title="1. 两种判断格式"></a>1. 两种判断格式</h3><ul><li>方式一<blockquote><p>test -e /root/install.log</p></blockquote></li></ul><ul><li>方式二<blockquote><p>[ -e /root/install.log ]</p></blockquote></li></ul><a id="more"></a><p>在 Shell 中多采用这种方式进行判断。</p><h3 id="2-按照文件类型进行判断"><a href="#2-按照文件类型进行判断" class="headerlink" title="2. 按照文件类型进行判断"></a>2. 按照文件类型进行判断</h3><p><img src="/../images/2019_09_22_01.png" alt></p><p>用蓝色字体标记的判断较为常用。</p><blockquote><p>[ -d /root ] &amp;&amp; echo “yes” || echo “no”</p></blockquote><p>第一个判断命令如果正确执行，则打印“yes”，否则打 印“no”</p><h3 id="3-按照文件权限进行判断"><a href="#3-按照文件权限进行判断" class="headerlink" title="3. 按照文件权限进行判断"></a>3. 按照文件权限进行判断</h3><p><img src="/../images/2019_09_22_02.png" alt></p><blockquote><p> [ -w student.txt ] &amp;&amp; echo “yes” || echo “no”</p></blockquote><p>判断文件是拥有写权限的，但是此种方式不会区别用户组。</p><h3 id="4-两个文件之间的比较"><a href="#4-两个文件之间的比较" class="headerlink" title="4. 两个文件之间的比较"></a>4. 两个文件之间的比较</h3><p><img src="/../images/2019_09_22_03.png" alt></p><p>简单理解：</p><p>nt: new to<br>ot: old to<br>ef: equal file</p><p>测试：</p><blockquote><p>ln /root/student.txt /tmp/stu.txt</p></blockquote><p>创建个硬链接吧</p><blockquote><p>[ /root/student.txt -ef /tmp/stu.txt ] &amp;&amp; echo “yes” || echo “no” yes</p></blockquote><p>用test测试下。</p><h3 id="5-两个整数之间的比较"><a href="#5-两个整数之间的比较" class="headerlink" title="5. 两个整数之间的比较"></a>5. 两个整数之间的比较</h3><p><img src="/../images/2019_09_22_04.png" alt></p><blockquote><p>[ 23 -ge 22 ] &amp;&amp; echo “yes” || echo “no” yes</p></blockquote><h3 id="6-两个字符串间的比较"><a href="#6-两个字符串间的比较" class="headerlink" title="6. 两个字符串间的比较"></a>6. 两个字符串间的比较</h3><p><img src="/../images/2019_09_22_05.png" alt></p><blockquote><p> name=sc</p></blockquote><p>给name变量赋值</p><blockquote><p>[ -z “$name” ] &amp;&amp; echo “yes” || echo “no” no</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">[ &quot;$aa&quot; == &quot;bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; no</span><br></pre></td></tr></table></figure><h3 id="7-多重条件的判断"><a href="#7-多重条件的判断" class="headerlink" title="7. 多重条件的判断"></a>7. 多重条件的判断</h3><p><img src="/../images/2019_09_22_07.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">[ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> aa=24</span><br><span class="line">[ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot; yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-两种判断格式&quot;&gt;&lt;a href=&quot;#1-两种判断格式&quot; class=&quot;headerlink&quot; title=&quot;1. 两种判断格式&quot;&gt;&lt;/a&gt;1. 两种判断格式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;方式一&lt;blockquote&gt;
&lt;p&gt;test -e /root/install.log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;方式二&lt;blockquote&gt;
&lt;p&gt;[ -e /root/install.log ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础学习四 -- 字符处理命令</title>
    <link href="/2019/05/25/Shell-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/05/25/Shell-基础学习四-字符处理命令/</id>
    <published>2019-05-25T12:58:07.000Z</published>
    <updated>2019-11-25T13:02:05.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sort：排序命令"><a href="#sort：排序命令" class="headerlink" title="sort：排序命令"></a>sort：排序命令</h3><p>支持管道符。</p><blockquote><p>sort [选项] 文件名</p></blockquote><p>选项：</p><a id="more"></a><ul><li>-f: 忽略大小写</li><li>-n: 以数值型进行排序，默认使用字符串型排序 </li><li>-r: 反向排序 </li><li>-t: 指定分隔符，默认是分隔符是制表符</li><li>-k n[,m]:按照指定的字段范围排序。从第n字段开始， m字段结束(默认到行尾)</li></ul><blockquote><p>sort /etc/passwd</p></blockquote><blockquote><p>sort -r /etc/passwd<br> 反向排序</p></blockquote><blockquote><p>sort -t “:” -k 3,3 /etc/passwd</p></blockquote><p> 指定分隔符是“:”，用第三字段开头，第三字段结尾排 序，就是只用第三字段排序，此时标记的第3个字段为字符排序，要想以数字排序，使用如下格式：</p><blockquote><p>sort -n -t “:” -k 3,3 /etc/passwd</p></blockquote><h3 id="wc-统计命令"><a href="#wc-统计命令" class="headerlink" title="wc:统计命令"></a>wc:统计命令</h3><p>支持管道符。</p><blockquote><p>wc [选项] 文件名</p></blockquote><p>选项：</p><ul><li><p>-l: 只统计行数 </p></li><li><p>-w: 只统计单词数 </p></li><li><p>-m: 只统计字符数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sort：排序命令&quot;&gt;&lt;a href=&quot;#sort：排序命令&quot; class=&quot;headerlink&quot; title=&quot;sort：排序命令&quot;&gt;&lt;/a&gt;sort：排序命令&lt;/h3&gt;&lt;p&gt;支持管道符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sort [选项] 文件名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell 基础学习三--正则表达式一</title>
    <link href="/2019/05/25/Shell-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%89-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/"/>
    <id>/2019/05/25/Shell-基础学习三-正则表达式一/</id>
    <published>2019-05-25T12:57:11.000Z</published>
    <updated>2019-11-25T13:02:07.724Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h3><ol><li>正则表达式与通配符</li></ol><p>正则表达式用来在 <strong>文件中</strong> 匹配符合条件的 <strong>字符串</strong>，正则是 <strong>包含匹配</strong>。grep、awk、 sed等命令可以支持正则表达式。</p><p>通配符用来匹配 <strong>系统 中</strong> 符合条件的 <strong>文件名</strong>，通配符是 <strong>完全匹配</strong>。ls、find、cp 这些命令不支持正则表达式，所以只能使用shell自己 的通配符来进行匹配了。</p><ul><li>? []</li></ul><h4 id="前一个字符匹配-0-次或任意多次"><a href="#前一个字符匹配-0-次或任意多次" class="headerlink" title="* :前一个字符匹配 0 次或任意多次"></a>* :前一个字符匹配 0 次或任意多次</h4><p>注意是前一个字符。</p><blockquote><p>grep “a*” file</p></blockquote><p>匹配所有内容，包括空白行，所以没有任何意义。</p><blockquote><p>grep “aa*” file</p></blockquote><p>至少有一个 a 的字符串。</p><h4 id="“-”-匹配除换行符的任意一个字符"><a href="#“-”-匹配除换行符的任意一个字符" class="headerlink" title="“.”: 匹配除换行符的任意一个字符"></a>“.”: 匹配除换行符的任意一个字符</h4><blockquote><p>grep “s..d” test_rule.txt</p></blockquote><p>“s..d”会匹配在s和d这两个字母之间一定有两个字符的单词 </p><blockquote><p>grep “s.*d” test_rule.txt</p></blockquote><p>匹配在s和d字母之间有任意字符。</p><p>在正则表达式中 “.*” 代表任意字符。</p><blockquote><p>grep “.*” test_rule.txt </p></blockquote><p>匹配所有内容</p><h4 id="”-“-匹配行首，”-”-匹配行尾。"><a href="#”-“-匹配行首，”-”-匹配行尾。" class="headerlink" title="”^“: 匹配行首，”$”: 匹配行尾。"></a>”^“: 匹配行首，”$”: 匹配行尾。</h4><blockquote><p>grep “^M” test_rule.txt</p></blockquote><p>匹配以大写“M”开头的行 </p><blockquote><p>grep “n$” test_rule.txt</p></blockquote><p>匹配以小写“n”结尾的行 </p><blockquote><p>grep -n “^$” test_rule.txt<br>会匹配空白行</p></blockquote><h4 id="“-”-匹配中括号中的任意一个字符，注意是只匹配一个"><a href="#“-”-匹配中括号中的任意一个字符，注意是只匹配一个" class="headerlink" title="“[]”:匹配中括号中的任意一个字符，注意是只匹配一个"></a>“[]”:匹配中括号中的任意一个字符，注意是只匹配一个</h4><blockquote><p>grep “s[ao]id” test_rule.txt </p></blockquote><p>匹配s和i字母中，要不是a、要不是o</p><blockquote><p>grep “[0-9]” test_rule.txt</p></blockquote><p>匹配任意一个数字</p><blockquote><p>grep “^[a-z]” test_rule.txt</p></blockquote><p>匹配用小写字母开头的行</p><h4 id="“-”-匹配中括号中以外的任意一个字符"><a href="#“-”-匹配中括号中以外的任意一个字符" class="headerlink" title="“[^]”:匹配中括号中以外的任意一个字符"></a>“[^]”:匹配中括号中以外的任意一个字符</h4><blockquote><p>grep “^[^a-z]” test_rule.txt </p></blockquote><p>匹配不用小写字母开头的行</p><blockquote><p>grep “^[^a-zA-Z]” test_rule.txt </p></blockquote><p>匹配不用字母开头的行</p><h4 id="“-quot-：使特殊符号失去特殊含义"><a href="#“-quot-：使特殊符号失去特殊含义" class="headerlink" title="“&quot;：使特殊符号失去特殊含义"></a>“&quot;：使特殊符号失去特殊含义</h4><blockquote><p>grep “.$” test_rule.txt </p></blockquote><p>匹配使用“.”结尾的行</p><h4 id="“-n-”：表示其前面的字符恰好出现n次"><a href="#“-n-”：表示其前面的字符恰好出现n次" class="headerlink" title="“{n}”：表示其前面的字符恰好出现n次"></a>“{n}”：表示其前面的字符恰好出现n次</h4><blockquote><p>grep “a{3}“ test_rule.txt</p></blockquote><p>匹配a字母连续出现三次的字符串 </p><blockquote><p>grep “[0-9]{3}“ test_rule.txt</p></blockquote><p>匹配包含连续的三个数字的字符串</p><h4 id="“-n-”表示其前面的字符出现不小于n次"><a href="#“-n-”表示其前面的字符出现不小于n次" class="headerlink" title="“{n,}”表示其前面的字符出现不小于n次"></a>“{n,}”表示其前面的字符出现不小于n次</h4><blockquote><p>grep “^[0-9]{3,}[a-z]” test_rule.txt </p></blockquote><p>匹配最少用连续三个数字开头的行</p><h4 id="“-n-m-”匹配其前面的字符至少出现n次，-最多出现m次"><a href="#“-n-m-”匹配其前面的字符至少出现n次，-最多出现m次" class="headerlink" title="“{n,m}”匹配其前面的字符至少出现n次， 最多出现m次"></a>“{n,m}”匹配其前面的字符至少出现n次， 最多出现m次</h4><blockquote><p>grep “sa{1,3}i” test_rule.txt </p></blockquote><p>匹配在字母s和字母i之间有最少一个a，最多三个a</p><h3 id="cut-字段提取命令"><a href="#cut-字段提取命令" class="headerlink" title="cut 字段提取命令"></a>cut 字段提取命令</h3><p>cut 命令</p><p>可以使用 cut 进行列提取，主要用途是配合 grep 提取相应的列。</p><h3 id="printf-格式化输出"><a href="#printf-格式化输出" class="headerlink" title="printf 格式化输出"></a>printf 格式化输出</h3><p>和 Java 等语言的格式化输出用法基本相同</p><h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><blockquote><p>awk ‘条件1{动作1} 条件2{动作2}…’ 文件名</p></blockquote><p>条件：一般使用表达式作为条件。</p><p>动作：格式化输出 printf、流程控制语句。</p><blockquote><p>awk ‘{printf $2 “\t” $6 “\n”}’ student</p></blockquote><p>打印 student 文件的第 2 列和第 6 列，再格式化输出。</p><p>awk 在执行时，是一行一行的输入，通过条件判断是否执行动作。</p><p>awk 可以识别以空格为列间的分割，而 cut 只能识别以 tab 为列分割。</p><p>BEGIN 在所有的动作前，先执行一个动作。</p><blockquote><p>awk ‘BEGIN{printf “This is a transcript \n” } {printf $2 “\t” $6 “\n”}’ student</p></blockquote><p>awk 指定分隔符,使用 FS</p><blockquote><p>awk ‘BEGIN {FS=”:”} {printf $1 “\t” $3 “\n”}’</p></blockquote><p>END: 在所有的动作后，再执行一个动作。</p><blockquote><p>awk ‘END{printf “The End \n” } {printf $2 “\t” $6 “\n”}’ student</p></blockquote><p>awk 使用关系运算符</p><p>awk 是复杂的命令，具体细节，使用时再查。</p><blockquote><p>cat student| grep -v Name | \ awk ‘$6 &gt;= 87 {printf $2 “\n” }’</p></blockquote><p>将第 6 列的数据是否大于数字打印出来。</p><h3 id="Sed-命令"><a href="#Sed-命令" class="headerlink" title="Sed 命令"></a>Sed 命令</h3><p><strong>流</strong> 编辑器，用来将数据进行选取、替换、删除、新<br> 增的命令。支持管道符操作，可以从管道符接收数据，不仅可以修改文件的内容，也可以修改命令的结果，这是 sed 与 vim 的主要区别。</p><p>sed 为 <strong>行操作</strong></p><blockquote><p>sed [选项] ‘[动作]’ 文件名 </p></blockquote><p>选项:</p><p>-n: 一般sed命令会把所有数据都输出到屏幕 ， 如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。<br>-e: 允许对输入数据应用多条sed命令编辑<br>-i: 用sed的修改结果直接修改读取数据的文件， 而不是由屏幕输出<br>-e: 允许对输入数据应用多条sed命令编辑<br>-i: 用sed的修改结果直接修改读取数据的文件， 而不是由屏幕输出</p><p>动作(单引号内):</p><p>a :追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用“\”代表数据未完结。<br>c :<br>行替换，用c后面的字符串替换原数据行，替换多行时，除最 后一行外，每行末尾需用“\”代表数据未完结。<br>i :插入，在当期行前插入一行或多行。插入多行时，除最后 一行 外，每行末尾需要用“\”代表数据未完结。<br>d:删除，删除指定的行。<br>p:打印，输出指定的行。<br>s: 字串替换，用一个字符串替换另外一个字符串。格式为“行范 围s/旧字串/新字串/g”(和vim中的替换格式类似)。</p><p>示例：</p><p><strong>打印：</strong></p><blockquote><p>sed ‘2p’ student.txt </p></blockquote><p>查看文件的第二行,但是会将整个文件打印出来。</p><blockquote><p>sed -n ‘2p’ student.txt</p></blockquote><p>只会讲第 2 行打印出来。</p><p><strong>删除：</strong></p><blockquote><p>sed ‘2,4d’ student.txt</p></blockquote><p>删除第二行到第四行的数据，但不修改文件本身。</p><p><strong>追加：</strong></p><blockquote><p>sed ‘2a hello’ student.txt<br>在第二行后追加hello。</p></blockquote><p><strong>插入：</strong></p><blockquote><p>sed ‘2i hello \ world’ student.txt</p></blockquote><p>在第二行前插入两行数据。</p><p><strong>替换：</strong></p><blockquote><p>sed ‘2c No such person‘ student.txt</p></blockquote><p>数据替换，将第2 行替换为具体内容。</p><p><strong>字符串替换：</strong></p><blockquote><p>sed ‘s/旧字串/新字串/g’ 文件名</p></blockquote><blockquote><p>sed ‘3s/74/99/g’ student.txt</p></blockquote><p>在第三行中，把74换成99。</p><blockquote><p>sed -e ‘s/Liming//g ; s/Gao//g’ student.txt</p></blockquote><p>同时进行多个替换动作。</p><p><strong>写入文件：</strong></p><blockquote><p>sed -i ‘3s/74/99/g’ student.txt</p></blockquote><p>将 sed 操作写入文件。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本正则表达式&quot;&gt;&lt;a href=&quot;#基本正则表达式&quot; class=&quot;headerlink&quot; title=&quot;基本正则表达式&quot;&gt;&lt;/a&gt;基本正则表达式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;正则表达式与通配符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正则表达式用来在 &lt;strong&gt;文件中
      
    
    </summary>
    
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="Shell" scheme="/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 单例模式的实现</title>
    <link href="/2019/05/24/Kotlin-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/05/24/Kotlin-单例模式的实现/</id>
    <published>2019-05-24T10:35:39.000Z</published>
    <updated>2019-05-29T09:45:44.388Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最简单的实现方式"><a href="#最简单的实现方式" class="headerlink" title="最简单的实现方式"></a>最简单的实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line">  fun method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在Kotlin里调用</span><br><span class="line">Singleton.method()</span><br><span class="line"></span><br><span class="line">//在Java中调用</span><br><span class="line">Singleton.INSTANCE.method();</span><br></pre></td></tr></table></figure><p>其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123;</span><br><span class="line">   public static final Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void method() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Singleton() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Singleton var0 = new Singleton();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java 中的 饿汉式获得单例方式相同。</p><p>同样也与 Java 中饿汉方式获得单例拥有相同的问题：</p><ul><li>如果没有使用该类的对象，那么已经实例化的对象，造成了内存浪费。</li><li>当构造器中执行复杂操作，造成实例化过程缓慢，可能造成性能问题。</li></ul><h4 id="懒汉式-一"><a href="#懒汉式-一" class="headerlink" title="懒汉式 一"></a>懒汉式 一</h4><p>在 Kotlin 中单例的实现和 Java 中一样，必须有：</p><ol><li>私有化的构造函数</li><li>获得对象的方法</li></ol><p>那么在 Kotlin 中有：</p><ul><li>显式声明构造方法为 private</li><li>companion object 用来在 class 内部声明一个对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        @Volatile</span><br><span class="line">        private var instance: Singleton? = null</span><br><span class="line"></span><br><span class="line">        fun getInstance() =</span><br><span class="line">                instance ?: synchronized(this) &#123;</span><br><span class="line">                    instance ?: Singleton().also &#123; instance =it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此写法 <a href="https://leegyplus.github.io/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/" target="_blank" rel="noopener">Java 单例模式的几种写法</a> 中懒汉模式的 <strong>方式三</strong> 相同。</p><p>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin 调用</span><br><span class="line">val singleton = Singleton.getInstance()</span><br><span class="line"></span><br><span class="line">//Java 调用</span><br><span class="line">Singleton singleton = Singleton.Companion.getInstance()</span><br></pre></td></tr></table></figure><h4 id="懒汉式-二"><a href="#懒汉式-二" class="headerlink" title="懒汉式 二"></a>懒汉式 二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance: Singleton by lazy &#123; Singleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Singleton</code> 通过 <code>lazy</code>来实现懒汉式加载。</li><li><code>lazy</code> 默认情况下是 <strong>线程安全</strong> 的，这就可以避免多个线程同时访问生成多个实例的问题。</li></ul><p>所以就不用象方式一中那样，对 Singleton 对象进行 <strong>加同步锁</strong> 和 <strong>双重校验</strong> 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最简单的实现方式&quot;&gt;&lt;a href=&quot;#最简单的实现方式&quot; class=&quot;headerlink&quot; title=&quot;最简单的实现方式&quot;&gt;&lt;/a&gt;最简单的实现方式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fun method() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;调用单例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//在Kotlin里调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.method()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//在Java中调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.INSTANCE.method();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="/tags/Kotlin/"/>
    
      <category term="Singleton" scheme="/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="/2019/05/23/%E9%9A%8F%E7%AC%94/"/>
    <id>/2019/05/23/随笔/</id>
    <published>2019-05-22T23:36:36.000Z</published>
    <updated>2019-05-23T03:14:25.537Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条随意的随笔，欢迎欢迎！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我是一条随意的随笔，欢迎欢迎！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(二)-CPU是如何执行指令的</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%8C-CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-二-CPU是如何执行指令的/</id>
    <published>2019-05-15T10:04:03.000Z</published>
    <updated>2019-05-29T07:35:01.658Z</updated>
    
    <content type="html"><![CDATA[<p>代码变成指令后，是一条一条顺序执行的。</p><p>在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。</p><p>在硬件上，寄存器有锁存器或触发器组成。</p><p><img src="https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg" alt="常见寄存器"></p><p>每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。</p><a id="more"></a><ul><li>PC 寄存器(指令地址寄存器)：用来存放下一条需要执行的计算机指令的 <strong>内存地址</strong>。</li><li>指令寄存器：用来存放正在执行的指令。</li><li>条件码寄存器：用里面的一个个标志位，用来存在 CPU 进行计算或逻辑运算的结果。</li></ul><p>以下图片展示如何根据机器码执行指令；</p><p><img src="https://static001.geekbang.org/resource/image/ad/8a/ad91b005e97959d571bbd2a0fa30b48a.jpeg" alt="执行指令"></p><p>我们可以看到，执行程序时，CPU 会根据 PC 寄存器中的内存地址，将指定内存的指令码读取到指令寄存器中，指令长度自增，开始顺序执行下一个指令，执行上面相同的操作。</p><p>以上可见程序的指令码是在内存中顺序保存的，也会一条一条加载。</p><h3 id="指令码跳转执行"><a href="#指令码跳转执行" class="headerlink" title="指令码跳转执行"></a>指令码跳转执行</h3><p>程序的指令码在内存中是顺序执行的，那么在程序执行跳转逻辑是，机器指令是如何执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  int r = rand() % 2;</span><br><span class="line">  int a = 10;</span><br><span class="line">  if (r == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -M intel -S test.o</span><br></pre></td></tr></table></figure><p>在 Mac 上对应的汇编码如下，限于平台问题，和原博客有所差别，所以直接参看原博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 // test.c</span><br><span class="line">26:   99  cltd</span><br><span class="line">27:   b9 02 00 00 00  movl    $2, %ecx</span><br><span class="line">2c:   f7 f9   idivl   %ecx</span><br><span class="line">2e:   89 55 f8    movl    %edx, -8(%rbp)</span><br><span class="line">; int a = 10;</span><br><span class="line">31:   c7 45 f4 0a 00 00 00    movl    $10, -12(%rbp)</span><br><span class="line">; if (r == 0)</span><br><span class="line">38:   83 7d f8 00     cmpl    $0, -8(%rbp)</span><br><span class="line">3c:   0f 85 0c 00 00 00   jne 12 &lt;_main+0x4e&gt;</span><br><span class="line">; a = 1;</span><br><span class="line">42:   c7 45 f4 01 00 00 00    movl    $1, -12(%rbp)</span><br><span class="line">; &#125; else &#123;</span><br><span class="line">49:   e9 07 00 00 00  jmp 7 &lt;_main+0x55&gt;</span><br><span class="line">; a = 2;</span><br><span class="line">4e:   c7 45 f4 02 00 00 00    movl    $2, -12(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">55:   8b 45 fc    movl    -4(%rbp), %eax</span><br><span class="line">58:   48 83 c4 10     addq    $16, %rsp</span><br><span class="line">5c:   5d  popq    %rbp</span><br><span class="line">5d:   c3  retq</span><br></pre></td></tr></table></figure><p> 原博客汇编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (r == 0)</span><br><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br><span class="line">&#123;</span><br><span class="line">a = 1;</span><br><span class="line">41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1</span><br><span class="line">48:   eb 07                   jmp    51 &lt;main+0x51&gt;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a = 2;</span><br><span class="line">4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2</span><br><span class="line">51:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注以下两行(r == 0 的编译结果)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br></pre></td></tr></table></figure><p>判断当条件成立时，跳转到操作数为 4a 的指令，进行接下来的指令执行。</p><p>执行过程图：</p><p><img src="https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg" alt="跳转指令执行"></p><p>所以代码变成指令后，是一条一条顺序执行的，这个顺序执行是基于跳转的顺序执行。</p><hr><p>常见指令解释：</p><p>cmp DWORD PTR [rbp-0x4],0x0</p><pre><code>从寄存器地址为[rbp-0x4]取出值与 0x0 比较</code></pre><p>mov DWORD PTR [rbp-0x8],0x2</p><pre><code>将 0x2 存入寄存器地址为 [rbp-0x8] 的内存中</code></pre><p>jne 指令，是 jump if not equal </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码变成指令后，是一条一条顺序执行的。&lt;/p&gt;
&lt;p&gt;在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。&lt;/p&gt;
&lt;p&gt;在硬件上，寄存器有锁存器或触发器组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg&quot; alt=&quot;常见寄存器&quot;&gt;&lt;/p&gt;
&lt;p&gt;每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(一)--计算机指令</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-一-计算机指令/</id>
    <published>2019-05-15T02:21:30.000Z</published>
    <updated>2019-05-15T09:25:42.585Z</updated>
    
    <content type="html"><![CDATA[<p>因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 是计算机的大脑，Central Processing Unit，中文为 <strong>中央处理器</strong>。</p><p>从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。</p><p>从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 <strong>机器语言</strong>。</p><p>每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 <strong>计算机指令</strong>。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。</p><p>一个计算机程序编译后，有很多的计算机指令。<br> <a id="more"></a></p><h3 id="从编译到汇编，代码是怎样变成机器码的？"><a href="#从编译到汇编，代码是怎样变成机器码的？" class="headerlink" title="从编译到汇编，代码是怎样变成机器码的？"></a>从编译到汇编，代码是怎样变成机器码的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 1; </span><br><span class="line">  int b = 2;</span><br><span class="line">  a = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让这段程序在 Linux 系统上跑起来，我们需要把整个程序翻译成一个 汇编语言(ASM,Assembly Language)的程序,这个过程我们叫做 <strong>编译(Compile)</strong> 成汇编代码。之后再使用汇编器将汇编代码翻译成用 “0”和”1” 组成的机器码。这一条条机器码就是一条条 <strong>计算机指令</strong>。</p><p>使用 GCC 编译器 和 objdump 命令，把对应的汇编代码和机器代码打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//MacOS 环境下</span><br><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -S test.o &gt; text.txt</span><br></pre></td></tr></table></figure><p>text.txt 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test.o: file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line">_main:</span><br><span class="line">; int main()&#123;</span><br><span class="line">       0:   55  pushq   %rbp</span><br><span class="line">       1:   48 89 e5    movq    %rsp, %rbp</span><br><span class="line">       4:   31 c0   xorl    %eax, %eax</span><br><span class="line">; int a = 1;</span><br><span class="line">       6:   c7 45 fc 01 00 00 00    movl    $1, -4(%rbp)</span><br><span class="line">; int b = 2;</span><br><span class="line">       d:   c7 45 f8 02 00 00 00    movl    $2, -8(%rbp)</span><br><span class="line">; a = a + b;</span><br><span class="line">      14:   8b 4d fc    movl    -4(%rbp), %ecx</span><br><span class="line">      17:   03 4d f8    addl    -8(%rbp), %ecx</span><br><span class="line">      1a:   89 4d fc    movl    %ecx, -4(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">      1d:   5d  popq    %rbp</span><br><span class="line">      1e:   c3  retq</span><br></pre></td></tr></table></figure><p>汇编语言其实就是让程序员能够看懂机器语言。</p><p>将上面文件中的汇编语言和机器语言分别拆分出来，分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">xorl    %eax, %eax</span><br><span class="line">movl    $1, -4(%rbp)</span><br><span class="line">movl    $2, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %ecx</span><br><span class="line">addl    -8(%rbp), %ecx</span><br><span class="line">movl    %ecx, -4(%rbp)</span><br><span class="line">popq    %rbp</span><br><span class="line">c3  retq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:   55</span><br><span class="line">1:   48 89 e5</span><br><span class="line">4:   31 c0 </span><br><span class="line">6:   c7 45 fc 01 00 00 00</span><br><span class="line">d:   c7 45 f8 02 00 00 00</span><br><span class="line">14:   8b 4d fc</span><br><span class="line">17:   03 4d f8</span><br><span class="line">1a:   89 4d fc</span><br><span class="line">1d:   5d</span><br><span class="line">1e:   c3</span><br></pre></td></tr></table></figure><h3 id="解析指令和机器码"><a href="#解析指令和机器码" class="headerlink" title="解析指令和机器码"></a>解析指令和机器码</h3><p>CPU 常见指令分类：</p><ul><li>算术类指令</li><li>数据传输类指令</li><li>逻辑指令</li><li>条件分支类指令</li><li>无条件跳转指令</li></ul><p>不同的 CPU 对应着不同的指令，也就对应着不同的汇编语言和机器码。</p><p>场景：</p><p>在 Android 开发过程中，我们需要添加第三方 so 库，根据不同的手机需要添加不同的 CPU 架构的 so 包,具体参见资料-<a href="****">Android的.so文件、ABI和CPU的关系</a></p><p>除了 C 这样的编译型语言之外，不管是 Python 这样的解释型语言，还是像 Java 这样使用虚拟机的语言，最终都是把写好的代码转换为 CPU 理解的机器码来执行。</p><p>解释型的语言，通过解释器在程序运行的时候逐句翻译，而 Java 这样 <strong>使用虚拟机的语言</strong>，则由虚拟机对编译出来的中间代码(.class)进行解释，或者即时编译成为机器码来最终执行。</p><p><strong>运行编译型语言：</strong> 是相对于解释型语言存在的，编译型语言的首先将源代码编译生成机器语言，再由机器运行机器码（二进制）。像C/C++等都是编译型语言。编译型语言程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等.  </p><p><strong>解释性语言</strong> 编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。&lt;/p&gt;
&lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;p&gt;CPU 是计算机的大脑，Central Processing Unit，中文为 &lt;strong&gt;中央处理器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。&lt;/p&gt;
&lt;p&gt;从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 &lt;strong&gt;机器语言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 &lt;strong&gt;计算机指令&lt;/strong&gt;。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。&lt;/p&gt;
&lt;p&gt;一个计算机程序编译后，有很多的计算机指令。&lt;br&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之WorkManager基本了解</title>
    <link href="/2019/05/14/Jetpack%E4%B9%8BWorkManager%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/14/Jetpack之WorkManager笔记/</id>
    <published>2019-05-14T07:15:58.000Z</published>
    <updated>2019-10-29T02:46:07.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。</p><h3 id="0x0001-feature"><a href="#0x0001-feature" class="headerlink" title="0x0001 feature"></a>0x0001 feature</h3><ul><li><p>向后兼容到 API 14</p><ul><li>在 API 23+ 的设备上使用 JobScheduler。</li><li>在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。</li></ul></li><li><p>为网络或获取充电状态添加约束</p></li><li><p>安排一次性异步任务或定期任务  </p></li><li><p>监控和管理计划任务</p></li><li><p>链接多个任务</p></li><li><p>即使应用程序或设备重新启动，也可确保任务执行</p></li><li><p>坚持Doze模式等省电模式</p></li></ul><a id="more"></a><p>WorkManager 适用于可延迟的任务-即不需要立即运行，即使应用程序退出或设备重新启动也需要可靠运行的情况。例如：</p><ul><li>将日志或分析发送到后端服务</li><li>定期将应用程序数据与服务器同步</li></ul><p>WorkManager 不适用于在应用程序进程消失时，安全退出的后台工作，也不适用于需要立即执行的任务。</p><h3 id="0x0002-使用-Work"><a href="#0x0002-使用-Work" class="headerlink" title="0x0002 使用 Work"></a>0x0002 使用 Work</h3><ol><li>通过 Work 来定义 任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UploadWorker(context:Context,workerParameters: WorkerParameters):Worker(context,workerParameters) &#123;</span><br><span class="line"></span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        return Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过 WorkRequest 来管理 任务怎样以及何时运行任务。</p><ul><li><p>对于一次性的 WorkRequest ，使用  OneTimeWorkRequest。</p></li><li><p>对于定时 WorkRequest，使用 PeriodicTimeWorkRequest。</p><p>WorkRequest 还可以包含其他信息，例如任务运行的约束条件，工作输入，延迟以及重试工作的退避策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;().build()</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>将您的任务交给系统。</li></ol><p>Work 执行的确切时间取决于 WorkRequest 和系统优化中使用的约束。WorkManager 旨在根据这些限制提供最佳行为。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance().enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure><h3 id="0x0004-Work、WorkRequest、WorkManager-关系"><a href="#0x0004-Work、WorkRequest、WorkManager-关系" class="headerlink" title="0x0004 Work、WorkRequest、WorkManager 关系"></a>0x0004 Work、WorkRequest、WorkManager 关系</h3><p>Work 定义任务, WorkRequest 基于 Work 创建 执行任务的请求，WorkManager 作为管理者执行 任务请求。</p><h3 id="0x0005-定义-WorkRequest"><a href="#0x0005-定义-WorkRequest" class="headerlink" title="0x0005 定义 WorkRequest"></a>0x0005 定义 WorkRequest</h3><h4 id="0x0006-为-WorkRequest-添加约束条件"><a href="#0x0006-为-WorkRequest-添加约束条件" class="headerlink" title="0x0006 为 WorkRequest 添加约束条件"></a>0x0006 为 WorkRequest 添加约束条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Create a Constraints object that defines when the task should run</span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(true)</span><br><span class="line">        .setRequiresCharging(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">// ...then create a OneTimeWorkRequest that uses those constraints</span><br><span class="line">val compressionWork = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>当所有的约束条件满足时，work 会执行。如果在执行 work 过程中不再满足约束条件，那么 WorkManager 会停止 work 的执行，等待约束条件满足后再次执行 work。</p><h4 id="0x0007-延迟执行"><a href="#0x0007-延迟执行" class="headerlink" title="0x0007 延迟执行"></a>0x0007 延迟执行</h4><p>以下是将任务设置为在排队后至少10分钟后运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInitialDelay(10, TimeUnit.MINUTES)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-feature&quot;&gt;&lt;a href=&quot;#0x0001-feature&quot; class=&quot;headerlink&quot; title=&quot;0x0001 feature&quot;&gt;&lt;/a&gt;0x0001 feature&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;向后兼容到 API 14&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 API 23+ 的设备上使用 JobScheduler。&lt;/li&gt;
&lt;li&gt;在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为网络或获取充电状态添加约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安排一次性异步任务或定期任务  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监控和管理计划任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接多个任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即使应用程序或设备重新启动，也可确保任务执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;坚持Doze模式等省电模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="WorkManager" scheme="/tags/WorkManager/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之Map</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/"/>
    <id>/2019/05/10/Java集合之Map/</id>
    <published>2019-05-10T10:17:08.000Z</published>
    <updated>2019-05-29T10:18:07.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Map 用于保存具有 <strong>映射关系</strong> 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。</p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><p>可以把 Map 里的 Key 放在一起，它们组成一个 <strong>Set 集合</strong>(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 <strong>List 集合</strong>(可重复，此时的索引为 key)。</p><p>如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。</p><a id="more"></a><h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p>HashMap 和 Hashtable 是 Map 的典型实现类。 Hashtable 在 JDK1.0 起就已经存在。在 Java8 时改进了 HashMap 的实现，使其在 HashMap 存在 key 冲突时具有更好的性能。</p><p>Hashtable 与 HashMap 主要区别：</p><ul><li>Hashtable: <strong>线程安全</strong> 的 Map 实现，但是 HashMap 是线程不安全的实现，所以 HashMap 的性能更高一些。多个线程访问同一个 Map 对象时，使用 Hashtable 会更好。</li><li>Hashtable 不允许使用 null 作为 key 和 value，否则会引起异常，但是 HashMap 可以。</li></ul><p>为了更好的在 HashMap 和 Hashtable 中存储、获取对象，<strong>用作 key 的对象必须实现 hashCode() 和 equals() 方法</strong>。</p><p>HashMap、Hashtable <strong>key 相同的标准</strong> 是：<strong>两个 key 通过 equals() 方法比较返回为 true，那么两个 key 的 hashcode 值必须相等</strong>。</p><p>HashMap、Hashtable <strong>value 相等</strong> 的标准：只要两个对象的 equals() 方法比较返回为 true 即可。</p><p>与 HashSet 相同，采用自定义类作为 HashMap、Hashtable 的 key，如果程序修改了作为 key 的可变对象，那么也会出现与 HashSet 类似的情形：程序无法准确访问到 Map 中被修改过的 key。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>与 LinkedHashSet 一致，LinkedHashMap 内部也是通过双向链表来维护添加的 key-value 的顺序(以 key 的添加顺序为准)。</p><p>同样的，由于维护链表 LinkedHashMap 的性能比 HashMap 差一些，但是也正是这个原因在遍历 Map 中元素时，LinkedHashMap 的效率更高一些。</p><h3 id="SortedMap-amp-amp-TreeMap"><a href="#SortedMap-amp-amp-TreeMap" class="headerlink" title="SortedMap &amp;&amp; TreeMap"></a>SortedMap &amp;&amp; TreeMap</h3><p>SortedMap 为 Map 派生的一个子接口，而 TreeMap 为 SortedMap 的一个实现类。</p><p>TreeMap 是一个红黑树结构，每个 key-value 为红黑树的一个节点，而 TreeMap 存储数据时，是以 key 为标准对 key-value 进行排序。</p><p>TreeMap 的两种排序方式：</p><ul><li><p>自然排序</p><p>  TreeMap 的所有的 key 必须实现 Comparable 接口，而且所有的 key 必须为同一个类的对象，否则会报 ClassCastException 。</p><p>  key 相同的标准为：两个 key 通过 compareTo() 方法返回 0，则认为相等。</p></li><li><p>定制排序</p><p>  在 创建 TreeMap 时，传入 Comparator 对象，该对象负责对 key 进行排序，此时 key 不要求实现 Comparator 接口。 </p><p>  如果想让排序更加顺利的进行，那么需要重写 key 对应类的 equal() 方法，并且 equal() 方法的返回值与 compareTo() 的返回值表达的结果一致，否则将于 Map 接口规则冲突。</p></li></ul><p><strong>自然排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Bean implements Comparable &#123;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (this == obj) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj != null &amp;&amp; obj.getClass() == Bean.class) &#123;</span><br><span class="line">            Bean bean = (Bean) obj;</span><br><span class="line">            return age == bean.age;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object obj) &#123;</span><br><span class="line">        Bean bean = (Bean) obj;</span><br><span class="line">        return Integer.compare(age, bean.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap();</span><br><span class="line">Bean bean = new Bean(1, &quot;mike&quot;);</span><br><span class="line">Bean bean2 = new Bean(4, &quot;mike2&quot;);</span><br><span class="line">Bean bean3 = new Bean(3, &quot;mike3&quot;);</span><br><span class="line">Bean bean4 = new Bean(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><p>TreeMap 按照 Bean 重写的 compareTo() 规则进行排序，注意重写的 equal() 需要满足以上逻辑。</p><p><strong>定制排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap((o1, o2) -&gt; &#123;</span><br><span class="line">    Bean2 bean = (Bean2) o1;</span><br><span class="line">    Bean2 bean2 = (Bean2) o2;</span><br><span class="line">    return Integer.compare(bean.getAge(), bean2.getAge());</span><br><span class="line">&#125;);</span><br><span class="line">Bean2 bean = new Bean2(1, &quot;mike&quot;);</span><br><span class="line">Bean2 bean2 = new Bean2(4, &quot;mike2&quot;);</span><br><span class="line">Bean2 bean3 = new Bean2(3, &quot;mike3&quot;);</span><br><span class="line">Bean2 bean4 = new Bean2(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>观字识意，WeakHashMap 与 HashMap 的区别是 WeakHashMap 中存在弱引用。</p><p>WeakHashMap 中的 key 只保留了对实际对象的弱引用，如果 WeakHashMap 对象的 key 引用的对象没有被其它强引用的变量引用，那么 key 所引用的对象在垃圾回收时很有可能被销毁，同时 WeakHashMap 也会自动移除 key 对应的 key-value 键值对。</p><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 中的所有的 key 必须是 单个枚举类中的枚举值。创建 EnumMap 对象时需要指定其对应的枚举类。</p><p>EnumMap 的特征：</p><ul><li>EnumMap 内部以数组的形式保存，所以高效。</li><li>EnumMap 根据 key 的自然排序(枚举类中枚举值的定义顺序)维护 key-value 的顺序。</li><li>EnumMap key 不可为 null。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enum Num&#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumMap enumMap = new EnumMap(Num.class);</span><br><span class="line">enumMap.put(Num.TWO,&quot;two&quot;);</span><br><span class="line">enumMap.put(Num.ONE,&quot;one&quot;);</span><br><span class="line">enumMap.put(Num.THREE,&quot;three&quot;);</span><br><span class="line">sout(enumMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ONE=oen,TWO=two,THREE=three&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>Hashtable 和 HashMap 的内部实现机制几乎一样，但是由于 Hashtable 为线性安全的集合，所以 HashMap 要比 Hashtable 要快。</p><p>TreeMap 的内部通过红黑树来维护添加顺序，所以比 Hashtable、HashMap 要慢(特别是在添加元素、删除元素时，此时需要重新整理红黑树)。同时也是因为内部红黑树 TreeMap 在变量元素时比较高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.binarySearch( treeMap.keySet().toArray(),new Bean(3, &quot;mike3&quot;)));</span><br></pre></td></tr></table></figure><p>一般场景下使用 HashMap，因为 HashMap 为快速查询而设计(底层使用数组存储 key-value)。如果需要对元素进行排序，那么使用 TreeMap。</p><p>由于需要维护内部链表，LinkedHashMap 比 HashMap慢一些，与 HashMap 实现基本一致，但是 LinkedHashMap 使用 == 而不是 equal() 来判断 key 相等。</p><p>EnumMap 性能最好，但是它的 key 只能是枚举值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Map 用于保存具有 &lt;strong&gt;映射关系&lt;/strong&gt; 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_02.jpg&quot; alt=&quot;Map&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以把 Map 里的 Key 放在一起，它们组成一个 &lt;strong&gt;Set 集合&lt;/strong&gt;(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 &lt;strong&gt;List 集合&lt;/strong&gt;(可重复，此时的索引为 key)。&lt;/p&gt;
&lt;p&gt;如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)&lt;/p&gt;
&lt;h3 id=&quot;操作&quot;&gt;&lt;a href=&quot;#操作&quot; class=&quot;headerlink&quot; title=&quot;操作&quot;&gt;&lt;/a&gt;操作&lt;/h3&gt;&lt;p&gt;向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Map" scheme="/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之Queue</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/"/>
    <id>/2019/05/10/Java集合之Queue/</id>
    <published>2019-05-10T09:57:03.000Z</published>
    <updated>2019-09-06T06:09:29.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>Queue 用于模拟 “队列” 这种数据结构，队列为 先进先出(First In First Out,FIFO) 的容器。队列可以将元素插入尾部，可以访问位于队列头部的元素，所以队列不能随机访问队列的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 将指定元素加入队列的尾部，内部调用 offer</span><br><span class="line">     */</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    /**</span><br><span class="line">     * 将指定元素加入队列的尾部</span><br><span class="line">     */</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，并删除该元素</span><br><span class="line">     */</span><br><span class="line">    E remove();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，并删除该元素</span><br><span class="line">     */</span><br><span class="line">    E poll();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，但是不删除该元素，与 peek 唯一不同是会抛出 NoSuchElementException 异常</span><br><span class="line">     */    </span><br><span class="line">    E element();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，不删除该元素</span><br><span class="line">     */</span><br><span class="line">    E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 有 PriorityQueue 实现类，同时 Queue 还有一个 Deque 接口，Deque 代表一个 “双端队列”，双端队列可以在两端进行添加、删除元素，Deque 的实现类既可以当做队列来使用也可以当做栈来使用，其有两个实现类： ArrayDeque、LinkedList。</p><h3 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h3><p>PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按队列元素的大小进行重新排序。而其排序方式有：自然排序和定制排序。两种排序规则的实现与 TreeSet 相同，不赘述。</p><p>PriorityQueue 内部通过数组实现。</p><h3 id="Deque-接口与-ArrayDeque-实现类"><a href="#Deque-接口与-ArrayDeque-实现类" class="headerlink" title="Deque 接口与 ArrayDeque 实现类"></a>Deque 接口与 ArrayDeque 实现类</h3><p>Deque 为 Queue 的子接口，代表了一个 <strong>双端队列</strong>，可以在双端添加、删除数据的，具体操作可以查看 Deque 的 Api。</p><p>与 Queue 方法不同为以上方法可以拆分为 xxxFirst()、xxxLast() 方法，代表对队列的两端进行的处理。</p><p>我们可以把 Deque 当做 <strong>队列</strong> 使用，也可以当做 <strong>栈</strong> 来使用。</p><p>与 ArrayList 相同，它们底层都是采用 <strong>一个动态的、可重新分配的 Object[] 数组</strong> 来存储集合元素。</p><p><strong>把 ArrayDeque 当做 “栈”(Fitst In Last Out,FILO) 来使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    //将 3 个元素 push 入栈</span><br><span class="line">    arrayDeque.push(&quot;one&quot;);</span><br><span class="line">    arrayDeque.push(&quot;two&quot;);</span><br><span class="line">    arrayDeque.push(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 访问第一个元素，但不出栈</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 第一个元素出栈</span><br><span class="line">    System.out.println(arrayDeque.pop());// 实现栈的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[two, one]</span><br></pre></td></tr></table></figure><p>ArrayDeque 很好的实现了 “栈” – <strong>先入后出</strong> 这种数据结构。在程序中使用栈时推荐使用 ArrayDeque ，避免使用 Stack(性能较差)。</p><p><strong>把 ArrayDeque 当做 “队列” 来使用</strong></p><p>当然 ArrayDeque 也可以当做队列使用，使用 <strong>先进先出</strong> 的方式操作集合元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void test3() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    // 将 3 个元素加入队列</span><br><span class="line">    arrayDeque.offer(&quot;one&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;two&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.poll());//实现队列的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[two, three]</span><br></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>LinkedList 是 List 的实现类，同时它也实现了 Deque 接口，所以 LinkedList 可以 根据 <strong>索引</strong> 来随机访问集合的元素，也可以被当做 <strong>双端队列</strong> 来使用，由此可见 LinkedList <strong>既可以当做队列也可以当做栈来使用</strong>。</p><p>LinkedList 内部实现机制与 ArrayList 、 ArrayDeque 不同，后两者内部维护动态、可扩容的 Object[] 数组，<strong>因此访问随机集合元素的性能较高</strong>；LinkedList 内部以 <strong>链表</strong> 的形式来保存集合中的元素，因此随机访问集合元素的性能较差，但是在 <strong>插入、删除集合元素性能较高(只需改变指针所指的地址)</strong>。</p><h3 id="各种线性表的性能表现"><a href="#各种线性表的性能表现" class="headerlink" title="各种线性表的性能表现"></a>各种线性表的性能表现</h3><p>Java 中 List 是一个线性表接口，最具代表性的实现类为：ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)。Queue 代表了队列，Deque 代表了双端队列。</p><p>由于数组以一块连续内存来保存数组元素，所以数组的随机访问的性能较好，那么以数组为底层实现的集合在随机访问时性能较好；而内部以链表为顶层实现的集合在添加、删除集合元素时有较好的性能。总体上 ArrayList 的性能比 LinkedList 的性能较好，因此大部分时候选用 ArrayList。</p><p>关于使用 List 几点建议：</p><ol><li>遍历 List 集合。对于 ArrayList 、ArrayDeque 等底层实现为数组集合使用随机访问来遍历元素，这样性能更好；而对于 LinkedList 则应该使用 Itertor 迭代器来遍历集合元素。</li><li>经常添加、删除元素操作的集合，可考虑 LinkedList。使用 ArrayList、Vector 集合可能需要经常重新分配内部数组的大小，性能较差。</li><li>多个线程访问 List 集合，可以使用 Collections 工具类对集合进行包装来实现线程安全。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;Q
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Queue" scheme="/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之List</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/"/>
    <id>/2019/05/10/Java集合之List/</id>
    <published>2019-05-10T08:59:47.000Z</published>
    <updated>2019-09-10T02:17:01.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>List 集合为元素有序、可重复的集合。</p><p>List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。</p><p>实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new ClassE(2));</span><br><span class="line">        list.add(new ClassE(1));</span><br><span class="line">        list.add(new ClassE(3));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.sort((o1, o2) -&gt;</span><br><span class="line">            ((ClassE)o1).getNum() -((ClassE)o2).getNum()</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ClassD&#123;num=2&#125;, ClassD&#123;num=1&#125;, ClassD&#123;num=3&#125;]</span><br><span class="line">[ClassD&#123;num=1&#125;, ClassD&#123;num=2&#125;, ClassD&#123;num=3&#125;]</span><br></pre></td></tr></table></figure><a id="more"></a><p>迭代遍历：</p><p>与 Set 集合只提供了 iterator() 方法不同，List 还提供了 listiterator() 方法，返回一个 ListIterator 对象， ListIterator 接口继承了 Itertor 接口，提供了专门操作 List 的方法。</p><p>ListIterator 在遍历过程中可以通过 add() 方法向上一个迭代元素后面添加一个新的元素,如果 list 对象为排过序的集合，以上操作不会触发再次排序，而 Itertor 只能实现删除元素的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListIterator listIterator = list.listIterator();</span><br><span class="line">int a = 6;</span><br><span class="line">while (listIterator.hasNext()) &#123;</span><br><span class="line">    ClassE classE = (ClassE) listIterator.next();</span><br><span class="line">    if (classE.getNum() == 2) &#123;</span><br><span class="line">        listIterator.add(new ClassE(6));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;listIterator &quot; + classE.toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>打印日志为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listIterator ClassE&#123;num=1&#125;</span><br><span class="line">listIterator ClassE&#123;num=2&#125;</span><br><span class="line">listIterator ClassE&#123;num=3&#125;</span><br><span class="line">[ClassE&#123;num=1&#125;, ClassE&#123;num=2&#125;, ClassE&#123;num=3&#125;, ClassE&#123;num=6&#125;]</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-Vector-类"><a href="#ArrayList-和-Vector-类" class="headerlink" title="ArrayList 和 Vector 类"></a>ArrayList 和 Vector 类</h3><p>ArrayList 和 Vector 在用法上几乎一致， Vector 在 JDK 1.0 就有了，那时候还没有 Java 集合框架的概念。在 JDK 1.2 将 Vector改为实现 List 接口，而 Vector 作为 List 的实现之一。</p><p>ArrayList 和 Vector 作为 List 的典型实现，支持 List 接口的全部功能。</p><p>ArrayList 和 Vector 都是基于数组实现的 List 类，在ArrayList 和 Vector <strong>内部封装了一个动态的、允许再分配的 Object[] 数组</strong>，使用 initiaCapacity 来初始化数组的长度，当数组元素超过数组的长度时，数组长度自动增加 initiaCapacity ,即长度增加 <strong>0.5</strong> 倍。</p><p>线程安全性：</p><ul><li>ArrayList 为线程不安全的，可以使用 Collections 工具类使 ArrayList 变成线程安全的。</li><li>Vector 时线程安全的，所以 Vector 性能比 ArrayList 低， 但是不推荐使用 Vector。</li></ul><h3 id="Vector-的子类-–-Stack"><a href="#Vector-的子类-–-Stack" class="headerlink" title="Vector 的子类 – Stack"></a>Vector 的子类 – Stack</h3><p>Vector 有一个子类 Stack，用于模拟 “栈”  这种数据结构：</p><ol><li>出栈 <ol><li>peek()：返回栈中的第一个元素，但是不将该元素移除。</li><li>pop():返回栈中的第一个元素，会将该元素移除</li></ol></li><li>进栈<ol><li>push(Object obj): 将元素压入栈，该元素位于集合的顶部。</li></ol></li></ol><p><strong>但是也应该尽量的避免使用 Stack，如果需要“栈”这种数据结构，可以使用 ArrayDeque</strong>。</p><p>ArrayDeque 是实现了 List 接口，也实现了 Deque 接口，因此可以作为栈使用，其也是基于数组的实现。</p><h3 id="固定长度的-List"><a href="#固定长度的-List" class="headerlink" title="固定长度的 List"></a>固定长度的 List</h3><p>Java 中有一个操作数组的工具类：<code>Arrays</code>，该工具类的 asList(Object …obj) 方法 <strong>可以把一个数组或指定个数的对象转换成一个 List 集合</strong>，这个 List 不是 ArrayList 或 Vector 的实现类，<strong>而是 Arrays 的内部类 ArrayList 的实例</strong>。 Arrays$ArrayList 为一个固定大小的 List  集合，不可删除或增加集合里的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = Arrays.asList(new Object());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;List 集合为元素有序、可重复的集合。&lt;/p&gt;
&lt;p&gt;List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。&lt;/p&gt;
&lt;p&gt;实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List list = new ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(2));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(3));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.sort((o1, o2) -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ((ClassE)o1).getNum() -((ClassE)o2).getNum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;打印日志：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="List" scheme="/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 Lifecycle 组件学习笔记</title>
    <link href="/2019/05/10/Jetpack%E4%B9%8B%20Lifecycle%20%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/10/Jetpack之 Lifecycle 组件学习笔记/</id>
    <published>2019-05-10T02:42:25.000Z</published>
    <updated>2019-10-21T09:01:16.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2019.10.21 更新</p></blockquote><h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。</p><p>传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。</p><p><code>android.arch.lifecycle (androidx 下为 androidx.lifecycle )</code> 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。</p><p>像 Activity、Service 等组件的生命周期均是由 Android Framework 管理，同样的，Lifecycle 也由运行的系统或者 Framework 中的进程管理，在编写 Andorid 程序时需要遵守相应的规则，不然会产生内存泄漏，甚至会导致应用奔溃。</p><h3 id="0x0001-Lifecycle"><a href="#0x0001-Lifecycle" class="headerlink" title="0x0001 Lifecycle"></a>0x0001 Lifecycle</h3><p><strong>Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态</strong>。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。</p><a id="more"></a><p>Lifecycle 使用两个重要的枚举类来跟踪它所关联的组件的生命周期状态：</p><ul><li><p>Event</p><p>  从 Android Framework 层面和 Lifecycle 类调度的生命周期事件,这些事件映射到 A/F 中的回调事件。</p></li><li><p>State</p><p>  Lifecycle 对象跟踪的组件的当前状态。</p></li></ul><p>下图展示 Event 和 State 的关联关系</p><p><img src="/source/images/2019_10_21_01.png" alt="Event和Statue"></p><p>在图中 State 作为一个个结点，作为事件间的边缘。</p><p>LifecycleObserver 通过在在其方法上添加注解来监听组件的状态，LifecycleOwner 通过 addObserver() 关联此 Observer 。</p><h3 id="0x0002-LifecycleOwner"><a href="#0x0002-LifecycleOwner" class="headerlink" title="0x0002 LifecycleOwner"></a>0x0002 LifecycleOwner</h3><p>LifecycleOwner 是只有一个方法的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface LifecycleOwner &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the Lifecycle of the provider.</span><br><span class="line">     *</span><br><span class="line">     * @return The lifecycle of the provider.</span><br><span class="line">     */</span><br><span class="line">    @NonNull</span><br><span class="line">    Lifecycle getLifecycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LifecycleOwner 接口抽象出单个类的生命周期所有权，比如 A/F，并且允许编写其他组件和它配合。owner 可以提供生命周期的变化，而 observer 可以注册到 owner 并且监听其生命周期的变化。</p><p>通过实现 LifecycleOwner 接口来 <strong>表明该类具有生命周期</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ComponentActivity extends Activity</span><br><span class="line">        implements LifecycleOwner, KeyEventDispatcher.Component</span><br></pre></td></tr></table></figure><p>LifecycleOwner 只有一个方法 getLifecycle()。</p><p>可见我们最常使用的 AppCompatActivity 已经实现了 LifecycleOwner 。实现 LifecycleObserver 的类作为 <code>观察者</code> 监听实现 LifecycleOwner 接口的类，监听 LifecycleOwner(也就是 Activity) 生命周期的变化。</p><p><strong>LiveData 的生命周期相关就是通过这种方式实现的。</strong></p><h3 id="0x0003-自定义-LifecycleOwner"><a href="#0x0003-自定义-LifecycleOwner" class="headerlink" title="0x0003 自定义 LifecycleOwner"></a>0x0003 自定义 LifecycleOwner</h3><p>平时通过实现 AppCompatActivity 创建的 Activity 已经实现了 LifecycleOwner 接口，如果想要自定义 LifecycleOwner，同样也需要实现 LifecycleOwner 接口，并且需要通过 LifecycleRegistry 对象来管理多个 LifecycleObserver，LifecycleRegistry 内部通过 Map 来存储 LifecycleObserver 对象。</p><p>自定义 LifecycleOwner 时，需要在相应的方法中显示的声明状态，其中生命周期事件 Event 与状态的对应关系可以参见上图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : Activity(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(this)</span><br><span class="line">        // 在该方法中声明对应声明周期的状态</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override fun onStart() &#123;</span><br><span class="line">        super.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getLifecycle(): Lifecycle &#123;</span><br><span class="line">        return lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看到，自定义实现 LifecycleOwner 需要定义 LifecycleRegistry 对象，该对象可以在 LifeOwner 的每个 Event 中标记该 Event 的 State，这样 LifeObserver 才可以在不同的 state 下执行相应的操作。</p><h3 id="0x0004-LifecycleObserver"><a href="#0x0004-LifecycleObserver" class="headerlink" title="0x0004 LifecycleObserver"></a>0x0004 LifecycleObserver</h3><p>生命周期的观察者，它的主要作用是监听 LifecycleOwner 对象的生命周期变化，通过注解的方式,将 LifecycleOwner 生命周期的变化映射到自己相应的方法上，并在自己的方法中进行相关业务处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CustomObserver : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun initObserver()&#123;</span><br><span class="line">        Log.e(&quot;initObserver&quot;,&quot;initObserver&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    fun back()&#123;</span><br><span class="line">        Log.e(&quot;back&quot;,&quot;back&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TestLifecycleActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test_lifecycle)</span><br><span class="line">        lifecycle.addObserver(CustomObserver())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-Lifecycle-aware-组件最佳实践"><a href="#0x0005-Lifecycle-aware-组件最佳实践" class="headerlink" title="0x0005 Lifecycle-aware 组件最佳实践"></a>0x0005 Lifecycle-aware 组件最佳实践</h3><ol><li>尽可能保证 UI 组件简单，比如不要在 UI 中获取数据，而在 ViewModel 中做这些事情， LiveData 对象会在数据变化后更新 UI。</li><li>尽可能在 ViewModel 中编写逻辑代码，ViewModel 应该是 UI(A/F) 和其他部分的桥梁。 但是这并不是说 ViewModel 的职责是获取数据，而应该调用其他组件来获取数据并返回 UI。</li><li>使用 DataBinding 来维护 UI 和 View 间关系。这使得可以使用更少的代码来更新 UI 。</li><li>如果 UI 十分复杂，可以考虑创建 presenter 来处理 UI 更改工作，虽然这个过程是费精力的，但是这对测试是十分友好的。</li><li>避免在 ViewModel 中引用 View 和 Context，避免造成内存泄漏。</li><li>使用 Kotlin 的协程来管理长时间运行的任务以及可以异步运行的其他操作。</li></ol><h3 id="0x0006-何时使用-lifecycle-awar-组件"><a href="#0x0006-何时使用-lifecycle-awar-组件" class="headerlink" title="0x0006 何时使用 lifecycle-awar 组件"></a>0x0006 何时使用 lifecycle-awar 组件</h3><ol><li>在粗粒度和细粒度的两种状态的地图切换展示。当 UI 在前台时使用细粒度的地图，在后台时切换为粗粒度的地图。</li><li>暂停和恢复动画。UI 在后台暂停动画，在前台恢复动画。</li></ol><h3 id="0x0007-关于-LiveData-的关于感知生命周期的实现"><a href="#0x0007-关于-LiveData-的关于感知生命周期的实现" class="headerlink" title="0x0007 关于 LiveData 的关于感知生命周期的实现"></a>0x0007 关于 LiveData 的关于感知生命周期的实现</h3><p>LiveData 同为 生命中期感知组件，其实它这种功能的实现主要是依托了 Lifecycle 的实现。在 LiveData 的 obsever() 方法中将 LiveData 的 Observer 包装成 LifecycleObserver 并与 LifecycleOwner 相关联，至此 LiveData 实现了生命周期的感知功能。</p><p>LiveData#observe(@NonNull LifecycleOwner owner, @NonNull Observer<t> observer) 源码：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123;</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // LifecycleOwnner 添加 LifecycleObserver</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上为个人翻译官方文档</p><p>以下为优秀博客：</p><p><a href="https://www.jianshu.com/p/b1208012b268" target="_blank" rel="noopener">Android官方架构组件Lifecycle:生命周期组件详解&amp;原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2019.10.21 更新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。&lt;/p&gt;
&lt;p&gt;传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android.arch.lifecycle (androidx 下为 androidx.lifecycle )&lt;/code&gt; 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。&lt;/p&gt;
&lt;p&gt;像 Activity、Service 等组件的生命周期均是由 Android Framework 管理，同样的，Lifecycle 也由运行的系统或者 Framework 中的进程管理，在编写 Andorid 程序时需要遵守相应的规则，不然会产生内存泄漏，甚至会导致应用奔溃。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-Lifecycle&quot;&gt;&lt;a href=&quot;#0x0001-Lifecycle&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Lifecycle&quot;&gt;&lt;/a&gt;0x0001 Lifecycle&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态&lt;/strong&gt;。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="Lifecycle" scheme="/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合之 Set 集合 </title>
    <link href="/2019/05/09/Java%E9%9B%86%E5%90%88%E4%B9%8B-Set/"/>
    <id>/2019/05/09/Java集合之-Set/</id>
    <published>2019-05-09T07:49:35.000Z</published>
    <updated>2019-12-03T03:41:42.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>Set 集合的特点无序、不可重复。</p><p>Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。</p><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>HashSet 集合按 <code>Hash 算法</code> 来存储集合的元素，<strong>因此具有很好的存取和查找功能</strong>。</p><p>HashSet 具有以下特点：</p><ol><li>不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。</li><li>HashSet 不是线程安全的。</li><li>元素可以为 null。</li></ol><a id="more"></a><h3 id="如何存储元素"><a href="#如何存储元素" class="headerlink" title="如何存储元素"></a>如何存储元素</h3><p>当向 HashSet 集合存入一个元素时， HashSet 会调用该对象的 <code>hashcode()</code> 方法来得到对象的 <code>hashcode</code> 值，<strong>然后根据该 hashcode 值决定对象在 HashSet 中的存储位置</strong>。如果两个元素通过 equals() 方法比较返回 true，但是它们的 hashcode() 方法返回值不相等，那么 HashSet 会把它们存储在不同的位置，可以添加成功。</p><h3 id="HashSet-如果定义元素相等"><a href="#HashSet-如果定义元素相等" class="headerlink" title="HashSet 如果定义元素相等"></a>HashSet 如果定义元素相等</h3><p>HashSet 集合判断两个元素相等的标准是：</p><ol><li>两个对象通过 equals() 方法比较相等。</li><li>两个对象的 hashcode() 方法的返回值也相等。</li></ol><p><strong>两者缺一不可</strong>。</p><p>所以当把一个对象放入 HashSet 中时，如果需要重写对象的 equals() 方法，那么也应该重写 hashcode() 方法。<strong>重写两方法的规则是：如果两个对象的 equals() 方法返回 true，这两个对象的 hashcode 也应该相同。</strong></p><p>两个对象的 equals() 方法返回 true，hashcode 返回不同的 hashcode 值，HashSet 会把两个对象保存在 Hash 表的不同位置，两个元素都会添加成功，但是这与 Set 集合的规则冲(元素不可重复)突了。如果是 equals() 方法返回 false，但是 hashcode 值相同，也会导致一些问题：hashcode 相同，HashSet 会尝试将多个元素保存在同一个位置，但又不行(这样的结果就是只剩下一个对象)，所以这样的结果就是在这个位置上通过链式结构来保存多个对象。HashSet 的特点就是通过元素的 hashcode 值来快速定位，而现在 HashSet 对象中有两个以上的元素具有相同的hashcode 值，导致性能下降。</p><h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><p>哈希算法的功能是，他能快速的查找被检索的对象，<strong>hash 算法的价值在于速度</strong>。当查询集合中的某个元素时，hash 算法可以直接根据该元素的 hashcode 值计算出该元素的存储位置，从而快速定位该元素。实现快速定位的原因是 HashSet 通过 hashcode 的值进行存储元素。</p><h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><p>由上面可知 hashCode() 方法对于 HashSet 的重要性，那么针对 hashCode() 方法的重写有如下规则：</p><ol><li>同一个对象多次调用 hashCode 方法应该返回相同的值。</li><li>两个对象通过 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法应返回相同的值。</li><li>对象中用于比较 equals() 方法比较标准的实例变量都应该用于计算 hashCode 值。</li><li>程序把可变对象添加到 HashSet 中之后，尽量不要去修改集合元素中参与计算 hashCode()、equals() 的实例变量，否则会导致 HashSet 无法正确的操作这些集合元素。</li></ol><h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>LinkedHashSet 为 HashSet 的一个子类，LinkedHashSet 也是通过hashcode 的值来决定元素的存储位置，<strong>但同时使用链表维护元素的次序</strong>，使得元素看起来是以插入顺序保存的。因为需要维护元素的插入顺序，所以性能略低于 HashSet。但是在迭代访问 Set 集合中的全部元素时有很好的性能，因为它以链表维护内部顺序。</p><p>遍历 LinkedHashSet 集合元素时，元素的顺序与添加顺序一致。</p><h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>TreeSet 为 SortSet 接口的实现类，其可以确保集合元素处于 <strong>排序状态</strong>。TreeSet 不是根据添加顺序进行排序而是 <strong>根据元素的实际值进行排序</strong>。</p><p>与 HashSet 根据 hash 算法来决定元素的存储位置不同，TreeSet 采用 <strong>红黑树</strong> 的数据结构来存储集合元素。TreeSet 支持两种排序算法：自然排序(默认)和定制排序。</p><h3 id="TreeSet-自然排序"><a href="#TreeSet-自然排序" class="headerlink" title="TreeSet 自然排序"></a>TreeSet 自然排序</h3><p>如果将一个对象添加到 TreeSet 中，那么 <strong>这个对象必须实现 Comparable 接口</strong>，依次来实现排序功能，否则程序会报出异常。</p><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后按升序排列，这就是 TreeSet 的自然排序。</p><p><strong>元素如何存储到集合中</strong></p><p>当把一个元素添加到 TreeSet 集合中， TreeSet 会调用这个对象的 compareTo(Object obj) 方法与集合中的其他元素比较大小，<strong>然后根据红黑树结构找到它的存储位置</strong>。如果两个对象通过 compareTo(Object obj) 方法比较相等，那么新的对象将不会添加到集合中。</p><p>如果想要 TreeSet 能够正常运行，那么 TreeSet 只能添加同一种类型的对象。</p><p><strong>判断集合元素相同</strong></p><p><strong>TreeSet 集合元素相等的唯一标准为：两个对象的 compareTo(Object obj) 方法是否返回 0，返回 0 则认为两个对象相等，反之不相等</strong>。基于以上标准，在重写 equals() 方法时，其返回值需要与 compareTo(Object obj) 的返回结果一致，否则 equals() 方法的返回值没有实际意义。</p><p>通过重写 compareTo(Object obj) 方法，使其不返回 0，此时可以实现将一个对象多次添加到 TreeSet集合中，但是此时集合多个元素均指向一个对象引用，如果对象发生变化，那么集合中的多个元素会同时发生相同变化。</p><p>基于以上描述，在重写对象类的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果，如果equals() 方法返回 true ，那么这两个对象通过 compareTo(Object obj) 方法应该返回 0。</p><p>改变Treeset 集合中的可变元素的实例变量后，这会导致它与其他对象的大小顺序发生改变，但是 TreeSet 不会再次调整它们的顺序。当尝试删除该对象时，TreeSet 也会删除失败。所以基于此原因 <strong>TreeSet 可以删除没有被修改实例变量、且不与其他被修改的实例变量的对象重复的对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeSet treeSet = new TreeSet();</span><br><span class="line">Dog dog1 = new Dog(&quot;mike&quot;,1);</span><br><span class="line">Dog dog2 = new Dog(&quot;mike&quot;,2);</span><br><span class="line">Dog dog3 = new Dog(&quot;mike&quot;,3);</span><br><span class="line">Dog dog4 = new Dog(&quot;mike&quot;,4);</span><br><span class="line">treeSet.add(dog1);</span><br><span class="line">treeSet.add(dog2);</span><br><span class="line">treeSet.add(dog3);</span><br><span class="line">treeSet.add(dog4);</span><br><span class="line">System.out.println(&quot;1 &quot; + treeSet);</span><br><span class="line">treeSet.remove(dog1);</span><br><span class="line">System.out.println(&quot;2 &quot; +treeSet);</span><br><span class="line">Dog showDog = (Dog) treeSet.first();</span><br><span class="line">showDog.setAge(6);</span><br><span class="line">System.out.println(&quot;3 &quot; +treeSet);</span><br><span class="line">System.out.println(&quot;4 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,6)));</span><br><span class="line">System.out.println(&quot;5 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,2)));</span><br><span class="line">System.out.println(&quot;6 &quot; +treeSet.first());</span><br><span class="line">System.out.println(&quot;7 &quot; +treeSet.remove(treeSet.first()));</span><br><span class="line">System.out.println(&quot;8 &quot; +treeSet);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 [Dog&#123;name=&apos;mike&apos;, age=1&#125;, Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">2 [Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">3 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">4 false</span><br><span class="line">5 false</span><br><span class="line">6 Dog&#123;name=&apos;mike&apos;, age=6&#125;</span><br><span class="line">7 false</span><br><span class="line">8 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br></pre></td></tr></table></figure><p>可以看到 日志3 TreeSet 对象并没有重新排序，通过日志 4、5、7 可以对象更改后 TreeSet 无法对其进行删除。</p><h3 id="TreeSet-定制排序"><a href="#TreeSet-定制排序" class="headerlink" title="TreeSet 定制排序"></a>TreeSet 定制排序</h3><p>实现定制排序，则需要在创建 TreeSet 集合对象时结合 Comparator 对象，<strong>并由 Comparator 负责集合元素的排序逻辑</strong>。</p><p>如例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">        TreeSet treeSet = new TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            ClassD classD1 = (ClassD) o1;</span><br><span class="line">            ClassD classD2 = (ClassD) o2;</span><br><span class="line">            if(classD1.getNum() == classD2.getNum())&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return classD1.getNum() &gt; classD2.getNum() ? -1 : 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(new ClassD(1));</span><br><span class="line">        treeSet.add(new ClassD(-1));</span><br><span class="line">        treeSet.add(new ClassD(0));</span><br><span class="line">//        ClassD classD = new ClassD(2);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 打印日志：[ClassD&#123;num=1&#125;, ClassD&#123;num=0&#125;, ClassD&#123;num=-1&#125;]</span><br></pre></td></tr></table></figure><p>对于自然排序和定制排序而言，添加到 TreeSet 集合对象中的元素应该为同一种类型的对象，否则会引发 ClassCastException 异常。</p><h3 id="3-EnumSet-类"><a href="#3-EnumSet-类" class="headerlink" title="3. EnumSet 类"></a>3. EnumSet 类</h3><p>EnumSet 是一个专门为枚举类设计的集合类， EnumSet 中的所有的元素都必须是枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式的指定。EnumSet 的集合元素也是有顺序的，<strong>EnumSet 以枚举值在枚举类中的定义顺序来决定集合元素在顺序</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumA &#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void test4() &#123;</span><br><span class="line">        EnumSet enumSet = EnumSet.noneOf(EnumA.class);</span><br><span class="line">        enumSet.add(EnumA.ONE);</span><br><span class="line">        enumSet.add(EnumA.THREE);</span><br><span class="line">        enumSet.add(EnumA.TWO);</span><br><span class="line">        System.out.println(enumSet);</span><br><span class="line">        EnumSet enumSet2 = EnumSet.allOf(EnumA.class);</span><br><span class="line">        System.out.println(enumSet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">// 打印日志：</span><br><span class="line">[ONE, TWO, THREE]</span><br><span class="line">[ONE, TWO, THREE]</span><br></pre></td></tr></table></figure><p>EnumSet在内部以位向量的形式保存，这种存储方式十分的高效，所以 EnumSet 占用的内存小、运行效率高。</p><p><strong>EnumSet 不可添加 null 元素。</strong></p><h3 id="各-Set-集合的性能"><a href="#各-Set-集合的性能" class="headerlink" title="各 Set 集合的性能"></a>各 Set 集合的性能</h3><p>HashSet 和 TreeSet 为 Set 集合的两个典型实现，两者如何选择呢？</p><p>由于 TreeSet 内部需要额外的红黑二叉树维护元素的添加顺序，所以 HashSet 的效率高于 TreeSet。<strong>当需要保持排序的 Set 时才使用 TreeSet，否则使用 HashSet。</strong></p><p>LinkedHashSet 为 HashSet 的子类，对于删除、插入操作 LinkedHashSet 比 HashSet 稍慢一些，这是因为 LinkedHashSet 内部需要维护链表造成的，但正是这个原因，遍历操作时 LinkedHashSet 会更快一些。</p><p>EnumSet 是所有 Set 集合中效率最好的，但是它只能保存他一个枚举类的枚举值作为集合元素。</p><p>Set 的三个实现类 HashSet 、TreeSet、 EnumSet 都是 <strong>线程不安全的</strong>，多个线程操作 Set 集合时需保证线程同步。通常使用 Collections  工具类的 synchronizedSortSet 方法来包装该 Set 集合，此操作最好在创建时进行，以防止对 Set 集合意外的非同步访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet treeSet = Collections.synchronizedSortedSet(new TreeSet((o1,o2)-&gt;&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Set-集合&quot;&gt;&lt;a href=&quot;#Set-集合&quot; class=&quot;headerlink&quot; title=&quot;Set 集合&quot;&gt;&lt;/a&gt;Set 集合&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;Set 集合的特点无序、不可重复。&lt;/p&gt;
&lt;p&gt;Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。&lt;/p&gt;
&lt;h3 id=&quot;HashSet-类&quot;&gt;&lt;a href=&quot;#HashSet-类&quot; class=&quot;headerlink&quot; title=&quot;HashSet 类&quot;&gt;&lt;/a&gt;HashSet 类&lt;/h3&gt;&lt;p&gt;HashSet 集合按 &lt;code&gt;Hash 算法&lt;/code&gt; 来存储集合的元素，&lt;strong&gt;因此具有很好的存取和查找功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HashSet 具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。&lt;/li&gt;
&lt;li&gt;HashSet 不是线程安全的。&lt;/li&gt;
&lt;li&gt;元素可以为 null。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Set" scheme="/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合概述</title>
    <link href="/2019/05/09/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <id>/2019/05/09/Java集合概述/</id>
    <published>2019-05-09T03:06:58.000Z</published>
    <updated>2019-12-04T10:24:04.025Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java<br> 集合来实现常见的数据结构，如堆、栈等。</p><h3 id="Java-集合的分类"><a href="#Java-集合的分类" class="headerlink" title="Java 集合的分类"></a>Java 集合的分类</h3><p> Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：</p><ul><li>List：有序、可重复的集合。</li><li>Set：无序、不可重复的集合。</li><li>Map：具有映射关系的集合。</li><li>Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。</li></ul><p>谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。</p><p>Java 集合可用来 <strong>存储对象</strong>，因此被称为 <strong>容器类</strong>。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。</p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/" target="_blank" rel="noopener">Java 集合之 List</a></p><p><a href="https://leegyplus.github.io/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/" target="_blank" rel="noopener">Java 集合之 Set</a></p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/" target="_blank" rel="noopener">Java 集合之 Map</a></p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/" target="_blank" rel="noopener">Java 集合之 Queue</a></p><p><a href="https://leegyplus.github.io/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/" target="_blank" rel="noopener">Java 集合工具类–Collections</a></p><a id="more"></a><h3 id="Java-集合继承树"><a href="#Java-集合继承树" class="headerlink" title="Java 集合继承树"></a>Java 集合继承树</h3><p>Java 集合主要是 Collection 和 Map 的派生类，集合的继承关系如下:</p><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><h3 id="Collection-和-Iterator-接口"><a href="#Collection-和-Iterator-接口" class="headerlink" title="Collection 和 Iterator 接口"></a>Collection 和 Iterator 接口</h3><p>List、Set、Queue 都是继承了 Collection 接口，那么该接口定义的方法都可以操作以上集合。</p><p>集合本就是容器，那么相应的操作：增加、删除、替换、清空等，也就对应了相应的方法。</p><p>Iterator 与 Collection 、Map 不同，Collection 、Map 主要的功能是为了盛放其他对象，而 <strong>Iterator 的主要用于遍历 Collection 集合中的元素</strong>，所以 Iterator 对象也被称为 <strong>迭代器</strong>。</p><p>Itertor 仅用于遍历元素，其本身不能盛放对象的能力，Itertor 对象的创建必须依托于 Collection，没有 Collection 的 Itertor 没有任何价值。</p><p>为了更好的理解 Itertor 看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList();</span><br><span class="line">    list.add(&quot;a&quot;);</span><br><span class="line">    list.add(&quot;b&quot;);</span><br><span class="line">    list.add(&quot;c&quot;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        String str = (String) iterator.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        if (str.equals(&quot;c&quot;))&#123;</span><br><span class="line">            iterator.remove();//2</span><br><span class="line">            // 使用 Itertor 遍历集合时，不可修改集合元素，以下代码引发异常</span><br><span class="line">            //list.remove(str);//3</span><br><span class="line">        &#125;</span><br><span class="line">        str = &quot;Chage&quot;;//1</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[a, b]</span><br></pre></td></tr></table></figure><p>在这里我们看到了一个很有意思的现象，在 <code>代码1</code> 处对迭代变量 str 赋了新值，但是通过打印日志我们看到 list 的元素并没有被改变。</p><p><strong>这是因为 Itertor 在对集合进行遍历时，Itertor 并不是把集合元素本身传给了迭代变量 str，仅仅是把集合元素的值传给 迭代变量 str，所以修改迭代变量 str 的值不会对集合元素有任何影响。</strong></p><p>当通过 <code>Itertor</code> 迭代遍历 <code>Collection</code> 中的集合元素时，Collection 集合中的元素不能被改变，<strong>只有通过 Itertor 的 remove() 方法删除上一次 next() 方法返回的值，否则就会引起 java.util.ConcurrentModificationException 异常</strong>，将 <code>代码2</code> 处替换为 <code>代码3</code> 就会报出异常。</p><h3 id="使用-foreach-遍历集合元素"><a href="#使用-foreach-遍历集合元素" class="headerlink" title="使用 foreach 遍历集合元素"></a>使用 foreach 遍历集合元素</h3><p>同 Itertor 一样，通过 foreach 遍历元素过程中也不能修改集合元素，系统同样也是把集合的元素的值赋值个迭代变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123;</span><br><span class="line">    String value = str;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    if (str.equals(&quot;c&quot;)) &#123;</span><br><span class="line">        // 下面的代码同样也会引起 ConcurrentModificationException 异常</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java&lt;br&gt; 集合来实现常见的数据结构，如堆、栈等。&lt;/p&gt;
&lt;h3 id=&quot;Java-集合的分类&quot;&gt;&lt;a href=&quot;#Java-集合的分类&quot; class=&quot;headerlink&quot; title=&quot;Java 集合的分类&quot;&gt;&lt;/a&gt;Java 集合的分类&lt;/h3&gt;&lt;p&gt; Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：有序、可重复的集合。&lt;/li&gt;
&lt;li&gt;Set：无序、不可重复的集合。&lt;/li&gt;
&lt;li&gt;Map：具有映射关系的集合。&lt;/li&gt;
&lt;li&gt;Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。&lt;/p&gt;
&lt;p&gt;Java 集合可用来 &lt;strong&gt;存储对象&lt;/strong&gt;，因此被称为 &lt;strong&gt;容器类&lt;/strong&gt;。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Set&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Queue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合工具类–Collections&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之LiveData 笔记</title>
    <link href="/2019/05/08/Jetpack%E4%B9%8BLiveData-%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/08/Jetpack之LiveData-笔记/</id>
    <published>2019-05-08T03:21:37.000Z</published>
    <updated>2019-10-30T09:35:01.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x000-概述"><a href="#0x000-概述" class="headerlink" title="0x000 概述"></a>0x000 概述</h3><p>在官方文档中首先对 LiveData 做了一个概述 : <code>LiveData is an observable data holder class</code>, LiveData 是一个 <strong>可观察的</strong> <strong>数据持有者类</strong>。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 <strong>活跃状态下</strong> 更新组件。</p><p>LiveData 认为上述中的 <strong>活跃状态</strong> 为对应的 Observer 处于 <strong>STARTED</strong> 或 <strong>RESUMED</strong> 状态。LiveData 数据更改不会触发非活跃组件的更新。</p><p>LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。</p><h3 id="0x0001-个人理解"><a href="#0x0001-个人理解" class="headerlink" title="0x0001 个人理解"></a>0x0001 个人理解</h3><p>官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:</p><p><code>public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)</code> </p><a id="more"></a><p>第一个参数为 LifecycleOwner 对象，一般为 Activity/Fragment/Servic 对象，第二参数为 Observer 对象，它的重要工作是一个回调– <code>onChanged(T t)</code>，用于更新 UI 等工作。</p><p> LiveData#observe() 方法中完成了对 observer 的包装(ObserverWrapper)，并将其添加到 LifecycleOwner 对象观察者列表中，完成了 observer 关联 LifecycleOwner(A/F) 组件的生命周期的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    assertMainThread(&quot;observe&quot;);</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    ....</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 LiveData 就实现了如下功能；</p><pre><code>1. 数据更改时触发处于 ACTIVE 的组件的功能。2. UI 生命周期变更时，LiveData 会通知 Observer。3. 组件被销毁后， Observer 对象会被移除。</code></pre><h4 id="0x0002-LiveData-优点"><a href="#0x0002-LiveData-优点" class="headerlink" title="0x0002 LiveData 优点"></a>0x0002 LiveData 优点</h4><ol><li><p>保证 UI 与 实时数据完美匹配，这种模式下：</p><ol><li>UI 生命周期变更时，LiveData 会通知 Observer。</li><li>LiveData 在数据发生变化时，通知 Observer 对象更新 UI，这就保证了数据在每次变更时 <strong>自动更新 UI</strong>, 而不需要手动的更新 UI。</li></ol></li></ol><ol start="2"><li><p>不会内存泄漏</p><p> Lifecycle 对象销毁后(Activity/Framgent/Service)，Observer 与 Lifecycle 对象 的绑定关系会被移除，这样就不会因为两者的互相引用而导致无法回收对象。</p></li><li><p>不会因为 Activity 的停止而导致崩溃</p><p> Observer 处于 InActive 状态时, 它不会接收到 LiveData 的 Event。根据 LiveData 的相关定义只有在 LifecycleOwner 的状态为 START 或 RESUME 时 Observer 才处于 Active 状态。</p></li><li><p>不再需要手动生命周期处理</p><p> UI组件只是观察相关数据，不会停止或恢复观察。LiveData自动管理生命周期，因为它可以观察到组件的生命周期状态变化。</p></li><li><p>时刻保持最新的数据</p><p> 当 LifecycleOwner 的生命周期从 incative 转换到 active 时，会更新最新的数据。</p></li><li><p>旋转屏幕等配置发生变化时，可以收到最新数据</p></li><li><p>共享数据资源<br>LiveData 对象一致，那么那所持有的数据或资源就可以被多个页面共享。</p></li></ol><h3 id="0x0003-使用-LiveData"><a href="#0x0003-使用-LiveData" class="headerlink" title="0x0003 使用 LiveData"></a>0x0003 使用 LiveData</h3><p>使用 LiveData 的基本步骤：</p><ol><li>创建持有特定类型的 LiveData 对象，这部分工作一般在 ViewModel 中完成。</li><li>创建 Observer 对象，当 LiveData 持有的数据变化时，在 Observer 对象的 onChanged() 中进行相应的逻辑处理。一般在 Activity/Fragment 中创建 Observer 对象。</li><li>通过 LiveData 的 observe() 关联 Observer 对象，并且传入 LifecycleOwner 对象，所以在 LiveData 数据更改时通知 Observer 对象。</li></ol><p>在 LiveData 对象中的数据变化时，如果相应的 LifecycleOwner 处于活动状态，它就会触发所有注册的观察者。</p><p>当 LiveData 对象保存的数据更改时，UI 会自动更新数据。</p><p><strong>创建 LiveData 对象</strong></p><p>LiveData 是泛型包装类，可以持有任意类型的数据，一般在 ViewModel 中初始化 LiveData：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class NameViewModel : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    // Create a LiveData with a String</span><br><span class="line">    val currentName: MutableLiveData&lt;String&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rest of the ViewModel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于以下原因，请确保将更新 UI 的 LiveData 对象存储在ViewModel对象中，而不是 Activity/Fragment 中：</p><ul><li>避免臃肿的 Activity和 Fragment。 UI 控制器 只负责显示数据，而不负责持有数据状态。</li><li>使 LiveData 实例与 Activity/Fragment 脱离，允许 LiveData 对象在配置变改后不被销毁。</li></ul><p><strong>创建 Observer 对象</strong></p><p>一般在 onCreate 方法进行初始化 Observer 对象，并且关联 LiveData 对象，原因有以下几条：</p><ul><li>确保不会在 onResume（）方法中进行多余的调用。</li><li>确保 Activity/Fragment 在进入 Active 状态后可以立即显示的数据。只有在 Observer 对象创建完毕后，当应用 A/F 处于 Active 状态，才可以就可以从关联的 LiveData 对象中接收最新值，所以应该尽早的创建 Observer 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// androidx 包下创建方式有所变更</span><br><span class="line">class NameActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var model: NameViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        // Other code to setup the activity...</span><br><span class="line"></span><br><span class="line">        // Get the ViewModel.</span><br><span class="line">        model = ViewModelProviders.of(this).get(NameViewModel::class.java)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // Create the observer which updates the UI.</span><br><span class="line">        val nameObserver = Observer&lt;String&gt; &#123; newName -&gt;</span><br><span class="line">            // Update the UI, in this case, a TextView.</span><br><span class="line">            nameTextView.text = newName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span><br><span class="line">        model.currentName.observe(this, nameObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是将 LifecycleOwner 的实例 this 传入 observer 方法中，这就意味着 Observer 对象的生命周期与其宿主 LifecycleOwner 的生命周期绑定，下文所说的 Observer 的 Active 状态和 InActive 状态与 LifecycleOwner 的状态是一致的。</p><p><strong>更新 LiveData 持有的数据</strong></p><p>LiveData 类没有公开的方法来更新数据，但是  MutableLiveData 暴露了两个方法：setValue(T) 和 postValue(T)，如果想要更改 LiveData 中持有的数据可以使用这两个方法。通常在 ViewModel 中使用 MutableLiveData，而 ViewModel 仅向观察者公开不可变的 LiveData 对象，保证了数据的安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    val anotherName = &quot;John Doe&quot;</span><br><span class="line">    model.currentName.setValue(anotherName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 setValue 方法会触发 Observer 对象的 onChanged() 方法，并且会携带变更后的数据。</p><blockquote><p>能够触发 App 组件更新的唯一情况是 LiveData 的数据源发生变化，即</p></blockquote><pre><code>1. 调用了 LiveData 的 setValue(T)// 必须在主线程调用 setValue 变更数据2. 调用了 LiveData 的 postValue(T)// 必须在子线程执行操作</code></pre><p><strong>和其他组件组合使用 LiveData</strong></p><p>Jetpack 的 Room 组件、与 Kotlin 协程组合使用。</p><h3 id="扩展-LiveData"><a href="#扩展-LiveData" class="headerlink" title="扩展 LiveData"></a>扩展 LiveData</h3><p>如果观察者的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 认为观察者处于 Active 状态。下面的示例代码说明了如何扩展 LiveData 类：</p><p>这是一个更新股价的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    private val stockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    private val listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActive() &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInactive() &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现 LiveData 的方法中，需要注意以下几个方法：</p><ul><li>onActive: 当 LiveData 对象具有活动的观察者时，将调用onActive（）方法。这意味着您需要从这种方法开始观察股价更新。</li><li>当 LiveData 对象没有任何活动的观察者时，将调用 onInactive（）方法。由于没有观察者在监听，不需要与 StockManager 建立连接。</li><li>setValue（T）方法将更新 LiveData 实例的值，并将有关更改通知所有处于 Active 状态的观察者。</li></ul><p>可以按如下方式使用 StockLiveData :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onActivityCreated(savedInstanceState)</span><br><span class="line">    val myPriceListener: LiveData&lt;BigDecimal&gt; = ...</span><br><span class="line">    myPriceListener.observe(this, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">        // Update the UI.</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 LiveData 是生命周期感知的组件，所以可以在多个 Activity、Fragment、Service 中共享它，可以将 StockLiveData 变为单例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    private val stockManager: StockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    private val listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onActive() &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun onInactive() &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var sInstance: StockLiveData</span><br><span class="line"></span><br><span class="line">        @MainThread</span><br><span class="line">        fun get(symbol: String): StockLiveData &#123;</span><br><span class="line">            sInstance = if (::sInstance.isInitialized) sInstance else StockLiveData(symbol)</span><br><span class="line">            return sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 Fragment 中按照如下方式使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        StockLiveData.get(symbol).observe(this, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">            // Update the UI.</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个Activity 和 Fragment 可以观察 MyPriceListener 实例。LiveData 只有当 <strong>一个或多个</strong> Activity 和 Fragment 处于可见状态并且处于活动状态时，才会连接到系统服务。</p><h3 id="0x0004-LiveData-操作符"><a href="#0x0004-LiveData-操作符" class="headerlink" title="0x0004  LiveData 操作符"></a>0x0004  LiveData 操作符</h3><h3 id="1-转换-LiveData"><a href="#1-转换-LiveData" class="headerlink" title="1. 转换 LiveData"></a>1. 转换 LiveData</h3><p>和 Rxjava 相似，通过使用 <code>Transformations</code> 的操作符转换 LiveData 对象。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>对 LiveData 对象中存储的值进行相应函数的操作，并将结果传播到下游。 </p><p>Transformations.map 变换 LiveData 持有的数据类型，即 Lambda 表达式完成数据类型 X 到 Y的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line">val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; &quot;$&#123;user.name&#125; $&#123;user.lastName&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中通过 map 实现了 LiveData<user> 向 LiveData<string> 的转换。</string></user></p><h4 id="3-switchMap"><a href="#3-switchMap" class="headerlink" title="3. switchMap()"></a>3. switchMap()</h4><p>Transformations.switchMap 同样也是变换 LiveData 持有的数据类型，但是不同的是，传入的 Lambda 表达式完成数据类型 X 到 LiveData<y> 的转换。</y></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private fun getUser(id: String): LiveData&lt;User&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">val userId: LiveData&lt;String&gt; = ...</span><br><span class="line">val user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure><p>switchMap 和 map 都实现了 LiveData 所持有数据类型的转换，但是与 map() 不同的 switchMap 的第二个参数 Function 的返回值类型必须为 LiveData。</p><p>在组件的生命周期内，可以使用 操作符方法进行传递信息，</p><p>可以使用转换方法在 Observer 的整个生命周期中传递信息。只有在 Observer 对象在监听 LiveData 对象时，转换操作符才会执行。因为转换操作是延时操作的，因此与生命周期相关的行为会隐式传递，而不需要显式调用或依赖。</p><p>如果你在 ViewModel 中需要 Lifecycle 对象，那么转换操作符可能是一个更好的解决方案。假设一个 UI 组件接收一个地址后返回该地址的邮编，该业务的实现可以用 ViewModel 实现，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    private fun getPostalCode(address: String): LiveData&lt;String&gt; &#123;</span><br><span class="line">        // DON&apos;T DO THIS</span><br><span class="line">        return repository.getPostCode(address)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这是不被推荐的，UI 组件每次调用 getPostalCode（）时都需要从先前的LiveDat a对象中注销并注册到新实例。此外，如果重新创建了 UI 组件，则会触发对 repository.getPostCode（）方法的调用，而不是使用先前调用的结果。</p><p>可以将地址到邮编的转换用 操作符实现，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel(private val repository: PostalCodeRepository) : ViewModel() &#123;</span><br><span class="line">    private val addressInput = MutableLiveData&lt;String&gt;()</span><br><span class="line">    val postalCode: LiveData&lt;String&gt; = Transformations.switchMap(addressInput) &#123;</span><br><span class="line">            address -&gt; repository.getPostCode(address) &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private fun setInput(address: String) &#123;</span><br><span class="line">        addressInput.value = address</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，postalCode 为 addressInput 转换后得到的。只有在应用程序具有与 postalCode 关联的处于 Active 的观察者的情况下，当 addressInput 发生更改，便会重新执行转换符相应的操作，获得新的 postalCode 值 。</p><p>此机制允许较低级别的应用程序创建按需延迟计算的 LiveData 对象。ViewModel 对象可以轻松获取对 LiveData 对象的引用，执行相应的转换操作。</p><h3 id="合并不同的-LiveData-数据源"><a href="#合并不同的-LiveData-数据源" class="headerlink" title="合并不同的 LiveData 数据源"></a>合并不同的 LiveData 数据源</h3><p>MediatorLiveData 是 LiveData 的子类，可以实现合并多个 LiveData 的数据源，当其中的一个 LiveData 数据源发生改变时，所以与该 MediatorLiveData 对象关联的 Observer 对象会被触发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x000-概述&quot;&gt;&lt;a href=&quot;#0x000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x000 概述&quot;&gt;&lt;/a&gt;0x000 概述&lt;/h3&gt;&lt;p&gt;在官方文档中首先对 LiveData 做了一个概述 : &lt;code&gt;LiveData is an observable data holder class&lt;/code&gt;, LiveData 是一个 &lt;strong&gt;可观察的&lt;/strong&gt; &lt;strong&gt;数据持有者类&lt;/strong&gt;。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 &lt;strong&gt;活跃状态下&lt;/strong&gt; 更新组件。&lt;/p&gt;
&lt;p&gt;LiveData 认为上述中的 &lt;strong&gt;活跃状态&lt;/strong&gt; 为对应的 Observer 处于 &lt;strong&gt;STARTED&lt;/strong&gt; 或 &lt;strong&gt;RESUMED&lt;/strong&gt; 状态。LiveData 数据更改不会触发非活跃组件的更新。&lt;/p&gt;
&lt;p&gt;LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-个人理解&quot;&gt;&lt;a href=&quot;#0x0001-个人理解&quot; class=&quot;headerlink&quot; title=&quot;0x0001 个人理解&quot;&gt;&lt;/a&gt;0x0001 个人理解&lt;/h3&gt;&lt;p&gt;官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&amp;lt;? super T&amp;gt; observer)&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="LiveData" scheme="/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 ViewModle 组件学习笔记</title>
    <link href="/2019/05/06/Jetpack%20%E4%B9%8B%20ViewModle%20%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/06/Jetpack 之 ViewModle 组件学习笔记/</id>
    <published>2019-05-06T03:52:23.000Z</published>
    <updated>2019-10-22T02:57:14.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>ViewModel 类旨在 <strong>通过生命周期感知</strong> 的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 <strong>存活</strong> 的状态。</p><p>Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。为了响应用户的动作，系统可能会新建或重建 UI，但是这些都不是开发者所能控制的。</p><a id="more"></a><p><strong>面临问题：</strong></p><ol><li><p>如果系统销毁或者新建 UI，则存储在其中的任何与 UI 相关短暂的数据都将丢失。对于简单的数据， Activity 可以在  onSaveInstanceState() 中保存下来，在新建的 Activity 的 onCreate() 方法中重新获得这些数据，但是这方法只适用于数据量较小、可以序列化和反序列化的数据，不使用大量的数据，例如对象列表、Bitmap 列表。</p></li><li><p>另外一个问题是：UI 中频繁的异步任务会占用一些时间返回数据。Activity 需要管理这些请求并且保证系统能够在 Activity 销毁后回收这些请求，避免潜在的内存泄漏，而管理上述情况会占用大量的资源。</p></li></ol><p><strong>UI 的主要职责是用来展示数据、响应用户的动作或者组件间交流</strong>，例如权限请求。让 UI 承担从网络或者数据库获取数据等职责，使得类变的十分的臃肿，同时使 UI 变得难以测试。我们不应该为 UI 分配过多的职责，不能让一个类去处理所有的工作，而是将这些工作委托给其他类。这其实是 MVC、MVP、MVVM 这些架构演进的重要原因。</p><p>将视图数据所有权与 UI 控制器逻辑分离，使逻辑更加简单、更易于维护。</p><h3 id="0x0001-ViewModel-使用"><a href="#0x0001-ViewModel-使用" class="headerlink" title="0x0001 ViewModel 使用"></a>0x0001 ViewModel 使用</h3><p>ViewModel 的主要职责是 <strong>为 UI 提供数据</strong>，Activity 重建后会复用第一次建立 Activity 的 ViewModel 对象。与之前的写法不同，现在我们需要将获取到的数据保存到 ViewModel，这样就保证数据在当前 Activity 重建后可以复用数据。</p><p>官方文档示例：</p><p>ViewModel 相应代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData().also &#123;</span><br><span class="line">            loadUsers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">        return users</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun loadUsers() &#123;</span><br><span class="line">        // Do an asynchronous operation to fetch users.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 ViewModel 中获取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        // Create a ViewModel the first time the system calls an activity&apos;s onCreate() method.</span><br><span class="line">        // Re-created activities receive the same MyViewModel instance created by the first activity.</span><br><span class="line"></span><br><span class="line">        val model = ViewModelProviders.of(this).get(MyViewModel::class.java)</span><br><span class="line">        model.getUsers().observe(this, Observer&lt;List&lt;User&gt;&gt;&#123; users -&gt;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the activity is re-created, it receives the same MyViewModel instance that was created by the first activity。<br>而当 ViewModel 的宿主 Activity 销毁后，系统会调用 ViewModel 对象的 onCleared() 方法，用来清除资源。</p><p><strong>ViewModel 禁止引用 View、Lifecycle 以及其他任何引用 Activity 环境变量的对象，这样会导致内存泄漏</strong></p><p>ViewModel 旨在创建超过 View 或 LifecycleOwners 对象生命周期的对象。这使得你可以更加容易的测试 ViewModel ，因为不需要知道 View 或 Lifecycle 对象。</p><p>ViewModel 可以持有 LifecycleObserver ，例如 LiveData 对象。但是 ViewModel 对象不能观察到生命周期感知的可观察对象（例如LiveData对象）的更改。</p><p>如果 ViewModel 需要 Application 上下文，例如查找系统服务，可以使用 ViewModel 的子类 AndroidViewModel 类，并在构造函数中传入 Application 对象。</p><h3 id="0x0002-ViewModel-的生命周期"><a href="#0x0002-ViewModel-的生命周期" class="headerlink" title="0x0002 ViewModel 的生命周期"></a>0x0002 ViewModel 的生命周期</h3><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="ViewModel 的生命周期"></p><p>You usually request a ViewModel the first time the system calls an activity object’s onCreate() method. The system may call onCreate() several times throughout the life of an activity, such as when a device screen is rotated. The ViewModel exists from when you first request a ViewModel until the activity is finished and destroyed.</p><p>ViewModel 会在 Activity 第一次创建存在，直到该 Activity 被彻底销毁不再重建。</p><p>获取 ViewModel 对象时，ViewModel 对象的范围限定为传递给ViewModelProvider 的对象的生命周期。</p><h3 id="0x0003-多-Fragment-间共享数据"><a href="#0x0003-多-Fragment-间共享数据" class="headerlink" title="0x0003 多 Fragment 间共享数据"></a>0x0003 多 Fragment 间共享数据</h3><p>，一个 Activity 中包含多个 Fragment 并且 Fragment 间需要通信，这在日常开发中是十分常见的。</p><p>看一下官方文档给出的案例：</p><p>想象一下主/从 Fragment 的一种常见情况，用户在一个 Fragment 的列表中选择一个 item，另一个 Fragment 显示了所选 item 的具体内容。这种情况绝非易事，因为两个 Fragment 都需要定义一些接口描述，并且 Activity 必须将两者绑定在一起。此外，两个Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p><p>可以通过使用 ViewModel 对象解决这种常见的情况。这些 Fragment 可以使用其宿主 Activity 范围的 共享ViewModel 来处理此通信，如以下示例代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SharedViewModel : ViewModel() &#123;</span><br><span class="line">    val selected = MutableLiveData&lt;Item&gt;()</span><br><span class="line"></span><br><span class="line">    fun select(item: Item) &#123;</span><br><span class="line">        selected.value = item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MasterFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var itemSelector: Selector</span><br><span class="line"></span><br><span class="line">    private lateinit var model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(this)[SharedViewModel::class.java]</span><br><span class="line">        &#125; ?: throw Exception(&quot;Invalid Activity&quot;)</span><br><span class="line">        itemSelector.setOnClickListener &#123; item -&gt;</span><br><span class="line">            // Update the UI</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DetailFragment : Fragment() &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var model: SharedViewModel</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        model = activity?.run &#123;</span><br><span class="line">            ViewModelProviders.of(this)[SharedViewModel::class.java]</span><br><span class="line">        &#125; ?: throw Exception(&quot;Invalid Activity&quot;)</span><br><span class="line">        model.selected.observe(this, Observer&lt;Item&gt; &#123; item -&gt;</span><br><span class="line">            // Update the UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 Fragment 都检索包含它们的 Activity。这样，当每个 Fragment 获得ViewModel Provider 对象，它们将收到相同的 SharedViewModel 实例，该实例的作用范围是其宿主 Activity。</p><p>这种方法具有以下优点：</p><ol><li>宿主 Activity 不需要执行任何操作，也无需了解此通信。</li><li>除 SharedViewModel 对象外， Fragment 不需要彼此了解。如果其中一个 Fragment 消失了，则另一个 Fragment 继续工作。</li><li>每个 Fragment 都有自己的生命周期，并且不受另一个 Fragment  的生命周期影响。如果一个 Fragment 替换了另一个 Fragment ，则 UI 可以继续工作而不会出现任何问题。</li></ol><hr><p>有问题欢迎点击：<a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;ViewModel 类旨在 &lt;strong&gt;通过生命周期感知&lt;/strong&gt; 的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 &lt;strong&gt;存活&lt;/strong&gt; 的状态。&lt;/p&gt;
&lt;p&gt;Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。为了响应用户的动作，系统可能会新建或重建 UI，但是这些都不是开发者所能控制的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="ViewModle" scheme="/tags/ViewModle/"/>
    
  </entry>
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/2019/05/06/TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>/2019/05/06/TCP-的三次握手和四次挥手/</id>
    <published>2019-05-06T03:35:16.000Z</published>
    <updated>2019-08-28T03:31:38.107Z</updated>
    
    <content type="html"><![CDATA[<p>TCP 协议做的是：在算法层面保证可靠性。</p><p>有关可靠性的指标：</p><ul><li>保证顺序</li><li>不丢包</li><li>维护 TCP 连接</li><li>流量控制</li><li>拥塞控制</li></ul><p>为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：</p><a id="more"></a><p><img src="/../images/2019_05_06_01.jpg" alt="TCP 包头格式"></p><h3 id="TCP-三次握手基本流程"><a href="#TCP-三次握手基本流程" class="headerlink" title="TCP 三次握手基本流程"></a>TCP 三次握手基本流程</h3><p>为了更好的理解 TCP 三次握手，来看一下生活中场景(A、B 两人彼此自我介绍的场景):</p><hr><p><strong>1、A (A -&gt; B):</strong> 你好，我是 A(此时 A 不知道 B 是否收到自己的介绍，所以 A 现在等待 B 的 <strong>应答</strong>)。</p><p><strong>2、B (B -&gt; A):</strong> 你好，我是 B(此时 B 不知道 A 是否收到自己的介绍，所以 B 现在等待 A 对自己的应答进行应答，可称为 <strong>应答之应答</strong>)。</p><p><strong>3、A (A -&gt; B):</strong> 你好 B (此时 A 已经知道了 B，同时 B 也知道了 A , A 认为双方建立了连接，即使此次数据发送失败，当 A 开始发送数据时，也可完成连接)。</p><hr><p>以上情况是在比较顺畅的情况两人建立了友谊关系，当然也会存在异常情况，如下几种：</p><h4 id="异常情况一"><a href="#异常情况一" class="headerlink" title="异常情况一"></a>异常情况一</h4><p>步骤一中 A 发送的数据包丢失，因为各种原因：丢失、绕路、B 没有响应等情况，无法进入到步骤二，由于 A 没有收到发送数据包的应答，所以 A 会再次发送数据包，如果还是无法收到应答，还会再发。</p><h4 id="异常情况二"><a href="#异常情况二" class="headerlink" title="异常情况二"></a>异常情况二</h4><p>A 发送的请求到达 B ,此时 B 已经知道了 A 的存在，如果 B 想要建立连接，就会发送应答给 A；如果 B 不想建立连接，就不会发送应答，A 在尝试发送数据包一段时间后就会放弃，此时建立连接失败。</p><h4 id="异常请求三"><a href="#异常请求三" class="headerlink" title="异常请求三"></a>异常请求三</h4><p>在 A 多次发送请求数据包时，各步骤终于顺畅的进行下去，A、B 建立连接。 在两者进行短暂的交流后结束了谈话后，此时结束了连接，但是此时 A 建立连接时发送的数据包经过一段时间的绕路后，来到了 B ，如果 B 认为这是一个正常的请求的话建立了连接，此时这个连接不会进行下去，但是也不会有结束的时候，极大的浪费了网络资源。</p><p>这个异常情况在说明了 <strong>两次握手是不可以的</strong>。</p><h4 id="异常情况四"><a href="#异常情况四" class="headerlink" title="异常情况四"></a>异常情况四</h4><p>B 发送的应答可能会发送多次，但是只要有一次到达了 A ，那么 A 就会认为已经建立了连接，因为 <strong>对于 A 来说消息有去有回</strong>。当 A 为此次应答发送的应答到达 B 后，B 就认为已经建立了连接，因为 <strong>对于 A 来说消息也是有去有回</strong>。</p><p>但是此时也会出现异常情况，如果 A 发送的应答消息丢失。按理来说，针对每一个应答都会有对方的应答之应答，依次循环往复，那么多少次握手都是可以的，但是并不能保证连接都是可靠的，所以 <strong>只要保证 A、B 双方的消息都有去有回就可以了</strong>，这也是为什么 <strong>TCP 建立连接需要三次握手的原因</strong> 了。</p><p>如果 A 发送的应答丢失了，此时对于 B 是怎样的情况？ 好在 A 在建立连接后就会发送数据，如果 A 发送的应答丢失了，后续 A 发送的数据到了 B，那么 B 就会认为已经建立了连接；如果 B 出现异常，那么 A 发送的数据会报错，说 B 是不可达的，A就知道了 B 出现了异常，就会做出相应的处理。</p><p>至此 TCP 三次握手过程大致梳理清楚了。</p><h3 id="TCP-数据包的序号问题"><a href="#TCP-数据包的序号问题" class="headerlink" title="TCP 数据包的序号问题"></a>TCP 数据包的序号问题</h3><p>TCP 三次握手处理建立连接外，主要还是为了沟通一件事情：  <strong>TCP 包的序号问题。</strong></p><p>A 需要告诉 B 自己发送的包的序号的起始是从哪个号开始的，同理 B 也要做相同的事情。</p><p>为什么序号不能都从 1 开始呢？</p><p>针对这个问题，我们来看一个场景：</p><p>A 发送 1、2、3 包给 B，1、2 安全可靠的到达 B，包 3 由于各种原因绕了原路，没有到达 B ，此时 A 短暂掉线，后重新连接，发送的数据序号从 1 开始，然后发送 2，至此该发送过程结束，但是绕路的 3 数据包有回来了，此时 B 认为它是一个正常包，于是产生了错误。</p><p>所以每个连接都要有不同的序号，这个序号的起始序号是随时间变化的，可以认为一个 32 位计数器，每 4ms 加 1，重复的序列号至少需要 4 h，此时由于 IP 包头中 TTL 的存在，绕路的包已经在该时间内就不复存在了。</p><p><strong>正是因为 TCP 序号的机制，才保证了 TCP 连接过程中的保证顺序、不丢包的指标。</strong></p><h3 id="TCP-三次握手中的状态机"><a href="#TCP-三次握手中的状态机" class="headerlink" title="TCP 三次握手中的状态机"></a>TCP 三次握手中的状态机</h3><p>在建立 TCP 连接时，为了维护这个连接，双方需要维护一个状态机<a href="状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。">^1</a>，在建立连接过程中，双方的状态变化时序图如下：</p><p><img src="/../images/2019_05_07_01.jpg" alt="状态时序图"></p><ol><li>Client 和 Server 均处于 CLOSED 状态，此时 Server <span style="color: #5bdaed;font-weight: bold;">主动</span> 监听某个端口号。</li><li>Client 主动发起连接 SYN ,之后 Client 处于 SYN-SENT 状态。</li><li>Server 收到 Client 发起的连接，返回 SYN，并且 ACK Client 的 SYN，之后 Server 进入到 SYN-RCVD 状态。</li><li>Client 收到 Server 发送的 SYN 和 ACK，发送 ACK 的 ACK ,之后 Client 进入 ESTABLISHED 状态，因为它一发一收成功了。</li><li>Server收到 ACK 的ACK 后，进入 ESTABLISHED 状态，因为它一发一收成功了。</li></ol><hr><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>使用上面同样的例子，A、B 相同认识，进行简单的交流后，挥手说再见，各回各家。</p><p><strong>1、A (A -&gt; B):</strong> B ,我不能和你再聊了，我要回家了。<br><strong>2、B (B -&gt; A):</strong> 好的 A，我知道了。</p><p>此时只是 A 单方面的不想再聊，即 A 在此后不会发送数据了。但是 B 不能再应答 A 之后马上就关闭连接，为什么呢？因为在此状况下，只是 A 在发送数据后不再发送数据了，B 还有自己没有做完的事情，此时 B 还是可以发送数据的，此时处于 <strong>半关闭状态</strong>。</p><p><strong>此时 A 可以选择不再接收数据，也可以选择最后在接收一段数据，等待 B 也主动关闭。</strong></p><p><strong>3、B (B -&gt; A):</strong> A 我也不玩了，Bye。<br><strong>4、A (A -&gt; B):</strong> 好的，Bye。</p><p>这样整个连接就关闭了，如建立连接时存在异常，同样关闭连接也会存在异常，如下：</p><h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>A 在说完“我不和你聊天了”，直接跑路，这是是会出现问题的，因为 B 还没发起结束，就算发起了，也得不到回答，此时 B 不知道怎么办。</p><p>还有一种异常情况是，当 A 说完 “我不和你聊天了， B 直接跑路，A 的发送的数据包没有得到应答，它不知道 B 是在处理自己的事情还是等一会发送结束。</p><h3 id="TCP-四次挥手的时序图"><a href="#TCP-四次挥手的时序图" class="headerlink" title="TCP 四次挥手的时序图"></a>TCP 四次挥手的时序图</h3><p><img src="/../images/2019_05_07_02.jpg" alt="四次挥手时序图"></p><ol><li><p>Clinet 自己断开连接，发送 FIN 后进入 FIN-WAIT-1 状态。</p></li><li><p>Server 收到 Client 的 FIN 请求，发送 FIN 的 ACK ，Server 进入 CLOSED-WAIT 的状态。</p></li><li><p>Client 收到 Server 的 ACK 后进入 FIN-WAIT-2 的状态。</p><p>若这个时候 Server 跑路，那么 A 将永远处在 FIN-WAIT-2 状态，TCP 协议没有对这个状态处理，但是 Linux 可以调整 tcp_fin_timeout 参数，来设置超时时间。</p></li><li><p>Server 发送 FIN 的请求到达 Client , Client 发送该请求的 ACK ,然后结束了 FIN-WAIT-2 状态，按理说 Client 可以跑路了，但是万一自己发送的 ACK 没有成功到达 Server 怎么办？如果是这样的情况，Server 在一段时间后会重新发送 FIN 请求，但是 Client 已经跑路了，Server 永远也收不到 ACK 了。基于此原因 TCP 协议要求 Cleint 在最后需要等待一段时间 TIME-WAIT ,这个时间需要足够长，长到下面的步骤能够成功执行。</p><p> 如果 Server 超过了 2MSL 依然没有收到 ACK ，虽然 Server 会重发 FIN ，但是 Client 收到这个数据包后表示我已经等待了这么长时间，也够意思了，朋友再见，发送 RST 请求，Server 收到这个请求后就知道 Client 已经跑路了。</p></li></ol><p>MSL(Maximum Segment Lifetime)，报文最大生存时间，它是报文在网络中存在的最大时间，超过这个时间报文会被丢弃。</p><p>IP 头中有 TTL域，IP 数据包每经过一个处理它的路由器后，该值减 1，此值为 0 是数据包被丢且。</p><h4 id="异常情况一-1"><a href="#异常情况一-1" class="headerlink" title="异常情况一"></a>异常情况一</h4><p>A 发送： ”不玩了“<br>B 回复： “知道了”</p><p>在这个回合中是不存在异常的，如果 A 发送的消息没有得到 B 的回复会重复发送。</p><p>但是在这个回合结束后，就有可能发生异常情况，因为存在一方先 “跑路” 的情况。</p><h4 id="异常情况二-1"><a href="#异常情况二-1" class="headerlink" title="异常情况二"></a>异常情况二</h4><p>A 发起结束后，马上跑路，此时 B 发起的结束，是得不到 A 的回复的。</p><h4 id="异常情况三"><a href="#异常情况三" class="headerlink" title="异常情况三"></a>异常情况三</h4><p>A 发起结束后，B 马上跑路，这时 A 不知道 B 的具体状态，是还有事情处理还是一会才会发送结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP 协议做的是：在算法层面保证可靠性。&lt;/p&gt;
&lt;p&gt;有关可靠性的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证顺序&lt;/li&gt;
&lt;li&gt;不丢包&lt;/li&gt;
&lt;li&gt;维护 TCP 连接&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络协议" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="TCP" scheme="/tags/TCP/"/>
    
      <category term="趣谈网络协议(刘超)" scheme="/tags/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%88%98%E8%B6%85/"/>
    
  </entry>
  
  <entry>
    <title>简单理解 Java 反射机制</title>
    <link href="/2019/04/30/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>/2019/04/30/Java-反射/</id>
    <published>2019-04-30T02:35:03.000Z</published>
    <updated>2019-10-27T08:45:44.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据一个对象获得一个类"><a href="#根据一个对象获得一个类" class="headerlink" title="根据一个对象获得一个类"></a>根据一个对象获得一个类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;adb&quot;;</span><br><span class="line">Class class = str.getClass();</span><br></pre></td></tr></table></figure><h2 id="根据一个字符串获得一个类"><a href="#根据一个字符串获得一个类" class="headerlink" title="根据一个字符串获得一个类"></a>根据一个字符串获得一个类</h2><p>字符串需要包括完整的包名和类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">Class class2 = Class.forName(&quot;android.widget.Button&quot;);</span><br><span class="line"></span><br><span class="line">// 获得对象的父类型</span><br><span class="line">Class class3 = class2.getSuperClass();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h2><h3 id="实例类"><a href="#实例类" class="headerlink" title="实例类"></a>实例类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private String name = &quot;default&quot;;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String tag;</span><br><span class="line"></span><br><span class="line">    public TestClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestClass(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String showName(String string) &#123;</span><br><span class="line">        return name + &quot; &amp;&amp; &quot; + string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void testStaticsMethod() &#123;</span><br><span class="line">        System.out.println(&quot;testStaticsMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printStatics()&#123;</span><br><span class="line">        System.out.println(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TestClass&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得所有构造函数"><a href="#获得所有构造函数" class="headerlink" title="获得所有构造函数"></a>获得所有构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestClass testClass = new TestClass();</span><br><span class="line">Class clazz = testClass.getClass();</span><br><span class="line">String className = clazz.getName();</span><br><span class="line">// 获得所有的构造函数</span><br><span class="line">Constructor[] classList = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 获得所有 public 构造函数</span><br><span class="line">Constructor[] classList2 = clazz.getConstructors();</span><br></pre></td></tr></table></figure><h3 id="获得无参构造函数"><a href="#获得无参构造函数" class="headerlink" title="获得无参构造函数"></a>获得无参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">// 获得 public 无参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br></pre></td></tr></table></figure><h3 id="获得有参构造器"><a href="#获得有参构造器" class="headerlink" title="获得有参构造器"></a>获得有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line"></span><br><span class="line">// 获得指定的 public 有参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor(params);</span><br></pre></td></tr></table></figure><h2 id="调用类的构造器"><a href="#调用类的构造器" class="headerlink" title="调用类的构造器"></a>调用类的构造器</h2><h3 id="调用无参构造器"><a href="#调用无参构造器" class="headerlink" title="调用无参构造器"></a>调用无参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure><h3 id="调用有参构造器"><a href="#调用有参构造器" class="headerlink" title="调用有参构造器"></a>调用有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line">Object obj = constructor.newInstance(&quot;Mike&quot;,23);</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><h3 id="调用私有实例方法"><a href="#调用私有实例方法" class="headerlink" title="调用私有实例方法"></a>调用私有实例方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//通过反射获得实例对象</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;test&quot;, 1);</span><br><span class="line">TestClass testClass = (TestClass) object;</span><br><span class="line"></span><br><span class="line">//获得指定的 private 方法</span><br><span class="line">Class[] params = &#123;String.class&#125;;</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;showName&quot;, params);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 调用指定对象的的方法</span><br><span class="line">Object[] argList = &#123;&quot;call private method&quot;&#125;;</span><br><span class="line">Object returnParam = method.invoke(testClass, argList);</span><br><span class="line">System.out.println(returnParam);</span><br></pre></td></tr></table></figure><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取私有静态方法</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;testStaticsMethod&quot;);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">method.invoke(null);</span><br></pre></td></tr></table></figure><h2 id="获得类的实例变量并修改"><a href="#获得类的实例变量并修改" class="headerlink" title="获得类的实例变量并修改"></a>获得类的实例变量并修改</h2><h3 id="非静态变量"><a href="#非静态变量" class="headerlink" title="非静态变量"></a>非静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 通过反射获得类实例</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;Mike&quot;, 3);</span><br><span class="line"></span><br><span class="line">//获得实例变量 getField 获取一个类的public 成员变量包括基类</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//非静态实例变量传入object ,获得 object 的实例变量的值，并把它包装成类</span><br><span class="line">Object fieldObject = field.get(object);</span><br><span class="line"></span><br><span class="line">//修改 object 对应属于的值,注意只会修改 object 这个对象的字段值</span><br><span class="line">field.set(object, &quot;test Field&quot;);</span><br><span class="line">System.out.println(fieldObject);</span><br><span class="line"></span><br><span class="line">Object fieldObject1 = field.get(object);</span><br><span class="line">System.out.println(fieldObject1);</span><br></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line"></span><br><span class="line">// 获取类的 name 静态字段</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;tag&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 为 static 变量时传入 null,获得静态变量，并包装</span><br><span class="line">Object fieldObject = field.get(null);</span><br><span class="line"></span><br><span class="line">//修改值</span><br><span class="line">field.set(fieldObject, &quot;ABCD&quot;);</span><br><span class="line"></span><br><span class="line">//查看值，静态变量一次修改，一生受用</span><br><span class="line">TestClass.printStatics();</span><br></pre></td></tr></table></figure><h2 id="对泛型进行反射"><a href="#对泛型进行反射" class="headerlink" title="对泛型进行反射"></a>对泛型进行反射</h2><p>通过指定类对应的 Class 对象，可以获得该类包含的所有成员变量，如获取指定成员变量的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = f.getType();</span><br></pre></td></tr></table></figure><p>但是这种方式只对普通的变量生效，如果该变量有泛型类型，如 Map&lt;String,String&gt;，则不能准确的获得该成员的泛型类型。为了获得指定变量的泛型类型，可以使用如下方法获得该变量的泛型类想：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = f.getGenericType();// Field 的方法</span><br></pre></td></tr></table></figure><p>然后将 Type 类型的对象强制转换为 ParameterizedType 类型对象，ParameterizedType 代表被参数化的类型，也就是增加泛型限制的类型，ParameterizedType 有以下两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type getRawType();// 返回没有泛型信息的原始类型</span><br><span class="line">Type[] getActualTypeArguments();// 返回泛型参数的类型</span><br></pre></td></tr></table></figure><p>以下为示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;GenericsClass&gt; clazz = GenericsClass.class;</span><br><span class="line">        Field field = clazz.getDeclaredField(&quot;map&quot;);</span><br><span class="line">        // getType 只对普通成员变量有效</span><br><span class="line">        Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">        System.out.println(&quot;map 的数据类型是：&quot; + fieldType);</span><br><span class="line"></span><br><span class="line">        Type type = field.getGenericType();</span><br><span class="line">        if(type instanceof ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">            Type rawType = parameterizedType.getRawType();</span><br><span class="line">            System.out.println(&quot;map 的原始类型是：&quot; + rawType);</span><br><span class="line">            // 取得泛型的的泛型参数</span><br><span class="line">            System.out.println(&quot;取得泛型的的泛型参数:&quot;);</span><br><span class="line">            Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">            for(int i = 0;i &lt; types.length;i++)&#123;</span><br><span class="line">                System.out.println(&quot;map 的第 &quot; + i + &quot; 个泛型类型是：&quot; + types[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;取得泛型类型错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map 的数据类型是：interface java.util.Map</span><br><span class="line">map 的原始类型是：interface java.util.Map</span><br><span class="line">取得泛型的的泛型参数:</span><br><span class="line">map 的第 0 个泛型类型是：class java.lang.String</span><br><span class="line">map 的第 1 个泛型类型是：class java.lang.Integer</span><br></pre></td></tr></table></figure><p>使用以上 API 可以获得泛型成员变量的类型参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;根据一个对象获得一个类&quot;&gt;&lt;a href=&quot;#根据一个对象获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个对象获得一个类&quot;&gt;&lt;/a&gt;根据一个对象获得一个类&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String str = &amp;quot;adb&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class = str.getClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;根据一个字符串获得一个类&quot;&gt;&lt;a href=&quot;#根据一个字符串获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个字符串获得一个类&quot;&gt;&lt;/a&gt;根据一个字符串获得一个类&lt;/h2&gt;&lt;p&gt;字符串需要包括完整的包名和类名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class class = Class.forName(&amp;quot;java.lang.String&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class2 = Class.forName(&amp;quot;android.widget.Button&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获得对象的父类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class3 = class2.getSuperClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Inflection" scheme="/tags/Inflection/"/>
    
  </entry>
  
  <entry>
    <title>理解 JNI</title>
    <link href="/2019/04/09/%E7%90%86%E8%A7%A3JNI/"/>
    <id>/2019/04/09/理解JNI/</id>
    <published>2019-04-09T08:28:01.000Z</published>
    <updated>2019-12-03T03:42:56.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI-概述"><a href="#JNI-概述" class="headerlink" title="JNI 概述"></a>JNI 概述</h3><p>JNI(Java Native Interface),意为 <strong>Java 本地调用</strong>,是连接 Java 和 native 的桥梁。</p><p>JNI 推出的原因：</p><ol><li>Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。</li><li>执行效率和速度。</li></ol><h3 id="JNI之-Java-层操作"><a href="#JNI之-Java-层操作" class="headerlink" title="JNI之 Java 层操作"></a>JNI之 Java 层操作</h3><p>Java 层主要有两个关键：</p><ol><li>加载 native 动态库</li><li>声明 Java 的 native 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MediaScanner implements AutoCloseable &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;media_jni&quot;);// 加载 so 库</span><br><span class="line">        native_init();//调用 native 方法</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private static native final void native_init();</span><br><span class="line">    private native final void native_setup();</span><br><span class="line">    private native final void native_finalize();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JNI-之-native-层操作-一"><a href="#JNI-之-native-层操作-一" class="headerlink" title="JNI 之 native 层操作 (一)"></a>JNI 之 native 层操作 (一)</h3><p>实例代码：<br>MediaScanner.cpp 代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// MediaScanner.java 的 native 的 JNI 实现</span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_init&quot;);</span><br><span class="line">    jclass clazz = env-&gt;FindClass(kClassMediaScanner);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    if (fields.context == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_setup(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_setup&quot;);</span><br><span class="line">    MediaScanner *mp = new StagefrightMediaScanner;</span><br><span class="line"></span><br><span class="line">    if (mp == NULL) &#123;</span><br><span class="line">        jniThrowException(env, kRunTimeException, &quot;Out of memory&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.context, (jlong)mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNI-之-native-层操作-二-–-注册-JNI-函数"><a href="#JNI-之-native-层操作-二-–-注册-JNI-函数" class="headerlink" title="JNI 之 native 层操作 (二) – 注册 JNI 函数"></a>JNI 之 native 层操作 (二) – 注册 JNI 函数</h3><p>如何知道 Java 层的 MediaScanner 中的 native_init 函数对于 JNI 层的 android_media_MediaScanner_native_init 函数,这时就需要 JNI 注册，将两个层面的函数关联起来。注册后，有了这层关联关系，Java 层调取 JNI 层函数就可以实现。</p><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>静态注册实现方法参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/84028290" target="_blank" rel="noopener">Android Studio 配置 javah 生成 C/C++ 头文件，完成 JNI 调用</a> 中相关内容。</p><p>当 Java 层调用 native_init 函数式，就会去 JNI 库中寻找 android_media_MediaScanner_native_init 函数，如果没有，就会报错，如果存在该函数，就会建立关联，<strong>此关联其实就是保存的 JNI 层函数的函数指针</strong>。以后再调用此函数，直接调用该函数指针就可以了，这部分的工作是在 Java 虚拟机中完成的。</p><p><strong>Java native 是通过函数指针来与 JNI 层的函数建立联系的。</strong></p><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>在静态注册中可知，Java 层和 JNI 层的函数是一一对应的，那么可以使用结构体来保存这种关联关系。JNI 中可以使用 JNINativeMethod 这种结构体来实现以上功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_init&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_init</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_setup&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_setup</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AndroidRuntime.cpp 类中提供了 registerNativeMethod 来完成注册工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Register native methods using JNI.</span><br><span class="line"> */</span><br><span class="line">/*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env,</span><br><span class="line">    const char* className, const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jniRegisterNativeMethods 为 JNIHelper 中提供的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Registering %s&apos;s %d native methods...&quot;, className, numMethods);</span><br><span class="line"></span><br><span class="line">    scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的工作只要两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 找到对应的类</span><br><span class="line">scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line"></span><br><span class="line">// 这句话其实是调用 JINEnv 的 RegisterNatives方法，将 JNI 类中结构体注册进来，从而完成注册关系</span><br><span class="line">(*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods)</span><br></pre></td></tr></table></figure><p>注册的函数在什么地方以及什么时候执行？</p><p>当 Java 层通过 <code>System.loadLibrary()</code> 加载完 JNI 动态库后，接着会查找库中的 <code>JNI_Onload</code> 的函数，如果有的话，就会调用他，而动态注册的工作就是在此处完成的。</p><h3 id="native-函数的参数含义"><a href="#native-函数的参数含义" class="headerlink" title="native 函数的参数含义"></a>native 函数的参数含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Java 层的 processFile 只有 3 个参数，而 JNI 中的方法有 5 中方法。</span><br><span class="line">* JNIEnv *env 为 代表 JNI 环境的结构体</span><br><span class="line">* jobject thiz：代表 Java 层的 MediaScanner 对象，如果方法为 static，参数为 jclass ,代表在调用 Java 的哪一个 Class 中的函数</span><br><span class="line">* 剩下的为 Java 层中该方法的参数</span><br><span class="line">*/</span><br><span class="line">static jboolean android_media_MediaScanner_processFile(</span><br><span class="line">        JNIEnv *env, jobject thiz, jstring path,</span><br><span class="line">        jstring mimeType, jobject client)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNIEnv-介绍"><a href="#JNIEnv-介绍" class="headerlink" title="JNIEnv 介绍"></a>JNIEnv 介绍</h3><p>JNIEnv 是一个 <strong>线程相关</strong> 的 <strong>代表 JNI 环境</strong> 的 <strong>结构体</strong>。</p><p><img src="/images/2019_04_10_1.jpg" alt="JNIEnv 内部结构简图"></p><p>JNIEnv 实际上是提供了一系列 JNI 系统函数，通过这些函数可以做到：</p><ol><li>调用 Java 函数</li><li>操作 jobject 对象</li></ol><h3 id="JNIEnv-的使用"><a href="#JNIEnv-的使用" class="headerlink" title="JNIEnv 的使用"></a>JNIEnv 的使用</h3><p>获得 Filed 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">android_media_MediaPlayer_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    // 获得 jclass</span><br><span class="line">    clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;);</span><br><span class="line">    // 获得 clazz 中的 </span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, &quot;postEventFromNative&quot;,</span><br><span class="line">                                               &quot;(Ljava/lang/Object;IIILjava/lang/Object;)V&quot;);</span><br><span class="line"></span><br><span class="line">    fields.surface_texture = env-&gt;GetFieldID(clazz, &quot;mNativeSurfaceTexture&quot;, &quot;J&quot;);</span><br><span class="line">    env-&gt;DeleteLocalRef(clazz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Field 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用 JNIEnv 的 CallVoidMethod 函数</span><br><span class="line">// 参数含义：mClient 为 MediaScannerClient 对象</span><br><span class="line">// 第二个参数为函数 scanFile 的 jmedthodid ,后面为 scanFile 的参数</span><br><span class="line">eEnv -&gt; CallVoidMethod(mClient,mScanFileMethod,pathStr,lastModified,fileSize)</span><br></pre></td></tr></table></figure><p>JNIEnv 有一系列类似 CallVoidMethod 的函数，形式如下：</p><p>NativeType Call<type>Method(JNIEnv *env,jobject obj,jmethodId methodId,….)</type></p><h3 id="jstring"><a href="#jstring" class="headerlink" title="jstring"></a>jstring</h3><p>jstring 对象可以看成 Java 中 String 对象在 JNI 层的代表。</p><ol><li>JNIEnv 调用 NewString(JNIEnv *env,const jchar *unicodeChars,jsize len):从 Native 的字符得到 jstring 对象(Unicode)。</li><li>JNIEnv 的 NewStringUTF 将 Native 的一个 UTF 字符串得到一个 jstring 对象(UTF)。</li><li>JNIEnv 提供 GetStringChar 函数，将 Java String对象转换成本地 Unicode 字符串。</li><li>JNIEnv 提供 GetStringUTFChars 函数 ，将 Java String 对象转换为本地 UTF 字符串。</li><li>调用上面四个函数后需要调用 ReleaseStringChars 或 ReleaseStringUTFChars 函数来释放相应资源。</li></ol><h3 id="JNI-中的三种引用"><a href="#JNI-中的三种引用" class="headerlink" title="JNI 中的三种引用"></a>JNI 中的三种引用</h3><ol><li>Local Reference：本地引用。JNI 函数执行完成后，这些 jobject 可能被回收。</li><li>Global Reference：这种方式的引用，不主动释放，永远不会被回收。</li><li>Weak Global Reference：  在使用过程中，可能会被回收。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JNI-概述&quot;&gt;&lt;a href=&quot;#JNI-概述&quot; class=&quot;headerlink&quot; title=&quot;JNI 概述&quot;&gt;&lt;/a&gt;JNI 概述&lt;/h3&gt;&lt;p&gt;JNI(Java Native Interface),意为 &lt;strong&gt;Java 本地调用&lt;/strong&gt;,是连接 Java 和 native 的桥梁。&lt;/p&gt;
&lt;p&gt;JNI 推出的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。&lt;/li&gt;
&lt;li&gt;执行效率和速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;JNI之-Java-层操作&quot;&gt;&lt;a href=&quot;#JNI之-Java-层操作&quot; class=&quot;headerlink&quot; title=&quot;JNI之 Java 层操作&quot;&gt;&lt;/a&gt;JNI之 Java 层操作&lt;/h3&gt;&lt;p&gt;Java 层主要有两个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载 native 动态库&lt;/li&gt;
&lt;li&gt;声明 Java 的 native 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class MediaScanner implements AutoCloseable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.loadLibrary(&amp;quot;media_jni&amp;quot;);// 加载 so 库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        native_init();//调用 native 方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static native final void native_init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_setup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JNI" scheme="/tags/JNI/"/>
    
      <category term="深入理解 Android 读书笔记" scheme="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Android-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想的思考</title>
    <link href="/2019/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>/2019/04/09/面向对象/</id>
    <published>2019-04-09T03:36:13.000Z</published>
    <updated>2019-04-09T06:01:42.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OOP-Object-Oriented-Programming-面向对象程序设计"><a href="#OOP-Object-Oriented-Programming-面向对象程序设计" class="headerlink" title="OOP (Object Oriented Programming) 面向对象程序设计"></a>OOP (Object Oriented Programming) 面向对象程序设计</h3><ol><li>OOP 强调的是数据。OOP 不像面向过程编程那样，试图使问题满足语言的过程性方法，而是试图让语言满足问题的要求。前者是让编程语言去 <strong>实现问题的解决方法</strong>，即以算法为主，而后者是让编程语言去 <strong>实现问题中的主体</strong>。</li><li>OOP 程序设计方法首先设计类，它准确的表示程序要处理的东西，然后设计一个使用这些类的对象的程序，从低级组织(如类)到高级组织的处理过程叫做 <strong>自下而上编程</strong>。</li><li>设计一个有用、可靠的类是十分重要的任务，一个优秀的类可以极大的减轻编程的难度及工作量。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OOP-Object-Oriented-Programming-面向对象程序设计&quot;&gt;&lt;a href=&quot;#OOP-Object-Oriented-Programming-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;OOP (Object 
      
    
    </summary>
    
    
      <category term="OOP" scheme="/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Four</title>
    <link href="/2019/04/04/Java-Basic-%E5%9B%9B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>/2019/04/04/Java-Basic-四内部类/</id>
    <published>2019-04-04T06:47:26.000Z</published>
    <updated>2019-06-14T09:04:24.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h3><ol><li>内部类为什么会出现</li><li>内部类的调用</li><li>内部类与外部类访问成员变量的不同</li><li>静态内部类和非静态内部类</li></ol><h4 id="1-1-为什么使用内部类"><a href="#1-1-为什么使用内部类" class="headerlink" title="1.1 为什么使用内部类"></a>1.1 为什么使用内部类</h4><ol><li><p>内部类提供了 <strong>更好的封装</strong>，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。</p></li><li><p><strong>内部类可以访问外部类的数据 (包括私有变量)</strong>，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。</p><p>内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。</p><p>真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用</p></li><li><p><strong>可以使用匿名内部类创建访问一次的类</strong>，十分方便。</p></li></ol><h3 id="2-非静态内部类"><a href="#2-非静态内部类" class="headerlink" title="2. 非静态内部类"></a>2. 非静态内部类</h3><p>例子 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private int num2 = 3;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        private int num = 2;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            System.out.println(&quot;innerclass method&quot;);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + num);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num &quot; + OutClass.this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num2 &quot; + num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass outclass = new OutClass();</span><br><span class="line">        System.out.println(&quot;main &quot;+ outclass.num);</span><br><span class="line">        outclass.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass();</span><br><span class="line">        inner.method();</span><br><span class="line">        System.out.println(&quot;outclass test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打印日志：</span><br><span class="line"></span><br><span class="line">main 1</span><br><span class="line">innerclass method</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method out num 1</span><br><span class="line">innerclass method out num2 3</span><br><span class="line">outclass test</span><br></pre></td></tr></table></figure><h4 id="2-1-内部类可以访问外部类的成员变量-包括私有变量"><a href="#2-1-内部类可以访问外部类的成员变量-包括私有变量" class="headerlink" title="2.1 内部类可以访问外部类的成员变量(包括私有变量)"></a>2.1 内部类可以访问外部类的成员变量(包括私有变量)</h4><p>原因：<br>在非静态内部类对象里，保存了 <strong>外部类对象的引用</strong>。</p><p>内存模型：</p><p><img src="/images/2019_04_04_1.jpg" alt="内存模型图"></p><p>但是当外部类与内部类有相同名字的变量时，引用外部类变量需要指定外部类对象 –  <code>Outclass.this</code> </p><h4 id="2-2-编译后的-Class-文件"><a href="#2-2-编译后的-Class-文件" class="headerlink" title="2.2 编译后的 Class 文件"></a>2.2 编译后的 Class 文件</h4><p>在 JVM 中没有内部类这个概念，所有的类都是普通类（POJO），内部类也会被编译成带有前缀的类。</p><p>编译后，得到两个 class 文件:</p><ol><li><code>OutClass.java</code> </li><li><code>OutClass$InnerClass.class</code></li></ol><h4 id="内部类方法中的变量的访问顺序"><a href="#内部类方法中的变量的访问顺序" class="headerlink" title="内部类方法中的变量的访问顺序"></a>内部类方法中的变量的访问顺序</h4><p>内部类方法内部中 –&gt; 内部类中的成员变量 –&gt; 外部类中的成员变量 –&gt; 不存在，编译异常</p><h4 id="2-3-内、外部类变量名相同"><a href="#2-3-内、外部类变量名相同" class="headerlink" title="2.3 内、外部类变量名相同"></a>2.3 内、外部类变量名相同</h4><p>访问使用如下格式：</p><p><code>this.field</code> : 内部类变量</p><p><code>OutClass.this.field</code> : 外部类变量</p><h4 id="2-4-外部类不可直接访问内部类成员"><a href="#2-4-外部类不可直接访问内部类成员" class="headerlink" title="2.4 外部类不可直接访问内部类成员"></a>2.4 外部类不可直接访问内部类成员</h4><p>非静态内部类成员只在非静态内部类范围内是可知的，外部类不能直接访问，但是可以通过 <strong>内部类实例对象来访问</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InnerClass().method();</span><br><span class="line">new InnerClass().num++;</span><br></pre></td></tr></table></figure><h4 id="2-5-外部类中静态成员中不允许直接使用非静态内部类"><a href="#2-5-外部类中静态成员中不允许直接使用非静态内部类" class="headerlink" title="2.5 外部类中静态成员中不允许直接使用非静态内部类"></a>2.5 外部类中静态成员中不允许直接使用非静态内部类</h4><p>静态成员为类成员，如静态变量、静态初始化块、静态内部类等，静态成员在编译期对其初始化，如果直接使用非静态成员(如非静态内部类)，则会发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OutterClass&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        // 这种情况是不被允许的</span><br><span class="line">        //new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-内、外部类关系"><a href="#2-6-内、外部类关系" class="headerlink" title="2.6 内、外部类关系"></a>2.6 内、外部类关系</h4><p>非静态内部类对象寄生在外部类对象里，有非静态内部类对象一定存在外部类对象，反之不成立。</p><h4 id="2-7-非静态内部类中的静态成员-重点理解"><a href="#2-7-非静态内部类中的静态成员-重点理解" class="headerlink" title="2.7 非静态内部类中的静态成员(重点理解)"></a>2.7 非静态内部类中的静态成员(重点理解)</h4><p>如果非静态内部类声明静态成员变量，那么必须使用 <code>final</code> 修饰，由于被 <code>final</code> 修饰该变量必须在声明处初始化。</p><p>因为一个静态变量只有一个实例，而对于每一个外部对象，分别有一个单独的内部类实例，如果这个变量不是 final 的，那么他就不是唯一的，这与 static 的含义相互冲突。</p><p><strong>非静态内部类中不能含有静态方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OutterClass &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private void outMethod()&#123;&#125;</span><br><span class="line">     class InnerClass &#123;</span><br><span class="line">        private final static String name = &quot;&quot;;</span><br><span class="line">        private /*static*/ void innerMethod() &#123;</span><br><span class="line">            age++;</span><br><span class="line">            outMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private static int age = 2;</span><br><span class="line"></span><br><span class="line">    private void doSomething()&#123;</span><br><span class="line">        StaticInnerClass.staticNum++;</span><br><span class="line">        StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">        staticInnerClass.method();</span><br><span class="line">        staticInnerClass.num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static class StaticInnerClass &#123;</span><br><span class="line">        private static int staticNum = 10;</span><br><span class="line">        private int num = 100;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            num++;</span><br><span class="line">            staticNum++;</span><br><span class="line">            age++;</span><br><span class="line">            // &apos;four.OutClass.this&apos; cannot be referenced from a static context</span><br><span class="line">            // -- four.OutClass.this 不能再 static 环境下被引用</span><br><span class="line">            // OutClass.this.num++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-静态内部类不可以访问外部类实例成员，可以访问类成员"><a href="#3-1-静态内部类不可以访问外部类实例成员，可以访问类成员" class="headerlink" title="3.1 静态内部类不可以访问外部类实例成员，可以访问类成员"></a>3.1 静态内部类不可以访问外部类实例成员，可以访问类成员</h4><p>静态内部类为外部类的类成员，只能访问外部类的静态变量，不可以访问非静态变量，还是一样牵涉到类加载、初始化顺序的问题。</p><h4 id="3-2-编译后的-Class-文件"><a href="#3-2-编译后的-Class-文件" class="headerlink" title="3.2 编译后的 Class 文件"></a>3.2 编译后的 Class 文件</h4><p>与非静态内部类相同，编译后得到两个 class 文件 – OutClass.class 、StaticInnerClass.class</p><h4 id="3-3-外部类不可直接访问静态内部类成员"><a href="#3-3-外部类不可直接访问静态内部类成员" class="headerlink" title="3.3 外部类不可直接访问静态内部类成员"></a>3.3 外部类不可直接访问静态内部类成员</h4><p>静态内部类成员、实例成员只在静态内部类范围内是可知的，外部类不能直接访问。</p><ul><li><p>通过 内部类名 来访问静态内部类类成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass.staticNum++;</span><br></pre></td></tr></table></figure></li><li><p>通过内部类实例对象访问静态内部类实例成员(不推荐，这样就忽视了 static 的含义)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">staticInnerClass.method();</span><br><span class="line">staticInnerClass.num++;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-内部类使用"><a href="#4-内部类使用" class="headerlink" title="4. 内部类使用"></a>4. 内部类使用</h3><h4 id="4-1-外部类使用内部类"><a href="#4-1-外部类使用内部类" class="headerlink" title="4.1 外部类使用内部类"></a>4.1 外部类使用内部类</h4><ul><li>基本的使用</li><li>外部类使用内部类的子类</li></ul><p>外部类中的静态代码块、静态方法中不可使用非静态内部类，因为静态成员不能使用非静态成员。</p><h4 id="4-2-外部类以外使用非静态内部类"><a href="#4-2-外部类以外使用非静态内部类" class="headerlink" title="4.2 外部类以外使用非静态内部类"></a>4.2 外部类以外使用非静态内部类</h4><p>根据内部类的访问权限修饰符，内部类对其他类的可见性不同。</p><p>外部类以外建立非静态内部类实例必须外部类实例和 new 来调用非静态内部类的构造器。</p><ul><li>非静态内部类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass innerclass = new OutClass().new InnerClass();</span><br><span class="line">innerclass.num++;</span><br><span class="line">innerclass.method();</span><br></pre></td></tr></table></figure><ul><li>非静态内部类子类</li></ul><h4 id="外部类以外使用静态内部类"><a href="#外部类以外使用静态内部类" class="headerlink" title="外部类以外使用静态内部类"></a>外部类以外使用静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected static InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass staticInnerClass = new OutClass.InnerClass();</span><br><span class="line">staticInnerClass.</span><br></pre></td></tr></table></figure><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5. 局部内部类"></a>5. 局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        class InnerBase&#123;</span><br><span class="line">            int a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class SubInnerClass extends InnerBase&#123;</span><br><span class="line">            int b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubInnerClass subInnerClass = new SubInnerClass();</span><br><span class="line">        subInnerClass.a = 1;</span><br><span class="line">        subInnerClass.b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类，顾名思义内部类定义在 方法内部，其有效范围也在方法内部，方法外部无法访问,即：对外部世界完全的隐藏起来。</p><p>通过 <code>javac Test.java</code> 对该类进行编译，生成的 class 有 3 个，分别为： <code>Test.class</code>、<code>Test$1InnerBase.class</code>、<code>Test$1SubInnerClass.class</code>。</p><p>局部内部类遵循如下命名格式：<br><strong>OutClassName$NInnerClassName 其中 N 表示第 N 个内部类。</strong></p><h3 id="6-匿名内部类-Anonymous-Inner-Class"><a href="#6-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="6. 匿名内部类(Anonymous Inner Class)"></a>6. 匿名内部类(Anonymous Inner Class)</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>匿名内部类适合创建只需要一次使用的类。</p><p>定义内部类的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 实现接口 或 父类构造器(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    类的主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由其格式可知，<strong>匿名内部类必须且只能继承一个父类，或实现且最多一个接口</strong>。</p><p>由于构造器必须与类名相同，而匿名内部类不能有类名，所以匿名类不能有构造器。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IClick &#123;</span><br><span class="line">    void change();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public  void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final String  name = &quot;name&quot;;</span><br><span class="line">        show(new IClick() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void change() &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  void show(IClick click)&#123;</span><br><span class="line">        click.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名内部类的时机：</p><p>show 方法参数为 IClick，此时考虑传入 IClick 的实现类的对象，如果 IClick 的实现类除了在此处使用外，还有其他类或方法使用该接口的实现类，那么此时应该定义一个该接口的实现类。但是如果 IClick 的实现类只会使用一次，那么可以定义一个匿名内部类，如上面实现方式。</p><p>在 Java8 之前，要求被匿名内部类、局部内部类访问的局部变量必须使用 final 修饰，Java8 则取消了这个限制，其实是 Java 自动添加了 final 修饰符。</p><p>原因：</p><p>对于普通局部变量而言，它的作用域停留在方法内，当方法执行完毕，该局部变量也随之消失，但局部内部类或匿名内部类，则可能产生隐式的 “闭包”，闭包使得局部变量脱离它所在的方法继续存在。</p><p>内部类和外部类处于同一层级，也就是说如果在方法内声明内部类实例的对象不会和局部变量一样在方法执行完毕后就会被回收</p><p>个人理解，匿名内部类是一个实现了接口或继承类的类。</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>由于系统在创建匿名内部类时，会创建匿名内部类的对象，所以匿名内部类 <strong>不能定义为抽象类</strong>。</li><li>由于匿名内部类没有类名，所以匿名内部类 <strong>无法定义构造器</strong>，但可以使用初始化块进行初始化。</li></ul><p>方法的返回值的生成和表示这个返回值的类的定义结合在一起。</p><hr><p><strong>Q:</strong> 为什么需要内部类？</p><p><strong>A:</strong> 如果你想实现一个接口，但是这个接口中的一个方法和你构想的这个类中的一个方法的名称，参数相同，你应该怎么办？这时候，你可以建一个内部类实现这个接口。由于内部类对外部类的所有内容都是可访问的，所以这样做可以完成所有你直接实现这个接口的功能。</p><p>真正的原因，java中的内部类和接口加在一起，可以很好的实现多继承的效果。</p><p><strong>Q:</strong> 内部类是否有用、必要和安全</p><p><strong>A:</strong> 内部类是一种编译器现象，与虚拟机无关。编译器会把内部了翻译成用 <code>$</code> 分割外部类名与内部类名的常规文件，而虚拟机对此一无所知。</p><hr><p><a href="https://www.zhihu.com/question/21395848" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内部类为什么会出现&lt;/li&gt;
&lt;li&gt;内部类的调用&lt;/li&gt;
&lt;li&gt;内部类与外部类访问成员变量的不同&lt;/li&gt;
&lt;li&gt;静态内部类和非静态内部类&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-1-为什么使用内部类&quot;&gt;&lt;a href=&quot;#1-1-为什么使用内部类&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么使用内部类&quot;&gt;&lt;/a&gt;1.1 为什么使用内部类&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内部类提供了 &lt;strong&gt;更好的封装&lt;/strong&gt;，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内部类可以访问外部类的数据 (包括私有变量)&lt;/strong&gt;，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。&lt;/p&gt;
&lt;p&gt;内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。&lt;/p&gt;
&lt;p&gt;真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可以使用匿名内部类创建访问一次的类&lt;/strong&gt;，十分方便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-非静态内部类&quot;&gt;&lt;a href=&quot;#2-非静态内部类&quot; class=&quot;headerlink&quot; title=&quot;2. 非静态内部类&quot;&gt;&lt;/a&gt;2. 非静态内部类&lt;/h3&gt;&lt;p&gt;例子 ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class OutClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num2 = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private class InnerClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private int num = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private void method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num &amp;quot; + OutClass.this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num2 &amp;quot; + num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OutClass outclass = new OutClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;main &amp;quot;+ outclass.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        outclass.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private void test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InnerClass inner = new InnerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inner.method();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;outclass test&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="内部类" scheme="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本使用</title>
    <link href="/2019/04/02/Vim/"/>
    <id>/2019/04/02/Vim/</id>
    <published>2019-04-02T03:33:55.000Z</published>
    <updated>2019-05-23T02:58:41.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插入命令"><a href="#1、插入命令" class="headerlink" title="1、插入命令"></a>1、插入命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">在光标所在字符<code>后</code>插入</td></tr><tr><td align="center">A</td><td align="center">在光标所在<code>行尾</code>插入</td></tr><tr><td align="center">i</td><td align="center">在光标所在字符<code>前</code>插入</td></tr><tr><td align="center">I</td><td align="center">在光标所在<code>行首</code>插入</td></tr><tr><td align="center">o</td><td align="center">在光标<code>下</code>插入行</td></tr><tr><td align="center">O</td><td align="center">在光标<code>上</code>插入行</td></tr></tbody></table><h3 id="2、定位命令"><a href="#2、定位命令" class="headerlink" title="2、定位命令"></a>2、定位命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:set nu</td><td align="center">设置行号</td></tr><tr><td align="center">:set nonu</td><td align="center">取消行号</td></tr><tr><td align="center">gg</td><td align="center">到第一行</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr><tr><td align="center">nG</td><td align="center">到第n行</td></tr><tr><td align="center">:n</td><td align="center">到第n行</td></tr><tr><td align="center">$</td><td align="center">移至行尾</td></tr><tr><td align="center">0</td><td align="center">移至行首</td></tr></tbody></table><a id="more"></a><h3 id="3、删除命令"><a href="#3、删除命令" class="headerlink" title="3、删除命令"></a>3、删除命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除光标所在处字符</td></tr><tr><td align="center">nx</td><td align="center">删除光标所在处后 n 个字符</td></tr><tr><td align="center">dd</td><td align="center">删除光标所在行</td></tr><tr><td align="center">ndd</td><td align="center">删除n行</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在行到<code>文件末尾</code>的内容</td></tr><tr><td align="center">D</td><td align="center">删除光标所在处到<code>行尾</code>的内容</td></tr><tr><td align="center">:n1,n2d</td><td align="center">删除指定范围的行</td></tr></tbody></table><h3 id="4、复制和剪切命令"><a href="#4、复制和剪切命令" class="headerlink" title="4、复制和剪切命令"></a>4、复制和剪切命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制当前行</td></tr><tr><td align="center">nyy</td><td align="center">复制当前行以下 n 行</td></tr><tr><td align="center">dd</td><td align="center">剪切当前行</td></tr><tr><td align="center">ndd</td><td align="center">剪切当前行以下 n 行</td></tr><tr><td align="center">p</td><td align="center">粘贴在当前光标所在行下</td></tr><tr><td align="center">P</td><td align="center">粘贴在当前光标所在行上</td></tr></tbody></table><h3 id="5、替换和取消命令"><a href="#5、替换和取消命令" class="headerlink" title="5、替换和取消命令"></a>5、替换和取消命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">取代光标所在处字符</td></tr><tr><td align="center">R</td><td align="center">从光标所在处开始替换字符，按 Esc 结束</td></tr><tr><td align="center">u</td><td align="center">取消上一步操作</td></tr></tbody></table><h3 id="6、搜索和搜索替换命令"><a href="#6、搜索和搜索替换命令" class="headerlink" title="6、搜索和搜索替换命令"></a>6、搜索和搜索替换命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">/string</td><td align="center">搜索指定字符串 、搜索时忽略大小写 <code>:set ic</code></td></tr><tr><td align="center">n</td><td align="center">搜索指定字符串的下一个出现位置</td></tr><tr><td align="center">：%s/old/new/g</td><td align="center">全文替换指定字符串</td></tr><tr><td align="center">：n1，n2/old/new/g</td><td align="center">在一定范围内替换指定字符串</td></tr></tbody></table><h3 id="7、保存和退出命令"><a href="#7、保存和退出命令" class="headerlink" title="7、保存和退出命令"></a>7、保存和退出命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">保存修改</td></tr><tr><td align="center">:w new_filename</td><td align="center">另存为指定文件</td></tr><tr><td align="center">：wq</td><td align="center">保存修改并退出</td></tr><tr><td align="center">ZZ</td><td align="center">快捷键，保存修改并退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存修改退出</td></tr><tr><td align="center">：wq!</td><td align="center">保存修改并退出（文件所有者及root 用户可使用）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、插入命令&quot;&gt;&lt;a href=&quot;#1、插入命令&quot; class=&quot;headerlink&quot; title=&quot;1、插入命令&quot;&gt;&lt;/a&gt;1、插入命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;a&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;后&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;A&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行尾&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;i&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;前&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;I&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行首&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;下&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;上&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;2、定位命令&quot;&gt;&lt;a href=&quot;#2、定位命令&quot; class=&quot;headerlink&quot; title=&quot;2、定位命令&quot;&gt;&lt;/a&gt;2、定位命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;设置行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nonu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;取消行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;gg&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;G&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;nG&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:n&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行首&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="VIM" scheme="/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>IntentFilter匹配规则</title>
    <link href="/2019/04/02/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>/2019/04/02/IntentFilter匹配规则/</id>
    <published>2019-04-02T02:28:45.000Z</published>
    <updated>2019-11-25T12:55:32.888Z</updated>
    
    <content type="html"><![CDATA[<p>IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。</p><h3 id="action-匹配规则"><a href="#action-匹配规则" class="headerlink" title="action 匹配规则"></a>action 匹配规则</h3><p>action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。</p><a id="more"></a><p>action 的匹配规则是：<strong>Intent 中的 action 必须能够和过滤规则中的 action 匹配</strong>，匹配是指两个 action 的字符串完全相同。</p><p>一个过滤规则的中可以有多个 action，<strong>只要 Intent 中的任何一个 action 和其中的一个 action 匹配，则可匹配成功</strong>。</p><p>action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，<strong>action 区分大小写</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(&quot;xxaction&quot;)</span><br><span class="line">intent.setAction(&quot;&quot;)</span><br></pre></td></tr></table></figure><!-- more --><h3 id="category-匹配规则"><a href="#category-匹配规则" class="headerlink" title="category 匹配规则"></a>category 匹配规则</h3><p>category 是一个字符串，系统预定义了一些 category，用户也可以定义自己的 category。</p><p>category 的匹配规则：Intent 中如果含有 category，那么 Intent <strong>所有的</strong> category 必须和过滤规则中的一个相同。</p><p>为 Intent 的添加 category 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addCategory(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>系统在调用 <code>startActivity</code> 或 <code>startActivityForResult</code> 时会为 Intent 添加 <code>android.intent.category.DEFAULT</code> 这个 category,所以在隐式调用 Activity 时需要在清单文件中显示的添加 <code>android.intent.category.DEFAULT</code> 这条过滤规则。</p><p>Activity 的显示调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this,SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>Activity 的隐式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intent.setAction(&quot;xxx&quot;)</span><br><span class="line">intent.addCategory(&quot;xxx&quot;)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;</span><br><span class="line">    &lt;intent-filter&gt;   </span><br><span class="line">        &lt;category android:name = &quot;android.intent.category.DEFAULT&quot; //&gt;   </span><br><span class="line">    &lt;/intent-filter&gt;       </span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="data-的匹配规则"><a href="#data-的匹配规则" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h3><h4 id="data-的结构"><a href="#data-的结构" class="headerlink" title="data 的结构"></a>data 的结构</h4><p>data 由两部分组成， mimeType 和 URI。</p><ul><li><p>mimeType</p><p>  mimeType 指的是 <strong>媒体类型</strong>，例如：如image/jpeg、audio/mpeg4generic和video/* 等，可以表示图片、文本、视频等不同的媒体类型。</p></li><li><p>URI(统一资源标识符)</p><p>  URI 的结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;](中括号中表示三者可选)</span><br></pre></td></tr></table></figure><p>  如下面的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/info</span><br></pre></td></tr></table></figure><ul><li><p>Scheme</p><p>  URI 模式，比如 http、file、content 等，如果 URI 没有指定有效 scheme，那么整个 URI 都是无效的。</p></li><li><p>Host</p><p>  URI 的主机名，如果没有指定 host ，那么其他的参数都是无效的，整个 URI 都是无效的。</p></li><li><p>Port</p><p>  URI 的端口号。当 URI 的 Scheme 和 Host 指定后 Port 才会有效。</p></li><li><p>Path、PathPrefix、PathPattern</p><p>  三者均表示路径信息。Path 表示完整的路径信息，PathPattern 也表示完整的路径信息，但是其中可以包含通配符 “*” ，表示 0 个或任意多个字符；PathPrefix 表示路径的前缀信息。</p></li></ul></li></ul><h4 id="data-的匹配规则-1"><a href="#data-的匹配规则-1" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h4><p>data 的匹配规则：<strong>Intent 中的 data 数据必须和过滤规则中的某一个 data 完全匹配。</strong><br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intnet.setDataAndType((Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)</span><br></pre></td></tr></table></figure><p>那么对应的 IntentFilter 中的匹配过滤信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot; android:scheme=&quot;file&quot; android:host=&quot;abc&quot;&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot;/&gt; </span><br><span class="line">    &lt;data android:scheme=&quot;file&quot;/&gt;</span><br><span class="line">    &lt;data android:host=&quot;abc&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">// 两组是完全相同的，只是第二组把 URI 的各个部分分开表示。</span><br></pre></td></tr></table></figure><p>在 App 中吊起系统相册时，我们就需要设置 Intent 的 data 属性来调取系统中特定的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。&lt;/p&gt;
&lt;h3 id=&quot;action-匹配规则&quot;&gt;&lt;a href=&quot;#action-匹配规则&quot; class=&quot;headerlink&quot; title=&quot;action 匹配规则&quot;&gt;&lt;/a&gt;action 匹配规则&lt;/h3&gt;&lt;p&gt;action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android编程中的一些概念(Wiki)</title>
    <link href="/2019/04/01/Android%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/04/01/Android编程中的一些概念/</id>
    <published>2019-04-01T02:38:59.000Z</published>
    <updated>2019-04-09T03:33:34.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器(compiler) ,是一种 <strong>应用程序</strong>，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。</p><p>它的主要目的是将人编写、维护的高级计算机语言所写出的 <strong>源代码程序</strong>，翻译为计算机能解读、运行的低价 <strong>机器语言</strong> 的程序，也就是 <strong>可执行文件</strong>。</p><p>常见的编译器：</p><ol><li>GCC(GUN Compiler Collection)</li></ol><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><ol start="2"><li>LLVM</li></ol><p>LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。</p><a id="more"></a><h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><ol><li>即时编译(JIT,Just In Time)</li></ol><p>动态编译的一种形式，提高程序运行效率的方法。程序运行有两种方式：<br>    1. 静态编译。执行程序前程序全部被翻译为机器码。<br>    2. 动态解释。解释执行则是边执行边翻译。<br>即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p><p>即时编译器有两种类型：</p><pre><code>1. 字节码翻译。2. 动态编译翻译。</code></pre><ol start="2"><li>提前编译(AOT,Ahead Of Time)</li></ol><h3 id="运行时系统"><a href="#运行时系统" class="headerlink" title="运行时系统"></a>运行时系统</h3><p>运行环境有称运行时系统，是指把半编译的运行码在目标机器上运行的环境，如 Java<br> 的 JRE。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p> 可执行文件，是指 <strong>内容可被计算机解释为程序</strong> 的文件，通常可执行文件内含有二进制编码的微处理器指令，所以可执行文件也可被称为 二进制文件。<br> <strong>扩展名：</strong></p><ul><li><p>.exe</p></li><li><p>.com</p></li><li><p>.run</p><p><strong>脚本：</strong></p><p>不是所有的可执行文件都只存在计算机识别的数据，脚本中也是可执行文件，但是内含人类识别的数据，原因：<strong>脚本语言无需经过编译器先编译，就可经过解释器运行(Perl、Python、Shell)</strong>。</p></li></ul><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释器(interpreter),是一种 <strong>计算机程序</strong>，能够把高级编程语言一行一行解释运行，每次运行程序都需要将先转成另外一种语言再作运行，因此解释器的程序运行速度比较慢，运行程序只能将程序一行一行的翻译。</p><p>解释器的好处是它消除了编译整个程序的负担，程序可以拆分成多个部分来模块化，但这会让运行时的效率打了折扣。相对地，编译器已一次将所有源代码翻译成另一种语言，如机器代码，运行时便无需再依赖编译器或额外的程序，故而其运行速度比较快。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>在计算机科学体系结构中，虚拟机指一种 <strong>特殊的软件</strong>，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是 <strong>基于这个软件所创建的环境来操作的软件</strong>。</p><h3 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h3><p>为 Google 开发的 Android 移动设备平台的核心组成部分之一，它支持 .dex(Dalvik Executable) 格式的 Java 应用程序的运行，.dex 格式为专门为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。</p><p>Java 虚拟机和大部分虚拟机包括 JVM 都是基于堆栈的虚拟机，而 Dalvik 虚拟机为 寄存器虚拟机。</p><p>从Android 5.0版起，Android Runtime（ART）取代Dalvik成为系统内默认虚拟机。</p><h3 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h3><p>ART，是一种在 Android 操作系统上的 <strong>运行环境</strong>， ART 能够把应用程序的字节码转换为机器码，是 Android 使用的一种新的虚拟机。与 Dalvik 不同的出 ART 使用的 AOT 技术，而 Dalvik 使用的为 JIT 技术。</p><p>ART 改善了性能、垃圾回收等方面。</p><p>ART引入了 AOT 技术，应用程序在安装时将所有的字节码编译成机器码，所以其在安装时花费的时间更长，同时也会占用更大的内部存储空间，用于存储编译后的代码。</p><h3 id="代码类型"><a href="#代码类型" class="headerlink" title="代码类型"></a>代码类型</h3><p><strong>源代码：</strong></p><p>指人类可读的计算机语言指令，如我们平时编程用到的 Java 、Py、PHP、C++ 等。</p><p><strong>目标代码：</strong></p><p>编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。存放目标代码的文件称为目标文件，常被称为 <strong>二进制文件</strong>。</p><p>目标文件中包含着机器代码以及代码运行中使用到的数据，以及其他信息。</p><p><strong>字节码：</strong></p><p><img src="/images/2019_04_02_2.jpg" alt="字节码"></p><p>字节码(ByteCode),通常指已经经过编译，但是与特定机器代码无关，需要解释器转译后才能成为机器的中间代码。字节码不能像源代码一样可以供人阅读，而是编译后的数值常量、引用、指令等构成的序列。</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机。编译器将源码编译成字节码，特定平台上的虚拟机将字节码转译为可以直接运行的指令。字节码的典型应用为Java bytecode。</p><p><strong>机器语言：</strong></p><p>机器语言是一种指令集体系，这种指令体系称为机器代码，是指计算机的 CPU 可直接解读的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h3&gt;&lt;p&gt;编译器(compiler) ,是一种 &lt;strong&gt;应用程序&lt;/strong&gt;，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。&lt;/p&gt;
&lt;p&gt;它的主要目的是将人编写、维护的高级计算机语言所写出的 &lt;strong&gt;源代码程序&lt;/strong&gt;，翻译为计算机能解读、运行的低价 &lt;strong&gt;机器语言&lt;/strong&gt; 的程序，也就是 &lt;strong&gt;可执行文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的编译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCC(GUN Compiler Collection)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译技术" scheme="/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>常用的 Gradle 命令</title>
    <link href="/2019/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84-Gradle-%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/28/常用的-Gradle-命令/</id>
    <published>2019-03-28T08:37:33.000Z</published>
    <updated>2019-11-05T04:35:01.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gradlew-q-app-dependencies"><a href="#gradlew-q-app-dependencies" class="headerlink" title="gradlew -q app:dependencies"></a>gradlew -q app:dependencies</h3><p>出现依赖库版本冲突，一般会包如下错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 28.0.0, 25.2.0. Examples include com.android.support:animated-vector-drawable:28.0.0 and com.android.support:support-media-compat:25.2.</span><br></pre></td></tr></table></figure><p>一般出现这种错的原因是自己依赖的库与其他依赖的库所依赖的库为同一个 group 的库，但是版本不同。</p><p>使用 <strong>./gradlew -q app:dependencies</strong> 可以看到自己项目依赖库的层级关系：</p><p>解决：使用 exclude 排除相应的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">api (&quot;com.alibaba:arouter-api:1.4.0&quot;)&#123;</span><br><span class="line">    exclude group: &apos;com.android.support&apos;,module:&apos;support-v4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;gradlew-q-app-dependencies&quot;&gt;&lt;a href=&quot;#gradlew-q-app-dependencies&quot; class=&quot;headerlink&quot; title=&quot;gradlew -q app:dependencies&quot;&gt;&lt;/a&gt;gradlew
      
    
    </summary>
    
    
      <category term="Gradle" scheme="/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>打包 jar 、aar</title>
    <link href="/2019/03/27/%E6%89%93%E5%8C%85-jar-%E3%80%81aar/"/>
    <id>/2019/03/27/打包-jar-、aar/</id>
    <published>2019-03-27T02:47:06.000Z</published>
    <updated>2019-03-28T10:06:15.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的 aar 文件包括：AndroidManifest.xml，classes.jar，res，R.txt。</p><p>jar：只包含了 class 文件和清单文件，不包含资源文件。</p><p>如果需要资源文件，那么以 aar 的形式引入到工程，反之使用 jar。</p><h3 id="打包-aar、jar"><a href="#打包-aar、jar" class="headerlink" title="打包 aar、jar"></a>打包 aar、jar</h3><p>如果将 Application 打包为 aar，做以下更改：</p><ol><li>将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为 <code>apply plugin: &#39;com.android.library&#39;</code></li><li>去掉 <code>applicationId</code></li><li>项目根目录执行 <code>./gradlew assembleRelease</code>,就可以在相应的目录(build/output/aar)下看到生成的 aar，在 <code>build/intermediates/packed-classes</code> 中看到相应的 jar 包。</li></ol><p>可以使用新建 gradle task 可以将生成的 jar 包直接复制到 libs 下，并完成构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    def name = project.name //Library名称</span><br><span class="line">    delete &apos;libs/&apos; + name + &apos;.jar&apos; //删除之前的旧jar包</span><br><span class="line">    from(&apos;build/intermediates/packaged-classes/release/&apos;) //从这个目录下取出默认jar包</span><br><span class="line">    into(&apos;libs/&apos;) //将jar包输出到指定目录下</span><br><span class="line">    include(&apos;classes.jar&apos;)</span><br><span class="line">    rename(&apos;classes.jar&apos;, name + &apos;.jar&apos;) //自定义jar包的名字</span><br><span class="line">&#125;</span><br><span class="line">copyJar.dependsOn(build)</span><br></pre></td></tr></table></figure><h3 id="自定义-jar"><a href="#自定义-jar" class="headerlink" title="自定义 jar"></a>自定义 jar</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Adb 运行原理和常用命令</title>
    <link href="/2019/03/26/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/26/adb-常用命令/</id>
    <published>2019-03-26T03:32:49.000Z</published>
    <updated>2019-08-12T10:03:10.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：</p><ol><li>客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。</li><li>后台程序。在相应的设备(模拟器、真机)上运行命令，作为<code>后台进程</code> 在 <code>设备</code>上运行。</li><li>服务器。管理客户端和后台程序之间的通信，在 <code>开发计算机</code> 上作为 <code>后台进程</code> 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。</li></ol><p>android_sdk/platform-tools/ 中找到 adb 工具。</p><h3 id="adb-工作方式"><a href="#adb-工作方式" class="headerlink" title="adb 工作方式"></a>adb 工作方式</h3><ol><li>启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。</li><li>服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。</li><li>当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。</li></ol><a id="more"></a><h3 id="通过-WLAN-连接设备"><a href="#通过-WLAN-连接设备" class="headerlink" title="通过 WLAN 连接设备"></a>通过 WLAN 连接设备</h3><p><strong>adb tcpip 5555:</strong> 设置设备监听 5555 端口上的 TCP/IP 的连接。</p><p><strong>adb connect xxx:</strong>  通过目标设备的 IP 连接设备。</p><p><strong>adb disconnect ip:</strong> 断开指定 IP 的设备 </p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>adb devices:</strong> 查找设备</p><p><strong>adb -s serialNum commond:</strong> 指定设备执行命令</p><p><strong>adb install apk:</strong> 安装 apk</p><p><strong>adb -s xxxx install apk:</strong> 指定设备上安装 apk</p><p><strong>adb install -r apk:</strong> 覆盖安装</p><p><strong>adb -d install apk:</strong> 唯一 USB 连接设备安装 apk</p><p><strong>adb -e install apk:</strong> 唯一模拟器设备安装 apk</p><p><strong>adb uninstall packageName:</strong> 卸载 apk</p><p><strong>adb uninsatll -k packageName:</strong> 卸载 apk,但是保留其配置和缓存文件</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>adb push localFile remoteDictory:</strong> 将本地的文件 push 远端指定的目录下</p><p><strong>adb pull file remoteDictory:</strong> 从 remoteDictory 中复制指定的 file 到当前目录下</p><h3 id="adb-服务器"><a href="#adb-服务器" class="headerlink" title="adb 服务器"></a>adb 服务器</h3><p>adb kill-server： 停止 adb 服务器</p><p>adb start-server：开启 adb 服务</p><h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h3><p>在目标设备启动远程 shell </p><h3 id="adb-shell-am"><a href="#adb-shell-am" class="headerlink" title="adb shell am"></a>adb shell am</h3><p>使用 adb shell am 与应用交互。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>start [option] <intent></intent></td><td>启动 <intent> 指定的 Activity</intent></td></tr><tr><td>startservice [options] <intent></intent></td><td>启动 <intent> 指定的 Service</intent></td></tr><tr><td>broadcast [options] <intent></intent></td><td>发送 <intent> 指定的广播</intent></td></tr><tr><td>force-stop <packagename></packagename></td><td>停止 <packagename> 相关的进程</packagename></td></tr></tbody></table><p><intent> 有关的选项<br>参数|含义<br>–|–<br>-a | <action>    指定 action，比如 android.intent.action.VIEW<br>-c | <category>    指定 category，比如 android.intent.category.APP_CONTACTS<br>-n | <component>    指定完整 component 名，用于明确指定启动哪个 Activity，如 com.gy/.MainActivity</component></category></action></intent></p><p><intent> 可以传参</intent></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell start -n com.gy/.MainActivity //启动指定的 Activity</span><br><span class="line"></span><br><span class="line">adb shell startService -n com.gy/.TestService //启动指定的 Service</span><br><span class="line"></span><br><span class="line">adb shell broadcast  -a android.intent.action.BOOT_COMPLETED -n com.gy/.TestBroadcast //向指定的 BroadCast 发送广播</span><br><span class="line"></span><br><span class="line">adb shell am force-stop com.gy // 关闭指定 app 的一切进程与服务</span><br></pre></td></tr></table></figure><h3 id="adb-shell-pm"><a href="#adb-shell-pm" class="headerlink" title="adb shell pm"></a>adb shell pm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br><span class="line"></span><br><span class="line">adb shell pm clear &lt;packagename&gt;:清除数据与缓存</span><br><span class="line"></span><br><span class="line">adb shell pm path &lt;packagename&gt;:应用安装路径</span><br></pre></td></tr></table></figure><h3 id="adb-shell-wm"><a href="#adb-shell-wm" class="headerlink" title="adb shell wm"></a>adb shell wm</h3><p>屏幕相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size: 屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm size 480x1024: 屏幕分辨率修改为 480x1024</span><br><span class="line"></span><br><span class="line">adb shell wm size reset: 恢复屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm density: 屏幕密度</span><br><span class="line"></span><br><span class="line">adb shell wm density 160 : 屏幕密度设置为 160dpi</span><br><span class="line"></span><br><span class="line">adb shell wm density reset: 恢复屏幕密度</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys"><a href="#adb-shell-dumpsys" class="headerlink" title="adb shell dumpsys"></a>adb shell dumpsys</h3><p>查看运行状态,打印出当前系统的系统信息，默认打印出设备中所有的 service 的信息。</p><p>查看 Service List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys</span><br><span class="line">adb shell service list</span><br></pre></td></tr></table></figure><p>查看正在运行中的 Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure><p>查看应用的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等</p><p>查看应用安装路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br><span class="line">db shell dumpsys window | grep init</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys-activity-内容组成"><a href="#adb-shell-dumpsys-activity-内容组成" class="headerlink" title="adb shell dumpsys activity 内容组成"></a>adb shell dumpsys activity 内容组成</h3><ol><li>ACTIVITY MANAGER SETTINGS(dumpsys activity settings)</li><li>ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)</li><li>ACTIVITY MANAGER BROADCAST STATE(dumpsys activity broadcasts)</li><li>ACTIVITY MANAGER CONTENT PROVIDERS(dumpsys activity providers)</li><li>ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)</li><li>ACTIVITY MANAGER SERVICES (dumpsys activity services)</li><li>ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)</li><li>ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)</li><li>ACTIVITY MANAGER STARTER (dumpsys activity starter)</li><li>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</li><li>ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)</li></ol><p>使用 <code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code> 限制仅输出 “Running activities” 列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。&lt;/li&gt;
&lt;li&gt;后台程序。在相应的设备(模拟器、真机)上运行命令，作为&lt;code&gt;后台进程&lt;/code&gt; 在 &lt;code&gt;设备&lt;/code&gt;上运行。&lt;/li&gt;
&lt;li&gt;服务器。管理客户端和后台程序之间的通信，在 &lt;code&gt;开发计算机&lt;/code&gt; 上作为 &lt;code&gt;后台进程&lt;/code&gt; 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;android_sdk/platform-tools/ 中找到 adb 工具。&lt;/p&gt;
&lt;h3 id=&quot;adb-工作方式&quot;&gt;&lt;a href=&quot;#adb-工作方式&quot; class=&quot;headerlink&quot; title=&quot;adb 工作方式&quot;&gt;&lt;/a&gt;adb 工作方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。&lt;/li&gt;
&lt;li&gt;服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。&lt;/li&gt;
&lt;li&gt;当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="adb" scheme="/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Java IO 流</title>
    <link href="/2019/03/25/%E6%B5%81/"/>
    <id>/2019/03/25/流/</id>
    <published>2019-03-25T09:03:45.000Z</published>
    <updated>2019-04-09T07:40:35.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 为文件和目录路径名的抽象表示方式。<br>一个 File 对象可以代表一个文件或目录的抽象。<br>建立 File 对象不会对文件系统产生影响。</p><p>File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。</p><p>File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。</p><h3 id="File-的基本操作"><a href="#File-的基本操作" class="headerlink" title="File 的基本操作"></a>File 的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getName():获得文件的名字、路径名</span><br><span class="line">getPath():路径名</span><br><span class="line">getAbsoluteFile():绝对路径名</span><br><span class="line">getParentFile():父路径，没有为 null</span><br><span class="line">file 的绝对路径和相对路径</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建文件和删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createNewFile():</span><br><span class="line">createTempFile():创建临时文件，调用 deleteOnExit 会在程序退出后删除。</span><br></pre></td></tr></table></figure><p>文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir():新建文件夹，父路径不存在创建失败,文件夹存在不创建</span><br><span class="line">mkdirs():新建文件夹链，父路径不存在创建父目录</span><br></pre></td></tr></table></figure><h3 id="IO-流原理"><a href="#IO-流原理" class="headerlink" title="IO 流原理"></a>IO 流原理</h3><p>程序与文件、数组、网络连接数据库之间进行进行数据交换。</p><p><strong>IO 流的操作以程序为中心，什么是以程序为中心？</strong></p><p>就是如果要读度文件数据的话，对于文件来说为输出流，而对于程序来说为输入流，那么就以输入流来命名该文件流。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按流向分类</strong>：</p><ol><li>输入流</li><li>输出流</li></ol><p><strong>按处理的数据分类：</strong></p><ol><li>字节流：二进制，可以处理一切文件</li><li>字符流：文本文件 ，只能处理纯文本</li></ol><p><strong>按功能分类：</strong></p><ol><li>节点流：离源头近，包裹源头</li><li>处理流：增强功能，提高效率</li></ol><h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p><strong>两种流均为节点流，节点流为直接和源文件相连的流。</strong></p><p>InputStream(输入字节流)、OutputStream(输出字节流)</p><table><thead><tr><th>–</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p><strong>字节流可以处理一切格式的文件</strong>。</p><p><strong>字节流常用 API</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileInputStream</span><br><span class="line">read(byte[] b)、read(byte[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileOutoutStream</span><br><span class="line">writer(byte[] b)、write(byte[],int off,int len)、flush()、close()</span><br></pre></td></tr></table></figure><p>// 读取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileInputStream inputStream = null;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // 缓存数组</span><br><span class="line">        byte[] array = new byte[10];</span><br><span class="line">        int len = 0;//实际读取的大小</span><br><span class="line">        while ((len = inputStream.read(array)) != -1) &#123;</span><br><span class="line">            String info = new String(array, 0, len);</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 写出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileOutputStream outputStream = null;</span><br><span class="line">try &#123;</span><br><span class="line">    outputStream = new FileOutputStream(file, true);</span><br><span class="line">    String inrfo = &quot;wojwoo我们&quot;;</span><br><span class="line">    byte[] data = inrfo.getBytes();</span><br><span class="line">    outputStream.write(data);</span><br><span class="line">    outputStream.flush();//强制刷新，使在数组中的数据强制写出</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符流常用API</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileReader</span><br><span class="line">read(char[] b)、read(char[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileWriter</span><br><span class="line">writer(char[] b)、write(char[],int off,int len)、flush()、close</span><br></pre></td></tr></table></figure><p><strong>流的基本操作：</strong></p><ol><li>建立联系。 File 为程序与文件之间的联系,即 建立 File 对象。</li><li>选择合适的流。 </li><li>操作：流的读取，关键：缓存数组。</li><li>关闭流。</li></ol><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>只可处理纯文本文件，如 .txt、 .html 。</strong>  </p><p>Reader、Writer、FileReader、FileWriter</p><p>纯文本的读取、纯文本的写出</p><p>数组为 char[] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File src = new File(allPath, &quot;a&quot;);</span><br><span class="line">Reader reader = null;</span><br><span class="line">if (src.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = new FileReader(src);</span><br><span class="line">        char[] buffer = new char[512];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">            String str = new String(buffer, 0, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;file not exist&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p><img src="/images/2019_04_02_4.jpg" alt="字节流"></p><p><img src="/images/2019_04_02_3.jpg" alt="处理流"></p><p>增强功能，提高性能。</p><p><strong>节点流和处理流的关系：</strong></p><ol><li><p>节点流：可以直接从数据源读取或写出数据。</p></li><li><p>处理流：不直接连接到数据源或目的地，是处理流的流，通过对其他流的处理提高程序的性能。 </p></li><li><p>节点流处于 IO 操作的第一线，所有的操作必须通过它们，处理流可以对其他流进行处理。</p></li><li><p>处理流在节点流之上。</p></li></ol><p><strong>字节流的处理流</strong>：</p><p>BufferredInputStream、BufferendOutoutStream</p><p><strong>为字节流添加处理流</strong>：</p><p>new BufferredInputStream(new FileInputStream(xx,xx));</p><p>new BufferendOutoutStream(new FileOutputStream(xx,xx));</p><p><strong>字符流的处理流</strong>：</p><p>BufferendReader: readLine()</p><p>BufferendWrinter: newLine()</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>将字节流转换为字符流，可以指定编码格式将字节流转换为字符流，处理乱码(编码器、解码集)。</p><p>以程序为中心：</p><p>解码：二进制   –(解码字符集)–&gt;    字符</p><p>编码：字符  –(编码字符集)–&gt; 二进制</p><p>乱码原因：</p><ol><li>编码与解码字符集不同。</li><li>字节数目不完整。</li></ol><p> 字节流转换为字符流：</p><ol><li>输入流：InputStreamReader  解码（读取二进制文件，显示为人类可识别的字符）</li><li>输出流：OutputStreamWriter   编码 （将人类识别的字符转换为字节，写入文件）</li></ol><p>编码要求：使用字符流用指定的解码格式读取文本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初步实现如下，但是不能指定解码格式</span><br><span class="line">BufferendReader reader = new BufferendReader(new FileReader(xxx));</span><br><span class="line"></span><br><span class="line">//现在就是转换流出场的时候了，可以使用转换流以指定的解码方式将字节流转换为字符流</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;&quot;),&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;File&quot;&gt;&lt;a href=&quot;#File&quot; class=&quot;headerlink&quot; title=&quot;File&quot;&gt;&lt;/a&gt;File&lt;/h3&gt;&lt;p&gt;File 为文件和目录路径名的抽象表示方式。&lt;br&gt;一个 File 对象可以代表一个文件或目录的抽象。&lt;br&gt;建立 File 对象不会对文件系统产生影响。&lt;/p&gt;
&lt;p&gt;File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。&lt;/p&gt;
&lt;p&gt;File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。&lt;/p&gt;
&lt;h3 id=&quot;File-的基本操作&quot;&gt;&lt;a href=&quot;#File-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;File 的基本操作&quot;&gt;&lt;/a&gt;File 的基本操作&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getName():获得文件的名字、路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getPath():路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getAbsoluteFile():绝对路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getParentFile():父路径，没有为 null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file 的绝对路径和相对路径&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="IO 流" scheme="/tags/IO-%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>设计六大准则(设计模式之禅)</title>
    <link href="/2019/03/19/%E8%AE%BE%E8%AE%A1%E5%85%AD%E5%A4%A7%E5%87%86%E5%88%99/"/>
    <id>/2019/03/19/设计六大准则/</id>
    <published>2019-03-19T04:58:37.000Z</published>
    <updated>2019-03-25T07:11:28.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则 (Single Responsibility Principle)(SRP)"></a>单一职责原则 (Single Responsibility Principle)(SRP)</h3><p><strong>定义：</strong> 应该有且仅有一个原因引起类的变更。</p><p><strong>操作：</strong></p><ol><li>当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。</li><li>SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。</li></ol><p><strong>好处：</strong></p><ol><li>降低类的复杂度，实现什么职责都有明显的定义</li><li>可读性提高、可维护性强</li><li>变更风险低</li></ol><p><strong>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。</strong></p><a id="more"></a><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)(LSP)"></a>里氏替换原则(Liskov Substitution Principle)(LSP)</h3><p><strong>继承的优点</strong>：</p><ol><li>代码共享，每个子类拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>提高代码的扩展性，可 “随意” 重写父类方法；</li></ol><p><strong>继承的缺点：</strong></p><ol><li>继承具有入侵性，实现父类就必须拥有父类的方法和属性；</li><li>降低代码的灵活性，原因同上；</li><li>增强了耦合性。父类中的常量、变量、方法修改后，影响子类。</li></ol><p><strong>定义：</strong></p><p>凡是引用父类的地方都可以透明的使用其子类对象，反之，不成立。</p><p><strong>引申义：</strong></p><ol><li>子类必须完全实现父类的方法</li></ol><p><em>在类中调用其他类时 <code>务必使用父类或接口</code>，如果不能使用父类或接口，说明类的设计已经违反了 LSP 原则。</em></p><p>如果子类不能完整的实现父类中的方法或者父类中的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承。</p><ol start="2"><li><p>子类可以有自己的方法。这也就是 LSP 原则不能反过来用的原因。</p></li><li><p>覆盖或实现父类方法时，输入参数可以被放大。 </p></li><li><p>覆盖或实现父类方法时，输出结果可以被缩小。</p></li></ol><p><strong>优点：</strong></p><p>里氏替换原则的目的是增强程序的健壮性，即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对于不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h3 id="依赖倒置-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置(Dependence Inversion Principle)(DIP)"></a>依赖倒置(Dependence Inversion Principle)(DIP)</h3><p><strong>依赖倒置含义：</strong></p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖抽象。</li><li>抽象不应该依赖细节。</li><li>细节应该依赖抽象。</li></ol><p><strong>具体含义：</strong></p><p>低层模块：基本逻辑</p><p>高层模块：基本逻辑的组合</p><p>抽象：接口或抽象类</p><p>细节：实现类、继承子类</p><p><strong><em>模块之间的关系通过抽象产生</em></strong>，实现类之间不能直接发生依赖关系，其依赖关系通过上层的接口或者抽象类产生。</p><p>接口或抽象类不依赖实现类，实现类依赖接口或抽象类。</p><p><strong>优点：</strong></p><p>采用依赖倒置原则可以减少类间的耦合关系(更准确的说是(通过抽象类之间的关系)降低实现类之间的关系)，提高系统的稳定性，降低开发风险，提高代码的可读性和维护性。</p><p>抽象是对实现的约束，对依赖者而言，也是一种契约，不仅约束自己，同时还约束自己与外界的关系，其目的是保证所有的而细节不脱离契约的范畴，确保约束的双方按照既定的契约(抽象)共同发展，只要抽象这根基线存在，细节就不会超出范围。</p><p><strong>依赖关系</strong></p><p>依赖关系的概、具体表现、UML 图例表示可以参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/81531727" target="_blank" rel="noopener">Java 对象间关系以及 UML 类图表示方法</a> 下面简写如下：</p><ol><li>构造器函数传递依赖对象</li><li>方法中参数传递对象</li><li>接口声明中声明依赖对象。</li></ol><p><strong>最佳实践：</strong></p><p>依赖倒置原则的本质是 <code>通过抽象(抽象类或接口类)使各个类或模块的实现彼此独立</code>，不互相影响，实现模块间的松耦合，如何做：</p><ol><li>每个类尽量都有接口或抽象类，这是依赖倒置原则的基本要求，<strong>有了抽象才有可能倒置</strong>。</li><li>变量的表面类型(编译类型)尽量是接口或抽象类。</li><li>任何类都不应该从具体类派生出来。</li><li>尽量不要覆盖基类的方法(该方法已经在基类中实现)。如果说基类是一个抽象类，而且这个方法已经被实现了，子类尽量不要覆写。类间的依赖是抽象，覆写类抽象方法，对依赖的稳定性有所影响。</li><li>集合里氏替换原则。</li></ol><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>再此层面上 接口分为：</p><ol><li>实例接口 (类也是一种接口)</li><li>类接口(interface)</li></ol><p>隔离：即把一个接口中的多种职责进一步拆分出来，作为两个颗粒度更小的接口，此刻两个职责被单独隔离处理。</p><p><strong>定义：</strong></p><p>接口尽量细化，同时接口中的方法尽量少。</p><p><strong>如何对接口进行约束：</strong></p><ol><li>接口尽量小，满足单一职责原则。</li><li>接口高内聚。</li></ol><p>针对于接口高内聚就是要在接口中尽量少公布 public 方法，接口是对外的承诺，对外承诺越少越有利于系统的开发，这样变更的风险越低。</p><h3 id="迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP"><a href="#迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP" class="headerlink" title="迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)"></a>迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)</h3><p>一个对象应该对其他对象有最少的了解，换句话说，一个类应该对自己需要耦合或调用的类知道的最少，被耦合的类或这被调用的类内部如何复杂都和该类没有关系，我只需知道它们提供的 public 方法。</p><p><strong>只需要和朋友类联系：</strong></p><p>朋友类：出现在成员变量、方法的输入和输出参数的类为朋友类。<br>其实朋友类就是产生 <code>依赖关系的类</code>。</p><p><strong>朋友类中不应该向对方暴露的过多</strong></p><p>如果可能的话，尽量向其他类暴露尽量少的方法。</p><p><strong>自己的自己拥有</strong><br>如果一个类可以放在本类中，既不会增加类间关系，也不会对本类产生负面影响，那就放在本类中。</p><p><strong>尽量少的使用 Serializable</strong></p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体如类、模块、函数应该对扩展开发，对修改关闭。</p><p>开闭原则是最基础的一个原则，前面介绍的 5 个原则都是在开闭原则的具体形态，它们为指导设计的工具和方法，而开闭原则才是精神领袖。</p><p><strong>原则细节</strong></p><p>应该尽量通过扩展实体行为的方式来实现变化，而不是通过修改已有的代码来实现变化。</p><p>在软件开发中，尽可能减少代码粒度，代码粒度越小，被复用的可能越大。</p><p><strong>如何使用</strong></p><ol><li>抽象约束。</li></ol><p>具体表现为：</p><pre><code>1. 在对接口或抽象类进行扩展时，不允许出现接口或抽象类中不存在的 public 方法。2. 参数类型、引用对象尽量使用接口或抽象类，而不是实现类。3. 抽象应保持稳定，一旦确定不允许更改。</code></pre><ol start="2"><li>封装变化</li></ol><p>含义：<br>        1. 将相同的变化封装到接口或抽象类中<br>        2. 将不同的变化封装到不同的接口或抽象类中，不应该两个变化出现在同一个接口或抽象中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单一职责原则-Single-Responsibility-Principle-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-Single-Responsibility-Principle-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 (Single Responsibility Principle)(SRP)&quot;&gt;&lt;/a&gt;单一职责原则 (Single Responsibility Principle)(SRP)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 应该有且仅有一个原因引起类的变更。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。&lt;/li&gt;
&lt;li&gt;SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低类的复杂度，实现什么职责都有明显的定义&lt;/li&gt;
&lt;li&gt;可读性提高、可维护性强&lt;/li&gt;
&lt;li&gt;变更风险低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式六大原则" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Three</title>
    <link href="/2019/03/15/Java-Basic-%E4%B8%89/"/>
    <id>/2019/03/15/Java-Basic-三/</id>
    <published>2019-03-15T09:08:48.000Z</published>
    <updated>2019-05-29T10:11:56.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在只定义了方法的签名，没有方法的类称为抽象类。</p><ul><li>抽象类和抽象方法使用 abstract 修饰</li><li>抽象类不能实例化</li><li>抽象类可以没有抽象方法，可以有非抽象方法</li><li>抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)</li><li>含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类</li></ul><p>abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。</p><a id="more"></a><h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><p>抽象类是将多个子类向高层抽象，为子类提供行为模板,定义了子类中存在的共有行为。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口进一步将抽象类抽象。</p><p>接口定义了多个类共同的公共行为规范。</p><p>接口中不能含有</p><ol><li>构造器</li><li>初始化块</li></ol><p>但是接口中包含：</p><ol><li>成员变量(只能是静态)</li><li>方法(抽象实例方法、类方法、默认方法)</li><li>内部类(内部接口、枚举)</li></ol><h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><p>接口中的所有成员的访问权限为 <code>public</code> 。<br>对于接口中的静态常量而言，它们是接口相关的，系统会自动为这些成员变量增加 static 和 final 两个修饰符，必须在定义时进行初始化。</p><h3 id="接口中的默认方法、静态方法"><a href="#接口中的默认方法、静态方法" class="headerlink" title="接口中的默认方法、静态方法"></a>接口中的默认方法、静态方法</h3><p>接口中的默认方法和静态方法都可以实现，拥有方法体。</p><p>在 Java8 之前接口中的所有方法均为抽象方法，但是在 Java8 后系统为接口增加了默认方法，此方法增加了接口的可扩展性，如果需要在已有业务上需要为接口增加新的方法来实现增加业务的目的。那么 Java8 之前如果为接口增加方法，那么所有实现类均需要更改。在 Java8 后增加而 <code>默认方法</code>，实现类不是必须要实现该方法，如果实现了没有显示实现该方法，那么调用时使用默认实现。</p><p>而接口中的静态方法，需要通过接口名实现调用，在默认方法中可以调用本类的默认方法。</p><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p><em>一个类实现了一个接口后，这个类需要实现这个接口中的所有抽象方法，否则，这个类将保留从接口继承的抽象方法，则这个类必须定义为抽象类</em>。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>同：</strong></p><ol><li>不能被实例化，只能被其他类继承或实现。</li><li>都可以包含抽象方法，实现或继承的子类需要实现这些抽象方法。</li></ol><p><strong>异：</strong></p><p>接口作为系统与外界交互的窗口，接口体现的是一种规范,对于接口的实现者来说，接口规定了实现者必须向外提供哪些服务(以方法的形式)；对于接口的调用者来说，接口规定了可以调用哪些服务，以及如何调用服务(如何调用方法)。</p><p>抽象作为系统中多个子类的共同父类，它体现的是一种模板式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;存在只定义了方法的签名，没有方法的类称为抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法使用 abstract 修饰&lt;/li&gt;
&lt;li&gt;抽象类不能实例化&lt;/li&gt;
&lt;li&gt;抽象类可以没有抽象方法，可以有非抽象方法&lt;/li&gt;
&lt;li&gt;抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)&lt;/li&gt;
&lt;li&gt;含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>requestDisallowInterceptTouchEvent</title>
    <link href="/2019/03/14/requestDisallowInterceptTouchEvent/"/>
    <id>/2019/03/14/requestDisallowInterceptTouchEvent/</id>
    <published>2019-03-14T03:54:33.000Z</published>
    <updated>2019-03-14T11:15:50.581Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p>调用 <code>requestDisallowInterceptTouchEvent</code> 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于 ViewGroup 为什么还是会拦截 ACTION_DOWN 事件，是因为 ViewGruop 在 ACTION_DOWN 事件时会重新置位 FLAG_DISALLOW_INTERCEPTER 标志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;requestDisallowInterceptTouchEvent&lt;/code&gt; 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于
      
    
    </summary>
    
    
      <category term="View" scheme="/tags/View/"/>
    
      <category term="事件分发机制" scheme="/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
