<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GY</title>
  
  <subtitle>Enjoy the life, enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-10-18T07:33:33.693Z</updated>
  <id>/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rxjava 源码学习(二):基本流程流程图</title>
    <link href="/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%BA%8C):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>/2019/10/18/Rxjava 源码学习(二):基本流程流程图/</id>
    <published>2019-10-18T07:32:54.000Z</published>
    <updated>2019-10-18T07:33:33.693Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href>Rxjava 源码学习(一):基本流程分析</a> 分析了基本流程，并且通过 Map 操作符一窥 Rxjava 操作符的特色，而本篇主体只有一张 Rxjava 流程图，但是这张流程图基本上可以概括 Rxjava 的框架，整个流程可以看做是一个 “横向 S” 模型。</p><p>该图共涉及 Rxjava 事件流的以下几个方面：</p><ol><li>Observable 的创建</li><li>Observer 的创建、产生订阅关系</li><li>订阅关系的传递</li><li>取消订阅的流程</li></ol><a id="more"></a><p>具体看图上的标记。</p><p><img src="/../images/2019_10_18_01.png" alt></p><p>从图上可以看到，在最终订阅 Observer 之前，执行每一个操作符并不会同时生成相应的 Observable 和 Observer，以调用 subscribe 为分界线，将整个事件流分成两部分：</p><ol><li>调用 subscribe 之前，生成相应操作符的 Observable。</li><li>调用 subscribe 之后，生成相应操作符的 Observer，并产生订阅关系。</li></ol><p>需要注意的一点是在查看源码会看到 upstream、downstream，具体的 up 和 down 不是有相应对象的生成顺序决定的，而是有 Rxjava 相应操作符的调用先后决定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href&gt;Rxjava 源码学习(一):基本流程分析&lt;/a&gt; 分析了基本流程，并且通过 Map 操作符一窥 Rxjava 操作符的特色，而本篇主体只有一张 Rxjava 流程图，但是这张流程图基本上可以概括 Rxjava 的框架，整个流程可以看做是一个 “横向 S” 模型。&lt;/p&gt;
&lt;p&gt;该图共涉及 Rxjava 事件流的以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Observable 的创建&lt;/li&gt;
&lt;li&gt;Observer 的创建、产生订阅关系&lt;/li&gt;
&lt;li&gt;订阅关系的传递&lt;/li&gt;
&lt;li&gt;取消订阅的流程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Rxjava 源码学习(一):基本流程分析</title>
    <link href="/2019/10/18/Rxjava%20%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>/2019/10/18/Rxjava 源码学习(一):基本流程分析/</id>
    <published>2019-10-18T07:02:06.000Z</published>
    <updated>2019-10-18T07:33:27.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Rxjava 源码版本：Rxjava2.2.8 </p></blockquote><h3 id="1-Rxjava-的基本实现"><a href="#1-Rxjava-的基本实现" class="headerlink" title="1. Rxjava 的基本实现"></a>1. Rxjava 的基本实现</h3><p>首先看一下最简单的例子，具体查看其内部实现：<br>通过以下代码查看 Rxjava 的典型使用：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        System.out.println(&quot;onSubscribe:&quot; + d.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;Throwable：&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        System.out.println(&quot;onComplete：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印日志为如下，可以看到事件接收的顺序和事件发送的顺序相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onSubscribe:CreateEmitter&#123;null&#125;</span><br><span class="line">onNext：one</span><br><span class="line">onNext：two</span><br><span class="line">onComplete</span><br></pre></td></tr></table></figure><h3 id="2-创建-Observable-对象"><a href="#2-创建-Observable-对象" class="headerlink" title="2. 创建 Observable 对象"></a>2. 创建 Observable 对象</h3><p>在上面的代码中，Observable 通过 create 来创建 Observable 对象，其具体源码如下：</p><p>Observable#create</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)</span><br><span class="line">    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 RxJavaPlugins.onAssembly 去组装 Observable，具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123;</span><br><span class="line">    Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;</span><br><span class="line">    if (f != null) &#123;</span><br><span class="line">        return apply(f, source);</span><br><span class="line">    &#125;</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 onObservableAssembly 是什么没看懂，但是不影响对流程的分析，在此方法中，我们可以认为直接返回传入的 Observable 对象。</p><p>其中 source 即为我们在使用 Rxjava 的 create 中传入的匿名对象，在上文中为 ObservableOnSubscribe，其方法 – subscribe 的参数为 <code>事件发生器</code>，可以用来发送事件，事件发生器为整个事件流的驱动。</p><p>其中涉及了 ObservableCreate，由于这个类对流程进行十分重要，所以我们查看一下其具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;</span><br><span class="line">    final ObservableOnSubscribe&lt;T&gt; source;</span><br><span class="line"></span><br><span class="line">    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123;</span><br><span class="line">        this.source = source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125; catch (Throwable ex) &#123;</span><br><span class="line">            Exceptions.throwIfFatal(ex);</span><br><span class="line">            parent.onError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class CreateEmitter&lt;T&gt;</span><br><span class="line">    extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">    implements ObservableEmitter&lt;T&gt;, Disposable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID = -3434801548987643227L;</span><br><span class="line"></span><br><span class="line">        final Observer&lt;? super T&gt; observer;</span><br><span class="line"></span><br><span class="line">        CreateEmitter(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">            this.observer = observer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class SerializedEmitter&lt;T&gt;</span><br><span class="line">    extends AtomicInteger</span><br><span class="line">    implements ObservableEmitter&lt;T&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的类层级结构为：ObservableCreate 内部包含两个内部类，分别为：CreateEmitter、SerializedEmitter，两者均继承了 ObservableEmitter，是事件发生器，为整个事件流的起点，但是具体如果发送事件，继续向下分析。</p><p>在 subscribeActual 方法中，我们可以看到创建了  CreateEmitter 对象，并通过以下调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.onSubscribe(parent);</span><br><span class="line">source.subscribe(parent);</span><br></pre></td></tr></table></figure><p>以上代码使 Obervable、Observer 与时间发射器分别产生关联，是事件流得以进行下去的关键。其实 <code>observer.onSubscribe(parent)</code> 即为在使用 Rxjava 过程的 Observer 中的 <code>onSubscribe(Disposable d)</code>，而 <code>source.subscribe(parent)</code> 即为 即为在使用 Rxjava 过程的 Observable 中的 <code>public void subscribe(ObservableEmitter&lt;String&gt; emitter)</code>，以上全是在方法 subscribeActual 中调用的，具体 subscribeActual 什么时候调用，查看下面的分析。</p><h3 id="3-产生订阅关系"><a href="#3-产生订阅关系" class="headerlink" title="3. 产生订阅关系"></a>3. 产生订阅关系</h3><p>Observable 对象通过 subscribe 与 Observer 产生调用关系。</p><p>Observable#subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 同样，我们可以认为直接返回 observer，对流程分析无影响 </span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">        ...</span><br><span class="line">        // 在此处 ObservableOnSubscribe#subscribeActual</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        ...</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在此时通过 ObservableOnSubscribe#subscribeActual 方法，从而使 Observer、Observable 分别与事件发生器发生关联。从上面知道 subscribeActual 中调用了 <code>source.subscribe(parent)</code>，其实为新建 ObservableOnSubscribe 对象的 subscribe 方法，从而完成回调 Rxjava 使用过程中自定义的事件发生器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    // source.subscribe(parent) 方法最终会回调到此处</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-发布事件"><a href="#4-发布事件" class="headerlink" title="4. 发布事件"></a>4. 发布事件</h3><p>既然 Observer、Observable 分别和事件发生器(Emitter) 产生关联，并且通过回调来到事件发射现场，那么具体查看是如何发生事件，以及观察者如何对每个事件是如何调用的。</p><p>具体以 CreateEmitter 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static final class CreateEmitter&lt;T&gt;</span><br><span class="line">extends AtomicReference&lt;Disposable&gt;</span><br><span class="line">implements ObservableEmitter&lt;T&gt;, Disposable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -3434801548987643227L;</span><br><span class="line"></span><br><span class="line">    final Observer&lt;? super T&gt; observer;</span><br><span class="line"></span><br><span class="line">    CreateEmitter(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        this.observer = observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(T t) &#123;</span><br><span class="line">        if (t == null) &#123;</span><br><span class="line">            onError(new NullPointerException(&quot;onNext called with null.....&quot;));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            observer.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        if (!isDisposed()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                observer.onComplete();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setDisposable(Disposable d) &#123;</span><br><span class="line">        DisposableHelper.set(this, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCancellable(Cancellable c) &#123;</span><br><span class="line">        setDisposable(new CancellableDisposable(c));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void dispose() &#123;</span><br><span class="line">        DisposableHelper.dispose(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isDisposed() &#123;</span><br><span class="line">        return DisposableHelper.isDisposed(get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件发生器发射事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emitter.onNext(&quot;one&quot;);</span><br></pre></td></tr></table></figure><p>最终会调用到 CreateEmitter#onNext：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNext(T t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        observer.onNext(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 发生器与自定义 Observer 已经产生关联关系，那么此时就会回调 Observer 的 onNext，也就是我们自定义 Observer 中的而如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onNext(String s) &#123;</span><br><span class="line">    System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理 emitter.onComplete()，emitter.onError() 也是如上过程，只不过 onError 会首先判断 error 是否能够自己处理，否则就交给 RxJavaPlugins 处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onError(Throwable t) &#123;</span><br><span class="line">    if (!tryOnError(t)) &#123;</span><br><span class="line">        RxJavaPlugins.onError(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean tryOnError(Throwable t) &#123;</span><br><span class="line">    if (t == null) &#123;</span><br><span class="line">        t = new NullPointerException(&quot;onError called with null. Null values are generally not allowed in 2.x operators an</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isDisposed()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 最终会调用到自定义  Observer 的 onError 方法</span><br><span class="line">            observer.onError(t);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            dispose();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Rxjava 的基本流程分析结束。</p><p>事件流可以而上而下进行下去，原因是 Observable 操作符 得到的还是 Observable，通过通过 Observable.subsribe 方法实现订阅关系。</p><h3 id="5-一个操作符：Map"><a href="#5-一个操作符：Map" class="headerlink" title="5. 一个操作符：Map"></a>5. 一个操作符：Map</h3><p>我们通过 map 操作符去理解 Rxjava 中数量众多的操作符的基本原理。</p><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;</span><br><span class="line">        emitter.onNext(&quot;one&quot;);</span><br><span class="line">        emitter.onNext(&quot;two&quot;);</span><br><span class="line">        emitter.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer apply(String s) throws Exception &#123;</span><br><span class="line">        return Integer.valueOf(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSubscribe(Disposable d) &#123;</span><br><span class="line">        System.out.println(&quot;onSubscribe:&quot; + d.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Integer s) &#123;</span><br><span class="line">        System.out.println(&quot;onNext：&quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;Throwable：&quot; + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        System.out.println(&quot;onComplete：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>map 操作符源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span><br><span class="line">    return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Function 对象 mapper 通过 ObservableMap 传给 ObservableMap，并完成相应的赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableMap&lt;T, U&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; &#123;</span><br><span class="line">    final Function&lt;? super T, ? extends U&gt; function;</span><br><span class="line"></span><br><span class="line">    public ObservableMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends U&gt; function) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.function = function;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">        source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class MapObserver&lt;T, U&gt; extends BasicFuseableObserver&lt;T, U&gt; &#123;</span><br><span class="line">        final Function&lt;? super T, ? extends U&gt; mapper;</span><br><span class="line"></span><br><span class="line">        MapObserver(Observer&lt;? super U&gt; actual, Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">            // 将观察者对象 actual 赋值给 downstream</span><br><span class="line">            super(actual);</span><br><span class="line">            this.mapper = mapper;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(T t) &#123;</span><br><span class="line">            if (done) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sourceMode != NONE) &#123;</span><br><span class="line">                downstream.onNext(null);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            U v;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 调用 mapper.apply ，其实是自定义 Function 中的 apply 方法</span><br><span class="line">                v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                fail(ex);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 最终调用 Observer 的 onNext 方法</span><br><span class="line">            downstream.onNext(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int requestFusion(int mode) &#123;</span><br><span class="line">            return transitiveBoundaryFusion(mode);</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的流程和 Rxjava 基本流程基本相同,执行产生订阅关系的方法 - subscribe 时调用 ObservableMap#subscribeActual：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    // 此处的 source 为调用 map 操作符的 Observable，即上一步通过 create 创建的 Observable </span><br><span class="line">    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">        ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook retu...);</span><br><span class="line">        // 由于多态的存在，此处的 subscribeActual 会调用 ObservableCreate 的subscribeActual</span><br><span class="line">        subscribeActual(observer);</span><br><span class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        RxJavaPlugins.onError(e);</span><br><span class="line">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t t</span><br><span class="line">        npe.initCause(e);</span><br><span class="line">        throw npe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的方法 subscribeActual 调用的为 ObservableCreate 的 subscribeActual 方法，接下来和基本流程一样会调用 ObservableCreate 的 subscribe 从而开启事件的分发，与 Rxjava 基本流程不同的是 map 操作符构建了 MapObserver，完成 MapObserver 的相关操作后，才会最终调用自定义的 Observer 对象。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>以 map 操作符为例，可以基本理清 Rxjava 中操作符的基本原理，<br>Rxjava <strong>整个事件流向的核心代码</strong> 如下：</p><p>xxxObservable#subscribeActual</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void subscribeActual(Observer&lt;? super U&gt; t) &#123;</span><br><span class="line">    source.subscribe(new XxxxObserver&lt;T, U&gt;(t, function));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observable#subscribe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    observer = RxJavaPlugins.onSubscribe(this, observer);</span><br><span class="line">    .... </span><br><span class="line">    subscribeActual(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 Observable 和 Observer 通过两个方法的往复调用，最终构建完整的事件流。</p><p>如果把第一个构建的 Observable 标记为 A，把自定义的 Observer 标记为 Z，那么各种操作符会构建不同的 Observer 标记为 B、C、D ….,通过 subscribeActual、 subscribe 方法使 A、B、C、D … 、Z 形成链式关系，最终由 Observable 对象 A 开启事件分发，将事件通过操作符定义的 Observer 对象 B、C、D … 进行各自处理，最终传递到 Observer 对象 Z 中，这个事件流得以完成，其实这就是平时所说的 Rxjava 中** Observer 由下向上 传递**，其实这也是 observerOn 只能只能指定下游 Observer 的线程的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Rxjava 源码版本：Rxjava2.2.8 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Rxjava-的基本实现&quot;&gt;&lt;a href=&quot;#1-Rxjava-的基本实现&quot; class=&quot;headerlink&quot; title=&quot;1. Rxjava 的基本实现&quot;&gt;&lt;/a&gt;1. Rxjava 的基本实现&lt;/h3&gt;&lt;p&gt;首先看一下最简单的例子，具体查看其内部实现：&lt;br&gt;通过以下代码查看 Rxjava 的典型使用：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Rxjava 源码分析" scheme="/tags/Rxjava-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 中的结构化并发是什么?</title>
    <link href="/2019/10/11/Kotlin-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>/2019/10/11/Kotlin-中的结构化并发是什么/</id>
    <published>2019-10-11T10:41:20.000Z</published>
    <updated>2019-10-18T06:46:03.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在接触到 Kotlin 的协程后，在官方文档知道，通过结构化的并发可以避免很多问题，具体参见官方文档 <a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">结构化的并发</a>，但是什么是结构化的并发呢？通过搜索引擎没有查询到有用的信息。此处只是记录自己通过网上博客的学习，为自己现阶段的记录和理解，这个话题也会持续更新。</p></blockquote><p>Kotlin 协程中如何实现结构化并发呢？ 先看一下官方文档中是基于什么问题使用结构化的并发？首先看一下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; // 启动一个新协程并保持对这个作业的引用</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">    job.join() // 等待直到子协程执行结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的启动总是全局的，一般是在程序的上下文启动的，对应协程，就如上面例子一样通过 GlobalScope 创建一个全局协程。不过官方文档上针对 GlobalScope 所阐述的确定，抱歉没看懂。。。</p><a id="more"></a><p>但是协程是可以 <strong>在指定作用域内启动协程的</strong>。协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中，外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束，此时就不用再像上面一样通过调用 join 来等待协程的执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun main() = runBlocking &#123; // this: CoroutineScope</span><br><span class="line">    launch &#123; // 在 runBlocking 作用域中启动一个新协程</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个例子似乎不太形象，在博客上存在这样一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image &#123; </span><br><span class="line">    val deferred1 = async &#123; loadImage(name1) &#125;</span><br><span class="line">    val deferred2 = async &#123; loadImage(name2) &#125;</span><br><span class="line">    return combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子是 <a href="https://www.youtube.com/watch?v=_hfBv0a09Jc" target="_blank" rel="noopener">KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov</a>，但是这个例子目前自己没能实现(参看了原博文说是此例子有很多处错误，不知是否该例是伪代码))，但是有这个例子又能够延伸什么是结构化的并发，先放在这吧(我尽力了)。</p><p>首先在外部协程中调用函数，如果此操作被取消了，那么这两个 loadImage 动作是不会被取消的。</p><p>进一步改善的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image &#123; </span><br><span class="line">    val deferred1 = async(conroutineContext) &#123; loadImage(name1) &#125;</span><br><span class="line">    val deferred2 = async(conroutineContext) &#123; loadImage(name2) &#125;</span><br><span class="line">    return combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在父协程被取消后，子协程也会被取消。但是这样也存在一定的问题，如果 deferred1.await() 抛出异常，但是 deferred2 不会受到影响，这样是不符合逻辑的。</p><p>这时就可以使用结构化的并发了，将 deferred1、deferred2 置于同一个作用域上，作用域内的协程称为外部协程的子协程，那么当其中外部协程被取消或者子协程异常时，作用域中的所有子协程都会被取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">suspend fun loadAndCombine(name1: String, name2: String): Image =</span><br><span class="line">    coroutineScope &#123; </span><br><span class="line">        val deferred1 = async &#123; loadImage(name1) &#125;</span><br><span class="line">        val deferred2 = async &#123; loadImage(name2) &#125;</span><br><span class="line">        combineImages(deferred1.await(), deferred2.await())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>知识来源：</strong></p><p><a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">结构化的并发</a></p><p><a href="https://blog.csdn.net/weixin_33755847/article/details/91366063" target="_blank" rel="noopener">[译] Kotlin 、协程、结构化并发</a></p><p><a href="https://trio.discourse.group/t/structured-concurrency-kickoff/55" target="_blank" rel="noopener">Structured Concurrency Kickoff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在接触到 Kotlin 的协程后，在官方文档知道，通过结构化的并发可以避免很多问题，具体参见官方文档 &lt;a href=&quot;https://www.kotlincn.net/docs/reference/coroutines/basics.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E5%B9%B6%E5%8F%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;结构化的并发&lt;/a&gt;，但是什么是结构化的并发呢？通过搜索引擎没有查询到有用的信息。此处只是记录自己通过网上博客的学习，为自己现阶段的记录和理解，这个话题也会持续更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kotlin 协程中如何实现结构化并发呢？ 先看一下官方文档中是基于什么问题使用结构化的并发？首先看一下这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fun main() = runBlocking &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    val job = GlobalScope.launch &amp;#123; // 启动一个新协程并保持对这个作业的引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(1000L)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;World!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(&amp;quot;Hello,&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    job.join() // 等待直到子协程执行结束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;线程的启动总是全局的，一般是在程序的上下文启动的，对应协程，就如上面例子一样通过 GlobalScope 创建一个全局协程。不过官方文档上针对 GlobalScope 所阐述的确定，抱歉没看懂。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin" scheme="/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(三)：协程的非阻塞式挂起是什么？</title>
    <link href="/2019/10/09/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%B8%89)%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%8C%82%E8%B5%B7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>/2019/10/09/Kotlin协程学习(三)：协程的非阻塞式挂起是什么/</id>
    <published>2019-10-09T07:51:42.000Z</published>
    <updated>2019-10-14T08:27:52.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kotlin-协程的-非阻塞式挂起是什么？"><a href="#Kotlin-协程的-非阻塞式挂起是什么？" class="headerlink" title="Kotlin 协程的 非阻塞式挂起是什么？"></a>Kotlin 协程的 非阻塞式挂起是什么？</h3><p>什么事非阻塞式：不卡当前线程。</p><p>Kotlin 协程的非阻塞原因：</p><pre><code>因为使用挂起函数会切换线程，既然切换了线程，那么肯定就不卡当前线程了。</code></pre><h3 id="其实线程也是非阻塞式的"><a href="#其实线程也是非阻塞式的" class="headerlink" title="其实线程也是非阻塞式的"></a>其实线程也是非阻塞式的</h3><p>线程中的阻塞式是 <code>在单线程</code> 下，在单线程下执行耗时操作是会阻塞线程的，如果在<code>多线程</code>情况下，那么此时的线程也是非阻塞式的。</p><a id="more"></a><p>但是 Kotlin 协程在 <strong>单协程的情况下也是非阻塞式</strong> 的，因为它可以利用挂起函数来切换线程。</p><p>协程是一种 <code>看起来阻塞，但是其实是非阻塞</code> 的写法,因为它有挂起函数。</p><pre><code>看起来阻塞：是因为确实你没有看到相关线程切换的代码，为顺序执行的代码。其实是非阻塞：是因为挂起函数可以自动帮助我们完成线程切换。</code></pre><h3 id="协程和线程的关系"><a href="#协程和线程的关系" class="headerlink" title="协程和线程的关系"></a>协程和线程的关系</h3><p>在 Kotlin 中协程是 <strong>基于线程而实现的一套更上层的工具 API</strong>，为基于线程的上层框架，类似 Executors ，并且和 Executors 的性能也差不多，所以 “轻量级线程说法，比线程更高效” 这种说法有待商榷。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>协程：就是切线程<br>挂起：可以自动切回来的切线程<br>非阻塞：协程可以用看起来阻塞的代码写出非阻塞式的操作</p><p>。</p><hr><p><strong>知识链接</strong></p><p><a href="https://www.bilibili.com/video/av69354029" target="_blank" rel="noopener">到底什么是「非阻塞式」挂起？协程真的比线程更轻量级吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kotlin-协程的-非阻塞式挂起是什么？&quot;&gt;&lt;a href=&quot;#Kotlin-协程的-非阻塞式挂起是什么？&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 协程的 非阻塞式挂起是什么？&quot;&gt;&lt;/a&gt;Kotlin 协程的 非阻塞式挂起是什么？&lt;/h3&gt;&lt;p&gt;什么事非阻塞式：不卡当前线程。&lt;/p&gt;
&lt;p&gt;Kotlin 协程的非阻塞原因：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因为使用挂起函数会切换线程，既然切换了线程，那么肯定就不卡当前线程了。&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;其实线程也是非阻塞式的&quot;&gt;&lt;a href=&quot;#其实线程也是非阻塞式的&quot; class=&quot;headerlink&quot; title=&quot;其实线程也是非阻塞式的&quot;&gt;&lt;/a&gt;其实线程也是非阻塞式的&lt;/h3&gt;&lt;p&gt;线程中的阻塞式是 &lt;code&gt;在单线程&lt;/code&gt; 下，在单线程下执行耗时操作是会阻塞线程的，如果在&lt;code&gt;多线程&lt;/code&gt;情况下，那么此时的线程也是非阻塞式的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程二</title>
    <link href="/2019/10/07/Kotlin%20%E5%8D%8F%E7%A8%8B%E4%BA%8C/"/>
    <id>/2019/10/07/Kotlin 协程二/</id>
    <published>2019-10-07T09:12:00.000Z</published>
    <updated>2019-10-09T07:52:46.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协程上下文和调度器"><a href="#协程上下文和调度器" class="headerlink" title="协程上下文和调度器"></a>协程上下文和调度器</h3><p>协程总是要运行在 CoroutineContext 类型为代表的协程上下文中，协程上下文是各种不同元素的集合，其中主元素为 Job，同事我们也会使用他的调度器。</p><h4 id="调度器与线程"><a href="#调度器与线程" class="headerlink" title="调度器与线程"></a>调度器与线程</h4><p>协程上下文包括了一个协程调度器，它确定了协程执行时使用的一个或多个线程。协程调度器可以指定协程运行在指定线程，也可以调度它运行在线程池中或不受限的运行。</p><p>所有的协程构建器(比如：launch、async) 会接收一个可选的 CoroutineContext 参数，它可以被显示的为一个新的协程或其他上下文元素指定一个调度器。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch &#123; // 运行在父协程的上下文中，即 runBlocking 主协程</span><br><span class="line">        println(&quot;main runBlocking      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // 不受限的——将工作在主线程中</span><br><span class="line">        println(&quot;Unconfined            : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; // 将会获取默认调度器</span><br><span class="line">        println(&quot;Default               : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(&quot;MyOwnThread&quot;)) &#123; // 将使它获得一个新的线程</span><br><span class="line">        println(&quot;newSingleThreadContext: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">Unconfined            : I&apos;m working in thread main</span><br><span class="line">Default               : I&apos;m working in thread DefaultDispatcher-worker-1</span><br><span class="line">newSingleThreadContext: I&apos;m working in thread MyOwnThread</span><br><span class="line">main runBlocking      : I&apos;m working in thread main</span><br></pre></td></tr></table></figure><h4 id="非受限调度器-vs-受限调度器"><a href="#非受限调度器-vs-受限调度器" class="headerlink" title="非受限调度器 vs 受限调度器"></a>非受限调度器 vs 受限调度器</h4><p>在上面的例子中有 Dispatchers.Unconfined ，此为非受限调度器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; // 非受限的——将和主线程一起工作</span><br><span class="line">        println(&quot;Unconfined      : I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(500)</span><br><span class="line">        println(&quot;Unconfined      : After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    launch &#123; // 父协程的上下文，主 runBlocking 协程</span><br><span class="line">        println(&quot;main runBlocking: I&apos;m working in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;main runBlocking: After delay in thread $&#123;Thread.currentThread().name&#125;&quot;)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">Unconfined      : I&apos;m working in thread main</span><br><span class="line">main runBlocking: I&apos;m working in thread main</span><br><span class="line">Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor</span><br></pre></td></tr></table></figure><p>Dispatchers.Unconfined协程调度器会在程序运行到第一个挂起点时，在调用者线程中启动,所以日志打印为：<br><code>Unconfined      : I&#39;m working in thread main</code>,此时在主线程中挂起。</p><p>挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行，挂起函数 delay() 运行的线程为<br><code>Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor</code></p><p>。非受限调度器适合协程不消耗 CPU 时间也不更新任何限于特定线程的共享数据（如 UI）的情境。</p><h4 id="调试协程与线程"><a href="#调试协程与线程" class="headerlink" title="调试协程与线程"></a>调试协程与线程</h4><p>由上面可知协程可以在一个线程中挂挂起在另外一个线程中恢复。在单一线程中也难弄清楚协程在何时何地在做什么事，所以这时我们需要打印正在执行代码的线程名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val a = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing a piece of the answer&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    val b = async &#123;</span><br><span class="line">        log(&quot;I&apos;m computing another piece of the answer&quot;)</span><br><span class="line">        7</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer is $&#123;a.await() * b.await()&#125;&quot;)    </span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">[main @coroutine#2] I&apos;m computing a piece of the answer</span><br><span class="line">[main @coroutine#3] I&apos;m computing another piece of the answer</span><br><span class="line">[main @coroutine#1] The answer is 42</span><br></pre></td></tr></table></figure><p>可以很清楚的知道协程执行的线程以及协程上下文。</p><h4 id="在不同线程间切换"><a href="#在不同线程间切换" class="headerlink" title="在不同线程间切换"></a>在不同线程间切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun log(msg: String) = println(&quot;[$&#123;Thread.currentThread().name&#125;] $msg&quot;)</span><br><span class="line"></span><br><span class="line">fun main() &#123;</span><br><span class="line">    newSingleThreadContext(&quot;Ctx1&quot;).use &#123; ctx1 -&gt;</span><br><span class="line">            newSingleThreadContext(&quot;Ctx2&quot;).use &#123; ctx2 -&gt;</span><br><span class="line">                    runBlocking(ctx1) &#123;</span><br><span class="line">                        log(&quot;Started in ctx1&quot;)</span><br><span class="line">                        withContext(ctx2) &#123;</span><br><span class="line">                            log(&quot;Working in ctx2&quot;)</span><br><span class="line">                        &#125;</span><br><span class="line">                        log(&quot;Back to ctx1&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">打印日志：</span><br><span class="line">[Ctx1 @coroutine#1] Started in ctx1</span><br><span class="line">[Ctx2 @coroutine#1] Working in ctx2</span><br><span class="line">[Ctx1 @coroutine#1] Back to ctx1</span><br></pre></td></tr></table></figure><p>从打印日志中可知 可以为 runBlocking() 显式的设置线程上下文，同时可以使用 withContext 函数来改变协程的线程上下文，从每条日志的<code>@coroutine#1</code>知它们仍运行在相同的协程中，以上函数只是改变了协程运行的线程，但是并没有改变协程的执行。</p><h4 id="上下文中的-Job"><a href="#上下文中的-Job" class="headerlink" title="上下文中的 Job"></a>上下文中的 Job</h4><p>Job 是它上下文中的一部分，协程可以在它所属的上下文中使用 coroutineContext[Job] 表达式来获取 Job 实例对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val job: Job? = coroutineContext[Job]</span><br><span class="line">    println(&quot;My job is $&#123;coroutineContext[Job]&#125;&quot;)</span><br><span class="line">    println(&quot;My job is $job&quot;)</span><br><span class="line">    println(&quot;Job is active?: $isActive&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">My job is BlockingCoroutine&#123;Active&#125;@5fa7e7ff</span><br><span class="line">My job is BlockingCoroutine&#123;Active&#125;@5fa7e7ff</span><br><span class="line">Job is active?: true</span><br></pre></td></tr></table></figure><p>进一步验证了 <code>coroutineContext[Job]</code> 取回的为所属上下文的 Job 对象。</p><p>CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。</p><h4 id="子协程"><a href="#子协程" class="headerlink" title="子协程"></a>子协程</h4><p>当一个协程被其它协程在 CoroutineScope 中启动的时候， 它将通过 CoroutineScope.coroutineContext 来承袭上下文，并且这个新协程的 Job 将会成为父协程的子 Job。<strong>当一个父协程被取消的时候，所有它的子协程也会被递归的取消</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    println(&quot;***[$&#123;Thread.currentThread().name&#125;] runBlocking above&quot;)</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        // 孵化了两个子作业, 其中一个通过 GlobalScope 启动</span><br><span class="line">        println(&quot;***[$&#123;Thread.currentThread().name&#125;] parent scope(父协程)&quot;)</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(&quot;job1: I run in GlobalScope and execute independently!&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;***[$&#123;Thread.currentThread().name&#125;] GlobalScope(全局协程)&quot;)</span><br><span class="line">            println(&quot;job1: I am not affected by cancellation of the request&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // 另一个则承袭了父协程的上下文</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(&quot;***[$&#123;Thread.currentThread().name&#125;] child scope(子协程)&quot;)</span><br><span class="line">            delay(100)</span><br><span class="line">            println(&quot;job2: I am a child of the request coroutine&quot;)</span><br><span class="line">            delay(1000)</span><br><span class="line">            println(&quot;job2: I will not execute this line if my parent request is cancelled&quot;)// 由于父协程 cancel，所以子协程中断执行，该语句无法打印</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(500)</span><br><span class="line">    request.cancel() // 取消请求（request）的执行</span><br><span class="line">    delay(1000) // 延迟一秒钟来看看发生了什么</span><br><span class="line">    println(&quot;main: Who has survived request cancellation?&quot;)</span><br><span class="line">    println(&quot;***[$&#123;Thread.currentThread().name&#125;] runBlocking Blew&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">***[main @coroutine#1] runBlocking above(runBlocking 外层协程)</span><br><span class="line">***[main @coroutine#2] parent scope(父协程)</span><br><span class="line">job1: I run in GlobalScope and execute independently!</span><br><span class="line">***[main @coroutine#4] child scope(子协程)</span><br><span class="line">job2: I am a child of the request coroutine</span><br><span class="line">***[DefaultDispatcher-worker-2 @coroutine#3] GlobalScope(全局协程)</span><br><span class="line">job1: I am not affected by cancellation of the request</span><br><span class="line">main: Who has survived request cancellation?</span><br><span class="line">***[main @coroutine#1] runBlocking Blew(runBlocking 外层协程)</span><br></pre></td></tr></table></figure><h4 id="父协程的职责"><a href="#父协程的职责" class="headerlink" title="父协程的职责"></a>父协程的职责</h4><p>父协程总是等待它所有的子协程全部执行完毕，父协程不必显式的跟踪所有子协程的启用，也不必使用 Job.join 在最后的时候等待它们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // 启动少量的子作业</span><br><span class="line">                launch  &#123;</span><br><span class="line">                    delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间</span><br><span class="line">                    println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    request.join() // 等待请求的完成，包括其所有子协程</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">request: I&apos;m done and I don&apos;t explicitly join my children that are still active</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Coroutine 2 is done</span><br><span class="line">Now processing of the request is complete</span><br></pre></td></tr></table></figure><p>如果注释掉 request.join()，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    // 启动一个协程来处理某种传入请求（request）</span><br><span class="line">    val request = launch &#123;</span><br><span class="line">        repeat(3) &#123; i -&gt; // 启动少量的子作业</span><br><span class="line">                launch  &#123;</span><br><span class="line">                    delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间</span><br><span class="line">                    println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(&quot;request: I&apos;m done and I don&apos;t explicitly join my children that are still active&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //request.join() // 等待请求的完成，包括其所有子协程</span><br><span class="line">    println(&quot;Now processing of the request is complete&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//打印日志：</span><br><span class="line">Now processing of the request is complete</span><br><span class="line">request: I&apos;m done and I don&apos;t explicitly join my children that are still active</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Coroutine 2 is done</span><br></pre></td></tr></table></figure><p>所以父协程不调用 join() 函数，也是会等待所有的子协程执行完毕。</p><h4 id="为协程命名"><a href="#为协程命名" class="headerlink" title="为协程命名"></a>为协程命名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking(CoroutineName(&quot;runBlockingName&quot;)) &#123;</span><br><span class="line">    log(&quot;Started main coroutine&quot;)</span><br><span class="line">    // 运行两个后台值计算</span><br><span class="line">    val v1 = async(CoroutineName(&quot;v1coroutine&quot;)) &#123;</span><br><span class="line">        delay(500)</span><br><span class="line">        log(&quot;Computing v1&quot;)</span><br><span class="line">        252</span><br><span class="line">    &#125;</span><br><span class="line">    val v2 = async(CoroutineName(&quot;v2coroutine&quot;)) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        log(&quot;Computing v2&quot;)</span><br><span class="line">        6</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;The answer for v1 / v2 = $&#123;v1.await() / v2.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">[main @runBlockingName#1] Started main coroutine</span><br><span class="line">[main @v1coroutine#2] Computing v1</span><br><span class="line">[main @v2coroutine#3] Computing v2</span><br><span class="line">[main @runBlockingName#1] The answer for v1 / v2 = 42</span><br></pre></td></tr></table></figure><h4 id="协程作用域"><a href="#协程作用域" class="headerlink" title="协程作用域"></a>协程作用域</h4><p>在日常开发过程中，在 Activity 中我们需要开启多个协程来获取网络数据、后台绘制、执行动画等，这协程动作必须在 Activity 销毁时取消，否则就会引起内存泄漏。</p><p>可以手动绑定协程和Activity 的生命周期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Activity &#123;</span><br><span class="line">    private val mainScope = MainScope()</span><br><span class="line"></span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续运行……</span><br></pre></td></tr></table></figure><p>也可以在这个 Activity 类中实现 CoroutineScope 接口，最好的方法是使用具有默认工厂函数的委托。 我们也可以将所需的调度器与作用域合并（我们在这个示例中使用 Dispatchers.Default）</p><p><strong>调度器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) &#123;</span><br><span class="line">    // 继续运行……</span><br></pre></td></tr></table></figure><p>完整执行程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) &#123;</span><br><span class="line"></span><br><span class="line">    fun destroy() &#123;</span><br><span class="line">        cancel() // Extension on CoroutineScope</span><br><span class="line">    &#125;</span><br><span class="line">    // 继续运行……</span><br><span class="line"></span><br><span class="line">    // class Activity continues</span><br><span class="line">    fun doSomething() &#123;</span><br><span class="line">        // 在示例中启动了 10 个协程，且每个都工作了不同的时长</span><br><span class="line">        repeat(10) &#123; i -&gt;</span><br><span class="line">            launch &#123;</span><br><span class="line">                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span><br><span class="line">                println(&quot;Coroutine $i is done&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; // Activity 类结束</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val activity = Activity()</span><br><span class="line">    activity.doSomething() // 运行测试函数</span><br><span class="line">    println(&quot;Launched coroutines&quot;)</span><br><span class="line">    delay(500L) // 延迟半秒钟</span><br><span class="line">    println(&quot;Destroying activity!&quot;)</span><br><span class="line">    activity.destroy() // 取消所有的协程</span><br><span class="line">    delay(1000) // 为了在视觉上确认它们没有工作    </span><br><span class="line">&#125;</span><br><span class="line">// 打印日志：</span><br><span class="line">Launched coroutines</span><br><span class="line">Coroutine 0 is done</span><br><span class="line">Coroutine 1 is done</span><br><span class="line">Destroying activity!</span><br></pre></td></tr></table></figure><h4 id="线程局部数据"><a href="#线程局部数据" class="headerlink" title="线程局部数据"></a>线程局部数据</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;协程上下文和调度器&quot;&gt;&lt;a href=&quot;#协程上下文和调度器&quot; class=&quot;headerlink&quot; title=&quot;协程上下文和调度器&quot;&gt;&lt;/a&gt;协程上下文和调度器&lt;/h3&gt;&lt;p&gt;协程总是要运行在 CoroutineContext 类型为代表的协程上下文中，协程上下文是各种不同元素的集合，其中主元素为 Job，同事我们也会使用他的调度器。&lt;/p&gt;
&lt;h4 id=&quot;调度器与线程&quot;&gt;&lt;a href=&quot;#调度器与线程&quot; class=&quot;headerlink&quot; title=&quot;调度器与线程&quot;&gt;&lt;/a&gt;调度器与线程&lt;/h4&gt;&lt;p&gt;协程上下文包括了一个协程调度器，它确定了协程执行时使用的一个或多个线程。协程调度器可以指定协程运行在指定线程，也可以调度它运行在线程池中或不受限的运行。&lt;/p&gt;
&lt;p&gt;所有的协程构建器(比如：launch、async) 会接收一个可选的 CoroutineContext 参数，它可以被显示的为一个新的协程或其他上下文元素指定一个调度器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin 官方文档" scheme="/tags/Kotlin-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 协程一</title>
    <link href="/2019/10/07/Kotlin%20%E5%8D%8F%E7%A8%8B%E4%B8%80/"/>
    <id>/2019/10/07/Kotlin 协程一/</id>
    <published>2019-10-07T09:11:30.000Z</published>
    <updated>2019-10-07T09:11:34.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协程的基本介绍"><a href="#协程的基本介绍" class="headerlink" title="协程的基本介绍"></a>协程的基本介绍</h3><p>协程，本质上是轻量级的线程。</p><p>它们在某些 <code>CoroutineScope 上下文中</code> 与 <code>launch 协程构建器</code> 一起启动。</p><p>在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。</p><p>delay 是挂起函数不会造成线程阻塞，但是会挂起协程，并且挂起函数只能在协程中使用。</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞都是针对于是否阻塞主线程来说的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例 1</span><br><span class="line">fun main() &#123;</span><br><span class="line">    GlobalScope.launch &#123; // 在后台启动一个新的协程并继续</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello&quot;) // 主线程中的代码会立即执行</span><br><span class="line">    runBlocking &#123;     // 但是这个表达式阻塞了主线程</span><br><span class="line">        delay(2000L)  // 我们延迟 2 秒来保证 JVM 的存活</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上程序中 GlobalScope.launch{} 中的 delay(1000L) 只会阻塞协程，但是 <strong>不会阻塞主线程的执行</strong>，所以以上代码会首先打印: Hello ，然后打印: World!。</p><p>runBlocking{} 代码块为阻塞式的。</p><h3 id="定义-Job"><a href="#定义-Job" class="headerlink" title="定义 Job"></a>定义 Job</h3><p>示例 1 中通过阻塞主线程一段时间:<br><code>(runBlocking{delay(2000L)})</code>，从而等待协程的完成，这不是一个好的方式，可以通过 Job 来改善上述方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = GlobalScope.launch &#123; // launch a new coroutine and keep a reference to its Job</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">    job.join() // wait until child coroutine completes    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>Job#join()</code> 主线程会一直阻塞，直到指定协程执行完毕。</p><h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><p>使用 GlobalScope.launch 会创建顶部协程，它会消耗一定的资源，如此的话启动多个协程会导致内存不足，此时使用 <strong>结构化并发</strong> 可以解决这个问题。</p><p>定义一个外部协程，在其内部也可以定义新的协程，包括外部协程在内的每个协程构建器都将 CoroutineScope 的实例添加到其代码块所在的作用域中。 我们可以在这个作用域中启动协程而无需显式调用 join ，因为 <strong>外部协程（示例中的 runBlocking）直到在其作用域中启动的所有协程都执行完毕后才会结束</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; //this:CoroutineScope</span><br><span class="line"></span><br><span class="line">    // 在 runBlocking 作用域中启动一个新协程</span><br><span class="line">    launch &#123;// this: CoroutineScope</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line"></span><br><span class="line">        launch &#123;// this: CoroutineScope</span><br><span class="line">            delay(5000L)</span><br><span class="line">            println(&quot;hahahah&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建作用域"><a href="#构建作用域" class="headerlink" title="构建作用域"></a>构建作用域</h3><p>除了使用构建器(如: launch、async 等)提供协程作用域之外，还可以使用 coroutineScope 构建器声明自己的作用域。</p><p>使用  coroutineScope 可以构建协程作用域，<strong>构建的协程作用域在所有子协程执行完毕之前不会结束</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123; // this: CoroutineScope</span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(200L)</span><br><span class="line">        println(&quot;Task from runBlocking&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; // 创建一个协程作用域</span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(500L) </span><br><span class="line">            println(&quot;Task from nested launch&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(100L)</span><br><span class="line">        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(&quot;Coroutine scope is over&quot;) // 这一行在内嵌 launch 执行完毕后才输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为打印日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task from coroutine scope</span><br><span class="line">Task from runBlocking</span><br><span class="line">Task from nested launch</span><br><span class="line">Coroutine scope is over</span><br></pre></td></tr></table></figure><p>注意打印顺序，从打印顺序中可以看出协程的 <strong>非阻塞</strong>，因为 <code>Task from coroutine scope</code> 最先打印出来。</p><h3 id="协程的取消与超时"><a href="#协程的取消与超时" class="headerlink" title="协程的取消与超时"></a>协程的取消与超时</h3><p>协程是可以被取消的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val job = launch &#123;</span><br><span class="line">        repeat(1000) &#123; i -&gt;</span><br><span class="line">                println(&quot;job: I&apos;m sleeping $i ...&quot;)</span><br><span class="line">            delay(500L)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(1300L) // 延迟一段时间</span><br><span class="line">    println(&quot;main: I&apos;m tired of waiting!&quot;)</span><br><span class="line">    job.cancel() // 取消该作业</span><br><span class="line">    job.join() // 等待作业执行结束</span><br><span class="line">    println(&quot;main: Now I can quit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job: I&apos;m sleeping 0 ...</span><br><span class="line">job: I&apos;m sleeping 1 ...</span><br><span class="line">job: I&apos;m sleeping 2 ...</span><br><span class="line">main: I&apos;m tired of waiting!</span><br><span class="line">main: Now I can quit.</span><br></pre></td></tr></table></figure><p>当协程中在执行计算任务是协程是不能被取消的。</p><p>超时 ：</p><p>withTimeout(1300L) {<br>    repeat(1000) { i -&gt;<br>            println(“I’m sleeping $i …”)<br>        delay(500L)<br>    }<br>}</p><p>在执行超过 1300ms 会报出错误。</p><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>使用 <code>suspend</code> 修饰的函数，排列的挂起函数 <strong>默认顺序执行</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">suspend fun doSomethingUsefulOne(): Int &#123;</span><br><span class="line">    delay(1000L) // 假设我们在这里做了一些有用的事</span><br><span class="line">    return 13</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun doSomethingUsefulTwo(): Int &#123;</span><br><span class="line">    delay(1000L) // 假设我们在这里也做了一些有用的事</span><br><span class="line">    return 29</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        val one = doSomethingUsefulOne()</span><br><span class="line">        val two = doSomethingUsefulTwo()</span><br><span class="line">        println(&quot;The answer is $&#123;one + two&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Completed in $time ms&quot;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 2012 ms</span><br></pre></td></tr></table></figure><p>通过打印时间可以得知默认挂起函数为顺序执行的。</p><h3 id="lauch-、-async"><a href="#lauch-、-async" class="headerlink" title="lauch 、 async"></a>lauch 、 async</h3><p>async 与 lauch 一样，开启了一个单独的协程，与其他协程一起进行并行工作。<br>不同的 launch 返回一个 Job 不附带任何结果值，而 async 返回 Deffered ，它是一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 <strong>.await() 在一个延期的值上得到它的最终结果</strong>， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它 。</p><p>同样是上面的例子，我们使用 async 并发修饰函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">        val one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        val two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)// 使用 await() 函数获得他的最终结果</span><br><span class="line">    &#125;</span><br><span class="line">println(&quot;Completed in $time ms&quot;) </span><br><span class="line"></span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 1029 ms</span><br></pre></td></tr></table></figure><p>从执行时间可知使用 async 修饰函数为 <strong>并行执行</strong> 的。</p><h3 id="惰性-async"><a href="#惰性-async" class="headerlink" title="惰性 async"></a>惰性 async</h3><p>如果懒加载一样，惰性 async 只有在使用时才会执行，执行 start() 方法执行该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">val time = measureTimeMillis &#123;</span><br><span class="line">    val one = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">    val two = async(start = CoroutineStart.LAZY) &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">    // 执行一些计算</span><br><span class="line">    one.start() // 启动第一个</span><br><span class="line">    two.start() // 启动第二个</span><br><span class="line">    println(&quot;The answer is $&#123;one.await() + two.await()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;Completed in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//执行结果：</span><br><span class="line">The answer is 42</span><br><span class="line">Completed in 1017 ms</span><br></pre></td></tr></table></figure><p>以上 one、two 只是定义的两个协程，由于 <code>start = CoroutineStart.LAZY</code> 的存在没有真正的执行，只有在执行 start 方法后两个协程才会真正的执行</p><h3 id="async-风格函数"><a href="#async-风格函数" class="headerlink" title="async 风格函数"></a>async 风格函数</h3><p>在 Kotlin 中不推荐使用此类型的函数,故不详述.</p><h3 id="结构化-async-函数"><a href="#结构化-async-函数" class="headerlink" title="结构化 async 函数"></a>结构化 async 函数</h3><p>结构化 async 函数 <strong>就是使多个 async 函数执行时如果一个函数发生异常,则其他未执行的 async 函数也不会得到执行</strong>,此功能使用  coroutineScope 来实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        failedConcurrentSum()</span><br><span class="line">    &#125; catch (e: ArithmeticException) &#123;</span><br><span class="line">        println(&quot;Computation failed with ArithmeticException&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async&lt;Int&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // 模拟一个长时间的运算</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        delay(2000L)</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val three = async &#123;</span><br><span class="line">        println(&quot;Test third run or not&quot;)</span><br><span class="line">        12</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await() + three.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印日志&quot;</span><br><span class="line">Test third run or not</span><br><span class="line">Second child throws an exception</span><br><span class="line">First child was cancelled</span><br><span class="line">Computation failed with ArithmeticException</span><br></pre></td></tr></table></figure><p>如果在上面函数执行过程中 two 发生异常,那么此时正在等待执行的 one 将中断执行,但是之前的 three 则可以正常的执行。</p><hr><p><strong>知识链接</strong></p><p><a href="https://developer.android.com/kotlin/coroutines" target="_blank" rel="noopener">Improve app performance with Kotlin coroutines</a></p><p><a href="https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb" target="_blank" rel="noopener">Coroutines on Android (part I): Getting the background</a></p><p><a href="https://blog.csdn.net/qq_32115439/article/details/74018755" target="_blank" rel="noopener">Kotlin-24.协程和线程(Coroutine &amp; Thread)</a></p><p><a href="https://github.com/hltj/kotlinx.coroutines-cn/blob/master/ui/coroutines-guide-ui.md" target="_blank" rel="noopener">使用协程进行 UI 编程指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;协程的基本介绍&quot;&gt;&lt;a href=&quot;#协程的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;协程的基本介绍&quot;&gt;&lt;/a&gt;协程的基本介绍&lt;/h3&gt;&lt;p&gt;协程，本质上是轻量级的线程。&lt;/p&gt;
&lt;p&gt;它们在某些 &lt;code&gt;CoroutineScope 上下文中&lt;/code&gt; 与 &lt;code&gt;launch 协程构建器&lt;/code&gt; 一起启动。&lt;/p&gt;
&lt;p&gt;在 GlobalScope 中启动了一个新的协程，这意味着新协程的生命周期只受整个应用程序的生命周期限制。&lt;/p&gt;
&lt;p&gt;delay 是挂起函数不会造成线程阻塞，但是会挂起协程，并且挂起函数只能在协程中使用。&lt;/p&gt;
&lt;h3 id=&quot;阻塞与非阻塞&quot;&gt;&lt;a href=&quot;#阻塞与非阻塞&quot; class=&quot;headerlink&quot; title=&quot;阻塞与非阻塞&quot;&gt;&lt;/a&gt;阻塞与非阻塞&lt;/h3&gt;&lt;p&gt;阻塞与非阻塞都是针对于是否阻塞主线程来说的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coroutines(协程)" scheme="/tags/Coroutines-%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Kotlin 官方文档" scheme="/tags/Kotlin-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 泛型</title>
    <link href="/2019/10/07/Kotlin%20%E6%B3%9B%E5%9E%8B/"/>
    <id>/2019/10/07/Kotlin 泛型/</id>
    <published>2019-10-07T07:50:47.000Z</published>
    <updated>2019-10-07T09:08:07.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-中的泛型"><a href="#Java-中的泛型" class="headerlink" title="Java 中的泛型"></a>Java 中的泛型</h3><p>协变(covariance)：子类的泛型类型也属于泛型类型的子类。</p><p>由于 Java 中类型擦除的存在，所以 Java 不支持协变，Kotlin 继承了这种限制。在 Java 中可以通过使用通配符(?) 来解除这种限制。</p><p>这样的话有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用了通配符，就可以把子类的泛型类型对象赋值给父类的泛型类型声明了</span><br><span class="line">List&lt;? extends TextView&gt; textViews = new ArrayList&lt;Button&gt;();</span><br></pre></td></tr></table></figure><p>虽然这种写法解除了赋值的限制，但是却增加了另外一个限制：在使用这个引用的时候，不能调用它的参数包含类型参数的方法，也不能给它的包含类型参数的字段赋值(除了空值)。</p><p>限制：父类的泛型类型声明的实际值不能是子类的泛型类型对象</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private ArrayList&lt;? extends TextView&gt; mList = new ArrayList&lt;Button&gt;();</span><br><span class="line">//mList.add(textView); 此调用是错误的</span><br></pre></td></tr></table></figure><p>看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void showTexts(List&lt;TextView&gt; list)&#123;</span><br><span class="line">    for(TextView tv: list)&#123;</span><br><span class="line">        sout(tv.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Button&gt; buttons = ...;</span><br><span class="line">....</span><br><span class="line">showTexts(buttons);// 如此调用，编译期会报错</span><br></pre></td></tr></table></figure><p>做如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void showTexts(List&lt;? extends TextView&gt; list)&#123;</span><br><span class="line">    for(TextView tv: list)&#123;</span><br><span class="line">        sout(tv.getText());// getText() 的参数中不包含类型参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Button&gt; buttons = ...;</span><br><span class="line">....</span><br><span class="line">showTexts(buttons);// showTexts 方法做以上更改，无错</span><br></pre></td></tr></table></figure><p>当遇到只想使用不想修改的情况时，可以使用 ？ extends ，使不具有协变的 Java 支持协变。</p><p>同时，还存在 ？ super 可以使原本不具有 逆变 的 Java 具有 逆变的性质。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void addTextView(List&lt;TextView&gt; list)&#123;</span><br><span class="line">    TextView textView = ..&apos;;</span><br><span class="line">    list.add(textview);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;View&gt; views = new ArrayList&lt;View&gt;();</span><br><span class="line">addTextView(views);// 如此调用，编译期错误</span><br></pre></td></tr></table></figure><p>做如下更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void addTextView(List&lt;? super TextView&gt; list)&#123;</span><br><span class="line">    TextView textView = ..&apos;;</span><br><span class="line">    list.add(textview);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;View&gt; views = new ArrayList&lt;View&gt;();</span><br><span class="line">addTextView(views);// 如此更改，无错</span><br></pre></td></tr></table></figure><p>限制：只能修改，不能使用</p><p>？extents 、？super 的使用场景：</p><p>PECS 法则：Producer extends，Conssumer super。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>? extends –&gt; out:只能输出，不能输入，只能读不能写。</p><p>? super –&gt; in：只能输入不能输出，只能写不能读。</p><p>Kotlin 中的 in 和 out 不仅可以直接使用在变量和参数的声明里，还可以使用在泛型类型声明的类型参数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Producer&lt;out T&gt;&#123;</span><br><span class="line">    fun producer():T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Consumer&lt;in T&gt;&#123;</span><br><span class="line">    fun consumer(t:T)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示这个类型只能用来输入或输出。</p><h3 id><a href="#" class="headerlink" title="*"></a>*</h3><p>Kotlin 中 * 相当于 Java 中的 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Java</span><br><span class="line">List&lt;?&gt; list;</span><br><span class="line">等效于 </span><br><span class="line">List&lt;? extends Object&gt; list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Kotlin</span><br><span class="line"></span><br><span class="line">var list:List&lt;*&gt;</span><br><span class="line">等效于</span><br><span class="line">var list:List&lt;out Any&gt;</span><br></pre></td></tr></table></figure><p>如果类型声明已经有了 in 或者 out，那么这个限制在变量声明是也依然存在，不会被 * 去掉，如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Conter&lt;out T : Number&gt;&#123;</span><br><span class="line">    fun count(): T</span><br><span class="line">&#125;</span><br><span class="line">// 虽然变量在声明时类型参数为 *，但是其效果依旧是 out Numbuer</span><br><span class="line">var counter:Counter&lt;*&gt; =</span><br></pre></td></tr></table></figure><h3 id="Java-声明中的上界和下界"><a href="#Java-声明中的上界和下界" class="headerlink" title="Java 声明中的上界和下界"></a>Java 声明中的上界和下界</h3><p>Java 在类型声明时可以指定类型声明的上界,和 ？ extends 不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Bird&lt;T extends Animal &amp; Food&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Bird&lt;T:Animal&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bird&lt;T&gt; where T:Animal, T:Food&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kotin-与-Java-的不同"><a href="#Kotin-与-Java-的不同" class="headerlink" title="Kotin 与 Java 的不同"></a>Kotin 与 Java 的不同</h3><p>Kotlin中有一个 Java 中没有的关键字： refield</p><p>Java 中的类型参数(比如说 T)，它不是一个真正的类型， 而仅仅是一个代号， 不能把它作为一个普通的类型来用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; void test(Object item)&#123;</span><br><span class="line">    if(item instanceof T)&#123;// 这样是不可以的</span><br><span class="line">        sout(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在 Kotlin 中这样也是不可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; test(item: Any)&#123;</span><br><span class="line">    if(item is T)&#123;// 这样不可以</span><br><span class="line">        sout(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 Kotlin 中只有添加一个 refield 关键字就可以解除以上限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;refield T&gt; test(item: Any)&#123;</span><br><span class="line">    if(item is T)&#123;// 这样不可以</span><br><span class="line">        sout(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 refield 自身有限制，只能用在 inline 函数上</p><hr><p><a href="https://www.bilibili.com/video/av66340216" target="_blank" rel="noopener">Kotlin 泛型</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-中的泛型&quot;&gt;&lt;a href=&quot;#Java-中的泛型&quot; class=&quot;headerlink&quot; title=&quot;Java 中的泛型&quot;&gt;&lt;/a&gt;Java 中的泛型&lt;/h3&gt;&lt;p&gt;协变(covariance)：子类的泛型类型也属于泛型类型的子类。&lt;/p&gt;
&lt;p&gt;由于 Java 中类型擦除的存在，所以 Java 不支持协变，Kotlin 继承了这种限制。在 Java 中可以通过使用通配符(?) 来解除这种限制。&lt;/p&gt;
&lt;p&gt;这样的话有：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 使用了通配符，就可以把子类的泛型类型对象赋值给父类的泛型类型声明了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;? extends TextView&amp;gt; textViews = new ArrayList&amp;lt;Button&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;虽然这种写法解除了赋值的限制，但是却增加了另外一个限制：在使用这个引用的时候，不能调用它的参数包含类型参数的方法，也不能给它的包含类型参数的字段赋值(除了空值)。&lt;/p&gt;
&lt;p&gt;限制：父类的泛型类型声明的实际值不能是子类的泛型类型对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 泛型" scheme="/tags/Kotlin-%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(二):挂起函数</title>
    <link href="/2019/10/07/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%BA%8C):%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0/"/>
    <id>/2019/10/07/Kotlin协程学习(二):挂起函数/</id>
    <published>2019-10-07T07:46:13.000Z</published>
    <updated>2019-10-09T10:55:21.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对 <a href="https://www.bilibili.com/video/av68241619" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a> 的文字记录，确实香啊！</p></blockquote><h3 id="1-Kotlin-协程挂起的基本了解"><a href="#1-Kotlin-协程挂起的基本了解" class="headerlink" title="1. Kotlin 协程挂起的基本了解"></a>1. Kotlin 协程挂起的基本了解</h3><blockquote><p>Q:Kotlin 协程中挂起的是什么？ </p></blockquote><p>A:挂起的是协程。</p><blockquote><p>Q:那什么是协程？</p></blockquote><p>A:kotlin 协程为 launch()、async() 等中的代码。</p><p>launch 在创建的一个协程，在执行到某一个 suspend 函数(挂起函数)时，这个协程会被 suspend(被挂起)。</p><blockquote><p>Q:从哪挂起？</p></blockquote><p>A:从当前线程挂起，就是这个协程从正在执行它的线程上脱离了，注意不是协程停下来了，而是协程所在的线程从这行代码开始不再运行这个协程了(意思就是挂起函数将由自己指定的线程运行，挂起可以理解为将协程挂到指定的线程中去执行)，那么分离了的线程和协程会各自发生什么？</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    ...</span><br><span class="line">    //suspendingGetImage 为挂起函数</span><br><span class="line">    val image = suspendingGetImage(imageId)</span><br><span class="line">    imageIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离了的线程和协程将如何执行？线程和协程分离了，具体到代码是什么意思？</p><h3 id="2-分离后的线程"><a href="#2-分离后的线程" class="headerlink" title="2.分离后的线程"></a>2.分离后的线程</h3><p>协程的代码块，在线程中到了 suspend 函数的时候，突然执行完毕了，返回了，完毕之后线程该干嘛呢？当然该干嘛干嘛去。</p><ul><li>线程为后台线程<br>如果线程是后台线程，那么接下来该线程就没有事或者去执行其他的后台任务，和 Java 中的线程池中线程做完工作是一样的，要么回收掉，要么再利用；</li></ul><ul><li>线程为主线程<br>如果是 Android 中的主线程，那么它会继续执行接下来的工作。<br>以上代码相当于：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handler.post&#123;</span><br><span class="line">    ...</span><br><span class="line">    val image = suspendingGetImage(imageId)</span><br><span class="line">    imageIv.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时挂起就相当于 post 的这个任务提前结束了。</p><h3 id="3-分离后的协程"><a href="#3-分离后的协程" class="headerlink" title="3. 分离后的协程"></a>3. 分离后的协程</h3><p>函数的代码在执行到挂起函数的时候被掐断了，所以接下来，它会在指定线程中从这个挂起函数开始向下执行，那么这个线程是谁指定的？当然是挂起函数指定的。在上面的例子钟就是 suspendingGetImage 这个函数中通过 withContext 指定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">suspend fun suspendingGetImage(imageId:String)&#123;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        getImage(imageId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在此例中，所指定的线程为函数内部的 withContext() 所指定的 IO 线程。</p><p>在挂起函数执行完毕后，它 <strong>会自动把线程再切回来</strong>。</p><p>在上面的例子中，在挂起函数执行完毕后，协程会再 post 一个任务，<strong>让剩下的代码继续回到主线程中去执行</strong>。</p><p>这也就是为什么协程中指定线程的参数不是 Thread ，而是 Dispatchers(调度器)，调度器不止能指定协程执行的线程，还能在 suspend 挂起函数执行完毕后再自动切回来，当然也可以指定特殊的 Dispatchers ，在指定挂起函数后不切换回来。</p><p>挂起的含义就是：<strong>暂时切走，稍后在切回来</strong>。<strong>就是切换线程，不过在执行完毕会切换回来</strong>，这个切回来的动作在协程中称为 <em>resume (恢复)*</em>。</p><h3 id="4-为什么挂起函数只能在协程里或者另一个挂起函数中调用？"><a href="#4-为什么挂起函数只能在协程里或者另一个挂起函数中调用？" class="headerlink" title="4. 为什么挂起函数只能在协程里或者另一个挂起函数中调用？"></a>4. 为什么挂起函数只能在协程里或者另一个挂起函数中调用？</h3><p>首先，挂起之后是需要恢复的，也就是把线程给切回来，而恢复这个动作是协程的，所以一个挂起函数不在协程/另一个挂起函数中被调用，那么这个恢复的动作是不能实现的。</p><h3 id="5-挂起是怎么做到的"><a href="#5-挂起是怎么做到的" class="headerlink" title="5. 挂起是怎么做到的"></a>5. 挂起是怎么做到的</h3><p>在 挂起函数中使用 withContext 指定切换的线程。</p><p>其实 suspend 关键字并不能起到挂起函数的作用，并不是因为使用 suspend 修饰，函数就可以实现挂起动作，而真正想要挂起协程，还需要在挂起函数里面去调用另外一个挂起函数，而里面的这个挂起函数需要是协程自带的、内部实现了协程挂起代码的，或者它的内部直接或间接的调用了某一个自带的挂起函数，最终需要调用一个协程自带的挂起函数，让它来做真正的挂起，实现线程切换的工作。</p><h3 id="6-suspend-真正的作用：提醒"><a href="#6-suspend-真正的作用：提醒" class="headerlink" title="6. suspend 真正的作用：提醒"></a>6. suspend 真正的作用：提醒</h3><p>既然 suspend 不能真正的做到挂起函数，那么 suspend 的作用是什么呢?</p><p>在语法上 suspend 的作用：它其实是一个 <strong>提醒</strong>，函数的创建者对函数的调用者的提醒：我是一个耗时函数，因此我被我的创建者用挂起函数的方式放到了后台运行，所以请在协程中调用我。</p><p>提醒调用者该函数为耗时操作，那么这个提醒有什么作用呢？</p><p>这个提醒有效避免主线程的卡顿，因为一旦不小心在主线程调用了一个耗时操作，那么主线程会产生卡顿。而协程通过挂起函数这种形式，把耗时任务切换线程的工作交给了函数的创建者而不是调用者，对于调用者会十分的简单，他看到 suspend 这个关键字就明白了应该在协程中调用，从而避免了调用者不熟悉调用的函数的情况下在主线程调用耗时操作的行为。</p><p>所以创建一个挂起函数，一定要在内部调用别的挂起函数，否则这个挂起函数就是没有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 这个挂起函数是没有意义的</span><br><span class="line">suspend fun test(str:String)&#123;</span><br><span class="line">    sout(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-自定义挂起函数"><a href="#7-自定义挂起函数" class="headerlink" title="7. 自定义挂起函数"></a>7. 自定义挂起函数</h3><ul><li><p>什么时候需要自定义挂起函数</p><ul><li>原则：耗时(特殊：等待)</li></ul></li></ul><p>如果某个函数比较耗时，两类：</p><ul><li>I/O 操作</li><li>计算工作</li></ul><p>比如文件读写、网络交互、图片操作等，还有在等待情况下，比如等待 5s 后继续操作，这些都可以写在挂起函数中。</p><ul><li>怎么写</li></ul><p>函数添加关键字 suspend，内部代码使用 withContext获取他挂起函数包裹。</p><hr><p><strong>知识链接</strong></p><p><a href="https://www.bilibili.com/video/av68241619" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是对 &lt;a href=&quot;https://www.bilibili.com/video/av68241619&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了&lt;/a&gt; 的文字记录，确实香啊！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-Kotlin-协程挂起的基本了解&quot;&gt;&lt;a href=&quot;#1-Kotlin-协程挂起的基本了解&quot; class=&quot;headerlink&quot; title=&quot;1. Kotlin 协程挂起的基本了解&quot;&gt;&lt;/a&gt;1. Kotlin 协程挂起的基本了解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Q:Kotlin 协程中挂起的是什么？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:挂起的是协程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:那什么是协程？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:kotlin 协程为 launch()、async() 等中的代码。&lt;/p&gt;
&lt;p&gt;launch 在创建的一个协程，在执行到某一个 suspend 函数(挂起函数)时，这个协程会被 suspend(被挂起)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:从哪挂起？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A:从当前线程挂起，就是这个协程从正在执行它的线程上脱离了，注意不是协程停下来了，而是协程所在的线程从这行代码开始不再运行这个协程了(意思就是挂起函数将由自己指定的线程运行，挂起可以理解为将协程挂到指定的线程中去执行)，那么分离了的线程和协程会各自发生什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程学习(一):协程的基本了解</title>
    <link href="/2019/10/07/Kotlin%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0(%E4%B8%80):%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
    <id>/2019/10/07/Kotlin协程学习(一):协程的基本了解/</id>
    <published>2019-10-07T07:45:22.000Z</published>
    <updated>2019-10-09T07:56:42.052Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-协程是什么"><a href="#1-协程是什么" class="headerlink" title="1. 协程是什么"></a>1. 协程是什么</h3><ul><li>其实是一套由 Kotlin 官方提供的 <strong>线程 API</strong></li></ul><p>可以理解为一个线程框架，它的好处是方便，最大的好处是 <strong>可以在同一个代码块中进行多次线程切换</strong>。</p><h3 id="2-协程的好处"><a href="#2-协程的好处" class="headerlink" title="2. 协程的好处"></a>2. 协程的好处</h3><p>更方便。</p><a id="more"></a><p>使用 Kotlin 协程可以用看起来同步的方式写出异步代码，这就是 Kotlin 著名的 <strong>非阻塞式挂起</strong>。</p><h3 id="3-使用-Kotlin-协程"><a href="#3-使用-Kotlin-协程" class="headerlink" title="3. 使用 Kotlin 协程"></a>3. 使用 Kotlin 协程</h3><ul><li>基本功能：并发(多线程)</li></ul><p>例如可以把任务切换到后台或前台执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    doSomething(data)</span><br><span class="line">&#125;</span><br><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    updateUI(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最大好处</li></ul><p>Kotlin 最大的好处在于可以把：运行在不同线程的代码，写在同一个代码块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;// 开始：主线程</span><br><span class="line">    val user = api.getUser()// 网络请求：后台线程</span><br><span class="line">    name.text = user.name// 更新 UI：主线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程和主线程使用 Kotlin 协程，可以消除了 Java 中的回调，避免回调地狱。</p><p>存在这么一个需要：需要合并两个独处接口的结果，然后操作。此时 Java 中传统的回调并不能很好的完成任务，此时很大可以会采用两次串行请求，然后合并进行操作，这样的两个独立的接口原本可以并行请求，现在只能串行请求，很明显网络的等待时间长了一倍，性能也差了一倍。而使用 Kotlin 协程则可以很好的解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    val avatar = async &#123;api.getAvatar(user)&#125;</span><br><span class="line">    val logo = async &#123; api.getLogo(user)&#125;</span><br><span class="line">    val merge = suspendingMerge(avatar,logo)</span><br><span class="line">    show(merge)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程消除了并发任务之间的协作难度，轻松写出复杂的并发代码。</p><p>这些才是协程的优势。</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul><li>简单</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    doSomething(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>launch 的具体含义是：创建一个新的协程，并在指定线程上运行它。</p><p>被创建、被运行的协程是什么？就是传给 launch 的代码，如 <code>doSomething(data)</code>，这一段连续代码称为协程。</p><p>当需要切换线程或者指定线程的时候，可以使用 协程。</p><h3 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lauch(Dispatchers.IO)&#123;</span><br><span class="line">    val image = api.getImage()</span><br><span class="line">    launch(Dispatchers.Main)&#123;</span><br><span class="line">        image.setImageBitmap(image) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是仅仅使用 launch 并不能避免回调地狱，在协程中有一个函数： withContext()，这个函数可以指定线程来执行代码，并且在执行之后,<strong>自动把线程切回来</strong>，继续执行代码，使用 withContext 后，以上代码可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    // 在 Dispatchers.IO 线程中执行相关代码，执行完毕后切换后 Dispatchers.Main 线程</span><br><span class="line">    val image = withContext(Dispatchers.IO)&#123;</span><br><span class="line">        api.getImage()</span><br><span class="line">    &#125;</span><br><span class="line">    image.setImageBitmap(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程消除了并发代码在协作时的嵌套，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.IO)&#123;</span><br><span class="line">    ...</span><br><span class="line">    launch(Dispatchers.Main)&#123;</span><br><span class="line">        ...</span><br><span class="line">        launch(Dispatchers.IO)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 withContext 可以吧以上的嵌套关系直接写成上下关系的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">launch(Dispatchers.Main)&#123;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    withContext(Dispatchers.IO)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suspend-函数"><a href="#suspend-函数" class="headerlink" title="suspend 函数"></a>suspend 函数</h3><p>有 suspend 修饰符的函数，称为 suspend 函数，挂起函数。</p><p>代码执行到 suspend 函数的时候会被 suspend(挂起)，并且这个 “挂起” 是 非阻塞式的，它不会阻挡你的线程。</p><hr><p><strong>知识来源：</strong></p><p><a href="https://www.bilibili.com/video/av67107689" target="_blank" rel="noopener">【码上开学】学不会协程？很可能因为你看过的教程都是错的——Kotlin 的协程「用力瞥一眼」</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-协程是什么&quot;&gt;&lt;a href=&quot;#1-协程是什么&quot; class=&quot;headerlink&quot; title=&quot;1. 协程是什么&quot;&gt;&lt;/a&gt;1. 协程是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;其实是一套由 Kotlin 官方提供的 &lt;strong&gt;线程 API&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以理解为一个线程框架，它的好处是方便，最大的好处是 &lt;strong&gt;可以在同一个代码块中进行多次线程切换&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-协程的好处&quot;&gt;&lt;a href=&quot;#2-协程的好处&quot; class=&quot;headerlink&quot; title=&quot;2. 协程的好处&quot;&gt;&lt;/a&gt;2. 协程的好处&lt;/h3&gt;&lt;p&gt;更方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin 协程" scheme="/tags/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal(Jdk1.8) 使用及源码分析</title>
    <link href="/2019/09/19/ThreadLocal(Jdk1.8)%20%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>/2019/09/19/ThreadLocal(Jdk1.8) 使用及源码分析/</id>
    <published>2019-09-19T06:30:16.000Z</published>
    <updated>2019-10-10T03:16:06.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-ThreadLocal-简介"><a href="#0x0001-ThreadLocal-简介" class="headerlink" title="0x0001 ThreadLocal 简介"></a>0x0001 ThreadLocal 简介</h3><p>使用 ThreadLocal 对象存储 <strong>线程相关</strong> 的变量，只能有存储动作执行所在线程内才能够获取相应变量。</p><h3 id="0x0002-ThreadLocal-中相关类简介"><a href="#0x0002-ThreadLocal-中相关类简介" class="headerlink" title="0x0002 ThreadLocal 中相关类简介"></a>0x0002 ThreadLocal 中相关类简介</h3><h4 id="1-ThreadLocalMap"><a href="#1-ThreadLocalMap" class="headerlink" title="1. ThreadLocalMap"></a>1. ThreadLocalMap</h4><p>ThreadLocalMap 是 ThreadLocal 中一个自定义的哈希映射，仅适用于维护线程本地值。不会在 ThreadLocal 类之外导出任何操作。该类是包私有的，允许在 Thread 类中声明字段。为了帮助处理非常大且长期使用的用法，哈希表条目使用WeakReferences 作为键。但是，由于未使用引用队列，因此只有在表开始空间不足时才能保证删除过时条目。</p><a id="more"></a><h4 id="2-ThreadLocalMap-中的-Entry"><a href="#2-ThreadLocalMap-中的-Entry" class="headerlink" title="2. ThreadLocalMap 中的 Entry"></a>2. ThreadLocalMap 中的 Entry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中以下是对 Entry 的介绍：</p><blockquote><p>The entries in this hash map extend WeakReference, using<br>its main ref field as the key (which is always a<br>ThreadLocal object).  Note that null keys (i.e. entry.get()<br>== null) mean that the key is no longer referenced, so the<br>entry can be expunged from table.  Such entries are referred to<br>as “stale entries” in the code that follows.</p></blockquote><blockquote><p>Entry 继承了 WeakReference，使用 Entry 对象的引用作为 ThreadLocalMap 存储元素的 key。当通过 entry.get() 获得为 null 时，说明不再引用该 key，因此可以从表中删除该条目。</p></blockquote><h3 id="0x0003-ThreadLocal-实现的关键"><a href="#0x0003-ThreadLocal-实现的关键" class="headerlink" title="0x0003 ThreadLocal 实现的关键"></a>0x0003 ThreadLocal 实现的关键</h3><p>这也是 ThreadLocal 可以存储线程相关的变量的关键，这是 <strong>因为 ThreadLocalMap 的对象是在 Thread 中维护的</strong>。</p><p>在通过 set 存储变量时：</p><ol><li>首先会获得所在线程对象</li><li>接着可以获取线程的属性 ThreadLocalMap 对象</li><li>从而实现以 ThreadLocal 为 key 的变量存储在 ThreadLocalMap 对象中，这一步就实现了存储线程相关的变量。</li></ol><p>在通过 get 获取变量时：</p><ol><li>首先获得所在线程对象，</li><li>接着那么就自然可以获得其属性值 – ThreadLocalMap 对象，</li><li>以当前 ThreadLocal 对象为 key 自然可以获得其中存储的变量。</li></ol><p>当然这只是大致步骤，其中还是有许多细节的。</p><h3 id="0x0004-ThreadLocal-set-方法"><a href="#0x0004-ThreadLocal-set-方法" class="headerlink" title="0x0004 ThreadLocal#set 方法"></a>0x0004 ThreadLocal#set 方法</h3><p>ThreadLocal#set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    // 步骤一：获取当前线程</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    // 步骤二：获取当前线程的属性值 -- ThreadLocalMap 对象</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    // 步骤三：存储变量值，其中 key 为当前 ThreadLocal 对象</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为步骤二的具体代码，可以看到线程维护了 ThreadLocalMap 对象，为 ThreadLocal 能够存储线程相关的变量提供可能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal#set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line">    // We don&apos;t use a fast path as with get() because it is at</span><br><span class="line">    // least as common to use set() to create new entries as</span><br><span class="line">    // it is to replace existing ones, in which case, a fast</span><br><span class="line">    // path would fail more often than not.</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (len-1);</span><br><span class="line">    for (Entry e = tab[i];</span><br><span class="line">         e != null;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        // 更新 key 对应的 value</span><br><span class="line">        if (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == null) &#123;</span><br><span class="line">            // 经过一系列算法操作，添加 value</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[i] = new Entry(key, value);</span><br><span class="line">    int sz = ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-ThreadLocal-get-方法"><a href="#0x0005-ThreadLocal-get-方法" class="headerlink" title="0x0005 ThreadLocal#get 方法"></a>0x0005 ThreadLocal#get 方法</h3><p>ThreadLocal#get</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前线程相关的 threadlocal 中变量，如果变量为 null，则返回 setInitialValue() 线程相关的初始值(null)。</span><br><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;  </span><br><span class="line">        // 很明显，通过 key 获取 Map 中的 value</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            // 返回相应的 value</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 线程相关的变量，返回初始化值</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果获取到的 ThreadLocalMap 对象 map 为 null ，会进行如下操作：</li></ul><p>ThreadLocal#setInitialValue</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果获取到的 ThreadLocalMap 对象 map 为 null ，会进行如下步骤，获取对应的 ThreadLocalMap.Entry 对象：</li></ul><p>ThreadLocalMap#getEntry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    // </span><br><span class="line">    if (e != null &amp;&amp; e.get() == key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        // 通过散列的 hash 索引获取不到值的话，那么就需要变量 ThreadLocalMap 中的数组进行遍历。</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap#getEntryAfterMiss</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 通过遍历 table 中元素，寻找对对应的 Entry 对象</span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i,  Entrye) &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    int len = tab.length;</span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        if (k == key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k == null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Entry 对象就可以获得具体的变量值。</p><h3 id="0x0006-多线程与多-同一个-ThreadLocal-对象"><a href="#0x0006-多线程与多-同一个-ThreadLocal-对象" class="headerlink" title="0x0006 多线程与多 同一个 ThreadLocal 对象"></a>0x0006 多线程与多 同一个 ThreadLocal 对象</h3><p>对 ThreadLocal 的原理有一定的理解，那么以下两个场景理解就十分容易了。</p><ul><li>情景一：同一个 ThreadLocal 对象，维护不同线程的变量</li></ul><p>明白了 ThreadLocal 原理，这个问题就不难理解了，因为每一个线程都维护者自己的 ThreadLocalMap 对象，不同所存储的变量在各自 ThreadLocalMap 对象中，所以即使同一个 ThreadLocal 对象，也是可以实现在各自线程获取属于各自存储的变量。</p><p>由于存储元素时，ThreadLocalMap 是以 ThreadLocal 对象的哈希值(一系列操作的 hash)为key，所以在同一个线程中对同一个 ThreadLocal 对象进行多次 set 的调用，那么会对值进行覆盖。</p><ul><li>情景二：同一线程下，使用多个 ThreadLocal 对象进行变量存储</li></ul><p>由上面的分析值，在同一个线程下只维护 ThreadLocalMap 对象，而存储是以 ThreadLocal 对象的哈希值为 key 进行存储的，所以多个 ThreadLocal 对象获取的变量一定是自己存储的。</p><h3 id="0x0007-使用场景"><a href="#0x0007-使用场景" class="headerlink" title="0x0007 使用场景"></a>0x0007 使用场景</h3><h4 id="1-线程内单例"><a href="#1-线程内单例" class="headerlink" title="1. 线程内单例"></a>1. 线程内单例</h4><p>我们平时使用到的单例为进程为单例，而通过 ThreadLocal 可实现线程内同步，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private static ThreadLocal&lt;User&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static User getInstance() &#123;</span><br><span class="line">        User instance = threadLocal.get();</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new User();</span><br><span class="line">            threadLocal.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量的作用域为线程"><a href="#2-变量的作用域为线程" class="headerlink" title="2. 变量的作用域为线程"></a>2. 变量的作用域为线程</h4><p>当一些数据是以线程为作用域，并且不同线程拥有数据的不同副本的时候，就可以考虑使用 ThreadLocal。</p><p>在子线程中初始化 Handler 需要手动的创建 Looper，因为 Looper 是线程相关的，那么 Looper 是怎样实现线程相关的呢？本质就是使用了 ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler;</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();//Looper初始化</span><br><span class="line">        //Handler初始化 需要注意, Handler初始化传入Looper对象是子线程中缓存的Looper对象</span><br><span class="line">        mHandler = new Handler(Looper.myLooper());</span><br><span class="line">        Looper.loop();//死循环</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>具体看一下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果不执行 <code>Looper.prepare()</code> ，则 <code>Looper.myLooper()</code> 就无法获取到线程相关的 Looper 实例对象。</p><p>当然 Android 给了更为简单的实现方式： HandlerThread，但是本质还是 ThreadLocal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread handlerThread = new HandlerThread(&quot;HandlerThread&quot;);</span><br><span class="line">handlerThread.start();</span><br><span class="line">Handler mHandler = new Handler(handlerThread.getLooper())&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">        Log.d(&quot;Log&quot;,&quot;current thread is &quot;+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mHandler.sendEmptyMessage(1);</span><br></pre></td></tr></table></figure><h4 id="3-复杂逻辑下的对象传递"><a href="#3-复杂逻辑下的对象传递" class="headerlink" title="3. 复杂逻辑下的对象传递"></a>3. 复杂逻辑下的对象传递</h4><p>有时候一个线程的逻辑过于复杂，导致函数的调用栈比较深，而这时候我们需要监视器能够贯穿整个线程的执行过程，这是就可以使用 ThreadLocal 。使用 ThreadLocal 存储监视器，这样就可以在线程中获得监视器对象。</p><p>其他能够想到的两种方式：</p><ol><li><p>将监视器对象通过参数的方式传递</p><p>这种方式当调用栈过深时，会让整个逻辑更加复杂、难懂。</p></li><li><p>将监视器作为静态变量供线程访问 </p><p> 这种方式是可以接受的，但是这种方式是不具有扩充性，如果有两个线程在执行，那么就需要提供两个静态的监听对象。如果是更多的线程呢？这无疑是代码中的”坏味道“。</p></li></ol><p>而使用 ThreadLocal 则完全不会遇到上面问题。</p><hr><p><strong>知识链接</strong></p><p><a href="https://item.jd.com/11760209.html" target="_blank" rel="noopener">Android 开发艺术探索</a></p><p><a href="https://www.jianshu.com/p/4167d7ff5ec1" target="_blank" rel="noopener">带你了解源码中的 ThreadLocal</a></p><p><a href="https://www.bilibili.com/video/av7592261?from=search&seid=7861472405873308618" target="_blank" rel="noopener">ThreadLocal类及应用技巧</a> : 视频建议 2 倍速看完，没什么营养，但可以向你展示如何使用 ThreadLocal </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-ThreadLocal-简介&quot;&gt;&lt;a href=&quot;#0x0001-ThreadLocal-简介&quot; class=&quot;headerlink&quot; title=&quot;0x0001 ThreadLocal 简介&quot;&gt;&lt;/a&gt;0x0001 ThreadLocal 简介&lt;/h3&gt;&lt;p&gt;使用 ThreadLocal 对象存储 &lt;strong&gt;线程相关&lt;/strong&gt; 的变量，只能有存储动作执行所在线程内才能够获取相应变量。&lt;/p&gt;
&lt;h3 id=&quot;0x0002-ThreadLocal-中相关类简介&quot;&gt;&lt;a href=&quot;#0x0002-ThreadLocal-中相关类简介&quot; class=&quot;headerlink&quot; title=&quot;0x0002 ThreadLocal 中相关类简介&quot;&gt;&lt;/a&gt;0x0002 ThreadLocal 中相关类简介&lt;/h3&gt;&lt;h4 id=&quot;1-ThreadLocalMap&quot;&gt;&lt;a href=&quot;#1-ThreadLocalMap&quot; class=&quot;headerlink&quot; title=&quot;1. ThreadLocalMap&quot;&gt;&lt;/a&gt;1. ThreadLocalMap&lt;/h4&gt;&lt;p&gt;ThreadLocalMap 是 ThreadLocal 中一个自定义的哈希映射，仅适用于维护线程本地值。不会在 ThreadLocal 类之外导出任何操作。该类是包私有的，允许在 Thread 类中声明字段。为了帮助处理非常大且长期使用的用法，哈希表条目使用WeakReferences 作为键。但是，由于未使用引用队列，因此只有在表开始空间不足时才能保证删除过时条目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Java 引用类型及回收机制简单解析</title>
    <link href="/2019/09/18/Java-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90/"/>
    <id>/2019/09/18/Java-引用类型及回收机制简单解析/</id>
    <published>2019-09-18T09:23:11.000Z</published>
    <updated>2019-09-18T09:24:58.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h3><p>在 JDK1.2 以前对引用的定义为：<br>    如果 reference 类型的数据中存储的数值代表另外一块内存的起始地址，那么就称这块内存代表一个引用。</p><p>此定义将一个对象分为被引用或者没有被引用的两种状态，但是如果内存不足时被引用的对象由于不能被释放，自然就会导致 OOM。</p><p>所以我们需要定义一类这样的对象：当内存空间足够时，我们希望对象继续保存在内存中，如果内存不够时，我们可以回收这些对象。</p><p>所以在 JDK1.2 之后就对 Java 引用的概念进行了扩充，将引用细分为</p><ul><li>强引用(Strong Reference)</li><li>软引用(Soft Reference)</li><li>弱引用(Weak Reference)</li><li>虚引用(Phantom Reference)</li></ul><h3 id="不同引用类型的回收机制"><a href="#不同引用类型的回收机制" class="headerlink" title="不同引用类型的回收机制"></a>不同引用类型的回收机制</h3><ol><li><p>强引用</p><p> 永远不会被回收，即使系统 OOM 也不会被回收，就是这么刚。</p><p> 对于一个普通的而对象，如果没有其他引用关系，只要超过了引用的作用域或者显式的将相应的引用赋值为 null，就可以被 GC 回收了。</p></li><li><p>软引用</p><p> 用来描述一些还有用并非必需的对象，对于软引用的关联的对象，在系统将要发生 <strong>OOM 之前</strong>，将会把这些对象列入回收范围内，进行第二次回收，如果此时内存还是不够，才会报出 OOM。</p><p> 软引用通常用来实现内存敏感的内存，如果还有空闲内存，就可以暂时保留缓存。当内存不足时才会清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li></ol><ol start="3"><li><p>弱引用(WeakReference)</p><p> 弱引用也用了描述非必需的对象，但是它的强度比弱引用更弱一些，被软引用关联的对象只能生存到 <strong>下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前的内存是否够用，都会回收掉只被弱引用关联的对象。</p><p> 弱引用仅仅是提供一种访问在弱引用状态下对象的途径，这样就可以构建一种没有特定约束的关系，比如维护一种非强制的映射关系，如果试图获取时该对象还在，就是用它，否则就重新实例化。</p><p> 和软引用一样，弱引用也是很多缓存实现的选择。</p></li></ol><ol start="4"><li><p>虚引用(PhantomReference)</p><p> 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象实例。</p><p> 为一个对象设置虚引用关联的唯一目的就是<strong>能在这个对象被垃圾回收器回收时收到一个系统通知</strong>。</p></li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>所有的引用类型，都是抽象类 java.lang.ref.Reference 的子类，它提供了 get() 方法，除了幻象引用( get() 获得的永远是 null)，如果对象还没有被销毁，都可以通过 get 方法获得原有的对象，这就意味着，可以利用软引用和弱引用将访问的对象重新指向强引用，所以引用类型之间是可以转换的。</p><p>但是如果我们将通过弱引用或软引用获得对象 (get() 方法) 指向错误的强引用(比如说 static 变量)，那么这个对象就不可能再变回之前的弱引用或软引用的状态的了，就导致产生内存泄漏。所以检查弱引用指向的对象有没有被 GC，这是检查特定对象是否引起内存泄漏的思路。</p><h3 id="引用队列-ReferenceQueue-的使用"><a href="#引用队列-ReferenceQueue-的使用" class="headerlink" title="引用队列(ReferenceQueue)的使用"></a>引用队列(ReferenceQueue)的使用</h3><blockquote><p>在创建 Reference 类型时，将创建的 ReferenceQueue 注册到 Reference 中，当 Reference 所引用的对象被 GC 回收时，JVM<br>就会就该对象对应的 Reference 对象放到该队列中，我们可以通过操作这个队列来完成一定的需求。</p></blockquote><blockquote><p>使用SoftReference，WeakReference，PhantomReference 的时候，可以关联一个ReferenceQueue。那么当垃圾回收器准备回收一个被引用包装的对象时，该引用会被加入到关联的ReferenceQueue。程序可以通过判断引用队列中是否已经加入引用,来了解被引用的对象是否被 GC 回收。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是引用&quot;&gt;&lt;a href=&quot;#什么是引用&quot; class=&quot;headerlink&quot; title=&quot;什么是引用&quot;&gt;&lt;/a&gt;什么是引用&lt;/h3&gt;&lt;p&gt;在 JDK1.2 以前对引用的定义为：&lt;br&gt;    如果 reference 类型的数据中存储的数值代表另外一块内
      
    
    </summary>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
      <category term="《深入理解 Java 虚拟机》读书笔记" scheme="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>EventBus 线程模式</title>
    <link href="/2019/09/12/EventBus-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>/2019/09/12/EventBus-线程模式/</id>
    <published>2019-09-12T03:37:55.000Z</published>
    <updated>2019-09-20T09:15:50.456Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus 可以处理 Android 中的线程切换的问题：事件发布的线程可以与线程处理的线程不同。以下几种模式为事件处理的线程。EventBus 可以帮助使用者子线程与主线程的同步问题。</p><h3 id="ThreadMode-POSTING-default"><a href="#ThreadMode-POSTING-default" class="headerlink" title="ThreadMode:POSTING (default)"></a>ThreadMode:POSTING (default)</h3><p>订阅者将在同一个线程中发布事件,这是默认情况。订阅者将在事件发布者的线程中响应事件，这是默认情况。事件传送将<code>同步</code>完成，一旦发布完成，所有订阅者就会被调用。这种 ThreadMode 避免了线程间的切换，因此所需的开销最小。因此，当任务简单、所需时间短、不需要占用主线程时，这种 ThreadMode 是推荐使用的。但由于事件分发可能发生在主线程，所以使用此模式的事件处理程序应该快速返回，以避免阻塞发布线程。处理函数中禁止更新UI操作。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Called in the same thread (default)</span><br><span class="line">// ThreadMode is optional here</span><br><span class="line">@Subscribe(threadMode = ThreadMode.POSTING)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">    log(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-MAIN"><a href="#ThreadMode-MAIN" class="headerlink" title="ThreadMode: MAIN"></a>ThreadMode: MAIN</h3><p>订阅者将在主线程中响应事件。如果发布线程为主线程，那么订阅者事件将会直接响应（像 ThreadMode.POSTING 线程模式进行事件同步）。订阅者响应事件必须快速处理完自己方法内的业务以避免阻塞主线程。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">textField.setText(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-MAIN-ORDERED"><a href="#ThreadMode-MAIN-ORDERED" class="headerlink" title="ThreadMode: MAIN_ORDERED"></a>ThreadMode: MAIN_ORDERED</h3><p> 在这种模式下，订阅者会在主线程中执行。该模式下，事件总是排队等待以后发送给订阅者，因此对 post 的调用将立即返回。这使事件处理更加严格且更加一致（因此名称为MAIN_ORDERED）。例如，如果您在具有 MAIN 线程模式的事件处理程序中发布另一个事件，则第二个事件处理程序将在第一个事件处理程序之前完成（因为它被同步调用 - 将其与方法调用进行比较）。使用 MAIN_ORDERED，第一个事件处理程序将完成，然后第二个事件处理程序将在稍后的时间点调用（一旦主线程具有容量）。</p><p> 这种模式和 MAIN 不同的是发布事件是否在主线程，如果不是的话就会采用这种模式，通过其源码可知实现原理为通过 Handler 将事件发布到主线程中。</p><p>由于在主线程中执行，则应避免耗时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in Android UI&apos;s main thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.MAIN_ORDERED)</span><br><span class="line">public void onMessage(MessageEvent event) &#123;</span><br><span class="line">    textField.setText(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadMode-BACKGROUD"><a href="#ThreadMode-BACKGROUD" class="headerlink" title="ThreadMode: BACKGROUD"></a>ThreadMode: BACKGROUD</h3><p>在这种模式下，订阅者将会在非UI线程中被调用。如果事件发布所在非UI线程，那么订阅者将会在该线程中被直接调用。反之，EventBus使用单个后台线程，它将顺序地处理响应事件。在这种模式下，订阅者快速处理完自己方法内的业务以避免阻塞线程。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in the background thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.BACKGROUND)</span><br><span class="line">public void onMessage(MessageEvent event)&#123;</span><br><span class="line">    saveToDisk(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThradMode-ASYNC"><a href="#ThradMode-ASYNC" class="headerlink" title="ThradMode: ASYNC"></a>ThradMode: ASYNC</h3><p>事件处理方法会在单独的线程中被调用，这个线程与主线程、事件发布线程相互独立。在这种模式下，事件发布不需要等待事件处理方法。当事件处理方法需要进行耗时操作，比如：网络请求等，这是需要使用这种模式。为了限制并发线程的数量，应避免同时触发大量长时间运行的异步处理操作。EventBus通过线程池通过重用，使用线程池从完成的异步事件处理程序通知中有效地重用线程。<br>EventBus 通过重用线程池中已经完成异步事件的线程来达到线程的高效复用。处理函数中禁止更新UI操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Called in a separate thread</span><br><span class="line">@Subscribe(threadMode = ThreadMode.ASYNC)</span><br><span class="line">public void onMessage(MessageEvent event)&#123;</span><br><span class="line">    backend.send(event.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;</span><br><span class="line">    switch (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        case POSTING:</span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        case MAIN:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MAIN_ORDERED:</span><br><span class="line">            if (mainThreadPoster != null) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // temporary: technically not correct as poster not decoupled from subscriber</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case BACKGROUND:</span><br><span class="line">            if (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码有以下结论：<br>POSTING 模式下只有一种执行方式：在事件发布的线程执行。<br>MAIN、MAIN_ORDERED、MAIN_ORDERED、BACKGROUND：这四种模式都会根据发布事件所在的线程是否为主线程而执行不同的方式。<br>ASYNC：不管发布事件的线程是否为主线程，均在子线程中执行相关动作。</p><hr><p><strong>知识链接</strong></p><p><a href="http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/" target="_blank" rel="noopener">官方地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus 可以处理 Android 中的线程切换的问题：事件发布的线程可以与线程处理的线程不同。以下几种模式为事件处理的线程。EventBus 可以帮助使用者子线程与主线程的同步问题。&lt;/p&gt;
&lt;h3 id=&quot;ThreadMode-POSTING-default&quot;&gt;&lt;a href=&quot;#ThreadMode-POSTING-default&quot; class=&quot;headerlink&quot; title=&quot;ThreadMode:POSTING (default)&quot;&gt;&lt;/a&gt;ThreadMode:POSTING (default)&lt;/h3&gt;&lt;p&gt;订阅者将在同一个线程中发布事件,这是默认情况。订阅者将在事件发布者的线程中响应事件，这是默认情况。事件传送将&lt;code&gt;同步&lt;/code&gt;完成，一旦发布完成，所有订阅者就会被调用。这种 ThreadMode 避免了线程间的切换，因此所需的开销最小。因此，当任务简单、所需时间短、不需要占用主线程时，这种 ThreadMode 是推荐使用的。但由于事件分发可能发生在主线程，所以使用此模式的事件处理程序应该快速返回，以避免阻塞发布线程。处理函数中禁止更新UI操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="EventBus" scheme="/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>线程的 wait、sleep、join、yeild 方法</title>
    <link href="/2019/09/05/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>/2019/09/05/线程的几个方法/</id>
    <published>2019-09-05T07:53:17.000Z</published>
    <updated>2019-09-05T07:56:32.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-wait"><a href="#0x0001-wait" class="headerlink" title="0x0001 wait()"></a>0x0001 wait()</h3><p>首先，需要明确的是 wait() 方法为 Object 类中的方法，所以 Object 对象才可以执行 wait() 方法，但是该方法和线程的各个状态息息相关。</p><p>当一个线程执行到 wait() 方法时，它就进入到一个 <strong>和该对象相关的等待池</strong> 中，同时 <strong>该线程失去(释放)对象所持有的锁</strong>，使得其他线程可以访问。用户可以使用 notify、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。</p><p>需要注意的是：wait()、notify()、notifyAll() 必须放在 synchronized block 中，否则会抛出异常。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    </span><br><span class="line">    private static final Object mLockObject = new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        waitAndNotifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void waitAndNotifyAll()&#123;</span><br><span class="line">        System.out.println(&quot;主线程执行&quot;);</span><br><span class="line">        Thread thread = new WaitThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        synchronized (mLockObject)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;主线程等待&quot;);</span><br><span class="line">                mLockObject.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long timsMs = System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(&quot;主线程继续 -&gt; 等待耗时：&quot;  + timsMs + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class WaitThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line">            synchronized (mLockObject)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(&quot;子线程执行,3s 后执行 notifyAll&quot;);</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    mLockObject.notifyAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主线程执行</span><br><span class="line">主线程等待</span><br><span class="line">子线程执行,3s 后执行 notifyAll</span><br><span class="line">主线程继续 -&gt; 等待耗时：3007 ms</span><br></pre></td></tr></table></figure><p>可以看到在主线程在执行 mLockObject 的 wait() 方法后就进入到等待状态，在子线程中执行 mLockObject 的 notifyAll() 方法来唤醒等待池中睡眠的主线程，使主线程继续执行。</p><h3 id="0x0002-sleep"><a href="#0x0002-sleep" class="headerlink" title="0x0002 sleep"></a>0x0002 sleep</h3><p>该方法时 Thread 的静态方法，作用是 <strong>使调用线程进入睡眠状态</strong>。因为 sleep 方法时 Thread 的静态方法，因此它 <strong>不能改变对象所持有的锁</strong>，所以当在一个 synchronized 块中调用 sleep 方法时，虽然线程休眠了，但是所持有的对象锁并不会被释放，其他线程也无法访问这个对象(睡着也要霸占锁的主)。</p><h3 id="0x003-join"><a href="#0x003-join" class="headerlink" title="0x003 join"></a>0x003 join</h3><p>等待目标线程执行完成后再继续执行，即 <strong>获得插队执行的权利</strong>。</p><p>阻塞当前调用 join() 方法时 <strong>所在的线程</strong>，直到目标线程(调用 join 方法的线程)执行完毕，阻塞的线程得以继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static void joinTest() &#123;</span><br><span class="line">    // 目标线程 1</span><br><span class="line">    Worker worker1 = new Worker(&quot;worker-1&quot;);</span><br><span class="line">    // 目标线程 2</span><br><span class="line">    Worker worker2 = new Worker(&quot;worker-2&quot;);</span><br><span class="line">    worker1.start();</span><br><span class="line"></span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;启动线程 1&quot;);</span><br><span class="line">        // 调用 worker1 中的 join 函数，主线程会阻塞知道 worker1 执行完成</span><br><span class="line">        worker1.join();</span><br><span class="line">        System.out.println(&quot;启动线程 2&quot;);</span><br><span class="line">        // 启动线程2 ，调用 worker2 中的 join 函数，主线程会阻塞知道 worker2 执行完成</span><br><span class="line">        worker2.start();</span><br><span class="line">        worker2.join();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;主线程继续执行&quot;);</span><br><span class="line">    System.out.println(&quot;主线程等待线程 1 和线程 2 的时间为：&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static class Worker extends Thread &#123;</span><br><span class="line">    public Worker(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Work in: &quot; + getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">启动线程 1</span><br><span class="line">Work in: worker-1</span><br><span class="line">启动线程 2</span><br><span class="line">Work in: worker-2</span><br><span class="line">主线程继续执行</span><br><span class="line">主线程等待线程 1 和线程 2 的时间为：4010 ms</span><br></pre></td></tr></table></figure><p>可以看到在开启线程后(执行 start() 方法)，执行指定线程的 join() 方法，主线程会一直阻塞，直到目标线程执行完毕后，主线程才得以执行执行。</p><h3 id="0x0004-yield"><a href="#0x0004-yield" class="headerlink" title="0x0004 yield"></a>0x0004 yield</h3><p>线程礼让。</p><p>使调用该函数的线程让出执行时间给其他已经处于就绪状态的线程。</p><p>目标线程有由 <strong>运行状态</strong> 转换为 <strong>就绪状态</strong>，让出执行权限，让其他线程得以优先执行，但是其他线程是否能够优先执行是位置的， 由 CPU 时间分片决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static void yieldTest()&#123;</span><br><span class="line">    YieldThread yieldThread1 = new YieldThread(&quot;thread-1&quot;);</span><br><span class="line">    YieldThread yieldThread2 = new YieldThread(&quot;thread-2&quot;);</span><br><span class="line">    yieldThread1.start();</span><br><span class="line">    yieldThread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class YieldThread extends Thread &#123;</span><br><span class="line">    </span><br><span class="line">    public YieldThread(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%s 优先级为：%d ---&gt; %d\n&quot;, this.getName(), this.getPriority(), i);</span><br><span class="line">            // 当 i = 2 时，调用当前线程执行 yield 函数</span><br><span class="line">            if (i == 2) &#123;</span><br><span class="line">                System.out.printf(&quot;%s 进入到就绪状态 ---&gt; %d %s \n&quot;, this.getName(), i,this.getName());</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                System.out.printf(&quot;%s 重新回到运行状态 ---&gt; %d  %s \n&quot;, this.getName(), i, this.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">thread-1 优先级为：5 ---&gt; 0</span><br><span class="line">thread-1 优先级为：5 ---&gt; 1</span><br><span class="line">thread-1 优先级为：5 ---&gt; 2</span><br><span class="line">thread-2 优先级为：5 ---&gt; 0</span><br><span class="line">thread-2 优先级为：5 ---&gt; 1</span><br><span class="line">thread-2 优先级为：5 ---&gt; 2</span><br><span class="line">thread-2 进入到就绪状态 ---&gt; 2 thread-2 </span><br><span class="line">thread-1 进入到就绪状态 ---&gt; 2 thread-1 </span><br><span class="line">thread-2 优先级为：5 ---&gt; 3</span><br><span class="line">thread-2 重新回到运行状态 ---&gt; 3  thread-2 </span><br><span class="line">thread-2 优先级为：5 ---&gt; 4</span><br><span class="line">thread-1 优先级为：5 ---&gt; 3</span><br><span class="line">thread-1 重新回到运行状态 ---&gt; 3  thread-1 </span><br><span class="line">thread-1 优先级为：5 ---&gt; 4</span><br></pre></td></tr></table></figure><p>以上日志打印情况只是众多情况中的一种，此时所说的众多情况是在 i = 2 之前，因为线程获得 CPU 时间分片是随机的，所以这是众线程的执行顺序可以说是零乱的，但是当一个线程中执行 yield(),那么该线程就处于就绪状态，需要等待其他线程执行完毕后才可以继续执行。</p><p>此例中，<br>当 thread-2 执行到 i = 2 时：<br>    thread-2 处于就绪状态，thread-1 进入运行状态<br>当 thread-1 执行到 i = 2 时：<br>    thread-1 处于就绪状态，thread-2 进入运行状态，此时 thread-2 的状态不会再改变，会一直执行，直到结束。<br>当 thread-2 执行完毕时：<br>    thread-1 继续执行，直到结束。</p><p>当一个线程中执行 yield)() 方法，同时存在处于 yield  就绪状态的线程和正常就绪状态的线程，那么正常状态的线程会得到优先执行权利，直到所有的线程均处于 yield 就绪状态，那么 yield 状态的线程会按照进入此状态的顺序恢复正常状态，好绕啊，具体验证可以查看 <a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/methods/Main.java" target="_blank" rel="noopener">GitHub 代码</a> 中 yieldTest 方法以及注释。</p><p>可以看到 join 方法和 yield 方法的作用完全相反：</p><ul><li>调用 join 方法的线程，将成功 <strong>抢夺</strong> 线程执行的权利</li><li>调用 yield 方法的线程，将 <strong>让出</strong> 自己线程执行的权利</li></ul><hr><p><strong>知识链接</strong></p><p><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="noopener">Android 开发进阶:从小工到专家</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-wait&quot;&gt;&lt;a href=&quot;#0x0001-wait&quot; class=&quot;headerlink&quot; title=&quot;0x0001 wait()&quot;&gt;&lt;/a&gt;0x0001 wait()&lt;/h3&gt;&lt;p&gt;首先，需要明确的是 wait() 方法为 Object 类中的方法，所以 Object 对象才可以执行 wait() 方法，但是该方法和线程的各个状态息息相关。&lt;/p&gt;
&lt;p&gt;当一个线程执行到 wait() 方法时，它就进入到一个 &lt;strong&gt;和该对象相关的等待池&lt;/strong&gt; 中，同时 &lt;strong&gt;该线程失去(释放)对象所持有的锁&lt;/strong&gt;，使得其他线程可以访问。用户可以使用 notify、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。&lt;/p&gt;
&lt;p&gt;需要注意的是：wait()、notify()、notifyAll() 必须放在 synchronized block 中，否则会抛出异常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Thread" scheme="/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>从缓存文件的角度帮你理解 Okhttp3 缓存原理</title>
    <link href="/2019/08/19/%E4%BB%8E%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%92%E5%BA%A6%E5%B8%AE%E4%BD%A0%E7%90%86%E8%A7%A3-Okhttp3-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
    <id>/2019/08/19/从缓存文件的角度帮你理解-Okhttp3-缓存原理/</id>
    <published>2019-08-19T08:07:38.000Z</published>
    <updated>2019-08-19T08:12:43.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文以一个不同的角度来解读 Okhttp3 实现缓存功能的思路，即：对于对于的缓存空间(文件夹)中的缓存文件的生成时机、不同时期下个文件的状态、不同时期下日志文件读写。通过这些方法来真正理解 Okhttp3 的缓存功能。如果你理解 DiskLrcCache 开源库的设计，那么对于 Okhttp3 的缓存实现你就已经掌握了，因为前者以后者为基础，你甚至没有看本文的必要。</p></blockquote><h1 id="1-需要了解的概念"><a href="#1-需要了解的概念" class="headerlink" title="1. 需要了解的概念"></a>1. 需要了解的概念</h1><p>缓存功能的实现，理所当然的涉及文件的读写操作、缓存机制方案的设计。Okhttp3 缓存功能的实现涉及到 Okio 和 DiskLruCache，在阐述具体缓存流程之前，我们需要了解两者的一些基本概念。</p><a id="more"></a><h2 id="1-2-Okio"><a href="#1-2-Okio" class="headerlink" title="1.2 Okio"></a>1.2 Okio</h2><p>Okio 中有两个关键的接口: <strong>Sink</strong> 和 <strong>Source</strong> ，对比 Java 中 I/O 流概念，我们可以把 Sink 看作 OutputStream , 把 Source 看作 InputStream 。</p><p>其具体实现非本文重点，有兴趣自己可以查看源码。</p><h2 id="1-1-DiskLruCache"><a href="#1-1-DiskLruCache" class="headerlink" title="1.1 DiskLruCache"></a>1.1 DiskLruCache</h2><p>Okhttp3 中 DiskLruCache 与JakeWharton 大神的 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a> 指导思想一致，但是具体细节不同，比如前者使用 Okio 进行 IO 操作，更加高效。</p><p>在 DiskLruCache 有几个重要概念，了解它们，才能对 DiskLruCache 的实现原理有基本的认识。</p><p>为了能够表达的更加直观，我们看一下一张图片进行缓存时缓存文件的具体内容：<br><img src="https://upload-images.jianshu.io/upload_images/1969719-74b5b0b5c7ff7db3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="在这里插入图片描述"></p><h3 id="1-2-1-日志文件-journal"><a href="#1-2-1-日志文件-journal" class="headerlink" title="1.2.1 日志文件 journal"></a>1.2.1 日志文件 journal</h3><p>该文件为 DiskLruCache 内部的日志文件，对 cache 的每一次操作都对应一条日志，并写入到 journal 文件中，同时也可以通过 journal 文件的分析创建 cache。</p><p>打开上图中 journal 文件，具体内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache</span><br><span class="line">1</span><br><span class="line">201105</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">DIRTY 0e39614b6f9e1f83c82cf663e453a9d7</span><br><span class="line">CLEAN 0e39614b6f9e1f83c82cf663e453a9d7 4687 14596</span><br></pre></td></tr></table></figure><p>在 DiskLruCache.java 类中，我们可以看到对 journal 文件内容的描述，在这里自己对其简单翻译，有兴趣的朋友可以看 JakeWharton 的描述: <a href="https://github.com/JakeWharton/DiskLruCache/blob/master/src/main/java/com/jakewharton/disklrucache/DiskLruCache.java" target="_blank" rel="noopener">DiskLruCache</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">文件的前五行构成头部，格式一般固定。</span><br><span class="line">第一行: 常量 -- libcore.io.DiskLruCache ；</span><br><span class="line">第二行: 硬盘缓存版本号 --  1</span><br><span class="line">第三行: 应用版本号 -- 201105</span><br><span class="line">第四行: 一个有意义的值 -- 2</span><br><span class="line">第五行: 空白行</span><br><span class="line"></span><br><span class="line">头部后的每一行都是 Cache 中 Entry 状态的一条记录。</span><br><span class="line">每条记录的信息包括: 状态值(DIRTY CLEAN READ REMOVE) 缓存信息entry的key值 状态相关的值(可选)。 </span><br><span class="line"></span><br><span class="line">下面对记录的状态进行说明：</span><br><span class="line">DIRTY: 该状态表明一个 entry 正在被创建或更新。每一个成功的 DIRTY 操作记录后应该 CLEAN 或 REMOVE 操作记录，否则被临时创建的文件会被删除。</span><br><span class="line">CLEAN: 该状态表明一个 entry 已经被成功的创建，并且可以被读取，后面记录了对应两个文件文件(具体哪两个文件后面会谈到)的字节数。</span><br><span class="line">READ: 该状态表明正在跟踪 LRU 的访问。</span><br><span class="line">REMOVE: 该状态表明entry被删除了。</span><br></pre></td></tr></table></figure><p>需要注意的是在这里 DIRTY 并不是 “脏”、“脏数据” 的意思，而是这个数据的状态不为最终态、稳定态，该文件现在正在被操作，<br>而 CLEAN 并不是数据被清除，而是表示该文件的操作已经完成。同时在后续的 dirtyFiles 和 cleanFiles 也表示此含义。 </p><p>关于日志文件在整个缓存系统中的作用，在后续过程中用到它的时候在具体阐述。</p><h3 id="1-2-2-DiskLruCache-Entry"><a href="#1-2-2-DiskLruCache-Entry" class="headerlink" title="1.2.2 DiskLruCache.Entry"></a>1.2.2 DiskLruCache.Entry</h3><p>每个 DiskLruCache.Entry 对象代表对每一个 URl 在缓存中的操作对象，该类成员变量的具体含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final class Entry &#123;</span><br><span class="line">        final String key; // Entry 的 key</span><br><span class="line">        final long[] lengths; // key.0 key.1 文件字节数的数组</span><br><span class="line">        final File[] cleanFiles; // 稳定的文件数组</span><br><span class="line">        final File[] dirtyFiles;// 正在执行操作的文件数组</span><br><span class="line">        boolean readable;// 如果该条目被提交了，为 true</span><br><span class="line">        Editor currentEditor;// 正在执行的编辑对象，在没有编辑时为 null</span><br><span class="line">        long sequenceNumber;// 编辑条目的最近提交的序列号</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体操作在缓存实现流程中阐述。</p><h3 id="1-2-3-DiskLruCache-SnapShot"><a href="#1-2-3-DiskLruCache-SnapShot" class="headerlink" title="1.2.3 DiskLruCache.SnapShot"></a>1.2.3 DiskLruCache.SnapShot</h3><p>此类为缓存的快照，为缓存空间中特定时刻的缓存的状态、内容，该类成员变量的具体含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Snapshot implements Closeable &#123;</span><br><span class="line">        private final String key;</span><br><span class="line">        private final long sequenceNumber; // 编辑条目的最近提交的序列号</span><br><span class="line">        private final Source[] sources;// 缓存中 key.0 key.1 文件的 Okio 输入流</span><br><span class="line">        private final long[] lengths;// 对应 Entry 中的 lengths，为文件字节大小</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-DiskLruCache-Editor"><a href="#1-2-3-DiskLruCache-Editor" class="headerlink" title="1.2.3 DiskLruCache.Editor"></a>1.2.3 DiskLruCache.Editor</h3><p>该类为 DiskLruCache 的编辑器，顾名思义该类是对 DiskLruCache 执行的一系列操作，如：abort() 、 commit() 等。</p><p><strong>Entry publish 的含义是什么？？？？？</strong></p><h1 id="2-缓存实现的有关流程"><a href="#2-缓存实现的有关流程" class="headerlink" title="2. 缓存实现的有关流程"></a>2. 缓存实现的有关流程</h1><p>简单介绍了几个概念，在这一节具体查看一下缓存实现的具体流程。在这之前我们需要明确一下几个前提：</p><ol><li>OkhttpClient 设置支持缓存。</li><li>网络请求头部中的字段设置为支持缓存(Http 协议首部字段值对缓存的实现有影响，具体看参见 <a href="https://item.jd.com/11449491.html" target="_blank" rel="noopener">图解 HTTP</a>、<a href="https://item.jd.com/11056556.html" target="_blank" rel="noopener">HTTP 权威指南</a>)。</li></ol><p><strong>由多个拦截器构成的拦截器链是 Okhttp3 网络请求的执行关键，可以说整个网络请求能够正确的执行是有整个链驱动的 (责任链模式)。仿照 RxJava 是事件驱动的，那么 Okhttp3 是拦截器驱动的。</strong></p><p>关于缓存功能实现的拦截器为 <strong>CacheInterceptor</strong>, CacheInterceptor 位于拦截器链中间位置，那么以执行下一个拦截器为界将缓存流程分为两部分：</p><ol><li>触发之后拦截器之前的操作</li><li>触发之后拦截器之后的操作</li></ol><p>即以 <code>networkResponse = chain.proceed(networkRequest);</code> 为分界</p><h3 id="1-触发之后拦截器之前的操作"><a href="#1-触发之后拦截器之前的操作" class="headerlink" title="1. 触发之后拦截器之前的操作"></a>1. 触发之后拦截器之前的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize()</span><br><span class="line">                : null;//本地缓存</span><br><span class="line"></span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        // 缓存策略</span><br><span class="line">        CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">        //策略中的请求</span><br><span class="line">        Request networkRequest = strategy.networkRequest;</span><br><span class="line">        ////策略中的响应</span><br><span class="line">        Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">        if (cache != null) &#123;</span><br><span class="line">            cache.trackResponse(strategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //缓存和网络皆为空，返回code 为504 的响应</span><br><span class="line">        // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">        if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            return new Response.Builder()</span><br><span class="line">                    .request(chain.request())</span><br><span class="line">                    .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                    .code(504)</span><br><span class="line">                    .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .sentRequestAtMillis(-1L)</span><br><span class="line">                    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we don&apos;t need the network, we&apos;re done.  缓存策略请求为null，则使用缓存</span><br><span class="line">        if (networkRequest == null) &#123;</span><br><span class="line">            return cacheResponse.newBuilder()</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-日志文件的初始化"><a href="#1-1-日志文件的初始化" class="headerlink" title="1.1 日志文件的初始化"></a>1.1 日志文件的初始化</h4><p>当执行如下代码时会按照调用链执行相关逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize()</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><p>首先检查在缓存中是否存在该 request 对应的缓存数据，如果有的话就返回 Response，如果没有就置 null。</p><p>调用链来到以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">Response get(Request request) &#123;</span><br><span class="line">    String key = key(request.url());</span><br><span class="line">    DiskLruCache.Snapshot snapshot;</span><br><span class="line">    Entry entry;</span><br><span class="line">    try &#123;</span><br><span class="line">        snapshot = cache.get(key);// 在这里会执行 </span><br><span class="line">        ...</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>snapshot = cache.get(key);</code> 处执行相应的初始化操作。</p><p>在此过程中执行一个特别重要的操作，需要对缓存中的 journal 系列日志文件(包括 journal journal.bak) 进行新建、重建、读取等操作，具体查看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// DiskLruCache#initialize()</span><br><span class="line">public synchronized void initialize() throws IOException &#123;</span><br><span class="line">        assert Thread.holdsLock(this);</span><br><span class="line"></span><br><span class="line">        if (initialized) &#123;// 代码 1 </span><br><span class="line">            return; // Already initialized.</span><br><span class="line">        &#125;</span><br><span class="line">        // If a bkp file exists, use it instead. journal文件备份是否存在</span><br><span class="line">        if (fileSystem.exists(journalFileBackup)) &#123;// 代码 2</span><br><span class="line">            // If journal file also exists just delete backup file.</span><br><span class="line">            if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">                fileSystem.delete(journalFileBackup);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileSystem.rename(journalFileBackup, journalFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Prefer to pick up where we left off.</span><br><span class="line">        if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                readJournal();// 代码 3</span><br><span class="line">                processJournal(); // 代码 4</span><br><span class="line">                initialized = true; // 代码 5</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (IOException journalIsCorrupt) &#123;</span><br><span class="line">                Platform.get().log(WARN, &quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot;</span><br><span class="line">                        + journalIsCorrupt.getMessage() + &quot;, removing&quot;, journalIsCorrupt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // The cache is corrupted, attempt to delete the contents of the directory. This can throw and</span><br><span class="line">            // we&apos;ll let that propagate out as it likely means there is a severe filesystem problem.</span><br><span class="line">            try &#123;</span><br><span class="line">                delete();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                closed = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rebuildJournal();// 代码 6</span><br><span class="line">        initialized = true;// 代码 7</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="1-App-启动后的初始化"><a href="#1-App-启动后的初始化" class="headerlink" title="1. App 启动后的初始化"></a>1. App 启动后的初始化</h5><p>在启动 App 是标志位 <code>initialized = false</code>，那么由 <code>代码 1</code> 可知此时需要执行初始化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (initialized) &#123;// 代码 1 </span><br><span class="line">    return; // Already initialized.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-1-若-journal-日志文件存在"><a href="#1-1-若-journal-日志文件存在" class="headerlink" title="1.1  若 journal 日志文件存在"></a>1.1  若 journal 日志文件存在</h6><p>如果存在 journal.bak 那么将该文件重命名为 journal。</p><p>接下来对 journal 日志文件所做的操作如 <code>代码 3、4 、5</code>  所示，具体作用做如下阐述。<code>代码 3</code> 要做的是读取日志文件 journal 并根据日志内容初始化 <code>LinkedHashMap&lt;String, Entry&gt; lruEntries</code> 中的元素，DiskLruCache 正是通过 LinkedHashMap 来实现 LRU 功能的。我们看一下 readJournal() 的具体代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void readJournal() throws IOException &#123;</span><br><span class="line">        BufferedSource source = Okio.buffer(fileSystem.source(journalFile));</span><br><span class="line">        try &#123;</span><br><span class="line">            String magic = source.readUtf8LineStrict();</span><br><span class="line">            String version = source.readUtf8LineStrict();</span><br><span class="line">            String appVersionString = source.readUtf8LineStrict();</span><br><span class="line">            String valueCountString = source.readUtf8LineStrict();</span><br><span class="line">            String blank = source.readUtf8LineStrict();</span><br><span class="line">            if (!MAGIC.equals(magic)</span><br><span class="line">                    || !VERSION_1.equals(version)</span><br><span class="line">                    || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">                    || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">                    || !&quot;&quot;.equals(blank)) &#123;</span><br><span class="line">                throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot;</span><br><span class="line">                        + valueCountString + &quot;, &quot; + blank + &quot;]&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int lineCount = 0;</span><br><span class="line">            while (true) &#123;// 不断执行如下操作，直到文件尾部，结束如下操作</span><br><span class="line">                try &#123;</span><br><span class="line">                    readJournalLine(source.readUtf8LineStrict());</span><br><span class="line">                    lineCount++;</span><br><span class="line">                &#125; catch (EOFException endOfJournal) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">            // If we ended on a truncated line, rebuild the journal before appending to it.</span><br><span class="line">            if (!source.exhausted()) &#123;</span><br><span class="line">                rebuildJournal();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                journalWriter = newJournalWriter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Util.closeQuietly(source);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在方法的开始读取 journal 日志文件的头部做基本的判断，如不满足要求则抛出异常。接下来在 该方法中通过方法 – <code>readJournalLine(source.readUtf8LineStrict());</code> 读取 journal 日志文件的每一行，根据日志文件的每一行生成 Entry 存入 lruEntries 中用来实现 LRU 功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void readJournalLine(String line) throws IOException &#123;</span><br><span class="line">      ...</span><br><span class="line">      ...</span><br><span class="line">      // 一顿操作得到 key 的值</span><br><span class="line">      </span><br><span class="line">      // 根据日志文件中 key 值获得或者生成 Entry，存入 lruEntries 中</span><br><span class="line">      Entry entry = lruEntries.get(key);</span><br><span class="line">      if (entry == null) &#123;</span><br><span class="line">          entry = new Entry(key);</span><br><span class="line">          lruEntries.put(key, entry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">          String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;);</span><br><span class="line">          entry.readable = true;</span><br><span class="line">          entry.currentEditor = null;</span><br><span class="line">          entry.setLengths(parts);</span><br><span class="line">      &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">          entry.currentEditor = new Editor(entry);</span><br><span class="line">      &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">          // This work was already done by calling lruEntries.get().</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          throw new IOException(&quot;unexpected journal line: &quot; + line);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>readJournal() 执行完毕后相当于对 lruEntries 进行初始化。lruEntries 元素的个数等于该 App 在此缓存文件夹下缓存文件的个数。在此过程中如果 lruEntries 中没有此行日志中的 key 对应的 Entry 对象，因为现在为进入 App 中的对缓存空间的初始化，所以都需要新建该类的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据日志文件中 key 值获得或者生成 Entry，存入 lruEntries 中</span><br><span class="line">   Entry entry = lruEntries.get(key);</span><br><span class="line">       if (entry == null) &#123;</span><br><span class="line">       entry = new Entry(key);</span><br><span class="line">       lruEntries.put(key, entry);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新建 Entry 对象的过程对于整个缓存体系的构建也十分重要，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Entry(String key) &#123;</span><br><span class="line">    this.key = key;</span><br><span class="line"></span><br><span class="line">    lengths = new long[valueCount];</span><br><span class="line">    cleanFiles = new File[valueCount];</span><br><span class="line">    dirtyFiles = new File[valueCount];</span><br><span class="line"></span><br><span class="line">    // The names are repetitive so re-use the same builder to avoid allocations.</span><br><span class="line">    //名称是重复的，所以要重复使用相同的构建器以避免分配</span><br><span class="line">    StringBuilder fileBuilder = new StringBuilder(key).append(&apos;.&apos;);</span><br><span class="line">    int truncateTo = fileBuilder.length();</span><br><span class="line">    for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">        fileBuilder.append(i);</span><br><span class="line">        cleanFiles[i] = new File(directory, fileBuilder.toString()); // key.0 key.1</span><br><span class="line">        fileBuilder.append(&quot;.tmp&quot;);</span><br><span class="line">        dirtyFiles[i] = new File(directory, fileBuilder.toString());// key.0.tmp key.1.tmp</span><br><span class="line">        fileBuilder.setLength(truncateTo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>新建对象过程中会根据 valueCount = 2; 的值定义缓存文件分别为 key.0、key.1、key.0.tmp、key.1.tmp ,其中 key.0 为稳定状态下的请求的 mate 数据，key.1 为稳定状态下的缓存数据，而 key.0.tmp、key.1.tmp 分别为 mate 数据和缓存数据的临时文件,此时并不会真正的新建文件。</p><p><strong>在这里需要明确的是 cleanFiles 和 dirtyFiles 都是 Entry 的成员变量，也就是说是通过 Entry 的对象对两者进行读取并进行相关操作的。</strong></p><p>processJournal() 方法实现了缓存文件夹下删除无用的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void processJournal() throws IOException &#123;</span><br><span class="line">    fileSystem.delete(journalFileTmp);</span><br><span class="line">    for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        Entry entry = i.next();</span><br><span class="line">        if (entry.currentEditor == null) &#123;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                size += entry.lengths[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            entry.currentEditor = null;</span><br><span class="line">            for (int t = 0; t &lt; valueCount; t++) &#123;</span><br><span class="line">                fileSystem.delete(entry.cleanFiles[t]);</span><br><span class="line">                fileSystem.delete(entry.dirtyFiles[t]);</span><br><span class="line">            &#125;</span><br><span class="line">            i.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>何为无用的文件 ？</strong></p><p>如果文件夹下存在 <code>entry.currentEditor != null;</code> 的文件，说明此文件为处在编辑状态下，但是此时的时机为刚打开 App 后的初始化状态，所有的文件均不应该处在编辑状态，所以此状态下的文件即为无用的文件，需要被删除。</p></blockquote><p>执行完毕后标志位 initialized 置位为 true 并中断执行 (return;) 返回操作去执行其他操作。</p><h6 id="1-2-若-journal-日志文件不存在"><a href="#1-2-若-journal-日志文件不存在" class="headerlink" title="1.2  若 journal 日志文件不存在"></a>1.2  若 journal 日志文件不存在</h6><p>若 journal 日志文件不存在，那么不会执行 代码 2、3、4、5 直接执行代码 6 –  rebuildJournal() ，具体执行操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">synchronized void rebuildJournal() throws IOException &#123;</span><br><span class="line">        if (journalWriter != null) &#123;</span><br><span class="line">            journalWriter.close();</span><br><span class="line">        &#125;</span><br><span class="line">        //产生 journal.tmp 文件</span><br><span class="line">        BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));</span><br><span class="line">        try &#123;// 写入 journal 文件内容</span><br><span class="line">            writer.writeUtf8(MAGIC).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeUtf8(VERSION_1).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeDecimalLong(appVersion).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeDecimalLong(valueCount).writeByte(&apos;\n&apos;);</span><br><span class="line">            writer.writeByte(&apos;\n&apos;);</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             *  将 lruEntries 的值重新写入 journal 文件</span><br><span class="line">             */</span><br><span class="line">            for (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">                if (entry.currentEditor != null) &#123; // 当前的 editor 不为 null 说明当前 journal 为非稳定态</span><br><span class="line">                    writer.writeUtf8(DIRTY).writeByte(&apos; &apos;);</span><br><span class="line">                    writer.writeUtf8(entry.key);</span><br><span class="line">                    writer.writeByte(&apos;\n&apos;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    writer.writeUtf8(CLEAN).writeByte(&apos; &apos;);</span><br><span class="line">                    writer.writeUtf8(entry.key);</span><br><span class="line">                    entry.writeLengths(writer);</span><br><span class="line">                    writer.writeByte(&apos;\n&apos;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">        // journal.tmp --&gt; journal</span><br><span class="line">        if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">            fileSystem.rename(journalFile, journalFileBackup);</span><br><span class="line">        &#125;</span><br><span class="line">        fileSystem.rename(journalFileTmp, journalFile);</span><br><span class="line">        fileSystem.delete(journalFileBackup);</span><br><span class="line"></span><br><span class="line">        journalWriter = newJournalWriter();</span><br><span class="line">        hasJournalErrors = false;</span><br><span class="line">        mostRecentRebuildFailed = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>十分重要的操作为 ： Okio.buffer(fileSystem.sink(journalFileTmp)); ,因为此时 journal 不存在，那么此行代码执行的操作正是新建journal 临时文件 –  journal.tmp ,写入文件头部文件后将 journal.tmp 重命名为 journal 。前文解析 journal 文件内容的含义，此处代码正好可以作为印证。</p><h4 id="1-2-初始化后"><a href="#1-2-初始化后" class="headerlink" title="1.2 初始化后"></a>1.2 初始化后</h4><p>经过初始化后最终获取 DiskLruCache 快照 DiskLruCache$Snapshot 对象，并进行相关包装返回 Response 对象为缓存中的Response 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   Response get(Request request) &#123;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">       try &#123;</span><br><span class="line">           snapshot = cache.get(key);// 在这里会执行 initialize(),进行一次初始化</span><br><span class="line">           if (snapshot == null) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">       Response response = entry.response(snapshot);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       return response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此,以上即为进入 CacheInterceptor 后的第一步操作，说实话工作量真是大，开启了 Debug 模式 n 遍才稍微把基本流程搞明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())// 执行 DiskLruCache#initialize() ，会对 journal 文件进行一些操作</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h4 id="1-3-缓存策略"><a href="#1-3-缓存策略" class="headerlink" title="1.3 缓存策略"></a>1.3 缓存策略</h4><p>缓存策略的获取主要涉及代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><p>具体执行代码位置：<br><code>CacheStrategy#getCandidate()</code>，由于具体业务逻辑比较容易理解，根据缓存响应、请求中头部关于缓存的字段进行相关判断，得出缓存策略，在这里不做过多阐释。</p><h3 id="2-触发之后拦截器之后的操作"><a href="#2-触发之后拦截器之后的操作" class="headerlink" title="2. 触发之后拦截器之后的操作"></a>2. 触发之后拦截器之后的操作</h3><p>触发之后的拦截器后，进行相关的一系列操作，根据责任链模式逻辑还是会最终回来，接着此拦截器的逻辑继续执行。此时整个请求的状态为已经成功得到网络响应，那么我们要做的就是对网络响应进行缓存，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);// 将 response 写入内存中，此时进行的步骤： 创建 0.tmp(已经写入数据) 和 1.tmp(尚未写入数据)</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">            // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟随 CacheRequest cacheRequest = cache.put(response); 执行如下逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CacheRequest put(Response response) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //由Response对象构建一个Entry对象,Entry是Cache的一个内部类</span><br><span class="line">        Entry entry = new Entry(response);</span><br><span class="line">        DiskLruCache.Editor editor = null;// disk 缓存的编辑</span><br><span class="line">        try &#123;</span><br><span class="line">            editor = cache.edit(key(response.request().url()));// key(response.request().url()) 根据 URL生成唯一 key</span><br><span class="line">            if (editor == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //把这个entry写入</span><br><span class="line">            //方法内部是通过Okio.buffer(editor.newSink(ENTRY_METADATA));获取到一个BufferedSink对象，随后将Entry中存储的Http报头数据写入到sink流中。</span><br><span class="line">            entry.writeTo(editor);// 触发生成 0.tmp</span><br><span class="line">            //构建一个CacheRequestImpl对象，构造器中通过editor.newSink(ENTRY_BODY)方法获得Sink对象</span><br><span class="line">            return new CacheRequestImpl(editor);// 触发生成 1.tmp</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            abortQuietly(editor);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Cache#writeTo()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 写入 0.tmp 数据 // 写入 的dirtyfile 文件的 buffersink 输出流</span><br><span class="line">public void writeTo(DiskLruCache.Editor editor) throws IOException &#123;</span><br><span class="line">    BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));//新建 key.0.tmp</span><br><span class="line">    // TODO: 在这里出现了 0.tmp</span><br><span class="line">    sink.writeUtf8(url)</span><br><span class="line">            .writeByte(&apos;\n&apos;);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常明显的操作在此处创建了 key.0.tmp 文件，并写入数据，此处写入的数据为 mate 数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CacheRequestImpl(final DiskLruCache.Editor editor) &#123;</span><br><span class="line">    this.editor = editor;</span><br><span class="line">    this.cacheOut = editor.newSink(ENTRY_BODY);// 在这里生成 1.tmp</span><br><span class="line">    this.body = new ForwardingSink(cacheOut) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void close() throws IOException &#123;</span><br><span class="line">            synchronized (Cache.this) &#123;</span><br><span class="line">                if (done) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                done = true;</span><br><span class="line">                writeSuccessCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            super.close();</span><br><span class="line">            editor.commit();//最终调用了此函数，0.tmp 1.tmp --》 key.0  key.1 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化 CacheRequestImpl 对象时创建了 key.1.tmp 文件。</p><p>执行如上操作后回到 CacheInterceptor 执行 cacheWritingResponse() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">private Response cacheWritingResponse(final CacheRequest cacheRequest, Response response)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">        // Some apps return a null body; for compatibility we treat that like a null cache request.</span><br><span class="line">        if (cacheRequest == null) return response;</span><br><span class="line">        Sink cacheBodyUnbuffered = cacheRequest.body();</span><br><span class="line">        if (cacheBodyUnbuffered == null) return response;</span><br><span class="line"></span><br><span class="line">        final BufferedSource source = response.body().source();</span><br><span class="line">        final BufferedSink cacheBody = Okio.buffer(cacheBodyUnbuffered);</span><br><span class="line"></span><br><span class="line">        Source cacheWritingSource = new Source() &#123;</span><br><span class="line">            boolean cacheRequestClosed;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long read(Buffer sink, long byteCount) throws IOException &#123;</span><br><span class="line">                long bytesRead;</span><br><span class="line">                try &#123;</span><br><span class="line">                    bytesRead = source.read(sink, byteCount);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheRequest.abort(); // Failed to write a complete cache response.</span><br><span class="line">                    &#125;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (bytesRead == -1) &#123;</span><br><span class="line">                    if (!cacheRequestClosed) &#123;</span><br><span class="line">                        cacheRequestClosed = true;</span><br><span class="line">                        cacheBody.close(); // The cache response is complete!</span><br><span class="line">                    &#125;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sink.copyTo(cacheBody.buffer(), sink.size() - bytesRead, bytesRead);</span><br><span class="line">                cacheBody.emitCompleteSegments();</span><br><span class="line">                return bytesRead;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Timeout timeout() &#123;</span><br><span class="line">                return source.timeout();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void close() throws IOException &#123;</span><br><span class="line">                if (!cacheRequestClosed</span><br><span class="line">                        &amp;&amp; !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) &#123;</span><br><span class="line">                    cacheRequestClosed = true;</span><br><span class="line">                    cacheRequest.abort();</span><br><span class="line">                &#125;</span><br><span class="line">                source.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        return response.newBuilder()</span><br><span class="line">                .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>执行一系列操作，使用 Okio 这个库不断的向 key.1.tmp 写入数据，具体操作过程实在是太过繁杂，而且牵涉到 Okio 库原理，自己在这么短时间无法理清具体流程。</p><p><strong>对于数据写入的切入点自己还没有很好的认识，在何处真正进行写文件操作自己只能够通过 Debug 知道其走向，但是对其原理还没有理解。</strong></p><p>最后会执行 CacheRequestImpl 对象的close 方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CacheRequestImpl(final DiskLruCache.Editor editor) &#123;</span><br><span class="line">            this.editor = editor;</span><br><span class="line">            this.cacheOut = editor.newSink(ENTRY_BODY);//在这里生成 1.tmp</span><br><span class="line">            this.body = new ForwardingSink(cacheOut) &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void close() throws IOException &#123;</span><br><span class="line">                    synchronized (Cache.this) &#123;</span><br><span class="line">                        if (done) &#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        done = true;</span><br><span class="line">                        writeSuccessCount++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    super.close();</span><br><span class="line">                    editor.commit();// 最终调用了此函数，0.tmp 1.tmp -&gt; key.0  key.1 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行 editor.commit(); 该方法会调用的 completeEdit()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123;</span><br><span class="line">        Entry entry = editor.entry;</span><br><span class="line">        if (entry.currentEditor != editor) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If this edit is creating the entry for the first time, every index must have a value.</span><br><span class="line">        if (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">            for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">                if (!editor.written[i]) &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                    throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!fileSystem.exists(entry.dirtyFiles[i])) &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // key.0.tmp key.1.tmp --&gt; key.0 key.1</span><br><span class="line">        for (int i = 0; i &lt; valueCount; i++) &#123;</span><br><span class="line">            File dirty = entry.dirtyFiles[i];</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                if (fileSystem.exists(dirty)) &#123;</span><br><span class="line">                    File clean = entry.cleanFiles[i];</span><br><span class="line">                    fileSystem.rename(dirty, clean);</span><br><span class="line">                    long oldLength = entry.lengths[i];</span><br><span class="line">                    long newLength = fileSystem.size(clean);</span><br><span class="line">                    entry.lengths[i] = newLength;</span><br><span class="line">                    size = size - oldLength + newLength;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                fileSystem.delete(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法中最终会将 key.0.tmp 、key.1.tmp 分别 重命名为 key.0 、key.1 ，这两个文件分别为两个文件的稳定状态，同时更新 journal 日志记录。</p><hr><p>至此 Okhttp3 实现缓存功能的大致流程基本结束，但是其中还是有很多的逻辑和细节是自己没有发现和不能理解的，其源码还是需要不断的去阅读去理解，需要对其中的实现、思想有进一步的体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文以一个不同的角度来解读 Okhttp3 实现缓存功能的思路，即：对于对于的缓存空间(文件夹)中的缓存文件的生成时机、不同时期下个文件的状态、不同时期下日志文件读写。通过这些方法来真正理解 Okhttp3 的缓存功能。如果你理解 DiskLrcCache 开源库的设计，那么对于 Okhttp3 的缓存实现你就已经掌握了，因为前者以后者为基础，你甚至没有看本文的必要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-需要了解的概念&quot;&gt;&lt;a href=&quot;#1-需要了解的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 需要了解的概念&quot;&gt;&lt;/a&gt;1. 需要了解的概念&lt;/h1&gt;&lt;p&gt;缓存功能的实现，理所当然的涉及文件的读写操作、缓存机制方案的设计。Okhttp3 缓存功能的实现涉及到 Okio 和 DiskLruCache，在阐述具体缓存流程之前，我们需要了解两者的一些基本概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Okhttp3" scheme="/tags/Okhttp3/"/>
    
      <category term="Okhttp3 缓存文件" scheme="/tags/Okhttp3-%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(四):静态同步synchronize方法与synchronize(class)代码块</title>
    <link href="/2019/08/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%9B%9B-%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5synchronize%E6%96%B9%E6%B3%95%E4%B8%8Esynchronize-class-%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>/2019/08/19/Java-多线程-四-静态同步synchronize方法与synchronize-class-代码块/</id>
    <published>2019-08-19T07:12:45.000Z</published>
    <updated>2019-08-19T07:31:30.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态同步-synchronize-方法"><a href="#静态同步-synchronize-方法" class="headerlink" title="静态同步 synchronize 方法"></a>静态同步 synchronize 方法</h3><p>关键字 synchronize 可以添加到静态方法上，这样的写法是对所属的 Class 进行加锁，从而可以实现同步效果。</p><p>虽然静态同步 synchronize 方法 和 非同步 synchronize 方法 的同步效果是一样的，但是其本质是不同的：</p><pre><code>静态同步 synchronize 方法为添加在 static 方法的上，是给 Class 类上锁。非静态同步 synchronize 方法是给对象加锁。</code></pre><p>Class 锁可以对类的所有对象实例起作用，多线程中其所有该类的实例对象调用 <strong>静态同步 synchronize 方法</strong> 都是同步的，但是与非静态同步 synchronize 方法间是异步的。</p><a id="more"></a><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/StaticSynchronziedMethodMain.kt" target="_blank" rel="noopener">StaticSynchronziedMethodMain</a> 的验证方法：</p><pre><code>one:验证同步方法与同步静态方法间的异步性two:同一个对象的同步静态方法的同步性three:多对象间的静态同步方法的同步性</code></pre><h3 id="synchronize-class-代码块"><a href="#synchronize-class-代码块" class="headerlink" title="synchronize(class)代码块"></a>synchronize(class)代码块</h3><p>synchronize(class)代码块与静态同步 synchronize 方法的作用是一样的。</p><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/StaticSynchronziedMethodMain.kt" target="_blank" rel="noopener">StaticSynchronziedMethodMain</a> 的验证方法：</p><pre><code>four:验证同一个对象 synchronize(class)代码块 间的同步性five:验证多个对象 synchronize(class)代码块 间的同步性</code></pre><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;静态同步-synchronize-方法&quot;&gt;&lt;a href=&quot;#静态同步-synchronize-方法&quot; class=&quot;headerlink&quot; title=&quot;静态同步 synchronize 方法&quot;&gt;&lt;/a&gt;静态同步 synchronize 方法&lt;/h3&gt;&lt;p&gt;关键字 synchronize 可以添加到静态方法上，这样的写法是对所属的 Class 进行加锁，从而可以实现同步效果。&lt;/p&gt;
&lt;p&gt;虽然静态同步 synchronize 方法 和 非同步 synchronize 方法 的同步效果是一样的，但是其本质是不同的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;静态同步 synchronize 方法为添加在 static 方法的上，是给 Class 类上锁。

非静态同步 synchronize 方法是给对象加锁。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Class 锁可以对类的所有对象实例起作用，多线程中其所有该类的实例对象调用 &lt;strong&gt;静态同步 synchronize 方法&lt;/strong&gt; 都是同步的，但是与非静态同步 synchronize 方法间是异步的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(三):同步代码块</title>
    <link href="/2019/08/19/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89):%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>/2019/08/19/Java 多线程(三):同步代码块/</id>
    <published>2019-08-19T07:12:40.000Z</published>
    <updated>2019-08-19T07:31:23.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synchronize-this-同步代码块"><a href="#synchronize-this-同步代码块" class="headerlink" title="synchronize(this) 同步代码块"></a>synchronize(this) 同步代码块</h3><p>synchronize 同步方法在某些情况下会有一些弊端：比如 A 线程调用同步方法执行一个长时间的任务，那么 B 线程必须等待比较长的时间才可以获得对象锁。在这种情况下可以使用 synchronize 同步代码块可以解决。</p><p><strong>synchronize 方法</strong>是对 <strong>当前对象</strong> 进行加锁，而 <strong>synchronize 代码块</strong> 是对 <strong>某一个对象</strong> 进行加锁。</p><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlock.kt" target="_blank" rel="noopener">SynchronizedMethodBlock</a> 中的方法 one、two、three 分别展示了非同步情况、同步方法、同步代码块，通过日志打印可知同步代码块可以有效的避免同步方法执行的低效率。</p><a id="more"></a><p>在执行同步代码块时需要注意将相应的代码放入代码块中，用来实现响应实例变量的同步性。</p><p>同样的，<strong>同步代码块 synchronize(this) 持有的是当前调用对象的锁</strong>，具体验证可以查看代码：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTest.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTest</a> 中可以验证该结论。</p><h3 id="synchronize-this-同步代码块间的同步性"><a href="#synchronize-this-同步代码块间的同步性" class="headerlink" title="synchronize(this) 同步代码块间的同步性"></a>synchronize(this) 同步代码块间的同步性</h3><p>在使用同步 <code>synchronize(this)</code> 同步代码块需要注意的是，当一个线程访问 object 的一个 <code>synchronize(this)</code> 同步代码块时，其他线程对 <strong>同一个 object</strong> 中的所有其他 <code>synchronize(this)</code> 同步代码块的访问将被阻塞，这说明 synchronize 使用的 “对象监视器“ 是一个。<br>代码验证：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTestTwo.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTestTwo</a>。</p><h3 id="synchronized-同步方法与synchronzied-this-同步代码块的同步性"><a href="#synchronized-同步方法与synchronzied-this-同步代码块的同步性" class="headerlink" title="synchronized 同步方法与synchronzied(this) 同步代码块的同步性"></a>synchronized 同步方法与synchronzied(this) 同步代码块的同步性</h3><p>多个线程调用同一个对象中的不同名称的 synchronized 同步方法或 synchronzied(this) 同步代码块时，为同步执行，阻塞执行的。</p><p>这说明 synchronized 同步方法或 synchronized(this) 同步代码块分别有两种作用：</p><p>synchronized 同步方法：</p><ol><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块调用呈阻塞状态。</li><li>同一时间只有一个线程可以执行 synchronize 同步方法中的代码。</li></ol><p>synchronized(this) 同步代码块：</p><ol><li>对其他 synchronized 同步方法或 synchronized(this) 同步代码块调用呈阻塞状态</li><li>同一时间只有一个线程可以执行 synchronized(this) 同步代码块中的代码。</li></ol><h3 id="将任意对象作为同步代码块的对象监视器"><a href="#将任意对象作为同步代码块的对象监视器" class="headerlink" title="将任意对象作为同步代码块的对象监视器"></a>将任意对象作为同步代码块的对象监视器</h3><p>Java 支持将任意对象作为 对象监视器，任意参数一般为实例变量或者是方法的参数，使用格式为：synchronzied(非 this 对象)。</p><p>synchronzied(非 this 对象) 同步代码块的作用为：</p><pre><code>在多个线程持有对象监视器为同一个对象的前提下，同一时间只有一个线程可以执行synchronzied(非 this 对象) 同步代码块中的代码。</code></pre><p>验证：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlockTestThree.kt" target="_blank" rel="noopener">SynchronizedMethodBlockTestThree</a> 中 two 方法展示synchronzied(非 this 对象) 的同步效果。</p><p>同样的，synchronzied(非 this 对象) 同步代码块也是对象锁，否则不能达到同步效果。</p><p>对于 synchronize(非this对象x)，有以下结论：</p><ul><li>当多个线程同时执行 synchronize(非this对象x){} 同步代码块时，呈同步效果。</li><li>当多个线程 x 对象中的 synchronize同步方法时，呈同步效果。</li><li>当多个线程 x 对象中的 synchronize(this)同步代码方法时，呈同步效果。</li></ul><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synchronize-this-同步代码块&quot;&gt;&lt;a href=&quot;#synchronize-this-同步代码块&quot; class=&quot;headerlink&quot; title=&quot;synchronize(this) 同步代码块&quot;&gt;&lt;/a&gt;synchronize(this) 同步代码块&lt;/h3&gt;&lt;p&gt;synchronize 同步方法在某些情况下会有一些弊端：比如 A 线程调用同步方法执行一个长时间的任务，那么 B 线程必须等待比较长的时间才可以获得对象锁。在这种情况下可以使用 synchronize 同步代码块可以解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronize 方法&lt;/strong&gt;是对 &lt;strong&gt;当前对象&lt;/strong&gt; 进行加锁，而 &lt;strong&gt;synchronize 代码块&lt;/strong&gt; 是对 &lt;strong&gt;某一个对象&lt;/strong&gt; 进行加锁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethodBlock.kt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SynchronizedMethodBlock&lt;/a&gt; 中的方法 one、two、three 分别展示了非同步情况、同步方法、同步代码块，通过日志打印可知同步代码块可以有效的避免同步方法执行的低效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(二):并发</title>
    <link href="/2019/08/19/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BA%8C-%E5%B9%B6%E5%8F%91/"/>
    <id>/2019/08/19/Java-多线程-二-并发/</id>
    <published>2019-08-19T07:12:35.000Z</published>
    <updated>2019-08-19T07:31:15.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="synchronized-同步方法"><a href="#synchronized-同步方法" class="headerlink" title="synchronized 同步方法"></a>synchronized 同步方法</h3><p>多个线程同时访问 <strong>同一个对象</strong> 的实例变量，则很有可能发生“非线程安全”问题。</p><p>在操作实例变量的方法前添加关键字 synchronize 关键字，则可以使原本“非线程安全” 变为 “线程安全”。</p><p>在 method 方法前添加 synchronize 关键字，使得多个线程在执行该方法时，以排队的方法进行处理。当一个线程执行 method 方法前，首先判断该方法有没有被上锁，如果上锁，说明有其他线程在调用 method 方法，必须等其他线程对 method 方法调用结束后才可以继续调用 method 方法。这样实现了排队调用 method 方法的目的，达到了顺序操作实例变量的目的。</p><a id="more"></a><p>synchronized 可以在任意对象及方法上加锁，而加锁的这段代码被称为“互斥区” 或 “临界区”。</p><p>当一个线程想要执行同步方法中的代码时，线程首先尝试去获得方法上的锁，如果能够拿到这把锁，那么这个线程就可以执行 synchronized 里面的代码。如果拿不到，那么这个线程就会不断的尝试去拿这把锁，直到拿到为止，而且有可能是多个线程同时去争抢这把锁。</p><h3 id="synchronized-同步方法中的锁属于谁？"><a href="#synchronized-同步方法中的锁属于谁？" class="headerlink" title="synchronized 同步方法中的锁属于谁？"></a>synchronized 同步方法中的锁属于谁？</h3><p>同步方法中关键字 synchronized 取得的锁都是 <strong>对象锁</strong>，哪一个线程先执行带有 synchronized 关键字的方法，哪一个线程就持有该方法 <strong>所属对象</strong> 的锁 Lock，那么其他对线程只能呈等待状态，前提是 <strong>多个线程访问的是同一个对象</strong>。</p><p>如果多个线程访问不同对象，那么 JVM 会创建多个锁。如果多个线程访问多个对象，那么执行结果显示为异步的。通过 <a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/thread/SynchronizedMethod.kt" target="_blank" rel="noopener">代码</a> 中的 one()、two() 的对比可得到此结论，结论：<strong>多个对象多个锁</strong>。</p><p>那么什么时候需要对方法进行同步操作呢？</p><blockquote><p>只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本不需要进行同步操作。</p></blockquote><p>既然同步方法的中的锁为对象锁，那么很自然的，<strong>当多个线程访问同一个对象中的多个同步方法时，同样呈现同步效果</strong>，那么当多个线程访问同一个对象中的 <strong>其他非同步方法</strong> 时，呈现异步效果。</p><h3 id="synchronized-锁重入"><a href="#synchronized-锁重入" class="headerlink" title="synchronized 锁重入"></a>synchronized 锁重入</h3><p>关键字 synchronize 用于锁重入的功能，也就是当一个线程得到一个对象锁之后，再次请求此对象锁时是可以再次得到该对象的锁的。</p><p>具体表现：synchronize 方法/块的内部调用 <strong>本类</strong> 的其他 synchronize 方法/块时，是永远可以获得锁的。</p><p><strong>自己可以再次获取自己的内部锁</strong>。</p><p>可重入锁也 <strong>支持在父子继承关系</strong> 的环境中。</p><h3 id="出现异常，锁自动释放"><a href="#出现异常，锁自动释放" class="headerlink" title="出现异常，锁自动释放"></a>出现异常，锁自动释放</h3><p>当一个线程执行代码时出现异常，其所持有的锁会自动释放。</p><h3 id="同步不支持继承性"><a href="#同步不支持继承性" class="headerlink" title="同步不支持继承性"></a>同步不支持继承性</h3><p>子类继承父类中的同步方法，则子类中的该方法不具有可同步性。</p><hr><p>需要明确的一点：<br>线程的同步性最终是体现在对象的同步方法上，即执行该方法的同步性，是线程中的一次执行动作的同步性，而不是线程的 run 方法上。比如这样一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class CustomThreadA extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private Task task;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">           task.doSomething(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomThreadB extends Thread&#123;</span><br><span class="line"></span><br><span class="line">    private Task task;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        for(int i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">           task.doSomething(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的两个线程执行 Task 中的方法，并不是当线程 CustomThreadB 抢到 doSomething 的锁就会将 run 方法中的动作执行完毕，而是线程 CustomThreadB 只拿到了一次执行 doSomething 的锁，执行结束后，会释放锁，下一次 CustomThreadB 、CustomThreadA 会同时争抢锁，从而执行自己 run 方法中的下一次循环。</p><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;synchronized-同步方法&quot;&gt;&lt;a href=&quot;#synchronized-同步方法&quot; class=&quot;headerlink&quot; title=&quot;synchronized 同步方法&quot;&gt;&lt;/a&gt;synchronized 同步方法&lt;/h3&gt;&lt;p&gt;多个线程同时访问 &lt;strong&gt;同一个对象&lt;/strong&gt; 的实例变量，则很有可能发生“非线程安全”问题。&lt;/p&gt;
&lt;p&gt;在操作实例变量的方法前添加关键字 synchronize 关键字，则可以使原本“非线程安全” 变为 “线程安全”。&lt;/p&gt;
&lt;p&gt;在 method 方法前添加 synchronize 关键字，使得多个线程在执行该方法时，以排队的方法进行处理。当一个线程执行 method 方法前，首先判断该方法有没有被上锁，如果上锁，说明有其他线程在调用 method 方法，必须等其他线程对 method 方法调用结束后才可以继续调用 method 方法。这样实现了排队调用 method 方法的目的，达到了顺序操作实例变量的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程(一):基本概念</title>
    <link href="/2019/08/19/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/08/19/Java 多线程一-基本概念/</id>
    <published>2019-08-19T07:12:30.000Z</published>
    <updated>2019-08-19T07:36:52.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程可以理解为在进程中独立运行的子任务，使用多线程后可以最大限度的利用 CPU 的空闲时间来处理其他任务。</p><p>多线程的执行是异步的。</p><h3 id="Thread-的常用-API"><a href="#Thread-的常用-API" class="headerlink" title="Thread 的常用 API"></a>Thread 的常用 API</h3><p>currentThread()(静态方法)</p><blockquote><p>currentThread() 方法返回的 <strong>代码段正在被哪个线程调用</strong>。</p></blockquote><p>getName()：获得线程的 Name</p><p>注意 <code>currentThread().getName()</code> 与 <code>getName()</code> 的不同。</p><a id="more"></a><p>isAlive()：判断当前线程是否处于活动状态。</p><p>sleep():在指定的毫秒内让当前“正在执行的线程” 休眠，这个 “正在执行的线程” 的是指 <code>currentThread()</code> 返回的线程。</p><h3 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h3><ul><li>继承 Thread</li><li>实现 Runnable</li></ul><p>继承 Thread 最大的局限就是不支持多继承，为了实现多继承可以通过实现 Runnable 的方式，但是两者本质上没有区别。</p><h3 id="线程调用"><a href="#线程调用" class="headerlink" title="线程调用"></a>线程调用</h3><p><strong>随机性</strong></p><p>使用多线程技术时，<strong>代码的运行的结果与代码的执行顺序或者调用顺序无关的</strong>，即 Thread 对象调用 start 的顺序并不代表 run 方法的执行顺序。线程是一个子任务， CPU 以不确定的方式，或者以随机的时间调用线程中的 run 方法。</p><p><strong>线程的调用</strong></p><p>Thread 类中的 start() 方法通知 “线程规划器” 此线程已经准备就绪，等待调用线程对象的 run 方法。</p><p>线程的执行其实是让系统安排一个时间来调用 run 方法，但是系统何时执行是随机的，也就印证了线程调用的随机性。</p><h3 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h3><p><strong>当多个线程可以同时访问一个变量时，容易发生数据线程安全问题。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private int count = 5;</span><br><span class="line">    public MyThread() &#123;</span><br><span class="line">        System.out.println(&quot;MyThread 当前的 Thread 的 name: &quot; + this.getName());</span><br><span class="line">        System.out.println(&quot;MyThread 代码执行的 Thread：&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        System.out.println(&quot;代码调用的 Thread&quot; + currentThread().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前的 Thread 的 Name  &quot; + this.getName());</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(&quot;Thread is：&quot; + currentThread().getName()+&quot;,计算结果是：&quot; + &quot;count is &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用过程如下(过滤无用信息)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> MyThread mMyThread = new MyThread();</span><br><span class="line">Thread a = new Thread(mMyThread, &quot;A&quot;);</span><br><span class="line">Thread b = new Thread(mMyThread, &quot;B&quot;);</span><br><span class="line">Thread c = new Thread(mMyThread, &quot;C&quot;);</span><br><span class="line">Thread d = new Thread(mMyThread, &quot;D&quot;);</span><br><span class="line">Thread e = new Thread(mMyThread, &quot;E&quot;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">d.start();</span><br><span class="line">e.start();</span><br></pre></td></tr></table></figure><p>打印日志的一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread is：A,计算结果是：count is 3</span><br><span class="line">Thread is：B,计算结果是：count is 3</span><br><span class="line">Thread is：C,计算结果是：count is 2</span><br><span class="line">Thread is：D,计算结果是：count is 1</span><br><span class="line">Thread is：E,计算结果是：count is 0</span><br></pre></td></tr></table></figure><p>很明显，线程 A 和 B 同时对 count 进行处理，获得了相同的打印 count，这是不想得到的结果，这就是所谓的 “非线程安全” 问题。</p><p>在本例中，产生线程不安全的原因为: <code>count--</code>:</p><p>在虚拟机中 count– 分为以下 3 步：</p><pre><code>1. 取得 count。2. 计算 count - 1。3. 对 count 赋值。</code></pre><p>以上 3 个步骤中，如果有多个线程同时访问，容易产生线程安全问题。</p><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>什么是非线程安全？</p><blockquote><p>非线程安全是指 <strong>多个线程</strong> 对 <strong>同一个对象</strong> 中的 <strong>同一个实例变量</strong> 进行操作时会出现值被更改、值不同步的情况，影响程序的正常执行。</p></blockquote><p>上面这种一个线程在操作中读取实例变量时，此值已经被其他线程更改过的情况被称为 <strong>脏读</strong>。</p><hr><p><strong>知识链接：</strong></p><p><a href="http://product.dangdang.com/23711315.html" target="_blank" rel="noopener">Java多线程编程核心技术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;p&gt;线程可以理解为在进程中独立运行的子任务，使用多线程后可以最大限度的利用 CPU 的空闲时间来处理其他任务。&lt;/p&gt;
&lt;p&gt;多线程的执行是异步的。&lt;/p&gt;
&lt;h3 id=&quot;Thread-的常用-API&quot;&gt;&lt;a href=&quot;#Thread-的常用-API&quot; class=&quot;headerlink&quot; title=&quot;Thread 的常用 API&quot;&gt;&lt;/a&gt;Thread 的常用 API&lt;/h3&gt;&lt;p&gt;currentThread()(静态方法)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;currentThread() 方法返回的 &lt;strong&gt;代码段正在被哪个线程调用&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;getName()：获得线程的 Name&lt;/p&gt;
&lt;p&gt;注意 &lt;code&gt;currentThread().getName()&lt;/code&gt; 与 &lt;code&gt;getName()&lt;/code&gt; 的不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java 多线程" scheme="/tags/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 对象拷贝</title>
    <link href="/2019/08/08/Java-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <id>/2019/08/08/Java-对象拷贝/</id>
    <published>2019-08-08T10:02:13.000Z</published>
    <updated>2019-08-08T10:03:56.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。</p><p>在对象属性复制过程中不同的是：</p><ul><li>如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；</li><li>如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。</li></ul><p>也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。</p><a id="more"></a><p><img src="/../images/2019_07_03_01.jpg" alt="图例"></p><h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><p>实现 Cloneable 接口：<a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/Student.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><p><a href></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student = new Student(1, &quot;杰克&quot;);</span><br><span class="line">        Student copyStudent = (Student) student.clone();</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        student.setName(&quot;再见杰克&quot;);</span><br><span class="line">        student.setAge(2);</span><br><span class="line">        student.getSubject().setName(&quot;Subject Rename Origin Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">        copyStudent.setAge(3);</span><br><span class="line">        copyStudent.setName(&quot;幻觉&quot;);</span><br><span class="line">        copyStudent.getSubject().setName(&quot;Subject Rename Copy Change&quot;);</span><br><span class="line">        printMessage(student, copyStudent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printMessage(Student originStudent, Student copiedStudent) &#123;</span><br><span class="line">        System.out.println(&quot;student Name is:&quot; + originStudent.getName() + &quot; ,age is &quot; + originStudent.getAge() + &quot; , subject Name is &quot; + originStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;copyStudent Name is:&quot; + copiedStudent.getName() + &quot; ,age is &quot; + copiedStudent.getAge() + &quot; , subject Name is &quot; + copiedStudent.getSubject().getName());</span><br><span class="line">        System.out.println(&quot;================&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">student Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Origin Change</span><br><span class="line">copyStudent Name is:杰克 ,age is 1 , subject Name is Subject Rename Origin Change</span><br><span class="line">================</span><br><span class="line">student Name is:再见杰克 ,age is 2 , subject Name is Subject Rename Copy Change</span><br><span class="line">copyStudent Name is:幻觉 ,age is 3 , subject Name is Subject Rename Copy Change</span><br><span class="line">================</span><br></pre></td></tr></table></figure><p>可以很明显的看出，如果对象的属性为对象引用时，原对象和拷贝对象指向的为同一块内存地址，当任何一个对象改变该属性时，另外一个对象的相应属性也会发生改变。</p><p><a href="https://github.com/leeGYPlus/JavaCode/tree/master/src/copy/Main.java" target="_blank" rel="noopener">GitHub 完整代码</a></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝会赋值所有的属性，属性为基本数据类型时，直接拷贝属性值；当属性为对象引用时会同时拷贝其所指向的内存。相较于浅拷贝，深拷贝拷贝速度更慢花销会更大。</p><p>深拷贝只是借助源对象在堆中产生一份源对象的复制，自此两者互不干涉。</p><p><img src="/../images/2019_07_03_04.jpg" alt="图例"></p><h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><p><a href="https://github.com/leeGYPlus/JavaCode/blob/master/src/copy/DeepMain.kt" target="_blank" rel="noopener">GitHub 完整代码</a></p><p>打印日志发现，对两个对象的任何操作都只对自己的对象有影响。</p><h3 id="通过序列化实现深拷贝"><a href="#通过序列化实现深拷贝" class="headerlink" title="通过序列化实现深拷贝"></a>通过序列化实现深拷贝</h3><p>序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。</p><p>需要类实现序列化相关接口。详细内容可参见序列化相关内容。</p><h3 id="如何选择拷贝类型"><a href="#如何选择拷贝类型" class="headerlink" title="如何选择拷贝类型"></a>如何选择拷贝类型</h3><p>如果对象的属性全是基本类型的，那么可以使用浅拷贝，但是如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。我的意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。</p><hr><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad" target="_blank" rel="noopener">Android Road</a></p><p><a href="https://www.androidos.net.cn/codebook/AndroidRoad/java/basis/copy.html" target="_blank" rel="noopener">Java 对象的浅拷贝和深拷贝</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;p&gt;浅拷贝是按位进行拷贝，它会创建一个对象，这个对象的属性为原对象一份复制。&lt;/p&gt;
&lt;p&gt;在对象属性复制过程中不同的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果属性是基本数据类型，那么拷贝的就是基本数据类型的值；&lt;/li&gt;
&lt;li&gt;如果属性为引用数据类型，那么拷贝的就是引用类型所指向的内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说原对象和拷贝对象的引用数据类型指向同一块内存地址，如果其中一个对象改变了这个内存地址，那么另外的一个对象也会改变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="对象拷贝" scheme="/tags/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>AIDL 浅析</title>
    <link href="/2019/08/07/AIDL-%E6%B5%85%E6%9E%90/"/>
    <id>/2019/08/07/AIDL-浅析/</id>
    <published>2019-08-07T10:01:49.000Z</published>
    <updated>2019-08-09T07:43:42.712Z</updated>
    
    <content type="html"><![CDATA[<p>AIDL 是理解 Android 系统不可避免的知识点。</p><h3 id="0x0001-自定义-AIDL"><a href="#0x0001-自定义-AIDL" class="headerlink" title="0x0001 自定义 AIDL"></a>0x0001 自定义 AIDL</h3><p>为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。</p><p>自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。</p><a id="more"></a><ol><li>建立 java 同级目录 aidl：</li></ol><img src="/../images/2019_08_06_01.png" width="50%" height="50%"><ol><li>自定义 Aidl 文件</li></ol><p>建立与 java 目录相同的包层级结构。</p><p>定义该该过程使用到的 Java 实体类，由于类对象会在 IPC 中使用，所以 <strong>类需要实现序列化</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Book implements Parcelable &#123;</span><br><span class="line">    private int bookId;</span><br><span class="line">    private String bookName;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Book.aidl(需要保证 Book.java 和 Book.aidl 在相同的包层级结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure><p>定义 IBookManager.aidl 文件，添加相关方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface IBookManager &#123;</span><br><span class="line">    List&lt;Book&gt; getBookList();</span><br><span class="line">    void addBook(in Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 aidl 的文件目录如下：</p><img src="/../images/2019_08_06_02.png" width="50%" height="50%"><ol start="3"><li>AS build 目录下生成对应的 Java 文件</li></ol><p>此处不会生成 Book.aidl 的 Java 文件，因为已经有 Book 类。</p><img src="/../images/2019_08_06_03.png" width="50%" height="50%"><p>将 build 文件中的 IBookManager.java 拷贝出来,新建 IBookManager2.java，源码如下:<a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/server/IBookManager2.java" target="_blank" rel="noopener">IBookManager.java</a></p><p>IBookManager 的内部层级结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IBookManager extends android.os.IInterface &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    public static abstract class Stub extends android.os.Binder implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        private static class Proxy implements com.mk.aidldemo.IBookManager &#123;</span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IBookManager 的成员方法如下：</p><img src="/../images/2019_08_08_01.png" width="50%" height="50%"><h3 id="0X0002-流程分析"><a href="#0X0002-流程分析" class="headerlink" title="0X0002 流程分析"></a>0X0002 流程分析</h3><p>为什么不生成 3 个文件(一个接口、两个类)，而是放在了一个文件中，这是因为当多个 AIDL 类时， Stub 和  Proxy 就会重名或者多个类会显得比较繁杂，而把它们放在各自的 AIDL 类中，就会比较容易区分。</p><p>下面分析如何进行跨进程通信。</p><p>起决定性作用的是 Stub 的 asInterface 方法和 onTranscact 方法，首先通过一个示意图大致了解其过程。</p><img src="/../images/2019_08_08_02.png" width="80%" height="80%"><ol><li>对于 Client 端，作为 AIDL 的使用端，调用相关方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IBookManager.asInterface(IBinder 对象).addBook(Book(countId, &quot;Book $countId&quot;))</span><br></pre></td></tr></table></figure><blockquote><p>这个 Binder 对象就是在 bindService 时 Service 中的 onBinder 方法返回的 IBinder 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  override fun onBind(intent: Intent?): IBinder? &#123;</span><br><span class="line">&gt;      return mBinder</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>该方法用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.Proxy 。</p><p>asInterface 方法主要是判断参数，也就是 IBinder 对象，<strong>是和与自己同处一个进程</strong>：</p><ul><li>是，则直接转换、直接使用，则接下来的操作与 Binder 跨进程无关。</li><li>否，则会把这个 IBinder 对象包装成一个 Proxy 对象，这时调用的 Stub 的方法，间接调用 Proxy 的相应方法。</li></ul><p>此处为两者位于不同进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static IBookManager2 asInterface(android.os.IBinder obj) &#123;</span><br><span class="line">    if ((obj == null)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    if (((iin != null) &amp;&amp; (iin instanceof IBookManager2))) &#123;</span><br><span class="line">        return ((IBookManager2) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Proxy 中调用相关的方法，会使用 Pracelable 数据来准备数据，把函数名、函数的参数都写入 _data,使用 _reply 来接收函数的返回值，使用 Binder 的 transact 方法，把数据传给 Binder 的 Server 端。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void addBook(com.mk.aidldemo.Book book) throws android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    try &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        if ((book != null)) &#123;</span><br><span class="line">            _data.writeInt(1);</span><br><span class="line">            book.writeToParcel(_data, 0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _data.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(&quot;process proxy add&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">        // mRemote 对象为构建 Proxy 对象时传入</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);</span><br><span class="line">        _reply.readException();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Server 端通过 onTransact 方法来接收 Client 传过来的数据(包括函数名称、函数的参数、函数的标识)，找到指定的函数，就相应的数据传入，得到结果并将结果写回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* 运行在 Binder 线程池</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteExcepti</span><br><span class="line">    String descriptor = DESCRIPTOR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(descriptor);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_getBookList: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            // 此处的 getBookList 为 Server 端中 Binder 对象中的 getBookList</span><br><span class="line">            java.util.List&lt;com.mk.aidldemo.Book&gt; _result = this.getBookList();</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            Log.e(&quot;process onTransact list&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">            reply.writeTypedList(_result);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_addBook: &#123;</span><br><span class="line">            data.enforceInterface(descriptor);</span><br><span class="line">            com.mk.aidldemo.Book _arg0;</span><br><span class="line">            if ((0 != data.readInt())) &#123;</span><br><span class="line">                _arg0 = com.mk.aidldemo.Book.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                _arg0 = null;</span><br><span class="line">            &#125;</span><br><span class="line">            // Service 中 onBinder 方法中返回的 Binder 对象值。</span><br><span class="line">            this.addBook(_arg0);</span><br><span class="line">            Log.e(&quot;process onTransact add&quot;, ProcessUtils.getCurrentProcessName());</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        default: &#123;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0003-具体分析"><a href="#0x0003-具体分析" class="headerlink" title="0x0003 具体分析"></a>0x0003 具体分析</h3><p>针对 Binder 跨进程通信机制，在每次通信过程中都需要有 Binder Client 端和 Binder Server 端。</p><p>在上面例子中应用程序进程(<code>com.mk.aidldemo</code>)为 Binder Client 端，用来发起请求，而新进程(<code>com.mk.aidldemo:remote</code>)为 Binder Server 端，用以处理请求。</p><p>在上文的流程图中，可以看到  Stub 为相应的 Binder Server 端，即为 Service 所在的进程中，我们通过加入 Log 日志，查看相应的操作执行哪个进程。</p><p>具体 Log 打点查看源码: <a href="https://github.com/leeGYPlus/AidlDemo/blob/master/app/src/main/java/com/mk/aidldemo/MainActivity.kt" target="_blank" rel="noopener">GitHub 源码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E/process binderService: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line">E/process add: com.mk.aidldemo</span><br><span class="line">E/process proxy add: com.mk.aidldemo</span><br><span class="line"></span><br><span class="line">E/process service addBook: com.mk.aidldemo:remote</span><br><span class="line">E/process onTransact add: com.mk.aidldemo:remote</span><br></pre></td></tr></table></figure><p>可以看到在进程 <code>com.mk.aidldemo:remote</code> 中执行的操作有：onTransact 和 Server 中实例化 Binder 中的方法，即为 Binder Server 端，其他均处于 Binder Client 端。</p><p>这其中的关键方法有 mRemote.transact  和 onTransact。</p><p><strong>onTransact</strong></p><p>这个方法运行在 <strong>服务端中的 Binder线程池</strong> 中，当客户端发起跨进程请求时，远程请求会通过 <code>系统底层封装</code> 后交由此方法来处理。该方法的原型为<code>publicBooleanonTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code>。服务端通过 code 可以确定客户端所请求的目标方法是什么，接着从 data 中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就向 reply 中写入返回值（如果目标方法有返回值的话）。</p><p>onTransact 方法的执行过程就是这样的。需要注意的是，如果此方法返回 false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p><p><strong>transact</strong></p><p><code>Proxy#getBookList、Proxy#addBook</code> 这个方法运行在 <strong>客户端</strong>，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入型 Parcel 对象_data、输出型Parcel对象 _reply 和返回值对象 List；然后把该方法的参数信息写入 _data 中（如果有参数的话）；<strong>接着调用 transact 方法来发起 RPC（远程过程调用）请求，同时当前线程挂起</strong>； 然后 <strong>服务端的onTransact 方法会被调用</strong>，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据。</p><p>这两个方法都为 Binder 的方法，至于底层是如何实现 RPC 实现了，需学习相关细节，期待学习，关于其基本原理可以查看：<a href="https://leegyplus.github.io/2019/06/05/Binder%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#more" target="_blank" rel="noopener">Binder 基本原理</a>。</p><hr><p>知识链接：</p><p><a href="http://product.dangdang.com/25325752.html" target="_blank" rel="noopener">Android 插件化开发指南</a></p><p><a href="http://product.dangdang.com/23766472.html" target="_blank" rel="noopener">Android 开发艺术探索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AIDL 是理解 Android 系统不可避免的知识点。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-自定义-AIDL&quot;&gt;&lt;a href=&quot;#0x0001-自定义-AIDL&quot; class=&quot;headerlink&quot; title=&quot;0x0001 自定义 AIDL&quot;&gt;&lt;/a&gt;0x0001 自定义 AIDL&lt;/h3&gt;&lt;p&gt;为了更加直观的展示相关内容，我们通过具体示例来展示相关的细节。&lt;/p&gt;
&lt;p&gt;自定义一个 aidl 文件，里面定义方法(如：MyAidl.aidl)，AS 会帮我们生产对于的类文件(MyAidl.java)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIDL" scheme="/tags/AIDL/"/>
    
      <category term="Android" scheme="/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浮点型数据的精度问题</title>
    <link href="/2019/08/01/%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>/2019/08/01/浮点型数据的精度问题/</id>
    <published>2019-08-01T10:05:17.000Z</published>
    <updated>2019-08-01T10:21:52.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何表示定点数"><a href="#如何表示定点数" class="headerlink" title="如何表示定点数"></a>如何表示定点数</h3><p>使用二进制来表示十进制的编码称为 <strong>BCD 编码</strong>。这种编码方式把小数点固定在某一位，所以其表示的数称为 <strong>定点数</strong>。</p><p>那么 4 个比特最大的表示是十进制数为 9 (1001)。</p><p>32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。</p><a id="more"></a><p>缺点：</p><ul><li>极大的浪费。本来 4 bit 可以表示 0-15，现在只可以表示 0-9。</li><li>无法表示很大和很小的数。</li></ul><h3 id="如何表示浮点数"><a href="#如何表示浮点数" class="headerlink" title="如何表示浮点数"></a>如何表示浮点数</h3><ul><li>32 bit 表示单精度的浮点数，float 或 float32。</li><li>64 bit 表示双精度的浮点数，double 或 float64。</li></ul><p>以单精度为准看如何表示浮点数</p><table><thead><tr><th>s:符号位</th><th>e:指数位</th><th>f:有效数位</th></tr></thead><tbody><tr><td>1 bit</td><td>8 bit</td><td>23 bit</td></tr></tbody></table><p>e:8 bit 组成的指数位，表示整数范围 0<del>254,其中 1</del>254 映射到带符号的整数 -126~127，这样浮点数不仅可以表示很大的数，也可以表示很小的数。</p><p>最终浮点数表示为：<br>(-1)^s×1.f×2^e (e = 指数位对应的整数 -127)</p><p>关于 e 为什么要这样计算查看 <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示–阮一峰</a> 中关于 IEEE-754 的相关内容。</p><p>以 0.5 为准：</p><p>0.5=(−1)^0×1.0×2^−1=0.5</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><h3 id="浮点数的二进制表示"><a href="#浮点数的二进制表示" class="headerlink" title="浮点数的二进制表示"></a>浮点数的二进制表示</h3><p>十进制浮点数二进制表示：9.1</p><p>9：1001</p><p>小数部分转换成二进制使用乘法操作，就是乘以 2，然后看看是否超过 1。如果超过 1，我们就记下 1，并把结果减去 1，进一步循环操作。</p><p><img src="https://static001.geekbang.org/resource/image/f9/ae/f9213c43f5fa658a2192a68cd26435ae.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.1：000110011...(0011 无限循环)</span><br><span class="line"></span><br><span class="line">9.1:1001.000110011，使用科学计数法，将小数点向左移三位，表示如下：</span><br><span class="line"></span><br><span class="line">1.001000110011..x2^3</span><br></pre></td></tr></table></figure><p>匹配浮点数表示的公式：(-1)^s×1.f×2^e </p><p>s=0、f=001000110011( 0011 循环至23位)、e=3 (根据指数位计算方式 指数位对于的十进制整数为 +3+127 = 130，对应二进制为 01111110)，所以 9.1 在 32bit 下的二进制表示为：</p><p><img src="https://static001.geekbang.org/resource/image/9a/27/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg" alt></p><p>在一位的小数中，只有 0.5 可以精确表示：</p><p><img src="https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg" alt></p><p>其他均为近似表示，这就是为什么浮点数计算出现精度问题的原因。</p><h3 id="浮点数的加法与精度丢失"><a href="#浮点数的加法与精度丢失" class="headerlink" title="浮点数的加法与精度丢失"></a>浮点数的加法与精度丢失</h3><p>浮点数的加法规则：<strong>先对齐，再计算</strong>。</p><p>其中对齐是将两个浮点数的指数位对齐，即通过位移使指数位相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.5 + 0.125：</span><br><span class="line"></span><br><span class="line">0.5：1.0x2^(-1)</span><br><span class="line">0.125: 1.0x2^(-3)=0.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.0x2^(-1) + 0.01x2^(-1) = 1.01x2^(-1)</span><br><span class="line"></span><br><span class="line">1.01x2^(-1) 的十进制表示为 0.625</span><br></pre></td></tr></table></figure><p>在加法前，浮点型数据的二进制表示就可能会发生精度丢失，如果相加的两个数相差比较大，那么在指数对齐过程中，有可能会丢失有效位，位移就会越大，那么丢失的精度就越大，那么产生的误差也会越大。但是如果丢失的全为 0 ，那么加法的数值不会有精度丢失。</p><h3 id="如何避免精度损失"><a href="#如何避免精度损失" class="headerlink" title="如何避免精度损失"></a>如何避免精度损失</h3><p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm" target="_blank" rel="noopener"><strong>Kahan Summation 算法</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class KahanSummation &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    float sum = 0.0f;</span><br><span class="line">    float c = 0.0f;</span><br><span class="line">    for (int i = 0; i &lt; 20000000; i++) &#123;</span><br><span class="line">    float x = 1.0f;</span><br><span class="line">    float y = x - c;</span><br><span class="line">    float t = sum + y;</span><br><span class="line">    c = (t-sum)-y;</span><br><span class="line">    sum = t;    </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;sum is &quot; + sum);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 BigDecimal</strong></p><p>BigDecimal 是专门为弥补浮点数无法精确计算的缺憾而设计的，它本身提供了加减乘除。</p><p><strong>使用整型</strong></p><p>如果保留小数点后 2 位，那么将参与运算的值扩大 100 倍 并转换为整型，在展示时再缩小 100 倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何表示定点数&quot;&gt;&lt;a href=&quot;#如何表示定点数&quot; class=&quot;headerlink&quot; title=&quot;如何表示定点数&quot;&gt;&lt;/a&gt;如何表示定点数&lt;/h3&gt;&lt;p&gt;使用二进制来表示十进制的编码称为 &lt;strong&gt;BCD 编码&lt;/strong&gt;。
这种编码方式把小数点固定在某一位，所以其表示的数称为 &lt;strong&gt;定点数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么 4 个比特最大的表示是十进制数为 9 (1001)。&lt;/p&gt;
&lt;p&gt;32 bit 使用右侧的 2 个 0-9 的整数(8 bit)，当成小数部分，左侧的6 个 0-9 表示整数部分(24 bit)，那么 32 bit 可以表示 0到 999999.99 这样的数组范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="极客时间笔记" scheme="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浮点型精度问题" scheme="/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hprof 拾遗</title>
    <link href="/2019/07/09/Hprof-%E6%8B%BE%E9%81%97/"/>
    <id>/2019/07/09/Hprof-拾遗/</id>
    <published>2019-07-09T09:43:11.000Z</published>
    <updated>2019-07-09T09:45:56.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0001-引用一"><a href="#0x0001-引用一" class="headerlink" title="0x0001 引用一"></a>0x0001 引用一</h3><p>以下内容来自：<a href="https://www.baeldung.com/java-heap-dump-capture" target="_blank" rel="noopener">Different Ways to Capture Java Heap Dumps</a></p><p>A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. <strong>Heap dumps are usually stored in binary format hprof files.</strong> </p><a id="more"></a><h3 id="0x0002-引用二"><a href="#0x0002-引用二" class="headerlink" title="0x0002 引用二"></a>0x0002 引用二</h3><p>以下内容来自：<a href="https://www.ibm.com/support/knowledgecenter/en/SS3KLZ/com.ibm.java.diagnostics.memory.analyzer.doc/heapdump.html" target="_blank" rel="noopener">Understanding heap dumps</a></p><p><strong>A heap dump is a snapshot of the memory of a Java™ process</strong>.</p><p>The snapshot contains information about the Java objects and classes in the heap at the moment the snapshot is triggered. Because there are different formats for persisting this data, there might be some differences in the information provided. Typically, a full garbage collection is triggered before the heap dump is written, so the dump contains information about <strong>the remaining objects in the heap</strong>.</p><p>The Memory Analyzer works with HPROF binary heap dumps, IBM® system dumps, and IBM portable heap dumps (PHD) from various platforms. See Supported dump file types.</p><p>Typical information in a heap dump, depending on the heap dump type, includes(堆转储文件中包含的信息):</p><p><strong>All Objects</strong></p><pre><code>Class, fields, primitive values, and references.</code></pre><p><strong>All Classes</strong></p><pre><code>Class loader, name, super class, and static fields.</code></pre><p><strong>Garbage collection roots</strong></p><pre><code>Objects defined to be reachable by the JVM.</code></pre><p><strong>Thread Stacks and Local Variables</strong></p><pre><code>Call-stacks of threads at the moment of the snapshot, and information about local objects on a frame by frame basis.</code></pre><h3 id="0x0003-Android-中的-Hprof"><a href="#0x0003-Android-中的-Hprof" class="headerlink" title="0x0003 Android 中的 Hprof"></a>0x0003 Android 中的 Hprof</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.dumpHprofData(String filePath);</span><br></pre></td></tr></table></figure><p>在 Android 中使用以上代码将对转储文件生成到指定的文件上。</p><p>在 AS 中如何分析 Hprof 见官方文档：<a href="https://developer.android.com/studio/profile/memory-profiler" target="_blank" rel="noopener">使用 Memory Profiler 查看 Java 堆和内存分配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0001-引用一&quot;&gt;&lt;a href=&quot;#0x0001-引用一&quot; class=&quot;headerlink&quot; title=&quot;0x0001 引用一&quot;&gt;&lt;/a&gt;0x0001 引用一&lt;/h3&gt;&lt;p&gt;以下内容来自：&lt;a href=&quot;https://www.baeldung.com/java-heap-dump-capture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Different Ways to Capture Java Heap Dumps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A heap dump is a snapshot of all the objects that are in memory in the JVM at a certain moment. They are very useful to troubleshoot memory-leak problems and optimize memory usage in Java applications. &lt;strong&gt;Heap dumps are usually stored in binary format hprof files.&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Hprof" scheme="/tags/Hprof/"/>
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 LeakCanary(1.6.3之前版本) 寻找内存泄漏位置</title>
    <link href="/2019/07/04/LeakCanary-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>/2019/07/04/LeakCanary-是如何工作的/</id>
    <published>2019-07-04T07:40:01.000Z</published>
    <updated>2019-07-10T03:16:54.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何使用-Leakmemory-泄漏链路-Trace-图"><a href="#如何使用-Leakmemory-泄漏链路-Trace-图" class="headerlink" title="如何使用 Leakmemory 泄漏链路(Trace 图)"></a>如何使用 Leakmemory 泄漏链路(Trace 图)</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.</p></blockquote><a id="more"></a><blockquote><p>[个人译] 如果你知道在 Trace 图中出现的对象是否应该存在于内存中，这会帮助你很好的分析内存泄漏位置。如果对象不应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象上面的位置；如果对象应该存在于内存中，那么内存泄漏的位置应该在Trace 中该对象下面的位置。</p></blockquote><blockquote><p>[12:37] Method:<br>Find an object and ask should this object should be alive or should be in garbage collection?</p></blockquote><h3 id="如何使用-package-leakmomory-进程进行问题定位"><a href="#如何使用-package-leakmomory-进程进行问题定位" class="headerlink" title="如何使用 package:leakmomory 进程进行问题定位"></a>如何使用 package:leakmomory 进程进行问题定位</h3><p>以下英文部分摘自 <a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><blockquote><p>[15：00] Should this object should be alive at this point in time? how we know that?</p></blockquote><p>不只是根据 leakcanary 在手机上的 Trace 图，leakcanary 可以在 package:leakmomory 进程显示详细的 Trace 日志。其实现在手机上的 Trace 图也可以显示出关键的 Trace 日志，只是手机品牌不同显示的详细程度不同，如果手机上信息语言简略，推荐查看 AS 中 package:leakmomory 中的相关日志。</p><!-- ![展示](/../images/2019_07_03_05.jpg) --><p><strong>package:leakmomory 中关于对象的详细信息</strong>：</p><img src="/../images/2019_07_03_05.jpg" height="70%" width="70%"><p>图中包名显示为 package:leakmomory 线程，以下为 Trace 的详细信息。</p><blockquote><p>[16：00] We will dump the states of every singleInstance and that’s where you can find the problem.</p></blockquote><p>可以在这里可以根据实例对象或其属性值判断每个实例是否应该被回收，当然这需要相应有关该类的一些知识。如果该实例对象应该被回收，那么说明内存泄漏的对象在上面。</p><p>在上面的视频中的一个例子：</p><pre><code>根据 LeakCanary 的内存泄漏 Trace 图，发现存在 ChangeHandlerFramLayout 对象存在泄漏链路中，在 leakmomory 进程中可以详细获知该对象的各个属性值，从而可以判断该对象的状态。在此处中 ChangeHandlerFramLayout 对象的 mAttachInfo = null，说明该对象不再与屏幕关联，该对象在此时应该被 GC 回收掉，不应该存活，说明内存泄漏是 Trace 图上面的对象引起的，进一步定位内存泄漏位置。</code></pre><!-- ![Trace 图](/../images/2019_07_05_01.jpg) --><p><strong>Trace</strong> 图：</p><img src="/../images/2019_07_05_01.jpg" height="50%" width="50%"><!-- ![ChangeHandlerFramLayout 对象](/../images/2019_07_05_02.png) --><p><strong>ChangeHandlerFramLayout</strong> 对象：</p><img src="/../images/2019_07_05_02.png" height="70%" width="70%"><!-- ![ChangeHandlerFramLayout 对象的 mAttachInfo 值](/../images/2019_07_05_03.png) --><p><strong>ChangeHandlerFramLayout 对象的 mAttachInfo 值</strong>：</p><img src="/../images/2019_07_05_03.png" height="70%" width="70%"><p>接下来分析了位于 ChangeHandlerFramLayout 上的 MainActivity 实例对象，同理，在 leakmomory 查看该实例的状态，与ChangeHandlerFramLayout 对象不同的是此时我们关注属性值为 mDestoryed = true，说明 MainActivity 对象已经销毁，说明该对象也应该被 GC 回收。</p><p>如此往复，结合 trace 图和 leakmomory 进程信息，判断对象是否应该存在，<strong>不过根据对象的不同，判断该对象是否应该存活标准不同</strong>，如例子中的 mAttachInfo、mDestoryed。</p><h3 id="LeakCanary-实践一"><a href="#LeakCanary-实践一" class="headerlink" title="LeakCanary 实践一"></a>LeakCanary 实践一</h3><p>使用官方 <a href="https://github.com/square/leakcanary/tree/v1.6.3" target="_blank" rel="noopener">LeakCanary 1.6.3 </a> 库的 demo 进行展示如何定位内存泄漏。此处演示的为 LeakCanary 1.6.3 ，master 分支已于 2019-05-21 变更为 由 1.x 变更为 2.x ，具体查看 <a href="https://github.com/square/leakcanary/blob/4bbc0f6f2e3c9a25ca890ece6770f81cf9059510/docs/changelog.md" target="_blank" rel="noopener">Chnage Log</a>。</p><p>LeakCanary 2.x 功能更加全面，定位难度更加简单，但是方法基本一致，这里以 1.6.3 版本为主展示如何寻找内存泄漏位置。</p><!-- ![Trace 图](/../images/2019_07_05_04.png) --><p><strong>Demo 的 Trace 图为</strong>：</p><img src="/../images/2019_07_05_04.png" height="50%" width="50%"><!-- ![MainActivity 相关信息](/../images/2019_07_05_05.png) --><p>点击 MainActivity 所在行，显示详细信息。<br><strong>详细信息</strong>：</p><img src="/../images/2019_07_05_05.png" height="50%" width="50%"><p>可以发现 MainActivity 的 mDestoryed = true,说明 MainActivity 应该被 GC 回收，那么内存泄漏的应该发生在 <strong>之上</strong>。</p><!-- ![MainActivity$2.this.0 相关信息](/../images/2019_07_05_06.png) --><p>点击 <code>MainActivity$2.this$0</code> 显示具体信息:</p><img src="/../images/2019_07_05_06.png" height="70%" width="70%"><p>从图中得知 <code>MainActivity$2.this$0</code> 为 <strong>anonymous implent Runnable(继承 Runnble 的匿名对象)</strong> 。从截图中值 <code>this$0</code> 为 <code>com.example.MainActivity</code> 实例对象,此时 <code>this$0</code> 所指向的 MainActivity 在旋转屏幕后会被销毁、被回收，但是 <code>Runnable 对象</code> 执行后台任务导致 <code>MainActivity$2</code> 对象依旧存在,即该对象此时应该存在于内存中，那么导致其所持有的 MainActivity 引用不能被回收，从而导致了 MainActivity 对象的泄漏。</p><p>匿名对象的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable work = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>这在 Java 中是一个经典的内存泄漏的案例，原因是匿名对象持有外部类的引用引起的，我们要做的就是将匿名对象静态化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static class CustomRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        SystemClock.sleep(20000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CustomRunnable work = new CustomRunnable();</span><br><span class="line">new Thread(work).start();</span><br></pre></td></tr></table></figure><p>针对匿名内部类具体分析一下过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line"></span><br><span class="line">        Runnable work = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // Do some slow work in background</span><br><span class="line">//                SystemClock.sleep(20000</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(work).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Java 命令编译该 Java 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure><p>编译出两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Main.class</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public Main() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        Runnable var1 = new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        (new Thread(var1)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Main$1.class</span><br><span class="line">class Main$1 implements Runnable &#123;</span><br><span class="line">    Main$1(Main var1) &#123;</span><br><span class="line">        this.this$0 = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 <code>this$0</code> 就为上面截图中的 <code>com.example.MainActivity</code> 实例对象，所以匿名内部类持有外部类的引用。</p><h3 id="LeakCanary-实践二"><a href="#LeakCanary-实践二" class="headerlink" title="LeakCanary 实践二"></a>LeakCanary 实践二</h3><p>这个例子更能够体现一步一步寻找内存泄漏点：</p><p>首先此次内存泄漏产生的 Trace 图如下：</p><!-- ![Trace 图](/../images/2019_07_06_01.png) --><p><strong>步骤一： Trace 图</strong></p><img src="/../images/2019_07_06_01.png" height="50%" width="50%"><p>首先我们通过截图 Title( MainActivity Leaked)明确 <strong>产生泄漏的对象为 MainActivity 的实例对象</strong>，Title 下面展示产生泄漏的 Trace 图。</p><p>我们根据 Trace 图一步一步分析:</p><p><strong>步骤二</strong>：</p><img src="/../images/2019_07_06_02.png" height="50%" width="50%"><p><strong>步骤三</strong>：</p><img src="/../images/2019_07_06_03.png" height="50%" width="50%"><p><strong>步骤四</strong>：</p><img src="/../images/2019_07_06_04.png" height="50%" width="50%"><p><strong>步骤五</strong>：</p><img src="/../images/2019_07_06_05.png" height="50%" width="50%"><p><strong>步骤六</strong>：</p><img src="/../images/2019_07_06_06.png" height="50%" width="50%"><!-- ![步骤一](/../images/2019_07_06_02.png) --><!-- ![步骤二](/../images/2019_07_06_03.png) --><!-- ![步骤三](/../images/2019_07_06_04.png) --><!-- ![步骤四](/../images/2019_07_06_05.png) --><!-- ![步骤五](/../images/2019_07_06_06.png) --><p>通过以上步骤，我们知道由于反转屏幕后 MainActivity 中的 Button 实例对象需要被回收，但是由于 HttpRequestHelper 对象在反转屏幕后继续存在，同时 HttpRequestHelper 实例对象持有 Button 对象的引用，所以 Button 不能成功被回收，导致 Button 持有的 MainActivity 实例对象在  Destory 后不能成功销毁，从而导致了 MainActivity 内存泄漏。</p><p>为了验证以上结论，我们可以继续向上查看 Trace：</p><!-- ![验证一](/../images/2019_07_06_07.png)![验证二](/../images/2019_07_06_08.png) --><img src="/../images/2019_07_06_07.png" height="50%" width="50%"><p><strong>实例对象详细信息</strong>：</p><img src="/../images/2019_07_06_08.png" height="50%" width="50%"><hr><p><strong>有用的资源：</strong></p><p><a href="https://square.github.io/leakcanary/" target="_blank" rel="noopener">leakcanary 官方网站</a></p><p><a href="https://square.github.io/leakcanary/fundamentals/" target="_blank" rel="noopener">leakcanary 基本原理</a></p><p><a href="https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745" target="_blank" rel="noopener">Detect all memory</a></p><p><a href="https://www.youtube.com/watch?v=KwArTJHLq5g" target="_blank" rel="noopener">Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau</a></p><p><a href="https://www.youtube.com/watch?v=LEX8dn4BLUw" target="_blank" rel="noopener">LeakCanary 2: Leaner, Better, Faster, Kotliner! by Pierre-Yves Ricau, Square, Inc EN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何使用-Leakmemory-泄漏链路-Trace-图&quot;&gt;&lt;a href=&quot;#如何使用-Leakmemory-泄漏链路-Trace-图&quot; class=&quot;headerlink&quot; title=&quot;如何使用 Leakmemory 泄漏链路(Trace 图)&quot;&gt;&lt;/a&gt;如何使用 Leakmemory 泄漏链路(Trace 图)&lt;/h3&gt;&lt;p&gt;以下英文部分摘自 &lt;a href=&quot;https://www.youtube.com/watch?v=KwArTJHLq5g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Youtube 视频：[Uber Mobility] Memory Leak Hunt: LeakCanary - Pierre-Yves Ricau&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[19:30] You look for objects that you know you try to ask the question throught subject should be in memory or not. If you can anwser the question, it’s greate because you’re going to help you reduce the space of the problem. If the anwser is yes that it should be in memory, the problem is in blow, if the anwser is no, the problem is above.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="内存泄漏" scheme="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="工具" scheme="/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="LeakCanary" scheme="/tags/LeakCanary/"/>
    
      <category term="内存优化" scheme="/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>刷机资源</title>
    <link href="/2019/06/26/%E5%88%B7%E6%9C%BA%E8%B5%84%E6%BA%90/"/>
    <id>/2019/06/26/刷机资源/</id>
    <published>2019-06-26T09:42:53.000Z</published>
    <updated>2019-09-20T07:07:23.579Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-TWRP"><a href="#1-TWRP" class="headerlink" title="1.TWRP"></a>1.TWRP</h3><p><a href="https://twrp.me/Devices/" target="_blank" rel="noopener">TeamWin - TWRP</a></p><h3 id="2-SuperSu"><a href="#2-SuperSu" class="headerlink" title="2.SuperSu"></a>2.SuperSu</h3><p><a href="http://www.supersu.com/download" target="_blank" rel="noopener">SuperSu</a></p><p>2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。</p><a id="more"></a><h3 id="3-Magisk"><a href="#3-Magisk" class="headerlink" title="3.Magisk"></a>3.Magisk</h3><p><a href="https://forum.xda-developers.com/apps/magisk/official-magisk-v7-universal-systemless-t3473445" target="_blank" rel="noopener">Magisk</a></p><p><a href="https://github.com/topjohnwu/Magisk" target="_blank" rel="noopener">Magisk-Github</a></p><p><a href="https://github.com/topjohnwu/Magisk/releases" target="_blank" rel="noopener">Magisk App 下载地址</a></p><p><a href="https://www.technobuzz.net/download-and-install-magisk-manager/" target="_blank" rel="noopener">android 9.0 Magisk 实现 root  </a></p><!-- ### Xposed Framework --><h3 id="4-Rom-资源"><a href="#4-Rom-资源" class="headerlink" title="4.Rom 资源"></a>4.Rom 资源</h3><p><a href="https://www.lineageos.org/" target="_blank" rel="noopener">LineageOS</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/lineage-rom/full/" target="_blank" rel="noopener">LineageOS 清华源</a></p><p><a href="https://download.pixelexperience.org/" target="_blank" rel="noopener">xda room 资源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-TWRP&quot;&gt;&lt;a href=&quot;#1-TWRP&quot; class=&quot;headerlink&quot; title=&quot;1.TWRP&quot;&gt;&lt;/a&gt;1.TWRP&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://twrp.me/Devices/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TeamWin - TWRP&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-SuperSu&quot;&gt;&lt;a href=&quot;#2-SuperSu&quot; class=&quot;headerlink&quot; title=&quot;2.SuperSu&quot;&gt;&lt;/a&gt;2.SuperSu&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.supersu.com/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SuperSu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2018 年 5 月，SuperSU 的作者 Chainfire 正式宣布停止开发所有 root 相关的应用，此后 Magisk 称为 root 利器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android 刷机" scheme="/tags/Android-%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>灵感来源</title>
    <link href="/2019/06/12/%E7%81%B5%E6%84%9F%E6%9D%A5%E6%BA%90/"/>
    <id>/2019/06/12/灵感来源/</id>
    <published>2019-06-12T10:54:16.000Z</published>
    <updated>2019-06-12T10:54:16.689Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/" target="_blank" rel="noopener">GayHub 交友社区</a></p><p><a href="https://www.ctolib.com/article/compares/53292" target="_blank" rel="noopener">CTOLib码库</a></p><p><a href="https://p.codekk.com/" target="_blank" rel="noopener">CodeKK</a></p><p><a href="https://www.diycode.cc/categories/Android" target="_blank" rel="noopener">diycode</a></p><p><a href="https://android-arsenal.com/" target="_blank" rel="noopener"> Android Arsenal</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GayHub 交友社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ctolib.com/article/compares/5329
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>性能优化之优化 App 启动速度</title>
    <link href="/2019/06/11/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BC%98%E5%8C%96-App-%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    <id>/2019/06/11/性能优化之优化-App-启动速度/</id>
    <published>2019-06-11T09:13:48.000Z</published>
    <updated>2019-06-11T09:13:48.445Z</updated>
    
    <content type="html"><![CDATA[<p>主要面临的问题：<br> APP 冷启动白屏。</p><p>针对于这个问题，基本上主流的解决方法存在两个：</p><pre><code>1. 主题替换。2. 减少冷启动时主线程的工作量。</code></pre><p>本文的重点不在解决问题方法，而在于解决问题的过程，包括影响启动速度的因素、时间统计工具、解决思路。</p><p>优化 App 启动速度主要是优化冷启动时的 App 启动速度，官方文档 (<a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a>) 中指出优化冷启动方式的同时，温启动和热启动也会得到改善。</p><p>在分析过程之前，首先了解启动方式。</p><h3 id="冷启动、温启动、热启动"><a href="#冷启动、温启动、热启动" class="headerlink" title="冷启动、温启动、热启动"></a>冷启动、温启动、热启动</h3><ul><li><p>冷启动</p><p>App 安装后第一次启动或者杀死 App 进程后重新启动称为冷启动。冷启动的启动成本较高，一切都要重新建立，包括新建应用进程、初始化应用以及首页的布局、渲染等操作。</p></li></ul><ul><li><p>热启动</p><p>  App 所在进程存活，并且所有 Activity 均未被销毁，热启动做的只是把应用从后台切换至前台，如果 Activity 实例中的被回收的实例变量会重新创建。</p><p>  具体场景为在微信中切换到桌面，后马上回到微信。</p></li><li><p>温启动</p><p>  Activity 被杀死但是 App 所在的进程在内存中依然存在。</p></li></ul><h4 id="启动时间组成"><a href="#启动时间组成" class="headerlink" title="启动时间组成"></a>启动时间组成</h4><p>很多时候解决问题需要我们拥有上帝视角，全面把控事态的发展，跳出事件本身，以俯视的角度看待整个流程，找出问题的关键点。总的来说我们需要纵观全局来看待问题、解决问题。</p><p>从在 Launcher 中点击 App 的 icon 到 App 的第一面展示的时间差称为冷启动时间，那么这段时间整个系统都经历了什么。用上帝之眼看待整个流程，从而寻找解决问题的切入点，首先我们分析一下整个过程都经历了什么。</p><p>在 Launcher 中我们点击 App 图标，经过一系列过程，涉及 AMS、 Binder、IPC 等组件和过程。</p><p>在启动 App 的主页面之前，系统操作如下：</p><ol><li>创建并启动 App 所在应用</li><li>启动 App 后会马上展示系统的 start window</li><li>创建 App 进程</li></ol><p>在系统创建完成 App 所在的进程后，App 进程负责完成下列一系列步骤：</p><ol><li>创建 App 对象</li><li>启动 App 主线程</li><li>创建主 Activity</li><li>加载 View 视图</li><li>布局屏幕</li><li>执行初始化绘制 View</li></ol><p>在 App 进程完成第一帧的绘制后，start window 会被替换，此时在屏幕上展示的就是在主 Activity 加载的布局。</p><p><img src="/../images/2019_06_01_01.png" alt="App 页面替换"></p><p>根据 <a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Colt McAnlis</a> 在 Yutobe 上的关于 App 启动时间的描述，以上过程可以形象的图形化表示如下：</p><p><img src="/../images/2019_06_01_02.png" alt="App 启动时间"></p><h4 id="为什么是白屏或黑屏"><a href="#为什么是白屏或黑屏" class="headerlink" title="为什么是白屏或黑屏"></a>为什么是白屏或黑屏</h4><p>在清单文件中我们需要设置 Application 的 Theme，比如自己设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        ...</span><br><span class="line">        android:theme=&quot;@style/sixcatTheme&quot;&gt;</span><br></pre></td></tr></table></figure><p>我们需要查看 sixcatTheme 主题的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;style name=&quot;sixcatTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">2. &lt;style name=&quot;Theme.AppCompat.Light&quot; parent=&quot;Base.Theme.AppCompat.Light&quot;/&gt;</span><br><span class="line"></span><br><span class="line">3. &lt;style name=&quot;Base.Theme.AppCompat.Light&quot; parent=&quot;Base.V7.Theme.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">4. &lt;style name=&quot;Base.V7.Theme.AppCompat.Light&quot; parent=&quot;Platform.AppCompat.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">5. &lt;style name=&quot;Platform.AppCompat.Light&quot; parent=&quot;android:Theme.Holo.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line">6. &lt;style name=&quot;Theme.Holo.Light&quot; parent=&quot;Theme.Light&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. &lt;style name=&quot;Theme.Light&quot;&gt;</span><br><span class="line">      &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_light&lt;/item&gt;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">8. &lt;style name=&quot;Theme&quot;&gt;</span><br></pre></td></tr></table></figure><p>层级自 1~8 自上而下具有继承关系。</p><p>可以看到在第 7 层中存在 windowBackground 属性，这是一路下来与背景唯一相关属性。</p><p>看一下 windowBackground 的 drawable 显示如何：</p><p><img src="/../images/2019_06_11_01.jpg" alt="drawable"></p><p>事实证明确实是这个属性决定着点击 App 后显示的白屏或黑屏，当然这也为解决此问题提供了一个思路。</p><p>官方图</p><p>拆解为两部分。</p><p>分析、找出优化点</p><h4 id="启动时间统计"><a href="#启动时间统计" class="headerlink" title="启动时间统计"></a>启动时间统计</h4><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>更换主题</p><p>截图 + 解决方法 + 截图</p><p>延时加载</p><p>CPU profile<br>trace 文件<br>命令行<br>Displayed Time</p><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure><p>在原来的 MainActivity 设定的主题中添加以上代码。</p><p>带来的效果：<br>透明效果，即点击 App icon 后的白屏时间变为 透明 状态，避免了白屏，但是两者的时间几乎相同。给人的错觉时点击 icon 后一段时间后，app 才调起，给人的印象不好。</p><p>方法二 主题替换</p><p>在 App 启动时</p><hr><p>App 启动时间统计</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W package/activity</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Google Developer</a></p><p><a href="https://www.youtube.com/watch?v=Vw1G1s73DsY" target="_blank" rel="noopener">Youtube 性能优化视频</a></p><p><a href="https://www.zhihu.com/question/35487841" target="_blank" rel="noopener">https://www.zhihu.com/question/35487841</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要面临的问题：&lt;br&gt; APP 冷启动白屏。&lt;/p&gt;
&lt;p&gt;针对于这个问题，基本上主流的解决方法存在两个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 主题替换。
2. 减少冷启动时主线程的工作量。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本文的重点不在解决问题方法，而在于解决问题的过程，
      
    
    </summary>
    
    
      <category term="性能优化" scheme="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Binder基本原理</title>
    <link href="/2019/06/05/Binder%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>/2019/06/05/Binder基本原理/</id>
    <published>2019-06-05T05:33:02.000Z</published>
    <updated>2019-06-05T05:36:07.356Z</updated>
    
    <content type="html"><![CDATA[<p>Binder 机制是 Android 特有的跨进程通信机制，本文为 <a href>Android 插件化开发</a> 相关章节的阅读笔记。</p><h4 id="00x01"><a href="#00x01" class="headerlink" title="00x01"></a>00x01</h4><p>Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。</p><h4 id="00x02"><a href="#00x02" class="headerlink" title="00x02"></a>00x02</h4><p>Binder 组成：</p><ul><li>Client</li><li>Server</li><li>ServerManager(管理 Server )</li></ul><a id="more"></a><h4 id="00x03"><a href="#00x03" class="headerlink" title="00x03"></a>00x03</h4><p>为了更好的帮助读者理解，我们可以看一个场景：<strong>打电话</strong>。</p><ul><li>ServerManager: 相当于电话局，储存每个用户的电话。</li><li>Client: 用户 A</li><li>Server: 用户 B</li></ul><p><code>用户 A 向用户 B 拨打电话</code></p><ol><li>A 拨打电话</li><li>电话会被转接到电话局</li><li>电话局查询 A 拨打的电话，若电话存在，则接通电话；若电话不存在，则提示该号码不存在。</li></ol><p>在这个过程中还有一个十分重要的角色：<strong>接线员</strong>，它做了很多事情，承担了十分重要的角色，映射到 Binder 机制，接线员相当于 <strong>Binder 驱动</strong>。</p><h4 id="00x04"><a href="#00x04" class="headerlink" title="00x04"></a>00x04</h4><p>Binder 基本运行机制如下图：</p><p><img src="/../images/2019_06_05_01.jpg" alt="Binder 运行机制"></p><h4 id="00x05-Binder-的通信过程"><a href="#00x05-Binder-的通信过程" class="headerlink" title="00x05 Binder 的通信过程"></a>00x05 Binder 的通信过程</h4><p>假如 Client 进程调用 Server 进程中的方法 add(),因为两者隶属于不同进程，此时需要在 Binder 的协助下完成 IPC(Inter-process Communication) 通信。</p><ol><li>Server 端在 SM(ServerManager) 中完成注册。</li><li>Client 要想调用 Server 的 add 方法，必须获得 Server 对象，但是 SM 不会吧真正的 Server 对象返回给 Client，而是把 Server 的代理对象 Proxy 返回给 Client。</li><li>Client 调用 Proxy 中的 add 方法，SM 会帮助它调用 Server 的 add 方法，并把结果返回给 Client。</li></ol><p>此时 Client 和 Server 实现了进程间通信，在此过程中 Binder 驱动做了许多事情，但是我们目前不需要关心。</p><p><img src="/../images/2019_06_05_02.png" alt="Binder 通信过程"></p><h4 id="00x06"><a href="#00x06" class="headerlink" title="00x06"></a>00x06</h4><p>在研究系统框架或第三方库时，我们不要陷入细节中，要先熟悉基本的运行机制、运行流程，根据自我需求，选择性的查看实现细节，但是需要注意的还是不能陷入细节，要有的放矢的跳出细节，把控全局。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binder 机制是 Android 特有的跨进程通信机制，本文为 &lt;a href&gt;Android 插件化开发&lt;/a&gt; 相关章节的阅读笔记。&lt;/p&gt;
&lt;h4 id=&quot;00x01&quot;&gt;&lt;a href=&quot;#00x01&quot; class=&quot;headerlink&quot; title=&quot;00x01&quot;&gt;&lt;/a&gt;00x01&lt;/h4&gt;&lt;p&gt;Binder 分为 Client 端和 Server 端，在进行跨进程通信时，两端分别为两个不同的进程。发消息者为 Client，相应的接收消息者为 Server。根据消息的流向，一端可以同时为 Client 和 Server。&lt;/p&gt;
&lt;h4 id=&quot;00x02&quot;&gt;&lt;a href=&quot;#00x02&quot; class=&quot;headerlink&quot; title=&quot;00x02&quot;&gt;&lt;/a&gt;00x02&lt;/h4&gt;&lt;p&gt;Binder 组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;ServerManager(管理 Server )&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Binder" scheme="/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 资源网站集</title>
    <link href="/2019/05/30/Kindle-%E8%B5%84%E6%BA%90%E9%9B%86/"/>
    <id>/2019/05/30/Kindle-资源集/</id>
    <published>2019-05-30T02:28:29.000Z</published>
    <updated>2019-06-01T02:02:51.829Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kaka3.com/" target="_blank" rel="noopener">kaka</a></p><p><a href="http://www.ireadweek.com/index.php/Index/index.html" target="_blank" rel="noopener">行行</a></p><a id="more"></a><p><a href="http://www.tushugu.com/" target="_blank" rel="noopener">图书馆</a></p><p><a href="https://book.shuyuzhe.com/" target="_blank" rel="noopener">书语者</a></p><p><a href="https://bookset.me/" target="_blank" rel="noopener">Bookset</a></p><p><a href="https://kgbook.com/" target="_blank" rel="noopener">苦瓜书盘</a></p><p><a href="http://mebook.cc/" target="_blank" rel="noopener">我的小书屋</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.kaka3.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kaka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ireadweek.com/index.php/Index/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;行行&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kindle" scheme="/tags/Kindle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合工具类--Collections</title>
    <link href="/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/"/>
    <id>/2019/05/29/Java-集合工具类-Collections/</id>
    <published>2019-05-29T09:17:24.000Z</published>
    <updated>2019-05-29T10:18:39.903Z</updated>
    
    <content type="html"><![CDATA[<p><strong>HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的</strong>，如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 <strong>线程同步问题</strong>。</p><p>Java 提供了 Collections 工具类，使用 synchronizedxxx()  方法可以将集合类包装成线程安全的集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections collections = Collections.synchronizedCollection(new ArrayList());</span><br><span class="line"></span><br><span class="line">List list = Collections.synchronizedList(new ArrayList());</span><br><span class="line"></span><br><span class="line">Set set = Collections.synchronizedSet(new HashSet());</span><br><span class="line"></span><br><span class="line">Map map = Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure><p>同时 Collections 还提供了排序、查找、替换、设置不可变集合等功能，有空自己看 API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;HashSet、TreeSet、ArrayList、ArrayDeque、LinkedList、HashMap 和 TreeMap 都是线程不安全的&lt;/strong&gt;，
如果多个线程对用一个集合对象进行存、取、删等操作，不免会产生 &lt;strong&gt;线程同步问
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Collections" scheme="/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 单例模式的实现</title>
    <link href="/2019/05/24/Kotlin-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>/2019/05/24/Kotlin-单例模式的实现/</id>
    <published>2019-05-24T10:35:39.000Z</published>
    <updated>2019-05-29T09:45:44.388Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最简单的实现方式"><a href="#最简单的实现方式" class="headerlink" title="最简单的实现方式"></a>最简单的实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line">  fun method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在Kotlin里调用</span><br><span class="line">Singleton.method()</span><br><span class="line"></span><br><span class="line">//在Java中调用</span><br><span class="line">Singleton.INSTANCE.method();</span><br></pre></td></tr></table></figure><p>其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Singleton &#123;</span><br><span class="line">   public static final Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void method() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private Singleton() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Singleton var0 = new Singleton();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 Java 中的 饿汉式获得单例方式相同。</p><p>同样也与 Java 中饿汉方式获得单例拥有相同的问题：</p><ul><li>如果没有使用该类的对象，那么已经实例化的对象，造成了内存浪费。</li><li>当构造器中执行复杂操作，造成实例化过程缓慢，可能造成性能问题。</li></ul><h4 id="懒汉式-一"><a href="#懒汉式-一" class="headerlink" title="懒汉式 一"></a>懒汉式 一</h4><p>在 Kotlin 中单例的实现和 Java 中一样，必须有：</p><ol><li>私有化的构造函数</li><li>获得对象的方法</li></ol><p>那么在 Kotlin 中有：</p><ul><li>显式声明构造方法为 private</li><li>companion object 用来在 class 内部声明一个对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line"></span><br><span class="line">        @Volatile</span><br><span class="line">        private var instance: Singleton? = null</span><br><span class="line"></span><br><span class="line">        fun getInstance() =</span><br><span class="line">                instance ?: synchronized(this) &#123;</span><br><span class="line">                    instance ?: Singleton().also &#123; instance =it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此写法 <a href="https://leegyplus.github.io/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/" target="_blank" rel="noopener">Java 单例模式的几种写法</a> 中懒汉模式的 <strong>方式三</strong> 相同。</p><p>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin 调用</span><br><span class="line">val singleton = Singleton.getInstance()</span><br><span class="line"></span><br><span class="line">//Java 调用</span><br><span class="line">Singleton singleton = Singleton.Companion.getInstance()</span><br></pre></td></tr></table></figure><h4 id="懒汉式-二"><a href="#懒汉式-二" class="headerlink" title="懒汉式 二"></a>懒汉式 二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Singleton private constructor()&#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val instance: Singleton by lazy &#123; Singleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Singleton</code> 通过 <code>lazy</code>来实现懒汉式加载。</li><li><code>lazy</code> 默认情况下是 <strong>线程安全</strong> 的，这就可以避免多个线程同时访问生成多个实例的问题。</li></ul><p>所以就不用象方式一中那样，对 Singleton 对象进行 <strong>加同步锁</strong> 和 <strong>双重校验</strong> 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最简单的实现方式&quot;&gt;&lt;a href=&quot;#最简单的实现方式&quot; class=&quot;headerlink&quot; title=&quot;最简单的实现方式&quot;&gt;&lt;/a&gt;最简单的实现方式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object Singleton &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  fun method() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;调用单例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//在Kotlin里调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.method()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//在Java中调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton.INSTANCE.method();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;其实这种方式的实现为 Java 中的饿汉式,在 AS 的 Kotlin 相关的工具对 object 类进行编译和反编译，可以看到起对应的 Java 代码如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="/tags/Kotlin/"/>
    
      <category term="Singleton" scheme="/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="/2019/05/23/%E9%9A%8F%E7%AC%94/"/>
    <id>/2019/05/23/随笔/</id>
    <published>2019-05-22T23:36:36.000Z</published>
    <updated>2019-05-23T03:14:25.537Z</updated>
    
    <content type="html"><![CDATA[<p>我是一条随意的随笔，欢迎欢迎！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我是一条随意的随笔，欢迎欢迎！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(二)-CPU是如何执行指令的</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%BA%8C-CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E7%9A%84/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-二-CPU是如何执行指令的/</id>
    <published>2019-05-15T10:04:03.000Z</published>
    <updated>2019-05-29T07:35:01.658Z</updated>
    
    <content type="html"><![CDATA[<p>代码变成指令后，是一条一条顺序执行的。</p><p>在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。</p><p>在硬件上，寄存器有锁存器或触发器组成。</p><p><img src="https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg" alt="常见寄存器"></p><p>每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。</p><a id="more"></a><ul><li>PC 寄存器(指令地址寄存器)：用来存放下一条需要执行的计算机指令的 <strong>内存地址</strong>。</li><li>指令寄存器：用来存放正在执行的指令。</li><li>条件码寄存器：用里面的一个个标志位，用来存在 CPU 进行计算或逻辑运算的结果。</li></ul><p>以下图片展示如何根据机器码执行指令；</p><p><img src="https://static001.geekbang.org/resource/image/ad/8a/ad91b005e97959d571bbd2a0fa30b48a.jpeg" alt="执行指令"></p><p>我们可以看到，执行程序时，CPU 会根据 PC 寄存器中的内存地址，将指定内存的指令码读取到指令寄存器中，指令长度自增，开始顺序执行下一个指令，执行上面相同的操作。</p><p>以上可见程序的指令码是在内存中顺序保存的，也会一条一条加载。</p><h3 id="指令码跳转执行"><a href="#指令码跳转执行" class="headerlink" title="指令码跳转执行"></a>指令码跳转执行</h3><p>程序的指令码在内存中是顺序执行的，那么在程序执行跳转逻辑是，机器指令是如何执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  srand(time(NULL));</span><br><span class="line">  int r = rand() % 2;</span><br><span class="line">  int a = 10;</span><br><span class="line">  if (r == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    a = 2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -M intel -S test.o</span><br></pre></td></tr></table></figure><p>在 Mac 上对应的汇编码如下，限于平台问题，和原博客有所差别，所以直接参看原博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1 // test.c</span><br><span class="line">26:   99  cltd</span><br><span class="line">27:   b9 02 00 00 00  movl    $2, %ecx</span><br><span class="line">2c:   f7 f9   idivl   %ecx</span><br><span class="line">2e:   89 55 f8    movl    %edx, -8(%rbp)</span><br><span class="line">; int a = 10;</span><br><span class="line">31:   c7 45 f4 0a 00 00 00    movl    $10, -12(%rbp)</span><br><span class="line">; if (r == 0)</span><br><span class="line">38:   83 7d f8 00     cmpl    $0, -8(%rbp)</span><br><span class="line">3c:   0f 85 0c 00 00 00   jne 12 &lt;_main+0x4e&gt;</span><br><span class="line">; a = 1;</span><br><span class="line">42:   c7 45 f4 01 00 00 00    movl    $1, -12(%rbp)</span><br><span class="line">; &#125; else &#123;</span><br><span class="line">49:   e9 07 00 00 00  jmp 7 &lt;_main+0x55&gt;</span><br><span class="line">; a = 2;</span><br><span class="line">4e:   c7 45 f4 02 00 00 00    movl    $2, -12(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">55:   8b 45 fc    movl    -4(%rbp), %eax</span><br><span class="line">58:   48 83 c4 10     addq    $16, %rsp</span><br><span class="line">5c:   5d  popq    %rbp</span><br><span class="line">5d:   c3  retq</span><br></pre></td></tr></table></figure><p> 原博客汇编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (r == 0)</span><br><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br><span class="line">&#123;</span><br><span class="line">a = 1;</span><br><span class="line">41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1</span><br><span class="line">48:   eb 07                   jmp    51 &lt;main+0x51&gt;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a = 2;</span><br><span class="line">4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2</span><br><span class="line">51:   b8 00 00 00 00          mov    eax,0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注以下两行(r == 0 的编译结果)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">3f:   75 09                   jne    4a &lt;main+0x4a&gt;</span><br></pre></td></tr></table></figure><p>判断当条件成立时，跳转到操作数为 4a 的指令，进行接下来的指令执行。</p><p>执行过程图：</p><p><img src="https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg" alt="跳转指令执行"></p><p>所以代码变成指令后，是一条一条顺序执行的，这个顺序执行是基于跳转的顺序执行。</p><hr><p>常见指令解释：</p><p>cmp DWORD PTR [rbp-0x4],0x0</p><pre><code>从寄存器地址为[rbp-0x4]取出值与 0x0 比较</code></pre><p>mov DWORD PTR [rbp-0x8],0x2</p><pre><code>将 0x2 存入寄存器地址为 [rbp-0x8] 的内存中</code></pre><p>jne 指令，是 jump if not equal </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码变成指令后，是一条一条顺序执行的。&lt;/p&gt;
&lt;p&gt;在代码的执行过程中，CPU 中的寄存器扮演着举足轻重的角色。&lt;/p&gt;
&lt;p&gt;在硬件上，寄存器有锁存器或触发器组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg&quot; alt=&quot;常见寄存器&quot;&gt;&lt;/p&gt;
&lt;p&gt;每种寄存器有不同的功能，而且每种寄存器都在指令执行过程中扮演重要角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出计算机组成原理(一)--计算机指令</title>
    <link href="/2019/05/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%80-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4/"/>
    <id>/2019/05/15/深入浅出计算机组成原理-一-计算机指令/</id>
    <published>2019-05-15T02:21:30.000Z</published>
    <updated>2019-05-15T09:25:42.585Z</updated>
    
    <content type="html"><![CDATA[<p>因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 是计算机的大脑，Central Processing Unit，中文为 <strong>中央处理器</strong>。</p><p>从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。</p><p>从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 <strong>机器语言</strong>。</p><p>每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 <strong>计算机指令</strong>。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。</p><p>一个计算机程序编译后，有很多的计算机指令。<br> <a id="more"></a></p><h3 id="从编译到汇编，代码是怎样变成机器码的？"><a href="#从编译到汇编，代码是怎样变成机器码的？" class="headerlink" title="从编译到汇编，代码是怎样变成机器码的？"></a>从编译到汇编，代码是怎样变成机器码的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.c</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 1; </span><br><span class="line">  int b = 2;</span><br><span class="line">  a = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要让这段程序在 Linux 系统上跑起来，我们需要把整个程序翻译成一个 汇编语言(ASM,Assembly Language)的程序,这个过程我们叫做 <strong>编译(Compile)</strong> 成汇编代码。之后再使用汇编器将汇编代码翻译成用 “0”和”1” 组成的机器码。这一条条机器码就是一条条 <strong>计算机指令</strong>。</p><p>使用 GCC 编译器 和 objdump 命令，把对应的汇编代码和机器代码打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//MacOS 环境下</span><br><span class="line">gcc -g -c test.c</span><br><span class="line">objdump -d -S test.o &gt; text.txt</span><br></pre></td></tr></table></figure><p>text.txt 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test.o: file format Mach-O 64-bit x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section __TEXT,__text:</span><br><span class="line">_main:</span><br><span class="line">; int main()&#123;</span><br><span class="line">       0:   55  pushq   %rbp</span><br><span class="line">       1:   48 89 e5    movq    %rsp, %rbp</span><br><span class="line">       4:   31 c0   xorl    %eax, %eax</span><br><span class="line">; int a = 1;</span><br><span class="line">       6:   c7 45 fc 01 00 00 00    movl    $1, -4(%rbp)</span><br><span class="line">; int b = 2;</span><br><span class="line">       d:   c7 45 f8 02 00 00 00    movl    $2, -8(%rbp)</span><br><span class="line">; a = a + b;</span><br><span class="line">      14:   8b 4d fc    movl    -4(%rbp), %ecx</span><br><span class="line">      17:   03 4d f8    addl    -8(%rbp), %ecx</span><br><span class="line">      1a:   89 4d fc    movl    %ecx, -4(%rbp)</span><br><span class="line">; &#125;</span><br><span class="line">      1d:   5d  popq    %rbp</span><br><span class="line">      1e:   c3  retq</span><br></pre></td></tr></table></figure><p>汇编语言其实就是让程序员能够看懂机器语言。</p><p>将上面文件中的汇编语言和机器语言分别拆分出来，分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbp</span><br><span class="line">movq    %rsp, %rbp</span><br><span class="line">xorl    %eax, %eax</span><br><span class="line">movl    $1, -4(%rbp)</span><br><span class="line">movl    $2, -8(%rbp)</span><br><span class="line">movl    -4(%rbp), %ecx</span><br><span class="line">addl    -8(%rbp), %ecx</span><br><span class="line">movl    %ecx, -4(%rbp)</span><br><span class="line">popq    %rbp</span><br><span class="line">c3  retq</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:   55</span><br><span class="line">1:   48 89 e5</span><br><span class="line">4:   31 c0 </span><br><span class="line">6:   c7 45 fc 01 00 00 00</span><br><span class="line">d:   c7 45 f8 02 00 00 00</span><br><span class="line">14:   8b 4d fc</span><br><span class="line">17:   03 4d f8</span><br><span class="line">1a:   89 4d fc</span><br><span class="line">1d:   5d</span><br><span class="line">1e:   c3</span><br></pre></td></tr></table></figure><h3 id="解析指令和机器码"><a href="#解析指令和机器码" class="headerlink" title="解析指令和机器码"></a>解析指令和机器码</h3><p>CPU 常见指令分类：</p><ul><li>算术类指令</li><li>数据传输类指令</li><li>逻辑指令</li><li>条件分支类指令</li><li>无条件跳转指令</li></ul><p>不同的 CPU 对应着不同的指令，也就对应着不同的汇编语言和机器码。</p><p>场景：</p><p>在 Android 开发过程中，我们需要添加第三方 so 库，根据不同的手机需要添加不同的 CPU 架构的 so 包,具体参见资料-<a href="****">Android的.so文件、ABI和CPU的关系</a></p><p>除了 C 这样的编译型语言之外，不管是 Python 这样的解释型语言，还是像 Java 这样使用虚拟机的语言，最终都是把写好的代码转换为 CPU 理解的机器码来执行。</p><p>解释型的语言，通过解释器在程序运行的时候逐句翻译，而 Java 这样 <strong>使用虚拟机的语言</strong>，则由虚拟机对编译出来的中间代码(.class)进行解释，或者即时编译成为机器码来最终执行。</p><p><strong>运行编译型语言：</strong> 是相对于解释型语言存在的，编译型语言的首先将源代码编译生成机器语言，再由机器运行机器码（二进制）。像C/C++等都是编译型语言。编译型语言程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如C、C++、Delphi等.  </p><p><strong>解释性语言</strong> 编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为计算机或者说 CPU 本身，并没有能力理解这些高级语言，计算机只能理解 “机器码”，即一连串的 “0” 和 “1” 这样的数字。&lt;/p&gt;
&lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;p&gt;CPU 是计算机的大脑，Central Processing Unit，中文为 &lt;strong&gt;中央处理器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从硬件角度： CPU 是一个超大规模的集成电路，通过电路实现加法、减法、乘法等逻辑运算。&lt;/p&gt;
&lt;p&gt;从软件角度：CPU 是一个执行 计算机指令的逻辑电器。这里的计算机指令是指 CPU 能够听懂的语言，可以把它看做 &lt;strong&gt;机器语言&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每种 CPU 能够听懂的语言是不同的，例如个人 PC 中的 Intel 的 CPU， IPhone 中的 ARM 的 CPU。每种 CPU 有自己能够支持的 &lt;strong&gt;计算机指令&lt;/strong&gt;。不同 CPU 间的计算机指令是不可互通的，例如你不能把运行在计算机上的程序复制到手机上，这是没有办法运行的。&lt;/p&gt;
&lt;p&gt;一个计算机程序编译后，有很多的计算机指令。&lt;br&gt;
    
    </summary>
    
    
      <category term="深入浅出计算机组成原理(徐文浩)" scheme="/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%BE%90%E6%96%87%E6%B5%A9/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之WorkManager基本了解</title>
    <link href="/2019/05/14/Jetpack%E4%B9%8BWorkManager%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/14/Jetpack之WorkManager笔记/</id>
    <published>2019-05-14T07:15:58.000Z</published>
    <updated>2019-05-23T02:54:04.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。</p><h3 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h3><ul><li><p>向后兼容到 API 14</p><ul><li>在 API 23+ 的设备上使用 JobScheduler。</li><li>在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。</li></ul></li><li><p>为网络或获取充电状态添加约束</p></li><li><p>安排一次性异步任务或定期任务  </p></li><li><p>监控和管理计划任务</p></li><li><p>链接多个任务</p></li><li><p>即使应用程序或设备重新启动，也可确保任务执行</p></li><li><p>坚持Doze模式等省电模式</p></li></ul><a id="more"></a><p>WorkManager 适用于可延迟的任务-即不需要立即运行，即使应用程序退出或设备重新启动也需要可靠运行的情况。例如：</p><ul><li>将日志或分析发送到后端服务</li><li>定期将应用程序数据与服务器同步</li></ul><p>WorkManager 不适用于在应用程序进程消失时，安全退出的后台工作，也不适用于需要立即执行的任务。</p><h3 id="使用-Work"><a href="#使用-Work" class="headerlink" title="使用 Work"></a>使用 Work</h3><ol><li>通过 Work 来定义 任务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UploadWorker(context:Context,workerParameters: WorkerParameters):Worker(context,workerParameters) &#123;</span><br><span class="line"></span><br><span class="line">    override fun doWork(): Result &#123;</span><br><span class="line">        return Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通过 WorkRequest 来管理 任务怎样以及何时运行任务。</p><ul><li><p>对于一次性的 WorkRequest ，使用  OneTimeWorkRequest。</p></li><li><p>对于定时 WorkRequest，使用 PeriodicTimeWorkRequest。</p><p>WorkRequest 还可以包含其他信息，例如任务运行的约束条件，工作输入，延迟以及重试工作的退避策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;().build()</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>将您的任务交给系统。</li></ol><p>Work 执行的确切时间取决于 WorkRequest 和系统优化中使用的约束。WorkManager 旨在根据这些限制提供最佳行为。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WorkManager.getInstance().enqueue(uploadWorkRequest)</span><br></pre></td></tr></table></figure><h3 id="Work、WorkRequest、WorkManager-关系"><a href="#Work、WorkRequest、WorkManager-关系" class="headerlink" title="Work、WorkRequest、WorkManager 关系"></a>Work、WorkRequest、WorkManager 关系</h3><p>Work 定义任务, WorkRequest 基于 Work 创建 执行任务的请求，WorkManager 作为管理者执行 任务请求。</p><h3 id="定义-WorkRequest"><a href="#定义-WorkRequest" class="headerlink" title="定义 WorkRequest"></a>定义 WorkRequest</h3><h4 id="为-WorkRequest-添加约束条件"><a href="#为-WorkRequest-添加约束条件" class="headerlink" title="为 WorkRequest 添加约束条件"></a>为 WorkRequest 添加约束条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Create a Constraints object that defines when the task should run</span><br><span class="line">val constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresDeviceIdle(true)</span><br><span class="line">        .setRequiresCharging(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">// ...then create a OneTimeWorkRequest that uses those constraints</span><br><span class="line">val compressionWork = OneTimeWorkRequestBuilder&lt;CompressWorker&gt;()</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure><p>当所有的约束条件满足时，work 会执行。如果在执行 work 过程中不再满足约束条件，那么 WorkManager 会停止 work 的执行，等待约束条件满足后再次执行 work。</p><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>以下是将任务设置为在排队后至少10分钟后运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val uploadWorkRequest = OneTimeWorkRequestBuilder&lt;UploadWorker&gt;()</span><br><span class="line">        .setInitialDelay(10, TimeUnit.MINUTES)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;通过WorkManager API，可以轻松安排即使应用程序退出或设备重新启动也可以运行的可延迟的异步任务。&lt;/p&gt;
&lt;h3 id=&quot;feature&quot;&gt;&lt;a href=&quot;#feature&quot; class=&quot;headerlink&quot; title=&quot;feature&quot;&gt;&lt;/a&gt;feature&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;向后兼容到 API 14&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 API 23+ 的设备上使用 JobScheduler。&lt;/li&gt;
&lt;li&gt;在 API 14-22 的设备上使用 BroadcastReceiver 以及 AlarmManager。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为网络或获取充电状态添加约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安排一次性异步任务或定期任务  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;监控和管理计划任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接多个任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;即使应用程序或设备重新启动，也可确保任务执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;坚持Doze模式等省电模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java集合之Map</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/"/>
    <id>/2019/05/10/Java集合之Map/</id>
    <published>2019-05-10T10:17:08.000Z</published>
    <updated>2019-05-29T10:18:07.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Map 用于保存具有 <strong>映射关系</strong> 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。</p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><p>可以把 Map 里的 Key 放在一起，它们组成一个 <strong>Set 集合</strong>(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 <strong>List 集合</strong>(可重复，此时的索引为 key)。</p><p>如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。</p><a id="more"></a><h3 id="HashMap-和-Hashtable"><a href="#HashMap-和-Hashtable" class="headerlink" title="HashMap 和 Hashtable"></a>HashMap 和 Hashtable</h3><p>HashMap 和 Hashtable 是 Map 的典型实现类。 Hashtable 在 JDK1.0 起就已经存在。在 Java8 时改进了 HashMap 的实现，使其在 HashMap 存在 key 冲突时具有更好的性能。</p><p>Hashtable 与 HashMap 主要区别：</p><ul><li>Hashtable: <strong>线程安全</strong> 的 Map 实现，但是 HashMap 是线程不安全的实现，所以 HashMap 的性能更高一些。多个线程访问同一个 Map 对象时，使用 Hashtable 会更好。</li><li>Hashtable 不允许使用 null 作为 key 和 value，否则会引起异常，但是 HashMap 可以。</li></ul><p>为了更好的在 HashMap 和 Hashtable 中存储、获取对象，<strong>用作 key 的对象必须实现 hashCode() 和 equals() 方法</strong>。</p><p>HashMap、Hashtable <strong>key 相同的标准</strong> 是：<strong>两个 key 通过 equals() 方法比较返回为 true，那么两个 key 的 hashcode 值必须相等</strong>。</p><p>HashMap、Hashtable <strong>value 相等</strong> 的标准：只要两个对象的 equals() 方法比较返回为 true 即可。</p><p>与 HashSet 相同，采用自定义类作为 HashMap、Hashtable 的 key，如果程序修改了作为 key 的可变对象，那么也会出现与 HashSet 类似的情形：程序无法准确访问到 Map 中被修改过的 key。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>与 LinkedHashSet 一致，LinkedHashMap 内部也是通过双向链表来维护添加的 key-value 的顺序(以 key 的添加顺序为准)。</p><p>同样的，由于维护链表 LinkedHashMap 的性能比 HashMap 差一些，但是也正是这个原因在遍历 Map 中元素时，LinkedHashMap 的效率更高一些。</p><h3 id="SortedMap-amp-amp-TreeMap"><a href="#SortedMap-amp-amp-TreeMap" class="headerlink" title="SortedMap &amp;&amp; TreeMap"></a>SortedMap &amp;&amp; TreeMap</h3><p>SortedMap 为 Map 派生的一个子接口，而 TreeMap 为 SortedMap 的一个实现类。</p><p>TreeMap 是一个红黑树结构，每个 key-value 为红黑树的一个节点，而 TreeMap 存储数据时，是以 key 为标准对 key-value 进行排序。</p><p>TreeMap 的两种排序方式：</p><ul><li><p>自然排序</p><p>  TreeMap 的所有的 key 必须实现 Comparable 接口，而且所有的 key 必须为同一个类的对象，否则会报 ClassCastException 。</p><p>  key 相同的标准为：两个 key 通过 compareTo() 方法返回 0，则认为相等。</p></li><li><p>定制排序</p><p>  在 创建 TreeMap 时，传入 Comparator 对象，该对象负责对 key 进行排序，此时 key 不要求实现 Comparator 接口。 </p><p>  如果想让排序更加顺利的进行，那么需要重写 key 对应类的 equal() 方法，并且 equal() 方法的返回值与 compareTo() 的返回值表达的结果一致，否则将于 Map 接口规则冲突。</p></li></ul><p><strong>自然排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Bean implements Comparable &#123;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (this == obj) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj != null &amp;&amp; obj.getClass() == Bean.class) &#123;</span><br><span class="line">            Bean bean = (Bean) obj;</span><br><span class="line">            return age == bean.age;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Object obj) &#123;</span><br><span class="line">        Bean bean = (Bean) obj;</span><br><span class="line">        return Integer.compare(age, bean.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">       ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap();</span><br><span class="line">Bean bean = new Bean(1, &quot;mike&quot;);</span><br><span class="line">Bean bean2 = new Bean(4, &quot;mike2&quot;);</span><br><span class="line">Bean bean3 = new Bean(3, &quot;mike3&quot;);</span><br><span class="line">Bean bean4 = new Bean(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><p>TreeMap 按照 Bean 重写的 compareTo() 规则进行排序，注意重写的 equal() 需要满足以上逻辑。</p><p><strong>定制排序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap((o1, o2) -&gt; &#123;</span><br><span class="line">    Bean2 bean = (Bean2) o1;</span><br><span class="line">    Bean2 bean2 = (Bean2) o2;</span><br><span class="line">    return Integer.compare(bean.getAge(), bean2.getAge());</span><br><span class="line">&#125;);</span><br><span class="line">Bean2 bean = new Bean2(1, &quot;mike&quot;);</span><br><span class="line">Bean2 bean2 = new Bean2(4, &quot;mike2&quot;);</span><br><span class="line">Bean2 bean3 = new Bean2(3, &quot;mike3&quot;);</span><br><span class="line">Bean2 bean4 = new Bean2(1, &quot;mike4&quot;);</span><br><span class="line">treeMap.put(bean, &quot;one&quot;);</span><br><span class="line">treeMap.put(bean4, &quot;two&quot;);</span><br><span class="line">treeMap.put(bean3, &quot;three&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;four&quot;);</span><br><span class="line">treeMap.put(bean2, &quot;five&quot;);</span><br><span class="line">System.out.println(treeMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Bean&#123;age=1, name=&apos;mike&apos;&#125;=two, Bean&#123;age=3, name=&apos;mike3&apos;&#125;=three, Bean&#123;age=4, name=&apos;mike2&apos;&#125;=five&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>观字识意，WeakHashMap 与 HashMap 的区别是 WeakHashMap 中存在弱引用。</p><p>WeakHashMap 中的 key 只保留了对实际对象的弱引用，如果 WeakHashMap 对象的 key 引用的对象没有被其它强引用的变量引用，那么 key 所引用的对象在垃圾回收时很有可能被销毁，同时 WeakHashMap 也会自动移除 key 对应的 key-value 键值对。</p><h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>EnumMap 中的所有的 key 必须是 单个枚举类中的枚举值。创建 EnumMap 对象时需要指定其对应的枚举类。</p><p>EnumMap 的特征：</p><ul><li>EnumMap 内部以数组的形式保存，所以高效。</li><li>EnumMap 根据 key 的自然排序(枚举类中枚举值的定义顺序)维护 key-value 的顺序。</li><li>EnumMap key 不可为 null。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enum Num&#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EnumMap enumMap = new EnumMap(Num.class);</span><br><span class="line">enumMap.put(Num.TWO,&quot;two&quot;);</span><br><span class="line">enumMap.put(Num.ONE,&quot;one&quot;);</span><br><span class="line">enumMap.put(Num.THREE,&quot;three&quot;);</span><br><span class="line">sout(enumMap);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ONE=oen,TWO=two,THREE=three&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>Hashtable 和 HashMap 的内部实现机制几乎一样，但是由于 Hashtable 为线性安全的集合，所以 HashMap 要比 Hashtable 要快。</p><p>TreeMap 的内部通过红黑树来维护添加顺序，所以比 Hashtable、HashMap 要慢(特别是在添加元素、删除元素时，此时需要重新整理红黑树)。同时也是因为内部红黑树 TreeMap 在变量元素时比较高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.binarySearch( treeMap.keySet().toArray(),new Bean(3, &quot;mike3&quot;)));</span><br></pre></td></tr></table></figure><p>一般场景下使用 HashMap，因为 HashMap 为快速查询而设计(底层使用数组存储 key-value)。如果需要对元素进行排序，那么使用 TreeMap。</p><p>由于需要维护内部链表，LinkedHashMap 比 HashMap慢一些，与 HashMap 实现基本一致，但是 LinkedHashMap 使用 == 而不是 equal() 来判断 key 相等。</p><p>EnumMap 性能最好，但是它的 key 只能是枚举值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Map 用于保存具有 &lt;strong&gt;映射关系&lt;/strong&gt; 的数据，因此 Map 集合内保存着两组数据，一组保存 Map 的 key，一组保存 Map 的 value，并且 key 和 value 可以是任何类型的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_02.jpg&quot; alt=&quot;Map&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以把 Map 里的 Key 放在一起，它们组成一个 &lt;strong&gt;Set 集合&lt;/strong&gt;(Key 没有顺序、不可重复)，其实Map 的内部的 keySet() 方法确实是返回的所有的 key 组成的 Set 集合对象。而把 Map 内的 Value 放在一起，它们类似一个 &lt;strong&gt;List 集合&lt;/strong&gt;(可重复，此时的索引为 key)。&lt;/p&gt;
&lt;p&gt;如果抽象的看 Map 的 key 可以看作为 Set 集合(即无序、不可重复)，而 value 可以看作为 Array 集合(可重复)&lt;/p&gt;
&lt;h3 id=&quot;操作&quot;&gt;&lt;a href=&quot;#操作&quot; class=&quot;headerlink&quot; title=&quot;操作&quot;&gt;&lt;/a&gt;操作&lt;/h3&gt;&lt;p&gt;向 Map 中添加数据中，如果 Map 中有存在 key，那么新添加的 value 会覆盖原来的 value。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Map" scheme="/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之Queue</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/"/>
    <id>/2019/05/10/Java集合之Queue/</id>
    <published>2019-05-10T09:57:03.000Z</published>
    <updated>2019-09-06T06:09:29.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>Queue 用于模拟 “队列” 这种数据结构，队列为 先进先出(First In First Out,FIFO) 的容器。队列可以将元素插入尾部，可以访问位于队列头部的元素，所以队列不能随机访问队列的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 将指定元素加入队列的尾部，内部调用 offer</span><br><span class="line">     */</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    /**</span><br><span class="line">     * 将指定元素加入队列的尾部</span><br><span class="line">     */</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，并删除该元素</span><br><span class="line">     */</span><br><span class="line">    E remove();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，并删除该元素</span><br><span class="line">     */</span><br><span class="line">    E poll();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，但是不删除该元素，与 peek 唯一不同是会抛出 NoSuchElementException 异常</span><br><span class="line">     */    </span><br><span class="line">    E element();</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列头部的元素，不删除该元素</span><br><span class="line">     */</span><br><span class="line">    E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 有 PriorityQueue 实现类，同时 Queue 还有一个 Deque 接口，Deque 代表一个 “双端队列”，双端队列可以在两端进行添加、删除元素，Deque 的实现类既可以当做队列来使用也可以当做栈来使用，其有两个实现类： ArrayDeque、LinkedList。</p><h3 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h3><p>PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按队列元素的大小进行重新排序。而其排序方式有：自然排序和定制排序。两种排序规则的实现与 TreeSet 相同，不赘述。</p><p>PriorityQueue 内部通过数组实现。</p><h3 id="Deque-接口与-ArrayDeque-实现类"><a href="#Deque-接口与-ArrayDeque-实现类" class="headerlink" title="Deque 接口与 ArrayDeque 实现类"></a>Deque 接口与 ArrayDeque 实现类</h3><p>Deque 为 Queue 的子接口，代表了一个 <strong>双端队列</strong>，可以在双端添加、删除数据的，具体操作可以查看 Deque 的 Api。</p><p>与 Queue 方法不同为以上方法可以拆分为 xxxFirst()、xxxLast() 方法，代表对队列的两端进行的处理。</p><p>我们可以把 Deque 当做 <strong>队列</strong> 使用，也可以当做 <strong>栈</strong> 来使用。</p><p>与 ArrayList 相同，它们底层都是采用 <strong>一个动态的、可重新分配的 Object[] 数组</strong> 来存储集合元素。</p><p><strong>把 ArrayDeque 当做 “栈”(Fitst In Last Out,FILO) 来使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    //将 3 个元素 push 入栈</span><br><span class="line">    arrayDeque.push(&quot;one&quot;);</span><br><span class="line">    arrayDeque.push(&quot;two&quot;);</span><br><span class="line">    arrayDeque.push(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 访问第一个元素，但不出栈</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    // 第一个元素出栈</span><br><span class="line">    System.out.println(arrayDeque.pop());// 实现栈的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[three, two, one]</span><br><span class="line">three</span><br><span class="line">[two, one]</span><br></pre></td></tr></table></figure><p>ArrayDeque 很好的实现了 “栈” – <strong>先入后出</strong> 这种数据结构。在程序中使用栈时推荐使用 ArrayDeque ，避免使用 Stack(性能较差)。</p><p><strong>把 ArrayDeque 当做 “队列” 来使用</strong></p><p>当然 ArrayDeque 也可以当做队列使用，使用 <strong>先进先出</strong> 的方式操作集合元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void test3() &#123;</span><br><span class="line">    ArrayDeque arrayDeque = new ArrayDeque();</span><br><span class="line">    // 将 3 个元素加入队列</span><br><span class="line">    arrayDeque.offer(&quot;one&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;two&quot;);</span><br><span class="line">    arrayDeque.offer(&quot;three&quot;);</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.peek());</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">    System.out.println(arrayDeque.poll());//实现队列的关键</span><br><span class="line">    System.out.println(arrayDeque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[one, two, three]</span><br><span class="line">one</span><br><span class="line">[two, three]</span><br></pre></td></tr></table></figure><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>LinkedList 是 List 的实现类，同时它也实现了 Deque 接口，所以 LinkedList 可以 根据 <strong>索引</strong> 来随机访问集合的元素，也可以被当做 <strong>双端队列</strong> 来使用，由此可见 LinkedList <strong>既可以当做队列也可以当做栈来使用</strong>。</p><p>LinkedList 内部实现机制与 ArrayList 、 ArrayDeque 不同，后两者内部维护动态、可扩容的 Object[] 数组，<strong>因此访问随机集合元素的性能较高</strong>；LinkedList 内部以 <strong>链表</strong> 的形式来保存集合中的元素，因此随机访问集合元素的性能较差，但是在 <strong>插入、删除集合元素性能较高(只需改变指针所指的地址)</strong>。</p><h3 id="各种线性表的性能表现"><a href="#各种线性表的性能表现" class="headerlink" title="各种线性表的性能表现"></a>各种线性表的性能表现</h3><p>Java 中 List 是一个线性表接口，最具代表性的实现类为：ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)。Queue 代表了队列，Deque 代表了双端队列。</p><p>由于数组以一块连续内存来保存数组元素，所以数组的随机访问的性能较好，那么以数组为底层实现的集合在随机访问时性能较好；而内部以链表为顶层实现的集合在添加、删除集合元素时有较好的性能。总体上 ArrayList 的性能比 LinkedList 的性能较好，因此大部分时候选用 ArrayList。</p><p>关于使用 List 几点建议：</p><ol><li>遍历 List 集合。对于 ArrayList 、ArrayDeque 等底层实现为数组集合使用随机访问来遍历元素，这样性能更好；而对于 LinkedList 则应该使用 Itertor 迭代器来遍历集合元素。</li><li>经常添加、删除元素操作的集合，可考虑 LinkedList。使用 ArrayList、Vector 集合可能需要经常重新分配内部数组的大小，性能较差。</li><li>多个线程访问 List 集合，可以使用 Collections 工具类对集合进行包装来实现线程安全。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;Q
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Queue" scheme="/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>Java集合之List</title>
    <link href="/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/"/>
    <id>/2019/05/10/Java集合之List/</id>
    <published>2019-05-10T08:59:47.000Z</published>
    <updated>2019-09-10T02:17:01.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>List 集合为元素有序、可重复的集合。</p><p>List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。</p><p>实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new ClassE(2));</span><br><span class="line">        list.add(new ClassE(1));</span><br><span class="line">        list.add(new ClassE(3));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.sort((o1, o2) -&gt;</span><br><span class="line">            ((ClassE)o1).getNum() -((ClassE)o2).getNum()</span><br><span class="line">        );</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ClassD&#123;num=2&#125;, ClassD&#123;num=1&#125;, ClassD&#123;num=3&#125;]</span><br><span class="line">[ClassD&#123;num=1&#125;, ClassD&#123;num=2&#125;, ClassD&#123;num=3&#125;]</span><br></pre></td></tr></table></figure><a id="more"></a><p>迭代遍历：</p><p>与 Set 集合只提供了 iterator() 方法不同，List 还提供了 listiterator() 方法，返回一个 ListIterator 对象， ListIterator 接口继承了 Itertor 接口，提供了专门操作 List 的方法。</p><p>ListIterator 在遍历过程中可以通过 add() 方法向上一个迭代元素后面添加一个新的元素,如果 list 对象为排过序的集合，以上操作不会触发再次排序，而 Itertor 只能实现删除元素的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListIterator listIterator = list.listIterator();</span><br><span class="line">int a = 6;</span><br><span class="line">while (listIterator.hasNext()) &#123;</span><br><span class="line">    ClassE classE = (ClassE) listIterator.next();</span><br><span class="line">    if (classE.getNum() == 2) &#123;</span><br><span class="line">        listIterator.add(new ClassE(6));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;listIterator &quot; + classE.toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>打印日志为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listIterator ClassE&#123;num=1&#125;</span><br><span class="line">listIterator ClassE&#123;num=2&#125;</span><br><span class="line">listIterator ClassE&#123;num=3&#125;</span><br><span class="line">[ClassE&#123;num=1&#125;, ClassE&#123;num=2&#125;, ClassE&#123;num=3&#125;, ClassE&#123;num=6&#125;]</span><br></pre></td></tr></table></figure><h3 id="ArrayList-和-Vector-类"><a href="#ArrayList-和-Vector-类" class="headerlink" title="ArrayList 和 Vector 类"></a>ArrayList 和 Vector 类</h3><p>ArrayList 和 Vector 在用法上几乎一致， Vector 在 JDK 1.0 就有了，那时候还没有 Java 集合框架的概念。在 JDK 1.2 将 Vector改为实现 List 接口，而 Vector 作为 List 的实现之一。</p><p>ArrayList 和 Vector 作为 List 的典型实现，支持 List 接口的全部功能。</p><p>ArrayList 和 Vector 都是基于数组实现的 List 类，在ArrayList 和 Vector <strong>内部封装了一个动态的、允许再分配的 Object[] 数组</strong>，使用 initiaCapacity 来初始化数组的长度，当数组元素超过数组的长度时，数组长度自动增加 initiaCapacity ,即长度增加 <strong>0.5</strong> 倍。</p><p>线程安全性：</p><ul><li>ArrayList 为线程不安全的，可以使用 Collections 工具类使 ArrayList 变成线程安全的。</li><li>Vector 时线程安全的，所以 Vector 性能比 ArrayList 低， 但是不推荐使用 Vector。</li></ul><h3 id="Vector-的子类-–-Stack"><a href="#Vector-的子类-–-Stack" class="headerlink" title="Vector 的子类 – Stack"></a>Vector 的子类 – Stack</h3><p>Vector 有一个子类 Stack，用于模拟 “栈”  这种数据结构：</p><ol><li>出栈 <ol><li>peek()：返回栈中的第一个元素，但是不将该元素移除。</li><li>pop():返回栈中的第一个元素，会将该元素移除</li></ol></li><li>进栈<ol><li>push(Object obj): 将元素压入栈，该元素位于集合的顶部。</li></ol></li></ol><p><strong>但是也应该尽量的避免使用 Stack，如果需要“栈”这种数据结构，可以使用 ArrayDeque</strong>。</p><p>ArrayDeque 是实现了 List 接口，也实现了 Deque 接口，因此可以作为栈使用，其也是基于数组的实现。</p><h3 id="固定长度的-List"><a href="#固定长度的-List" class="headerlink" title="固定长度的 List"></a>固定长度的 List</h3><p>Java 中有一个操作数组的工具类：<code>Arrays</code>，该工具类的 asList(Object …obj) 方法 <strong>可以把一个数组或指定个数的对象转换成一个 List 集合</strong>，这个 List 不是 ArrayList 或 Vector 的实现类，<strong>而是 Arrays 的内部类 ArrayList 的实例</strong>。 Arrays$ArrayList 为一个固定大小的 List  集合，不可删除或增加集合里的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = Arrays.asList(new Object());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;List 集合为元素有序、可重复的集合。&lt;/p&gt;
&lt;p&gt;List 集合判断元素相等的标准：两个对象的 equals() 方法比较返回值为 true 。&lt;/p&gt;
&lt;p&gt;实现排序：List 的 sort() 方法需要一个 Comparator 对象来控制元素的排序。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List list = new ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(2));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.add(new ClassE(3));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.sort((o1, o2) -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ((ClassE)o1).getNum() -((ClassE)o2).getNum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(list);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;打印日志：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ClassD&amp;#123;num=1&amp;#125;, ClassD&amp;#123;num=2&amp;#125;, ClassD&amp;#123;num=3&amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="List" scheme="/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之Lifecycle 笔记</title>
    <link href="/2019/05/10/Jetpack%E4%B9%8BLifecycle-%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/10/Jetpack之Lifecycle-笔记/</id>
    <published>2019-05-10T02:42:25.000Z</published>
    <updated>2019-07-10T07:25:59.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。</p><p>传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。</p><p><code>android.arch.lifecycle</code> 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。</p><h3 id="0x0001-Lifecycle"><a href="#0x0001-Lifecycle" class="headerlink" title="0x0001 Lifecycle"></a>0x0001 Lifecycle</h3><p>Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，  可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。</p><a id="more"></a><p>Lifecycle 使用两个重要的枚举类来跟踪它所关联的组件的生命周期状态：</p><ul><li><p>Event</p><p>  从 Android Framework 层面和 Lifecycle 类调度的生命周期事件,这些事件映射到 A/F 中的回调事件。</p></li><li><p>State</p><p>  Lifecycle 对象跟踪的组件的当前状态。</p></li></ul><p>下图展示 Event 和 State 的关联关系</p><p><img src="https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.png" alt="Event和Statue"></p><p>在图中 State 作为一个个结点，作为事件间的边缘。</p><p>LifecycleObserver 通过在在其方法上添加注解来监听组件的状态，LifecycleOwner 通过 addObserver() 关联此 Observer 。</p><h3 id="0x0002-LifecycleOwner"><a href="#0x0002-LifecycleOwner" class="headerlink" title="0x0002 LifecycleOwner"></a>0x0002 LifecycleOwner</h3><p>通过实现 LifecycleOwner 接口来 <strong>表明该类具有生命周期</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ComponentActivity extends Activity</span><br><span class="line">        implements LifecycleOwner, KeyEventDispatcher.Component</span><br></pre></td></tr></table></figure><p>LifecycleOwner 只有一个方法 getLifecycle()。</p><p>可见我们最常使用的 AppCompatActivity 已经对 LifecycleOwner 做了兼容。实现 LifecycleObserver 的类作为 <code>观察者</code> 监听实现 实现 LifecycleOwner 接口类的声明周期的变化。</p><p><strong>LiveData 的生命周期相关就是通过这种方式实现的。</strong></p><h3 id="0x0003-自定义-LifecycleOwner"><a href="#0x0003-自定义-LifecycleOwner" class="headerlink" title="0x0003 自定义 LifecycleOwner"></a>0x0003 自定义 LifecycleOwner</h3><p>如果自定义实现 LifecycleOwner ,那么需要使用 LifecycleRegistry ,这个类用来管理多个 LifecycleObserver ,在其内部通过 Map 来存储 LifecycleObserver 对象。</p><p>自定义 LifecycleOwner 时，需要在相应的方法中显示的声明事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : Activity(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    private lateinit var lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(this)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override fun onStart() &#123;</span><br><span class="line">        super.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun getLifecycle(): Lifecycle &#123;</span><br><span class="line">        return lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0004-LifecycleObserver"><a href="#0x0004-LifecycleObserver" class="headerlink" title="0x0004 LifecycleObserver"></a>0x0004 LifecycleObserver</h3><p>生命周期的观察者，它的主要作用是监听 LifecycleOwner 对象的生命周期变化，通过注解的方式,将 LifecycleOwner 生命周期的变化映射到自己相应的方法上，并在自己的方法中进行相关业务处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CustomObserver : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun initObserver()&#123;</span><br><span class="line">        Log.e(&quot;initObserver&quot;,&quot;initObserver&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    fun back()&#123;</span><br><span class="line">        Log.e(&quot;back&quot;,&quot;back&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TestLifecycleActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_test_lifecycle)</span><br><span class="line">        lifecycle.addObserver(CustomObserver())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0005-Lifecycle-aware-组件最佳实践"><a href="#0x0005-Lifecycle-aware-组件最佳实践" class="headerlink" title="0x0005 Lifecycle-aware 组件最佳实践"></a>0x0005 Lifecycle-aware 组件最佳实践</h3><ol><li>尽可能保证 UI 组件简单，比如不要在 UI 中获取数据，而在 ViewModel 中做这些事情， LiveData 对象会在数据变化后更新 UI。</li><li>尽可能在 ViewModel 中编写逻辑代码，ViewModel 应该是 UI(A/F) 和其他部分的桥梁。 但是这并不是说 ViewModel 的职责是获取数据，而应该调用其他组件来获取数据并返回 UI。</li><li>使用 DataBinding 来维护 UI 和 View 间关系。这使得可以使用更少的代码来更新 UI 。</li><li>如果 UI 十分复杂，可以考虑创建 presenter 来处理 UI 更改工作，虽然这个过程是费精力的，但是这对测试是十分友好的。</li><li>避免在 ViewModel 中引用 View 和 Context，避免造成内存泄漏。</li><li>使用 Kotlin 的协程来管理长时间运行的任务以及可以异步运行的其他操作。</li></ol><h3 id="0x0006-何时使用-lifecycle-awar-组件"><a href="#0x0006-何时使用-lifecycle-awar-组件" class="headerlink" title="0x0006 何时使用 lifecycle-awar 组件"></a>0x0006 何时使用 lifecycle-awar 组件</h3><ol><li>在粗粒度和细粒度的两种状态的地图切换展示。当 UI 在前台时使用细粒度的地图，在后台时切换为粗粒度的地图。</li><li>暂停和恢复动画。UI 在后台暂停动画，在前台恢复动画。</li></ol><h3 id="0x0007-关于-LiveData-的实现"><a href="#0x0007-关于-LiveData-的实现" class="headerlink" title="0x0007 关于 LiveData 的实现"></a>0x0007 关于 LiveData 的实现</h3><p>LiveData 同为 生命中期感知组件，其实它这种功能的实现主要是依托了 Lifecycle 的实现。在 LiveData 的 obsever() 方法中将 LiveData的 Observer 包装成 LifecycleObserver 并与 LifecycleOwner 相关联，至此 LiveData 实现了生命周期的感知功能。</p><p>LiveData#observe(@NonNull LifecycleOwner owner, @NonNull Observer<t> observer) 源码：</t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123;</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        // ignore</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing != null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // LifecycleOwnner 添加 LifecycleObserver</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上为个人翻译官方文档</p><p>以下为优秀博客：</p><p><a href="https://www.jianshu.com/p/b1208012b268" target="_blank" rel="noopener">Android官方架构组件Lifecycle:生命周期组件详解&amp;原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;在 A/F 生命周期变化后，生命周期感知组件(Lifecycle—aware component)会响应相应动作，它会帮助你编写有良好组织的、轻量级、易维护的代码。&lt;/p&gt;
&lt;p&gt;传统模式下，要想做的生命感知需要做的是实现其他组件的接口，并在 A/F 的生命周期函数中调用其他组件的方法。但是这样并不是好的代码组织方式，并且容易产生错误。而通过 生命周期感知组件(Lifecycle—aware component) 可以把这部分逻辑从 A/F 中移到组件自身中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android.arch.lifecycle&lt;/code&gt; 包下的类和接口允许你创建 生命周期感知组件(lifecycle-aware components),它们可以根据 A/F 的生命周期来调整自己的行为。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-Lifecycle&quot;&gt;&lt;a href=&quot;#0x0001-Lifecycle&quot; class=&quot;headerlink&quot; title=&quot;0x0001 Lifecycle&quot;&gt;&lt;/a&gt;0x0001 Lifecycle&lt;/h3&gt;&lt;p&gt;Lifecycle 持有 A/F 组件有关生命周期的信息，并且允许其他对象监听它的状态。在 Android API 26.0.1以及其后 A/F实现了LifecycleOwner，  可在 A/F 中通过 getLifecycle() 获得 A/F 的 Lifecycle 对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="Lifecycle" scheme="/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合之 Set 集合 </title>
    <link href="/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/"/>
    <id>/2019/05/09/Java-集合之-Set/</id>
    <published>2019-05-09T07:49:35.000Z</published>
    <updated>2019-09-09T08:44:00.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p>Set 集合的特点无序、不可重复。</p><p>Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。</p><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>HashSet 集合按 <code>Hash 算法</code> 来存储集合的元素，<strong>因此具有很好的存取和查找功能</strong>。</p><p>HashSet 具有以下特点：</p><ol><li>不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。</li><li>HashSet 不是线程安全的。</li><li>元素可以为 null。</li></ol><a id="more"></a><h3 id="如何存储元素"><a href="#如何存储元素" class="headerlink" title="如何存储元素"></a>如何存储元素</h3><p>当向 HashSet 集合存入一个元素时， HashSet 会调用该对象的 <code>hashcode()</code> 方法来得到对象的 <code>hashcode</code> 值，<strong>然后根据该 hashcode 值决定对象在 HashSet 中的存储位置</strong>。如果两个元素通过 equals() 方法比较返回 true，但是它们的 hashcode() 方法返回值不相等，那么 HashSet 会把它们存储在不同的位置，可以添加成功。</p><h3 id="HashSet-如果定义元素相等"><a href="#HashSet-如果定义元素相等" class="headerlink" title="HashSet 如果定义元素相等"></a>HashSet 如果定义元素相等</h3><p>HashSet 集合判断两个元素相等的标准是：</p><ol><li>两个对象通过 equals() 方法比较相等。</li><li>两个对象的 hashcode() 方法的返回值也相等。</li></ol><p><strong>两者缺一不可</strong>。</p><p>所以当把一个对象放入 HashSet 中时，如果需要重写对象的 equals() 方法，那么也应该重写 hashcode() 方法。<strong>重写两方法的规则是：如果两个对象的 equals() 方法返回 true，这两个对象的 hashcode 也应该相同。</strong></p><p>两个对象的 equals() 方法返回 true，hashcode 返回不同的 hashcode 值，HashSet 会把两个对象保存在 Hash 表的不同位置，两个元素都会添加成功，但是这与 Set 集合的规则冲(元素不可重复)突了。如果是 equals() 方法返回 false，但是 hashcode 值相同，也会导致一些问题：hashcode 相同，HashSet 会尝试将多个元素保存在同一个位置，但又不行(这样的结果就是只剩下一个对象)，所以这样的结果就是在这个位置上通过链式结构来保存多个对象。HashSet 的特点就是通过元素的 hashcode 值来快速定位，而现在 HashSet 对象中有两个以上的元素具有相同的hashcode 值，导致性能下降。</p><h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><p>哈希算法的功能是，他能快速的查找被检索的对象，<strong>hash 算法的价值在于速度</strong>。当查询集合中的某个元素时，hash 算法可以直接根据该元素的 hashcode 值计算出该元素的存储位置，从而快速定位该元素。实现快速定位的原因是 HashSet 通过 hashcode 的值进行存储元素。</p><h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><p>由上面可知 hashCode() 方法对于 HashSet 的重要性，那么针对 hashCode() 方法的重写有如下规则：</p><ol><li>同一个对象多次调用 hashCode 方法应该返回相同的值。</li><li>两个对象通过 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法应返回相同的值。</li><li>对象中用于比较 equals() 方法比较标准的实例变量都应该用于计算 hashCode 值。</li><li>程序把可变对象添加到 HashSet 中之后，尽量不要去修改集合元素中参与计算 hashCode()、equals() 的实例变量，否则会导致 HashSet 无法正确的操作这些集合元素。</li></ol><h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>LinkedHashSet 为 HashSet 的一个子类，LinkedHashSet 也是通过hashcode 的值来决定元素的存储位置，<strong>但同时使用链表维护元素的次序</strong>，使得元素看起来是以插入顺序保存的。因为需要维护元素的插入顺序，所以性能略低于 HashSet。但是在迭代访问 Set 集合中的全部元素时有很好的性能，因为它以链表维护内部顺序。</p><p>遍历 LinkedHashSet 集合元素时，元素的顺序与添加顺序一致。</p><h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>TreeSet 为 SortSet 接口的实现类，其可以确保集合元素处于 <strong>排序状态</strong>。TreeSet 不是根据添加顺序进行排序而是 <strong>根据元素的实际值进行排序</strong>。</p><p>与 HashSet 根据 hash 算法来决定元素的存储位置不同，TreeSet 采用 <strong>红黑树</strong> 的数据结构来存储集合元素。TreeSet 支持两种排序算法：自然排序(默认)和定制排序。</p><h3 id="TreeSet-自然排序"><a href="#TreeSet-自然排序" class="headerlink" title="TreeSet 自然排序"></a>TreeSet 自然排序</h3><p>如果将一个对象添加到 TreeSet 中，那么 <strong>这个对象必须实现 Comparable 接口</strong>，依次来实现排序功能，否则程序会报出异常。</p><p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后按升序排列，这就是 TreeSet 的自然排序。</p><p><strong>元素如何存储到集合中</strong></p><p>当把一个元素添加到 TreeSet 集合中， TreeSet 会调用这个对象的 compareTo(Object obj) 方法与集合中的其他元素比较大小，<strong>然后根据红黑树结构找到它的存储位置</strong>。如果两个对象通过 compareTo(Object obj) 方法比较相等，那么新的对象将不会添加到集合中。</p><p>如果想要 TreeSet 能够正常运行，那么 TreeSet 只能添加同一种类型的对象。</p><p><strong>判断集合元素相同</strong></p><p><strong>TreeSet 集合元素相等的唯一标准为：两个对象的 compareTo(Object obj) 方法是否返回 0，返回 0 则认为两个对象相等，反之不相等</strong>。基于以上标准，在重写 equals() 方法时，其返回值需要与 compareTo(Object obj) 的返回结果一致，否则 equals() 方法的返回值没有实际意义。</p><p>通过重写 compareTo(Object obj) 方法，使其不返回 0，此时可以实现将一个对象多次添加到 TreeSet集合中，但是此时集合多个元素均指向一个对象引用，如果对象发生变化，那么集合中的多个元素会同时发生相同变化。</p><p>基于以上描述，在重写对象类的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果，如果equals() 方法返回 true ，那么这两个对象通过 compareTo(Object obj) 方法应该返回 0。</p><p>改变Treeset 集合中的可变元素的实例变量后，这会导致它与其他对象的大小顺序发生改变，但是 TreeSet 不会再次调整它们的顺序。当尝试删除该对象时，TreeSet 也会删除失败。所以基于此原因 <strong>TreeSet 可以删除没有被修改实例变量、且不与其他被修改的实例变量的对象重复的对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeSet treeSet = new TreeSet();</span><br><span class="line">Dog dog1 = new Dog(&quot;mike&quot;,1);</span><br><span class="line">Dog dog2 = new Dog(&quot;mike&quot;,2);</span><br><span class="line">Dog dog3 = new Dog(&quot;mike&quot;,3);</span><br><span class="line">Dog dog4 = new Dog(&quot;mike&quot;,4);</span><br><span class="line">treeSet.add(dog1);</span><br><span class="line">treeSet.add(dog2);</span><br><span class="line">treeSet.add(dog3);</span><br><span class="line">treeSet.add(dog4);</span><br><span class="line">System.out.println(&quot;1 &quot; + treeSet);</span><br><span class="line">treeSet.remove(dog1);</span><br><span class="line">System.out.println(&quot;2 &quot; +treeSet);</span><br><span class="line">Dog showDog = (Dog) treeSet.first();</span><br><span class="line">showDog.setAge(6);</span><br><span class="line">System.out.println(&quot;3 &quot; +treeSet);</span><br><span class="line">System.out.println(&quot;4 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,6)));</span><br><span class="line">System.out.println(&quot;5 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,2)));</span><br><span class="line">System.out.println(&quot;6 &quot; +treeSet.first());</span><br><span class="line">System.out.println(&quot;7 &quot; +treeSet.remove(treeSet.first()));</span><br><span class="line">System.out.println(&quot;8 &quot; +treeSet);</span><br></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 [Dog&#123;name=&apos;mike&apos;, age=1&#125;, Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">2 [Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">3 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">4 false</span><br><span class="line">5 false</span><br><span class="line">6 Dog&#123;name=&apos;mike&apos;, age=6&#125;</span><br><span class="line">7 false</span><br><span class="line">8 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br></pre></td></tr></table></figure><p>可以看到 日志3 TreeSet 对象并没有重新排序，通过日志 4、5、7 可以对象更改后 TreeSet 无法对其进行删除。</p><h3 id="TreeSet-定制排序"><a href="#TreeSet-定制排序" class="headerlink" title="TreeSet 定制排序"></a>TreeSet 定制排序</h3><p>实现定制排序，则需要在创建 TreeSet 集合对象时结合 Comparator 对象，<strong>并由 Comparator 负责集合元素的排序逻辑</strong>。</p><p>如例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">        TreeSet treeSet = new TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            ClassD classD1 = (ClassD) o1;</span><br><span class="line">            ClassD classD2 = (ClassD) o2;</span><br><span class="line">            if(classD1.getNum() == classD2.getNum())&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return classD1.getNum() &gt; classD2.getNum() ? -1 : 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(new ClassD(1));</span><br><span class="line">        treeSet.add(new ClassD(-1));</span><br><span class="line">        treeSet.add(new ClassD(0));</span><br><span class="line">//        ClassD classD = new ClassD(2);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 打印日志：[ClassD&#123;num=1&#125;, ClassD&#123;num=0&#125;, ClassD&#123;num=-1&#125;]</span><br></pre></td></tr></table></figure><p>对于自然排序和定制排序而言，添加到 TreeSet 集合对象中的元素应该为同一种类型的对象，否则会引发 ClassCastException 异常。</p><h3 id="3-EnumSet-类"><a href="#3-EnumSet-类" class="headerlink" title="3. EnumSet 类"></a>3. EnumSet 类</h3><p>EnumSet 是一个专门为枚举类设计的集合类， EnumSet 中的所有的元素都必须是枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式的指定。EnumSet 的集合元素也是有顺序的，<strong>EnumSet 以枚举值在枚举类中的定义顺序来决定集合元素在顺序</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumA &#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void test4() &#123;</span><br><span class="line">        EnumSet enumSet = EnumSet.noneOf(EnumA.class);</span><br><span class="line">        enumSet.add(EnumA.ONE);</span><br><span class="line">        enumSet.add(EnumA.THREE);</span><br><span class="line">        enumSet.add(EnumA.TWO);</span><br><span class="line">        System.out.println(enumSet);</span><br><span class="line">        EnumSet enumSet2 = EnumSet.allOf(EnumA.class);</span><br><span class="line">        System.out.println(enumSet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">// 打印日志：</span><br><span class="line">[ONE, TWO, THREE]</span><br><span class="line">[ONE, TWO, THREE]</span><br></pre></td></tr></table></figure><p>EnumSet在内部以位向量的形式保存，这种存储方式十分的高效，所以 EnumSet 占用的内存小、运行效率高。</p><p><strong>EnumSet 不可添加 null 元素。</strong></p><h3 id="各-Set-集合的性能"><a href="#各-Set-集合的性能" class="headerlink" title="各 Set 集合的性能"></a>各 Set 集合的性能</h3><p>HashSet 和 TreeSet 为 Set 集合的两个典型实现，两者如何选择呢？</p><p>由于 TreeSet 内部需要额外的红黑二叉树维护元素的添加顺序，所以 HashSet 的效率高于 TreeSet。<strong>当需要保持排序的 Set 时才使用 TreeSet，否则使用 HashSet。</strong></p><p>LinkedHashSet 为 HashSet 的子类，对于删除、插入操作 LinkedHashSet 比 HashSet 稍慢一些，这是因为 LinkedHashSet 内部需要维护链表造成的，但正是这个原因，遍历操作时 LinkedHashSet 会更快一些。</p><p>EnumSet 是所有 Set 集合中效率最好的，但是它只能保存他一个枚举类的枚举值作为集合元素。</p><p>Set 的三个实现类 HashSet 、TreeSet、 EnumSet 都是 <strong>线程不安全的</strong>，多个线程操作 Set 集合时需保证线程同步。通常使用 Collections  工具类的 synchronizedSortSet 方法来包装该 Set 集合，此操作最好在创建时进行，以防止对 Set 集合意外的非同步访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet treeSet = Collections.synchronizedSortedSet(new TreeSet((o1,o2)-&gt;&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Set-集合&quot;&gt;&lt;a href=&quot;#Set-集合&quot; class=&quot;headerlink&quot; title=&quot;Set 集合&quot;&gt;&lt;/a&gt;Set 集合&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/../images/2019_05_09_01.jpg&quot; alt=&quot;List、Set、Queue&quot;&gt;&lt;/p&gt;
&lt;p&gt;Set 集合的特点无序、不可重复。&lt;/p&gt;
&lt;p&gt;Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。&lt;/p&gt;
&lt;h3 id=&quot;HashSet-类&quot;&gt;&lt;a href=&quot;#HashSet-类&quot; class=&quot;headerlink&quot; title=&quot;HashSet 类&quot;&gt;&lt;/a&gt;HashSet 类&lt;/h3&gt;&lt;p&gt;HashSet 集合按 &lt;code&gt;Hash 算法&lt;/code&gt; 来存储集合的元素，&lt;strong&gt;因此具有很好的存取和查找功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;HashSet 具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。&lt;/li&gt;
&lt;li&gt;HashSet 不是线程安全的。&lt;/li&gt;
&lt;li&gt;元素可以为 null。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
      <category term="Set" scheme="/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合概述</title>
    <link href="/2019/05/09/Java-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <id>/2019/05/09/Java-集合概述/</id>
    <published>2019-05-09T03:06:58.000Z</published>
    <updated>2019-09-06T08:21:44.151Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java<br> 集合来实现常见的数据结构，如堆、栈等。</p><h3 id="Java-集合的分类"><a href="#Java-集合的分类" class="headerlink" title="Java 集合的分类"></a>Java 集合的分类</h3><p> Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：</p><ul><li>List：有序、可重复的集合。</li><li>Set：无序、不可重复的集合。</li><li>Map：具有映射关系的集合。</li><li>Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。</li></ul><p>谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。</p><p>Java 集合可用来 <strong>存储对象</strong>，因此被称为 <strong>容器类</strong>。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。</p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/" target="_blank" rel="noopener">Java 集合之 List</a></p><p><a href="https://leegyplus.github.io/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/" target="_blank" rel="noopener">Java 集合之 Set</a></p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/" target="_blank" rel="noopener">Java 集合之 Map</a></p><p><a href="https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/" target="_blank" rel="noopener">Java 集合之 Queue</a></p><p><a href="https://leegyplus.github.io/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/" target="_blank" rel="noopener">Java 集合工具类–Collections</a></p><a id="more"></a><h3 id="Java-集合继承树"><a href="#Java-集合继承树" class="headerlink" title="Java 集合继承树"></a>Java 集合继承树</h3><p>Java 集合主要是 Collection 和 Map 的派生类，集合的继承关系如下:</p><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p><p><img src="/../images/2019_05_09_02.jpg" alt="Map"></p><h3 id="Collection-和-Iterator-接口"><a href="#Collection-和-Iterator-接口" class="headerlink" title="Collection 和 Iterator 接口"></a>Collection 和 Iterator 接口</h3><p>List、Set、Queue 都是继承了 Collection 接口，那么该接口定义的方法都可以操作以上集合。</p><p>集合本就是容器，那么相应的操作：增加、删除、替换、清空等，也就对应了相应的方法。</p><p>Iterator 与 Collection 、Map 不同，Collection 、Map 主要的功能是为了盛放其他对象，而 <strong>Iterator 的主要用于遍历 Collection 集合中的元素</strong>，所以 Iterator 对象也被称为 <strong>迭代器</strong>。</p><p>Itertor 仅用于遍历元素，其本身不能盛放对象的能力，Itertor 对象的创建必须依托于 Collection，没有 Collection 的 Itertor 没有任何价值。</p><p>为了更好的理解 Itertor 看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList();</span><br><span class="line">    list.add(&quot;a&quot;);</span><br><span class="line">    list.add(&quot;b&quot;);</span><br><span class="line">    list.add(&quot;c&quot;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        String str = (String) iterator.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        if (str.equals(&quot;c&quot;))&#123;</span><br><span class="line">            iterator.remove();//2</span><br><span class="line">            // 使用 Itertor 遍历集合时，不可修改集合元素，以下代码引发异常</span><br><span class="line">            //list.remove(str);//3</span><br><span class="line">        &#125;</span><br><span class="line">        str = &quot;Chage&quot;;//1</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c]</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">[a, b]</span><br></pre></td></tr></table></figure><p>在这里我们看到了一个很有意思的现象，在 <code>代码1</code> 处对迭代变量 str 赋了新值，但是通过打印日志我们看到 list 的元素并没有被改变。</p><p><strong>这是因为 Itertor 在对集合进行遍历时，Itertor 并不是把集合元素本身传给了迭代变量 str，仅仅是把集合元素的值传给 迭代变量 str，所以修改迭代变量 str 的值不会对集合元素有任何影响。</strong></p><p>当通过 <code>Itertor</code> 迭代遍历 <code>Collection</code> 中的集合元素时，Collection 集合中的元素不能被改变，<strong>只有通过 Itertor 的 remove() 方法删除上一次 next() 方法返回的值，否则就会引起 java.util.ConcurrentModificationException 异常</strong>，将 <code>代码2</code> 处替换为 <code>代码3</code> 就会报出异常。</p><h3 id="使用-foreach-遍历集合元素"><a href="#使用-foreach-遍历集合元素" class="headerlink" title="使用 foreach 遍历集合元素"></a>使用 foreach 遍历集合元素</h3><p>同 Itertor 一样，通过 foreach 遍历元素过程中也不能修改集合元素，系统同样也是把集合的元素的值赋值个迭代变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123;</span><br><span class="line">    String value = str;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">    if (str.equals(&quot;c&quot;)) &#123;</span><br><span class="line">        // 下面的代码同样也会引起 ConcurrentModificationException 异常</span><br><span class="line">        list.remove(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 集合在日常的开发中的使用频率是很高的，我们可以通过 Java&lt;br&gt; 集合来实现常见的数据结构，如堆、栈等。&lt;/p&gt;
&lt;h3 id=&quot;Java-集合的分类&quot;&gt;&lt;a href=&quot;#Java-集合的分类&quot; class=&quot;headerlink&quot; title=&quot;Java 集合的分类&quot;&gt;&lt;/a&gt;Java 集合的分类&lt;/h3&gt;&lt;p&gt; Java 集合分为 List、Set、Map、Queue 四种体系，以下为各个体系的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List：有序、可重复的集合。&lt;/li&gt;
&lt;li&gt;Set：无序、不可重复的集合。&lt;/li&gt;
&lt;li&gt;Map：具有映射关系的集合。&lt;/li&gt;
&lt;li&gt;Queue：Java5 后增加了 Queue 体系，代表队列的一种实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;谈到集合就不得不提在 Java5 增加的泛型，但是不在这里进行阐述。&lt;/p&gt;
&lt;p&gt;Java 集合可用来 &lt;strong&gt;存储对象&lt;/strong&gt;，因此被称为 &lt;strong&gt;容器类&lt;/strong&gt;。与 数组既可以存储基本数据类型也可以存储对象不同，集合只能存储对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BList/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 List&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/09/Java-%E9%9B%86%E5%90%88%E4%B9%8B-Set/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Set&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BMap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/10/Java%E9%9B%86%E5%90%88%E4%B9%8BQueue/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合之 Queue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leegyplus.github.io/2019/05/29/Java-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB-Collections/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 集合工具类–Collections&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java Collection" scheme="/tags/Java-Collection/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之LiveData 笔记</title>
    <link href="/2019/05/08/Jetpack%E4%B9%8BLiveData-%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/08/Jetpack之LiveData-笔记/</id>
    <published>2019-05-08T03:21:37.000Z</published>
    <updated>2019-07-10T07:41:28.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x000-概述"><a href="#0x000-概述" class="headerlink" title="0x000 概述"></a>0x000 概述</h3><p>在官方文档中首先对 LiveData 做了一个概述 : <code>LiveData is an observable data holder class</code>, LiveData 是一个 <strong>可观察的</strong> <strong>数据持有者类</strong>。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 <strong>活跃状态下</strong> 更新组件。</p><p>LiveData 认为上述中的 <strong>活跃状态</strong> 为对应的 Observer 处于 <strong>STARTED</strong> 或 <strong>RESUMED</strong> 状态。LiveData 数据更改不会触发非活跃组件的更新。</p><p>LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。</p><h3 id="0x0001-个人理解"><a href="#0x0001-个人理解" class="headerlink" title="0x0001 个人理解"></a>0x0001 个人理解</h3><p>官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:</p><p><code>public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer)</code> </p><a id="more"></a><p>第一个参数为 LifecycleOwner 对象，一般为 Activity/Fragment/Servic 对象，第二参数为 Observer 对象，它的重要工作是一个回调– <code>onChanged(T t)</code>，用于更新 UI 等工作。</p><p> LiveData#observe() 方法中完成了对 observer 的包装，并将其添加到 LifecycleOwner 对象观察者列表中，完成了 observer 关联 LifecycleOwner 生命周期的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> @MainThread</span><br><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    assertMainThread(&quot;observe&quot;);</span><br><span class="line">    if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    ....</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 LiveData 就实现了如下功能；<br>    1. 数据更改时触发处于 ACTIVE 的组件的功能。<br>    2. UI 生命周期变更时，LiveData 会通知 Observer。</p><h4 id="0x0002-LiveData-优点"><a href="#0x0002-LiveData-优点" class="headerlink" title="0x0002 LiveData 优点"></a>0x0002 LiveData 优点</h4><ol><li><p>保证 UI 与 实时数据完美匹配，这种模式下：</p><ol><li>UI 生命周期变更时，LiveData 会通知 Observer。</li><li>LiveData 在数据发生变化时，通知 Observer 对象更新 UI，这就保证了数据在每次变更时 <strong>自动更新 UI</strong>, 而不需要手动的更新 UI。</li></ol></li></ol><ol start="2"><li><p>不会内存泄漏</p><p> Lifecycle 对象销毁后(Activity/Framgent/Service)，Observer 与 Lifecycle 对象 的绑定关系会被移除，这样就不会因为两者的互相引用而导致无法回收对象。</p></li><li><p>不会因为 Activity 的停止而导致崩溃</p><p> Observer 处于 InActive 状态时, 它不会接收到 LiveData 的 Event。根据 LiveData 的相关定义只有在 LifecycleOwner 的状态为 START 或 RESUME 时 Observer 才处于 Active 状态。</p></li><li><p>不再需要手动生命周期处理</p><p> UI组件只是观察相关数据，不会停止或恢复观察。LiveData自动管理生命周期，因为它可以观察到组件的生命周期状态变化。</p></li><li><p>时刻保持最新的数据</p><p> 当 LifecycleOwner 的生命周期从 incative 转换到 active 时，会更新最新的数据。</p></li><li><p>旋转屏幕等配置发生变化时，可以收到最新数据</p></li><li><p>共享数据资源<br>LiveData 对象一致，那么那所持有的数据或资源就可以被多个页面共享。</p></li></ol><h3 id="0x0003-使用-LiveData"><a href="#0x0003-使用-LiveData" class="headerlink" title="0x0003 使用 LiveData"></a>0x0003 使用 LiveData</h3><ol><li>创建 LiveData 对象。</li><li>观察 LiveData 对象，传入 LifecycleOwner 和 Observer ,以 LiveData 为桥梁，创建两者的监听关系。</li><li>变更 LiveData 所持有的数据。</li></ol><p>能够触发 App 组件更新的唯一情况是 LiveData 的数据源发生变化，即</p><pre><code>1. 调用了 LiveData 的 setValue(T)// 在主线程中变更数据2. 调用了 LiveData 的 postValue(T)// 在 Worker 线程执行操作</code></pre><h3 id="0x0004-自定义-LiveData"><a href="#0x0004-自定义-LiveData" class="headerlink" title="0x0004 自定义 LiveData"></a>0x0004 自定义 LiveData</h3><h3 id="1-转换-LiveData"><a href="#1-转换-LiveData" class="headerlink" title="1. 转换 LiveData"></a>1. 转换 LiveData</h3><p>和 Rxjava 相似，通过使用 <code>Transformations</code> 的操作符转换 LiveData 对象。</p><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. map()</h4><p>该操作符做转换的工作如下：</p><pre><code>LiveData&lt;T&gt; -&gt; LiveData&lt;R&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line">val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;</span><br><span class="line">    user -&gt; &quot;$&#123;user.name&#125; $&#123;user.lastName&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中通过 map 实现了 LiveData<user> 向 LiveData<string> 的转换。</string></user></p><h4 id="3-switchMap"><a href="#3-switchMap" class="headerlink" title="3. switchMap()"></a>3. switchMap()</h4><p>该操作符做转换的工作如下：</p><pre><code>LiveData&lt;T&gt; -&gt; LiveData&lt;R&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private fun getUser(id: String): LiveData&lt;User&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">val userId: LiveData&lt;String&gt; = ...</span><br><span class="line">val user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure><p>本例中通过 map 实现了 LiveData<string> 向 LiveData<user> 的转换。</user></string></p><p>switchMap 和 map 都实现了 LiveData 所持有数据类型的转换，但是与 map() 不同的 switchMap 的第二个参数 Function 的返回值类型必须为 LiveData。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x000-概述&quot;&gt;&lt;a href=&quot;#0x000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x000 概述&quot;&gt;&lt;/a&gt;0x000 概述&lt;/h3&gt;&lt;p&gt;在官方文档中首先对 LiveData 做了一个概述 : &lt;code&gt;LiveData is an observable data holder class&lt;/code&gt;, LiveData 是一个 &lt;strong&gt;可观察的&lt;/strong&gt; &lt;strong&gt;数据持有者类&lt;/strong&gt;。它是可以感知 Activity/Fragment/Service 的生命周期的，这使得 LiveData 只会在以上组件处于 &lt;strong&gt;活跃状态下&lt;/strong&gt; 更新组件。&lt;/p&gt;
&lt;p&gt;LiveData 认为上述中的 &lt;strong&gt;活跃状态&lt;/strong&gt; 为对应的 Observer 处于 &lt;strong&gt;STARTED&lt;/strong&gt; 或 &lt;strong&gt;RESUMED&lt;/strong&gt; 状态。LiveData 数据更改不会触发非活跃组件的更新。&lt;/p&gt;
&lt;p&gt;LiveData 与 观察者(实现 LifecycleOwner 的类) 建立的连接会在组件处于 DESTORY 状态后被移除。&lt;/p&gt;
&lt;h3 id=&quot;0x0001-个人理解&quot;&gt;&lt;a href=&quot;#0x0001-个人理解&quot; class=&quot;headerlink&quot; title=&quot;0x0001 个人理解&quot;&gt;&lt;/a&gt;0x0001 个人理解&lt;/h3&gt;&lt;p&gt;官方文档看了几遍，大致明白了 LiveData 的作用， LiveData 可持有数据，并且它有一个重要的方法:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&amp;lt;? super T&amp;gt; observer)&lt;/code&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="LiveData" scheme="/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack之ViewModle 笔记</title>
    <link href="/2019/05/06/Jetpack%E4%B9%8BViewModle%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/05/06/Jetpack之ViewModle笔记/</id>
    <published>2019-05-06T03:52:23.000Z</published>
    <updated>2019-07-11T11:18:51.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x0000-概述"><a href="#0x0000-概述" class="headerlink" title="0x0000 概述"></a>0x0000 概述</h3><p>ViewModel 是一个设计通过用来存储、管理 UI 相关的数据类。</p><p>ViewModel 类旨在通过生命周期感知的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 <strong>存活</strong> 的状态。</p><p>Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。响应用户的动作系统可能会新建或重建 UI，但是这并不在用户的控制范围内。</p><a id="more"></a><p><strong>面临问题：</strong></p><ol><li><p>如果系统销毁或者新建 UI，则存储在其中的任何与 UI 相关短暂的数据都将丢失。对于简单的数据， Activity 可以在  onSaveInstanceState() 中保存下来，在新建的 Activity 的 onCreate() 方法中重新获得这些数据，但是这方法只适用于数据量较小、可以序列化和反序列化的数据，不使用大量的数据，例如对象列表、Bitmap 列表。</p></li><li><p>另外一个问题是：UI 中频繁的异步任务会占用一些时间返回数据。UI 控制器需要管理这些请求并且保证系统能够在 UI 销毁后回收这些请求，避免潜在的内存泄漏，而管理上述情况会占用大量的资源。</p></li></ol><p>UI 的主要职责是用来展示数据、响应用户的动作或者组件间交流，例如权限请求。让 UI 承担从网络或者数据库获取数据等职责，使得类变的十分的臃肿，同时使 UI 变得难以测试。我们不应该为 UI 分配过多的职责，不能让一个类去处理所有的工作，而不是将工作委托给其他类。这其实是 MVC、MVP、MVVM 这些架构演进的重要原因。</p><p>将视图数据所有权与 UI 控制器逻辑分离，使逻辑更加简单、更易于维护。</p><h3 id="0x0001-ViewModel-使用"><a href="#0x0001-ViewModel-使用" class="headerlink" title="0x0001 ViewModel 使用"></a>0x0001 ViewModel 使用</h3><p>ViewModel 的主要职责是为 UI 提供数据，Activity 重建后会复用第一次建立 Activity 的 ViewModel 对象。与之前的写法不同，现在我们需要将获取到的数据保存到 ViewModel，这样就保证数据在当前 Activity 重建后可以复用数据。</p><p>官方文档示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyViewModel : ViewModel() &#123;</span><br><span class="line">    private val users: MutableLiveData&lt;List&lt;User&gt;&gt; by lazy &#123;</span><br><span class="line">        MutableLiveData().also &#123;</span><br><span class="line">            loadUsers()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun getUsers(): LiveData&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line">        return users</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun loadUsers() &#123;</span><br><span class="line">        // Do an asynchronous operation to fetch users.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        // Create a ViewModel the first time the system calls an activity&apos;s onCreate() method.</span><br><span class="line">        // Re-created activities receive the same MyViewModel instance created by the first activity.</span><br><span class="line"></span><br><span class="line">        val model = ViewModelProviders.of(this).get(MyViewModel::class.java)</span><br><span class="line">        model.getUsers().observe(this, Observer&lt;List&lt;User&gt;&gt;&#123; users -&gt;</span><br><span class="line">            // update UI</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the activity is re-created, it receives the same MyViewModel instance that was created by the first activity。<br>当 ViewModel 的宿主 Activity 销毁后，系统会调用 ViewModel 对象的 onCleared() 方法，用来清除资源。</p><p><strong>ViewModel 禁止引用 View、Lifecycle 以及其他任何引用 Activity 环境变量的对象。</strong></p><p>ViewModel 旨在创建超过 View 或 LifecycleOwners 对象生命周期的对象。这使得你可以更加容易的测试 ViewModel ，因为不需要知道 View 或 Lifecycle 对象。</p><p>ViewModel 可以持有 LifecycleObserver ，例如 LiveData 对象。但是 ViewModel 对象不能观察到生命周期感知的可观察对象（例如LiveData对象）的更改。</p><p>如果 ViewModel 需要 Application 上下文，例如查找系统服务，可以使用 ViewModel 的子类 AndroidViewModel 类，并在构造函数中传入 Application 对象。</p><h3 id="0x0002-ViewModel-的生命周期"><a href="#0x0002-ViewModel-的生命周期" class="headerlink" title="0x0002 ViewModel 的生命周期"></a>0x0002 ViewModel 的生命周期</h3><p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="ViewModel 的生命周期"></p><p>You usually request a ViewModel the first time the system calls an activity object’s onCreate() method. The system may call onCreate() several times throughout the life of an activity, such as when a device screen is rotated. The ViewModel exists from when you first request a ViewModel until the activity is finished and destroyed.</p><p>ViewModel 会在 Activity 第一次创建存在，直到该 Activity 被彻底销毁不再重建。</p><p>获取 ViewModel 对象时，ViewModel 对象的范围限定为传递给ViewModelProvider 的对象的生命周期。</p><hr><p>有问题欢迎点击：<a href="https://developer.android.com/topic/libraries/architecture/viewmodel" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x0000-概述&quot;&gt;&lt;a href=&quot;#0x0000-概述&quot; class=&quot;headerlink&quot; title=&quot;0x0000 概述&quot;&gt;&lt;/a&gt;0x0000 概述&lt;/h3&gt;&lt;p&gt;ViewModel 是一个设计通过用来存储、管理 UI 相关的数据类。&lt;/p&gt;
&lt;p&gt;ViewModel 类旨在通过生命周期感知的方式存储、管理与 UI 相关的数据。ViewModel 类可以在屏幕旋转情况下保持数据处于 &lt;strong&gt;存活&lt;/strong&gt; 的状态。&lt;/p&gt;
&lt;p&gt;Android 通过 Framework 层管理 UI(Activity/Fragment) 的生命周期。响应用户的动作系统可能会新建或重建 UI，但是这并不在用户的控制范围内。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jetpack" scheme="/tags/Jetpack/"/>
    
      <category term="ViewModle" scheme="/tags/ViewModle/"/>
    
  </entry>
  
  <entry>
    <title>TCP 的三次握手和四次挥手</title>
    <link href="/2019/05/06/TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>/2019/05/06/TCP-的三次握手和四次挥手/</id>
    <published>2019-05-06T03:35:16.000Z</published>
    <updated>2019-08-28T03:31:38.107Z</updated>
    
    <content type="html"><![CDATA[<p>TCP 协议做的是：在算法层面保证可靠性。</p><p>有关可靠性的指标：</p><ul><li>保证顺序</li><li>不丢包</li><li>维护 TCP 连接</li><li>流量控制</li><li>拥塞控制</li></ul><p>为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：</p><a id="more"></a><p><img src="/../images/2019_05_06_01.jpg" alt="TCP 包头格式"></p><h3 id="TCP-三次握手基本流程"><a href="#TCP-三次握手基本流程" class="headerlink" title="TCP 三次握手基本流程"></a>TCP 三次握手基本流程</h3><p>为了更好的理解 TCP 三次握手，来看一下生活中场景(A、B 两人彼此自我介绍的场景):</p><hr><p><strong>1、A (A -&gt; B):</strong> 你好，我是 A(此时 A 不知道 B 是否收到自己的介绍，所以 A 现在等待 B 的 <strong>应答</strong>)。</p><p><strong>2、B (B -&gt; A):</strong> 你好，我是 B(此时 B 不知道 A 是否收到自己的介绍，所以 B 现在等待 A 对自己的应答进行应答，可称为 <strong>应答之应答</strong>)。</p><p><strong>3、A (A -&gt; B):</strong> 你好 B (此时 A 已经知道了 B，同时 B 也知道了 A , A 认为双方建立了连接，即使此次数据发送失败，当 A 开始发送数据时，也可完成连接)。</p><hr><p>以上情况是在比较顺畅的情况两人建立了友谊关系，当然也会存在异常情况，如下几种：</p><h4 id="异常情况一"><a href="#异常情况一" class="headerlink" title="异常情况一"></a>异常情况一</h4><p>步骤一中 A 发送的数据包丢失，因为各种原因：丢失、绕路、B 没有响应等情况，无法进入到步骤二，由于 A 没有收到发送数据包的应答，所以 A 会再次发送数据包，如果还是无法收到应答，还会再发。</p><h4 id="异常情况二"><a href="#异常情况二" class="headerlink" title="异常情况二"></a>异常情况二</h4><p>A 发送的请求到达 B ,此时 B 已经知道了 A 的存在，如果 B 想要建立连接，就会发送应答给 A；如果 B 不想建立连接，就不会发送应答，A 在尝试发送数据包一段时间后就会放弃，此时建立连接失败。</p><h4 id="异常请求三"><a href="#异常请求三" class="headerlink" title="异常请求三"></a>异常请求三</h4><p>在 A 多次发送请求数据包时，各步骤终于顺畅的进行下去，A、B 建立连接。 在两者进行短暂的交流后结束了谈话后，此时结束了连接，但是此时 A 建立连接时发送的数据包经过一段时间的绕路后，来到了 B ，如果 B 认为这是一个正常的请求的话建立了连接，此时这个连接不会进行下去，但是也不会有结束的时候，极大的浪费了网络资源。</p><p>这个异常情况在说明了 <strong>两次握手是不可以的</strong>。</p><h4 id="异常情况四"><a href="#异常情况四" class="headerlink" title="异常情况四"></a>异常情况四</h4><p>B 发送的应答可能会发送多次，但是只要有一次到达了 A ，那么 A 就会认为已经建立了连接，因为 <strong>对于 A 来说消息有去有回</strong>。当 A 为此次应答发送的应答到达 B 后，B 就认为已经建立了连接，因为 <strong>对于 A 来说消息也是有去有回</strong>。</p><p>但是此时也会出现异常情况，如果 A 发送的应答消息丢失。按理来说，针对每一个应答都会有对方的应答之应答，依次循环往复，那么多少次握手都是可以的，但是并不能保证连接都是可靠的，所以 <strong>只要保证 A、B 双方的消息都有去有回就可以了</strong>，这也是为什么 <strong>TCP 建立连接需要三次握手的原因</strong> 了。</p><p>如果 A 发送的应答丢失了，此时对于 B 是怎样的情况？ 好在 A 在建立连接后就会发送数据，如果 A 发送的应答丢失了，后续 A 发送的数据到了 B，那么 B 就会认为已经建立了连接；如果 B 出现异常，那么 A 发送的数据会报错，说 B 是不可达的，A就知道了 B 出现了异常，就会做出相应的处理。</p><p>至此 TCP 三次握手过程大致梳理清楚了。</p><h3 id="TCP-数据包的序号问题"><a href="#TCP-数据包的序号问题" class="headerlink" title="TCP 数据包的序号问题"></a>TCP 数据包的序号问题</h3><p>TCP 三次握手处理建立连接外，主要还是为了沟通一件事情：  <strong>TCP 包的序号问题。</strong></p><p>A 需要告诉 B 自己发送的包的序号的起始是从哪个号开始的，同理 B 也要做相同的事情。</p><p>为什么序号不能都从 1 开始呢？</p><p>针对这个问题，我们来看一个场景：</p><p>A 发送 1、2、3 包给 B，1、2 安全可靠的到达 B，包 3 由于各种原因绕了原路，没有到达 B ，此时 A 短暂掉线，后重新连接，发送的数据序号从 1 开始，然后发送 2，至此该发送过程结束，但是绕路的 3 数据包有回来了，此时 B 认为它是一个正常包，于是产生了错误。</p><p>所以每个连接都要有不同的序号，这个序号的起始序号是随时间变化的，可以认为一个 32 位计数器，每 4ms 加 1，重复的序列号至少需要 4 h，此时由于 IP 包头中 TTL 的存在，绕路的包已经在该时间内就不复存在了。</p><p><strong>正是因为 TCP 序号的机制，才保证了 TCP 连接过程中的保证顺序、不丢包的指标。</strong></p><h3 id="TCP-三次握手中的状态机"><a href="#TCP-三次握手中的状态机" class="headerlink" title="TCP 三次握手中的状态机"></a>TCP 三次握手中的状态机</h3><p>在建立 TCP 连接时，为了维护这个连接，双方需要维护一个状态机<a href="状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。">^1</a>，在建立连接过程中，双方的状态变化时序图如下：</p><p><img src="/../images/2019_05_07_01.jpg" alt="状态时序图"></p><ol><li>Client 和 Server 均处于 CLOSED 状态，此时 Server <span style="color: #5bdaed;font-weight: bold;">主动</span> 监听某个端口号。</li><li>Client 主动发起连接 SYN ,之后 Client 处于 SYN-SENT 状态。</li><li>Server 收到 Client 发起的连接，返回 SYN，并且 ACK Client 的 SYN，之后 Server 进入到 SYN-RCVD 状态。</li><li>Client 收到 Server 发送的 SYN 和 ACK，发送 ACK 的 ACK ,之后 Client 进入 ESTABLISHED 状态，因为它一发一收成功了。</li><li>Server收到 ACK 的ACK 后，进入 ESTABLISHED 状态，因为它一发一收成功了。</li></ol><hr><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>使用上面同样的例子，A、B 相同认识，进行简单的交流后，挥手说再见，各回各家。</p><p><strong>1、A (A -&gt; B):</strong> B ,我不能和你再聊了，我要回家了。<br><strong>2、B (B -&gt; A):</strong> 好的 A，我知道了。</p><p>此时只是 A 单方面的不想再聊，即 A 在此后不会发送数据了。但是 B 不能再应答 A 之后马上就关闭连接，为什么呢？因为在此状况下，只是 A 在发送数据后不再发送数据了，B 还有自己没有做完的事情，此时 B 还是可以发送数据的，此时处于 <strong>半关闭状态</strong>。</p><p><strong>此时 A 可以选择不再接收数据，也可以选择最后在接收一段数据，等待 B 也主动关闭。</strong></p><p><strong>3、B (B -&gt; A):</strong> A 我也不玩了，Bye。<br><strong>4、A (A -&gt; B):</strong> 好的，Bye。</p><p>这样整个连接就关闭了，如建立连接时存在异常，同样关闭连接也会存在异常，如下：</p><h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>A 在说完“我不和你聊天了”，直接跑路，这是是会出现问题的，因为 B 还没发起结束，就算发起了，也得不到回答，此时 B 不知道怎么办。</p><p>还有一种异常情况是，当 A 说完 “我不和你聊天了， B 直接跑路，A 的发送的数据包没有得到应答，它不知道 B 是在处理自己的事情还是等一会发送结束。</p><h3 id="TCP-四次挥手的时序图"><a href="#TCP-四次挥手的时序图" class="headerlink" title="TCP 四次挥手的时序图"></a>TCP 四次挥手的时序图</h3><p><img src="/../images/2019_05_07_02.jpg" alt="四次挥手时序图"></p><ol><li><p>Clinet 自己断开连接，发送 FIN 后进入 FIN-WAIT-1 状态。</p></li><li><p>Server 收到 Client 的 FIN 请求，发送 FIN 的 ACK ，Server 进入 CLOSED-WAIT 的状态。</p></li><li><p>Client 收到 Server 的 ACK 后进入 FIN-WAIT-2 的状态。</p><p>若这个时候 Server 跑路，那么 A 将永远处在 FIN-WAIT-2 状态，TCP 协议没有对这个状态处理，但是 Linux 可以调整 tcp_fin_timeout 参数，来设置超时时间。</p></li><li><p>Server 发送 FIN 的请求到达 Client , Client 发送该请求的 ACK ,然后结束了 FIN-WAIT-2 状态，按理说 Client 可以跑路了，但是万一自己发送的 ACK 没有成功到达 Server 怎么办？如果是这样的情况，Server 在一段时间后会重新发送 FIN 请求，但是 Client 已经跑路了，Server 永远也收不到 ACK 了。基于此原因 TCP 协议要求 Cleint 在最后需要等待一段时间 TIME-WAIT ,这个时间需要足够长，长到下面的步骤能够成功执行。</p><p> 如果 Server 超过了 2MSL 依然没有收到 ACK ，虽然 Server 会重发 FIN ，但是 Client 收到这个数据包后表示我已经等待了这么长时间，也够意思了，朋友再见，发送 RST 请求，Server 收到这个请求后就知道 Client 已经跑路了。</p></li></ol><p>MSL(Maximum Segment Lifetime)，报文最大生存时间，它是报文在网络中存在的最大时间，超过这个时间报文会被丢弃。</p><p>IP 头中有 TTL域，IP 数据包每经过一个处理它的路由器后，该值减 1，此值为 0 是数据包被丢且。</p><h4 id="异常情况一-1"><a href="#异常情况一-1" class="headerlink" title="异常情况一"></a>异常情况一</h4><p>A 发送： ”不玩了“<br>B 回复： “知道了”</p><p>在这个回合中是不存在异常的，如果 A 发送的消息没有得到 B 的回复会重复发送。</p><p>但是在这个回合结束后，就有可能发生异常情况，因为存在一方先 “跑路” 的情况。</p><h4 id="异常情况二-1"><a href="#异常情况二-1" class="headerlink" title="异常情况二"></a>异常情况二</h4><p>A 发起结束后，马上跑路，此时 B 发起的结束，是得不到 A 的回复的。</p><h4 id="异常情况三"><a href="#异常情况三" class="headerlink" title="异常情况三"></a>异常情况三</h4><p>A 发起结束后，B 马上跑路，这时 A 不知道 B 的具体状态，是还有事情处理还是一会才会发送结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP 协议做的是：在算法层面保证可靠性。&lt;/p&gt;
&lt;p&gt;有关可靠性的指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证顺序&lt;/li&gt;
&lt;li&gt;不丢包&lt;/li&gt;
&lt;li&gt;维护 TCP 连接&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了能够保证以上指标，设计了对于的 TCP 包头格式,如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络协议" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="TCP" scheme="/tags/TCP/"/>
    
      <category term="趣谈网络协议(刘超)" scheme="/tags/%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%88%98%E8%B6%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="/2019/04/30/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>/2019/04/30/Java-反射/</id>
    <published>2019-04-30T02:35:03.000Z</published>
    <updated>2019-05-29T10:12:06.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据一个对象获得一个类"><a href="#根据一个对象获得一个类" class="headerlink" title="根据一个对象获得一个类"></a>根据一个对象获得一个类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;adb&quot;;</span><br><span class="line">Class class = str.getClass();</span><br></pre></td></tr></table></figure><h2 id="根据一个字符串获得一个类"><a href="#根据一个字符串获得一个类" class="headerlink" title="根据一个字符串获得一个类"></a>根据一个字符串获得一个类</h2><p>字符串需要包括完整的包名和类名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class class = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">Class class2 = Class.forName(&quot;android.widget.Button&quot;);</span><br><span class="line"></span><br><span class="line">// 获得对象的父类型</span><br><span class="line">Class class3 = class2.getSuperClass();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h2><h3 id="实例类"><a href="#实例类" class="headerlink" title="实例类"></a>实例类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private String name = &quot;default&quot;;</span><br><span class="line">    private int age;</span><br><span class="line">    private static String tag;</span><br><span class="line"></span><br><span class="line">    public TestClass() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestClass(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String showName(String string) &#123;</span><br><span class="line">        return name + &quot; &amp;&amp; &quot; + string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void testStaticsMethod() &#123;</span><br><span class="line">        System.out.println(&quot;testStaticsMethod&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printStatics()&#123;</span><br><span class="line">        System.out.println(tag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;TestClass&#123;&quot; +</span><br><span class="line">                &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得所有构造函数"><a href="#获得所有构造函数" class="headerlink" title="获得所有构造函数"></a>获得所有构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestClass testClass = new TestClass();</span><br><span class="line">Class clazz = testClass.getClass();</span><br><span class="line">String className = clazz.getName();</span><br><span class="line">// 获得所有的构造函数</span><br><span class="line">Constructor[] classList = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">// 获得所有 public 构造函数</span><br><span class="line">Constructor[] classList2 = clazz.getConstructors();</span><br></pre></td></tr></table></figure><h3 id="获得无参构造函数"><a href="#获得无参构造函数" class="headerlink" title="获得无参构造函数"></a>获得无参构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">// 获得 public 无参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br></pre></td></tr></table></figure><h3 id="获得有参构造器"><a href="#获得有参构造器" class="headerlink" title="获得有参构造器"></a>获得有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line"></span><br><span class="line">// 获得指定的 public 有参构造器</span><br><span class="line">Constructor constructor = clazz.getConstructor(params);</span><br></pre></td></tr></table></figure><h2 id="调用类的构造器"><a href="#调用类的构造器" class="headerlink" title="调用类的构造器"></a>调用类的构造器</h2><h3 id="调用无参构造器"><a href="#调用无参构造器" class="headerlink" title="调用无参构造器"></a>调用无参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure><h3 id="调用有参构造器"><a href="#调用有参构造器" class="headerlink" title="调用有参构造器"></a>调用有参构造器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class params = &#123;String.class,int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(params);</span><br><span class="line">Object obj = constructor.newInstance(&quot;Mike&quot;,23);</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><h3 id="调用私有实例方法"><a href="#调用私有实例方法" class="headerlink" title="调用私有实例方法"></a>调用私有实例方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//通过反射获得实例对象</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;test&quot;, 1);</span><br><span class="line">TestClass testClass = (TestClass) object;</span><br><span class="line"></span><br><span class="line">//获得指定的 private 方法</span><br><span class="line">Class[] params = &#123;String.class&#125;;</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;showName&quot;, params);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 调用指定对象的的方法</span><br><span class="line">Object[] argList = &#123;&quot;call private method&quot;&#125;;</span><br><span class="line">Object returnParam = method.invoke(testClass, argList);</span><br><span class="line">System.out.println(returnParam);</span><br></pre></td></tr></table></figure><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取私有静态方法</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;testStaticsMethod&quot;);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">method.invoke(null);</span><br></pre></td></tr></table></figure><h2 id="获得类的实例变量并修改"><a href="#获得类的实例变量并修改" class="headerlink" title="获得类的实例变量并修改"></a>获得类的实例变量并修改</h2><h3 id="非静态变量"><a href="#非静态变量" class="headerlink" title="非静态变量"></a>非静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 通过反射获得类实例</span><br><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line">Class[] classes = &#123;String.class, int.class&#125;;</span><br><span class="line">Constructor constructor = clazz.getConstructor(classes);</span><br><span class="line">Object object = constructor.newInstance(&quot;Mike&quot;, 3);</span><br><span class="line"></span><br><span class="line">//获得实例变量 getField 获取一个类的public 成员变量包括基类</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">//非静态实例变量传入object ,获得 object 的实例变量的值，并把它包装成类</span><br><span class="line">Object fieldObject = field.get(object);</span><br><span class="line"></span><br><span class="line">//修改 object 对应属于的值,注意只会修改 object 这个对象的字段值</span><br><span class="line">field.set(object, &quot;test Field&quot;);</span><br><span class="line">System.out.println(fieldObject);</span><br><span class="line"></span><br><span class="line">Object fieldObject1 = field.get(object);</span><br><span class="line">System.out.println(fieldObject1);</span><br></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;reflect.TestClass&quot;);</span><br><span class="line"></span><br><span class="line">// 获取类的 name 静态字段</span><br><span class="line">Field field = clazz.getDeclaredField(&quot;tag&quot;);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// 为 static 变量时传入 null,获得静态变量，并包装</span><br><span class="line">Object fieldObject = field.get(null);</span><br><span class="line"></span><br><span class="line">//修改值</span><br><span class="line">field.set(fieldObject, &quot;ABCD&quot;);</span><br><span class="line"></span><br><span class="line">//查看值，静态变量一次修改，一生受用</span><br><span class="line">TestClass.printStatics();</span><br></pre></td></tr></table></figure><h2 id="对泛型进行反射"><a href="#对泛型进行反射" class="headerlink" title="对泛型进行反射"></a>对泛型进行反射</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;根据一个对象获得一个类&quot;&gt;&lt;a href=&quot;#根据一个对象获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个对象获得一个类&quot;&gt;&lt;/a&gt;根据一个对象获得一个类&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String str = &amp;quot;adb&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class = str.getClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;根据一个字符串获得一个类&quot;&gt;&lt;a href=&quot;#根据一个字符串获得一个类&quot; class=&quot;headerlink&quot; title=&quot;根据一个字符串获得一个类&quot;&gt;&lt;/a&gt;根据一个字符串获得一个类&lt;/h2&gt;&lt;p&gt;字符串需要包括完整的包名和类名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class class = Class.forName(&amp;quot;java.lang.String&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class2 = Class.forName(&amp;quot;android.widget.Button&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获得对象的父类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class3 = class2.getSuperClass();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Inflection" scheme="/tags/Inflection/"/>
    
  </entry>
  
  <entry>
    <title>理解JNI</title>
    <link href="/2019/04/09/%E7%90%86%E8%A7%A3JNI/"/>
    <id>/2019/04/09/理解JNI/</id>
    <published>2019-04-09T08:28:01.000Z</published>
    <updated>2019-05-23T02:57:06.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JNI-概述"><a href="#JNI-概述" class="headerlink" title="JNI 概述"></a>JNI 概述</h3><p>JNI(Java Native Interface),意为 <strong>Java 本地调用</strong>,是连接 Java 和 native 的桥梁。</p><p>JNI 推出的原因：</p><ol><li>Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。</li><li>执行效率和速度。</li></ol><h3 id="JNI之-Java-层操作"><a href="#JNI之-Java-层操作" class="headerlink" title="JNI之 Java 层操作"></a>JNI之 Java 层操作</h3><p>Java 层主要有两个关键：</p><ol><li>加载 native 动态库</li><li>声明 Java 的 native 方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MediaScanner implements AutoCloseable &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;media_jni&quot;);// 加载 so 库</span><br><span class="line">        native_init();//调用 native 方法</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private static native final void native_init();</span><br><span class="line">    private native final void native_setup();</span><br><span class="line">    private native final void native_finalize();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="JNI-之-native-层操作-一"><a href="#JNI-之-native-层操作-一" class="headerlink" title="JNI 之 native 层操作 (一)"></a>JNI 之 native 层操作 (一)</h3><p>实例代码：<br>MediaScanner.cpp 代码片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// MediaScanner.java 的 native 的 JNI 实现</span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_init&quot;);</span><br><span class="line">    jclass clazz = env-&gt;FindClass(kClassMediaScanner);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    if (fields.context == NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">android_media_MediaScanner_native_setup(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;native_setup&quot;);</span><br><span class="line">    MediaScanner *mp = new StagefrightMediaScanner;</span><br><span class="line"></span><br><span class="line">    if (mp == NULL) &#123;</span><br><span class="line">        jniThrowException(env, kRunTimeException, &quot;Out of memory&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.context, (jlong)mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNI-之-native-层操作-二-–-注册-JNI-函数"><a href="#JNI-之-native-层操作-二-–-注册-JNI-函数" class="headerlink" title="JNI 之 native 层操作 (二) – 注册 JNI 函数"></a>JNI 之 native 层操作 (二) – 注册 JNI 函数</h3><p>如何知道 Java 层的 MediaScanner 中的 native_init 函数对于 JNI 层的 android_media_MediaScanner_native_init 函数,这时就需要 JNI 注册，将两个层面的函数关联起来。注册后，有了这层关联关系，Java 层调取 JNI 层函数就可以实现。</p><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>静态注册实现方法参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/84028290" target="_blank" rel="noopener">Android Studio 配置 javah 生成 C/C++ 头文件，完成 JNI 调用</a> 中相关内容。</p><p>当 Java 层调用 native_init 函数式，就会去 JNI 库中寻找 android_media_MediaScanner_native_init 函数，如果没有，就会报错，如果存在该函数，就会建立关联，<strong>此关联其实就是保存的 JNI 层函数的函数指针</strong>。以后再调用此函数，直接调用该函数指针就可以了，这部分的工作是在 Java 虚拟机中完成的。</p><p><strong>Java native 是通过函数指针来与 JNI 层的函数建立联系的。</strong></p><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>在静态注册中可知，Java 层和 JNI 层的函数是一一对应的，那么可以使用结构体来保存这种关联关系。JNI 中可以使用 JNINativeMethod 这种结构体来实现以上功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_init&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_init</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        &quot;native_setup&quot;,</span><br><span class="line">        &quot;()V&quot;,</span><br><span class="line">        (void *)android_media_MediaScanner_native_setup</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AndroidRuntime.cpp 类中提供了 registerNativeMethod 来完成注册工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Register native methods using JNI.</span><br><span class="line"> */</span><br><span class="line">/*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env,</span><br><span class="line">    const char* className, const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, className, gMethods, numMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jniRegisterNativeMethods 为 JNIHelper 中提供的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int jniRegisterNativeMethods(C_JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Registering %s&apos;s %d native methods...&quot;, className, numMethods);</span><br><span class="line"></span><br><span class="line">    scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的工作只要两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 找到对应的类</span><br><span class="line">scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className));</span><br><span class="line"></span><br><span class="line">// 这句话其实是调用 JINEnv 的 RegisterNatives方法，将 JNI 类中结构体注册进来，从而完成注册关系</span><br><span class="line">(*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods)</span><br></pre></td></tr></table></figure><p>注册的函数在什么地方以及什么时候执行？</p><p>当 Java 层通过 <code>System.loadLibrary()</code> 加载完 JNI 动态库后，接着会查找库中的 <code>JNI_Onload</code> 的函数，如果有的话，就会调用他，而动态注册的工作就是在此处完成的。</p><h3 id="native-函数的参数含义"><a href="#native-函数的参数含义" class="headerlink" title="native 函数的参数含义"></a>native 函数的参数含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Java 层的 processFile 只有 3 个参数，而 JNI 中的方法有 5 中方法。</span><br><span class="line">* JNIEnv *env 为 代表 JNI 环境的结构体</span><br><span class="line">* jobject thiz：代表 Java 层的 MediaScanner 对象，如果方法为 static，参数为 jclass ,代表在调用 Java 的哪一个 Class 中的函数</span><br><span class="line">* 剩下的为 Java 层中该方法的参数</span><br><span class="line">*/</span><br><span class="line">static jboolean android_media_MediaScanner_processFile(</span><br><span class="line">        JNIEnv *env, jobject thiz, jstring path,</span><br><span class="line">        jstring mimeType, jobject client)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNIEnv-介绍"><a href="#JNIEnv-介绍" class="headerlink" title="JNIEnv 介绍"></a>JNIEnv 介绍</h3><p>JNIEnv 是一个 <strong>线程相关</strong> 的 <strong>代表 JNI 环境</strong> 的 <strong>结构体</strong>。</p><p><img src="/images/2019_04_10_1.jpg" alt="JNIEnv 内部结构简图"></p><p>JNIEnv 实际上是提供了一系列 JNI 系统函数，通过这些函数可以做到：</p><ol><li>调用 Java 函数</li><li>操作 jobject 对象</li></ol><h3 id="JNIEnv-的使用"><a href="#JNIEnv-的使用" class="headerlink" title="JNIEnv 的使用"></a>JNIEnv 的使用</h3><p>获得 Filed 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">android_media_MediaPlayer_native_init(JNIEnv *env)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    // 获得 jclass</span><br><span class="line">    clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;);</span><br><span class="line">    // 获得 clazz 中的 </span><br><span class="line">    fields.context = env-&gt;GetFieldID(clazz, &quot;mNativeContext&quot;, &quot;J&quot;);</span><br><span class="line">    fields.post_event = env-&gt;GetStaticMethodID(clazz, &quot;postEventFromNative&quot;,</span><br><span class="line">                                               &quot;(Ljava/lang/Object;IIILjava/lang/Object;)V&quot;);</span><br><span class="line"></span><br><span class="line">    fields.surface_texture = env-&gt;GetFieldID(clazz, &quot;mNativeSurfaceTexture&quot;, &quot;J&quot;);</span><br><span class="line">    env-&gt;DeleteLocalRef(clazz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Field 和 Method</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//调用 JNIEnv 的 CallVoidMethod 函数</span><br><span class="line">// 参数含义：mClient 为 MediaScannerClient 对象</span><br><span class="line">// 第二个参数为函数 scanFile 的 jmedthodid ,后面为 scanFile 的参数</span><br><span class="line">eEnv -&gt; CallVoidMethod(mClient,mScanFileMethod,pathStr,lastModified,fileSize)</span><br></pre></td></tr></table></figure><p>JNIEnv 有一系列类似 CallVoidMethod 的函数，形式如下：</p><p>NativeType Call<type>Method(JNIEnv *env,jobject obj,jmethodId methodId,….)</type></p><h3 id="jstring"><a href="#jstring" class="headerlink" title="jstring"></a>jstring</h3><p>jstring 对象可以看成 Java 中 String 对象在 JNI 层的代表。</p><ol><li>JNIEnv 调用 NewString(JNIEnv *env,const jchar *unicodeChars,jsize len):从 Native 的字符得到 jstring 对象(Unicode)。</li><li>JNIEnv 的 NewStringUTF 将 Native 的一个 UTF 字符串得到一个 jstring 对象(UTF)。</li><li>JNIEnv 提供 GetStringChar 函数，将 Java String对象转换成本地 Unicode 字符串。</li><li>JNIEnv 提供 GetStringUTFChars 函数 ，将 Java String 对象转换为本地 UTF 字符串。</li><li>调用上面四个函数后需要调用 ReleaseStringChars 或 ReleaseStringUTFChars 函数来释放相应资源。</li></ol><h3 id="JNI-中的三种引用"><a href="#JNI-中的三种引用" class="headerlink" title="JNI 中的三种引用"></a>JNI 中的三种引用</h3><ol><li>Local Reference：本地引用。JNI 函数执行完成后，这些 jobject 可能被回收。</li><li>Global Reference：这种方式的引用，不主动释放，永远不会被回收。</li><li>Weak Global Reference：  在使用过程中，可能会被回收。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JNI-概述&quot;&gt;&lt;a href=&quot;#JNI-概述&quot; class=&quot;headerlink&quot; title=&quot;JNI 概述&quot;&gt;&lt;/a&gt;JNI 概述&lt;/h3&gt;&lt;p&gt;JNI(Java Native Interface),意为 &lt;strong&gt;Java 本地调用&lt;/strong&gt;,是连接 Java 和 native 的桥梁。&lt;/p&gt;
&lt;p&gt;JNI 推出的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java 的平台无关性不能迁移到虚拟机上, Java 虚拟机是使用 native 编写的，虚拟机运行在具体的平台上(Linux、Windows等),由于平台的特性，所以虚拟机无法实现平台无关性。Java 使用 JNI 技术可以作为桥梁，可以实现 Java 调用虚拟机的 native 层，实现了Java 的平台无关性。&lt;/li&gt;
&lt;li&gt;执行效率和速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;JNI之-Java-层操作&quot;&gt;&lt;a href=&quot;#JNI之-Java-层操作&quot; class=&quot;headerlink&quot; title=&quot;JNI之 Java 层操作&quot;&gt;&lt;/a&gt;JNI之 Java 层操作&lt;/h3&gt;&lt;p&gt;Java 层主要有两个关键：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载 native 动态库&lt;/li&gt;
&lt;li&gt;声明 Java 的 native 方法&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class MediaScanner implements AutoCloseable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.loadLibrary(&amp;quot;media_jni&amp;quot;);// 加载 so 库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        native_init();//调用 native 方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static native final void native_init();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_setup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private native final void native_finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JNI" scheme="/tags/JNI/"/>
    
      <category term="深入理解 Android 读书笔记" scheme="/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Android-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想的思考</title>
    <link href="/2019/04/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>/2019/04/09/面向对象/</id>
    <published>2019-04-09T03:36:13.000Z</published>
    <updated>2019-04-09T06:01:42.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OOP-Object-Oriented-Programming-面向对象程序设计"><a href="#OOP-Object-Oriented-Programming-面向对象程序设计" class="headerlink" title="OOP (Object Oriented Programming) 面向对象程序设计"></a>OOP (Object Oriented Programming) 面向对象程序设计</h3><ol><li>OOP 强调的是数据。OOP 不像面向过程编程那样，试图使问题满足语言的过程性方法，而是试图让语言满足问题的要求。前者是让编程语言去 <strong>实现问题的解决方法</strong>，即以算法为主，而后者是让编程语言去 <strong>实现问题中的主体</strong>。</li><li>OOP 程序设计方法首先设计类，它准确的表示程序要处理的东西，然后设计一个使用这些类的对象的程序，从低级组织(如类)到高级组织的处理过程叫做 <strong>自下而上编程</strong>。</li><li>设计一个有用、可靠的类是十分重要的任务，一个优秀的类可以极大的减轻编程的难度及工作量。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OOP-Object-Oriented-Programming-面向对象程序设计&quot;&gt;&lt;a href=&quot;#OOP-Object-Oriented-Programming-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;OOP (Object 
      
    
    </summary>
    
    
      <category term="OOP" scheme="/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Four</title>
    <link href="/2019/04/04/Java-Basic-%E5%9B%9B%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>/2019/04/04/Java-Basic-四内部类/</id>
    <published>2019-04-04T06:47:26.000Z</published>
    <updated>2019-06-14T09:04:24.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h3><ol><li>内部类为什么会出现</li><li>内部类的调用</li><li>内部类与外部类访问成员变量的不同</li><li>静态内部类和非静态内部类</li></ol><h4 id="1-1-为什么使用内部类"><a href="#1-1-为什么使用内部类" class="headerlink" title="1.1 为什么使用内部类"></a>1.1 为什么使用内部类</h4><ol><li><p>内部类提供了 <strong>更好的封装</strong>，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。</p></li><li><p><strong>内部类可以访问外部类的数据 (包括私有变量)</strong>，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。</p><p>内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。</p><p>真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用</p></li><li><p><strong>可以使用匿名内部类创建访问一次的类</strong>，十分方便。</p></li></ol><h3 id="2-非静态内部类"><a href="#2-非静态内部类" class="headerlink" title="2. 非静态内部类"></a>2. 非静态内部类</h3><p>例子 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private int num2 = 3;</span><br><span class="line"></span><br><span class="line">    private class InnerClass &#123;</span><br><span class="line"></span><br><span class="line">        private int num = 2;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            System.out.println(&quot;innerclass method&quot;);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + num);</span><br><span class="line">            System.out.println(&quot;innerclass method inner num &quot; + this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num &quot; + OutClass.this.num);</span><br><span class="line">            System.out.println(&quot;innerclass method out num2 &quot; + num2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OutClass outclass = new OutClass();</span><br><span class="line">        System.out.println(&quot;main &quot;+ outclass.num);</span><br><span class="line">        outclass.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test() &#123;</span><br><span class="line">        InnerClass inner = new InnerClass();</span><br><span class="line">        inner.method();</span><br><span class="line">        System.out.println(&quot;outclass test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打印日志：</span><br><span class="line"></span><br><span class="line">main 1</span><br><span class="line">innerclass method</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method inner num 2</span><br><span class="line">innerclass method out num 1</span><br><span class="line">innerclass method out num2 3</span><br><span class="line">outclass test</span><br></pre></td></tr></table></figure><h4 id="2-1-内部类可以访问外部类的成员变量-包括私有变量"><a href="#2-1-内部类可以访问外部类的成员变量-包括私有变量" class="headerlink" title="2.1 内部类可以访问外部类的成员变量(包括私有变量)"></a>2.1 内部类可以访问外部类的成员变量(包括私有变量)</h4><p>原因：<br>在非静态内部类对象里，保存了 <strong>外部类对象的引用</strong>。</p><p>内存模型：</p><p><img src="/images/2019_04_04_1.jpg" alt="内存模型图"></p><p>但是当外部类与内部类有相同名字的变量时，引用外部类变量需要指定外部类对象 –  <code>Outclass.this</code> </p><h4 id="2-2-编译后的-Class-文件"><a href="#2-2-编译后的-Class-文件" class="headerlink" title="2.2 编译后的 Class 文件"></a>2.2 编译后的 Class 文件</h4><p>在 JVM 中没有内部类这个概念，所有的类都是普通类（POJO），内部类也会被编译成带有前缀的类。</p><p>编译后，得到两个 class 文件:</p><ol><li><code>OutClass.java</code> </li><li><code>OutClass$InnerClass.class</code></li></ol><h4 id="内部类方法中的变量的访问顺序"><a href="#内部类方法中的变量的访问顺序" class="headerlink" title="内部类方法中的变量的访问顺序"></a>内部类方法中的变量的访问顺序</h4><p>内部类方法内部中 –&gt; 内部类中的成员变量 –&gt; 外部类中的成员变量 –&gt; 不存在，编译异常</p><h4 id="2-3-内、外部类变量名相同"><a href="#2-3-内、外部类变量名相同" class="headerlink" title="2.3 内、外部类变量名相同"></a>2.3 内、外部类变量名相同</h4><p>访问使用如下格式：</p><p><code>this.field</code> : 内部类变量</p><p><code>OutClass.this.field</code> : 外部类变量</p><h4 id="2-4-外部类不可直接访问内部类成员"><a href="#2-4-外部类不可直接访问内部类成员" class="headerlink" title="2.4 外部类不可直接访问内部类成员"></a>2.4 外部类不可直接访问内部类成员</h4><p>非静态内部类成员只在非静态内部类范围内是可知的，外部类不能直接访问，但是可以通过 <strong>内部类实例对象来访问</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new InnerClass().method();</span><br><span class="line">new InnerClass().num++;</span><br></pre></td></tr></table></figure><h4 id="2-5-外部类中静态成员中不允许直接使用非静态内部类"><a href="#2-5-外部类中静态成员中不允许直接使用非静态内部类" class="headerlink" title="2.5 外部类中静态成员中不允许直接使用非静态内部类"></a>2.5 外部类中静态成员中不允许直接使用非静态内部类</h4><p>静态成员为类成员，如静态变量、静态初始化块、静态内部类等，静态成员在编译期对其初始化，如果直接使用非静态成员(如非静态内部类)，则会发生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OutterClass&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        // 这种情况是不被允许的</span><br><span class="line">        //new InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-内、外部类关系"><a href="#2-6-内、外部类关系" class="headerlink" title="2.6 内、外部类关系"></a>2.6 内、外部类关系</h4><p>非静态内部类对象寄生在外部类对象里，有非静态内部类对象一定存在外部类对象，反之不成立。</p><h4 id="2-7-非静态内部类中的静态成员-重点理解"><a href="#2-7-非静态内部类中的静态成员-重点理解" class="headerlink" title="2.7 非静态内部类中的静态成员(重点理解)"></a>2.7 非静态内部类中的静态成员(重点理解)</h4><p>如果非静态内部类声明静态成员变量，那么必须使用 <code>final</code> 修饰，由于被 <code>final</code> 修饰该变量必须在声明处初始化。</p><p>因为一个静态变量只有一个实例，而对于每一个外部对象，分别有一个单独的内部类实例，如果这个变量不是 final 的，那么他就不是唯一的，这与 static 的含义相互冲突。</p><p><strong>非静态内部类中不能含有静态方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OutterClass &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private void outMethod()&#123;&#125;</span><br><span class="line">     class InnerClass &#123;</span><br><span class="line">        private final static String name = &quot;&quot;;</span><br><span class="line">        private /*static*/ void innerMethod() &#123;</span><br><span class="line">            age++;</span><br><span class="line">            outMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class OutClass &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 1;</span><br><span class="line">    private static int age = 2;</span><br><span class="line"></span><br><span class="line">    private void doSomething()&#123;</span><br><span class="line">        StaticInnerClass.staticNum++;</span><br><span class="line">        StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">        staticInnerClass.method();</span><br><span class="line">        staticInnerClass.num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected static class StaticInnerClass &#123;</span><br><span class="line">        private static int staticNum = 10;</span><br><span class="line">        private int num = 100;</span><br><span class="line"></span><br><span class="line">        private void method() &#123;</span><br><span class="line">            num++;</span><br><span class="line">            staticNum++;</span><br><span class="line">            age++;</span><br><span class="line">            // &apos;four.OutClass.this&apos; cannot be referenced from a static context</span><br><span class="line">            // -- four.OutClass.this 不能再 static 环境下被引用</span><br><span class="line">            // OutClass.this.num++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-静态内部类不可以访问外部类实例成员，可以访问类成员"><a href="#3-1-静态内部类不可以访问外部类实例成员，可以访问类成员" class="headerlink" title="3.1 静态内部类不可以访问外部类实例成员，可以访问类成员"></a>3.1 静态内部类不可以访问外部类实例成员，可以访问类成员</h4><p>静态内部类为外部类的类成员，只能访问外部类的静态变量，不可以访问非静态变量，还是一样牵涉到类加载、初始化顺序的问题。</p><h4 id="3-2-编译后的-Class-文件"><a href="#3-2-编译后的-Class-文件" class="headerlink" title="3.2 编译后的 Class 文件"></a>3.2 编译后的 Class 文件</h4><p>与非静态内部类相同，编译后得到两个 class 文件 – OutClass.class 、StaticInnerClass.class</p><h4 id="3-3-外部类不可直接访问静态内部类成员"><a href="#3-3-外部类不可直接访问静态内部类成员" class="headerlink" title="3.3 外部类不可直接访问静态内部类成员"></a>3.3 外部类不可直接访问静态内部类成员</h4><p>静态内部类成员、实例成员只在静态内部类范围内是可知的，外部类不能直接访问。</p><ul><li><p>通过 内部类名 来访问静态内部类类成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass.staticNum++;</span><br></pre></td></tr></table></figure></li><li><p>通过内部类实例对象访问静态内部类实例成员(不推荐，这样就忽视了 static 的含义)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br><span class="line">staticInnerClass.method();</span><br><span class="line">staticInnerClass.num++;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-内部类使用"><a href="#4-内部类使用" class="headerlink" title="4. 内部类使用"></a>4. 内部类使用</h3><h4 id="4-1-外部类使用内部类"><a href="#4-1-外部类使用内部类" class="headerlink" title="4.1 外部类使用内部类"></a>4.1 外部类使用内部类</h4><ul><li>基本的使用</li><li>外部类使用内部类的子类</li></ul><p>外部类中的静态代码块、静态方法中不可使用非静态内部类，因为静态成员不能使用非静态成员。</p><h4 id="4-2-外部类以外使用非静态内部类"><a href="#4-2-外部类以外使用非静态内部类" class="headerlink" title="4.2 外部类以外使用非静态内部类"></a>4.2 外部类以外使用非静态内部类</h4><p>根据内部类的访问权限修饰符，内部类对其他类的可见性不同。</p><p>外部类以外建立非静态内部类实例必须外部类实例和 new 来调用非静态内部类的构造器。</p><ul><li>非静态内部类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass innerclass = new OutClass().new InnerClass();</span><br><span class="line">innerclass.num++;</span><br><span class="line">innerclass.method();</span><br></pre></td></tr></table></figure><ul><li>非静态内部类子类</li></ul><h4 id="外部类以外使用静态内部类"><a href="#外部类以外使用静态内部类" class="headerlink" title="外部类以外使用静态内部类"></a>外部类以外使用静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutClass&#123;</span><br><span class="line">    private int num = 1;</span><br><span class="line">    protected static InnerClass&#123;</span><br><span class="line">    </span><br><span class="line">        private int num = 2;</span><br><span class="line">        </span><br><span class="line">        private void method()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.InnerClass staticInnerClass = new OutClass.InnerClass();</span><br><span class="line">staticInnerClass.</span><br></pre></td></tr></table></figure><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5. 局部内部类"></a>5. 局部内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        class InnerBase&#123;</span><br><span class="line">            int a ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class SubInnerClass extends InnerBase&#123;</span><br><span class="line">            int b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubInnerClass subInnerClass = new SubInnerClass();</span><br><span class="line">        subInnerClass.a = 1;</span><br><span class="line">        subInnerClass.b = 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类，顾名思义内部类定义在 方法内部，其有效范围也在方法内部，方法外部无法访问,即：对外部世界完全的隐藏起来。</p><p>通过 <code>javac Test.java</code> 对该类进行编译，生成的 class 有 3 个，分别为： <code>Test.class</code>、<code>Test$1InnerBase.class</code>、<code>Test$1SubInnerClass.class</code>。</p><p>局部内部类遵循如下命名格式：<br><strong>OutClassName$NInnerClassName 其中 N 表示第 N 个内部类。</strong></p><h3 id="6-匿名内部类-Anonymous-Inner-Class"><a href="#6-匿名内部类-Anonymous-Inner-Class" class="headerlink" title="6. 匿名内部类(Anonymous Inner Class)"></a>6. 匿名内部类(Anonymous Inner Class)</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>匿名内部类适合创建只需要一次使用的类。</p><p>定义内部类的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 实现接口 或 父类构造器(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    类的主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由其格式可知，<strong>匿名内部类必须且只能继承一个父类，或实现且最多一个接口</strong>。</p><p>由于构造器必须与类名相同，而匿名内部类不能有类名，所以匿名类不能有构造器。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IClick &#123;</span><br><span class="line">    void change();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public  void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        final String  name = &quot;name&quot;;</span><br><span class="line">        show(new IClick() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void change() &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  void show(IClick click)&#123;</span><br><span class="line">        click.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名内部类的时机：</p><p>show 方法参数为 IClick，此时考虑传入 IClick 的实现类的对象，如果 IClick 的实现类除了在此处使用外，还有其他类或方法使用该接口的实现类，那么此时应该定义一个该接口的实现类。但是如果 IClick 的实现类只会使用一次，那么可以定义一个匿名内部类，如上面实现方式。</p><p>在 Java8 之前，要求被匿名内部类、局部内部类访问的局部变量必须使用 final 修饰，Java8 则取消了这个限制，其实是 Java 自动添加了 final 修饰符。</p><p>原因：</p><p>对于普通局部变量而言，它的作用域停留在方法内，当方法执行完毕，该局部变量也随之消失，但局部内部类或匿名内部类，则可能产生隐式的 “闭包”，闭包使得局部变量脱离它所在的方法继续存在。</p><p>内部类和外部类处于同一层级，也就是说如果在方法内声明内部类实例的对象不会和局部变量一样在方法执行完毕后就会被回收</p><p>个人理解，匿名内部类是一个实现了接口或继承类的类。</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><ul><li>由于系统在创建匿名内部类时，会创建匿名内部类的对象，所以匿名内部类 <strong>不能定义为抽象类</strong>。</li><li>由于匿名内部类没有类名，所以匿名内部类 <strong>无法定义构造器</strong>，但可以使用初始化块进行初始化。</li></ul><p>方法的返回值的生成和表示这个返回值的类的定义结合在一起。</p><hr><p><strong>Q:</strong> 为什么需要内部类？</p><p><strong>A:</strong> 如果你想实现一个接口，但是这个接口中的一个方法和你构想的这个类中的一个方法的名称，参数相同，你应该怎么办？这时候，你可以建一个内部类实现这个接口。由于内部类对外部类的所有内容都是可访问的，所以这样做可以完成所有你直接实现这个接口的功能。</p><p>真正的原因，java中的内部类和接口加在一起，可以很好的实现多继承的效果。</p><p><strong>Q:</strong> 内部类是否有用、必要和安全</p><p><strong>A:</strong> 内部类是一种编译器现象，与虚拟机无关。编译器会把内部了翻译成用 <code>$</code> 分割外部类名与内部类名的常规文件，而虚拟机对此一无所知。</p><hr><p><a href="https://www.zhihu.com/question/21395848" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概要&quot;&gt;&lt;a href=&quot;#1-概要&quot; class=&quot;headerlink&quot; title=&quot;1. 概要&quot;&gt;&lt;/a&gt;1. 概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;内部类为什么会出现&lt;/li&gt;
&lt;li&gt;内部类的调用&lt;/li&gt;
&lt;li&gt;内部类与外部类访问成员变量的不同&lt;/li&gt;
&lt;li&gt;静态内部类和非静态内部类&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-1-为什么使用内部类&quot;&gt;&lt;a href=&quot;#1-1-为什么使用内部类&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么使用内部类&quot;&gt;&lt;/a&gt;1.1 为什么使用内部类&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内部类提供了 &lt;strong&gt;更好的封装&lt;/strong&gt;，可以把内部类的细节隐藏在外部类中，对同一个包中的其他类不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;内部类可以访问外部类的数据 (包括私有变量)&lt;/strong&gt;，但是外部类不可以访问内部类的私有变量。因为内部类持有外部类的引用。&lt;/p&gt;
&lt;p&gt;内部类为外部类的成员，成员之间可以互相访问,这符合 Java 对象思想，但是外部类不可以访问内部类的私有数据。&lt;/p&gt;
&lt;p&gt;真实原因是 JVM 在编译时会将外部类和内部类便以为两个类 – OutterClass.class、OutterClass$InnerClass,OutterClass$InnerClass 对象持有 OutterClass 类的引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可以使用匿名内部类创建访问一次的类&lt;/strong&gt;，十分方便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;2-非静态内部类&quot;&gt;&lt;a href=&quot;#2-非静态内部类&quot; class=&quot;headerlink&quot; title=&quot;2. 非静态内部类&quot;&gt;&lt;/a&gt;2. 非静态内部类&lt;/h3&gt;&lt;p&gt;例子 ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class OutClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private int num2 = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private class InnerClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private int num = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        private void method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method inner num &amp;quot; + this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num &amp;quot; + OutClass.this.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;innerclass method out num2 &amp;quot; + num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        OutClass outclass = new OutClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;main &amp;quot;+ outclass.num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        outclass.test();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private void test() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InnerClass inner = new InnerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inner.method();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;outclass test&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="内部类" scheme="/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本使用</title>
    <link href="/2019/04/02/Vim/"/>
    <id>/2019/04/02/Vim/</id>
    <published>2019-04-02T03:33:55.000Z</published>
    <updated>2019-05-23T02:58:41.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、插入命令"><a href="#1、插入命令" class="headerlink" title="1、插入命令"></a>1、插入命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">在光标所在字符<code>后</code>插入</td></tr><tr><td align="center">A</td><td align="center">在光标所在<code>行尾</code>插入</td></tr><tr><td align="center">i</td><td align="center">在光标所在字符<code>前</code>插入</td></tr><tr><td align="center">I</td><td align="center">在光标所在<code>行首</code>插入</td></tr><tr><td align="center">o</td><td align="center">在光标<code>下</code>插入行</td></tr><tr><td align="center">O</td><td align="center">在光标<code>上</code>插入行</td></tr></tbody></table><h3 id="2、定位命令"><a href="#2、定位命令" class="headerlink" title="2、定位命令"></a>2、定位命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:set nu</td><td align="center">设置行号</td></tr><tr><td align="center">:set nonu</td><td align="center">取消行号</td></tr><tr><td align="center">gg</td><td align="center">到第一行</td></tr><tr><td align="center">G</td><td align="center">到最后一行</td></tr><tr><td align="center">nG</td><td align="center">到第n行</td></tr><tr><td align="center">:n</td><td align="center">到第n行</td></tr><tr><td align="center">$</td><td align="center">移至行尾</td></tr><tr><td align="center">0</td><td align="center">移至行首</td></tr></tbody></table><a id="more"></a><h3 id="3、删除命令"><a href="#3、删除命令" class="headerlink" title="3、删除命令"></a>3、删除命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除光标所在处字符</td></tr><tr><td align="center">nx</td><td align="center">删除光标所在处后 n 个字符</td></tr><tr><td align="center">dd</td><td align="center">删除光标所在行</td></tr><tr><td align="center">ndd</td><td align="center">删除n行</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在行到<code>文件末尾</code>的内容</td></tr><tr><td align="center">D</td><td align="center">删除光标所在处到<code>行尾</code>的内容</td></tr><tr><td align="center">:n1,n2d</td><td align="center">删除指定范围的行</td></tr></tbody></table><h3 id="4、复制和剪切命令"><a href="#4、复制和剪切命令" class="headerlink" title="4、复制和剪切命令"></a>4、复制和剪切命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制当前行</td></tr><tr><td align="center">nyy</td><td align="center">复制当前行以下 n 行</td></tr><tr><td align="center">dd</td><td align="center">剪切当前行</td></tr><tr><td align="center">ndd</td><td align="center">剪切当前行以下 n 行</td></tr><tr><td align="center">p</td><td align="center">粘贴在当前光标所在行下</td></tr><tr><td align="center">P</td><td align="center">粘贴在当前光标所在行上</td></tr></tbody></table><h3 id="5、替换和取消命令"><a href="#5、替换和取消命令" class="headerlink" title="5、替换和取消命令"></a>5、替换和取消命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">取代光标所在处字符</td></tr><tr><td align="center">R</td><td align="center">从光标所在处开始替换字符，按 Esc 结束</td></tr><tr><td align="center">u</td><td align="center">取消上一步操作</td></tr></tbody></table><h3 id="6、搜索和搜索替换命令"><a href="#6、搜索和搜索替换命令" class="headerlink" title="6、搜索和搜索替换命令"></a>6、搜索和搜索替换命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">/string</td><td align="center">搜索指定字符串 、搜索时忽略大小写 <code>:set ic</code></td></tr><tr><td align="center">n</td><td align="center">搜索指定字符串的下一个出现位置</td></tr><tr><td align="center">：%s/old/new/g</td><td align="center">全文替换指定字符串</td></tr><tr><td align="center">：n1，n2/old/new/g</td><td align="center">在一定范围内替换指定字符串</td></tr></tbody></table><h3 id="7、保存和退出命令"><a href="#7、保存和退出命令" class="headerlink" title="7、保存和退出命令"></a>7、保存和退出命令</h3><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">保存修改</td></tr><tr><td align="center">:w new_filename</td><td align="center">另存为指定文件</td></tr><tr><td align="center">：wq</td><td align="center">保存修改并退出</td></tr><tr><td align="center">ZZ</td><td align="center">快捷键，保存修改并退出</td></tr><tr><td align="center">:q!</td><td align="center">不保存修改退出</td></tr><tr><td align="center">：wq!</td><td align="center">保存修改并退出（文件所有者及root 用户可使用）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、插入命令&quot;&gt;&lt;a href=&quot;#1、插入命令&quot; class=&quot;headerlink&quot; title=&quot;1、插入命令&quot;&gt;&lt;/a&gt;1、插入命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;a&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;后&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;A&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行尾&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;i&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在字符&lt;code&gt;前&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;I&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标所在&lt;code&gt;行首&lt;/code&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;o&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;下&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;在光标&lt;code&gt;上&lt;/code&gt;插入行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;2、定位命令&quot;&gt;&lt;a href=&quot;#2、定位命令&quot; class=&quot;headerlink&quot; title=&quot;2、定位命令&quot;&gt;&lt;/a&gt;2、定位命令&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;命令&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;设置行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:set nonu&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;取消行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;gg&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;G&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;nG&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;:n&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;到第n行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移至行首&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="VIM" scheme="/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>IntentFilter匹配规则</title>
    <link href="/2019/04/02/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>/2019/04/02/IntentFilter匹配规则/</id>
    <published>2019-04-02T02:28:45.000Z</published>
    <updated>2019-05-16T07:52:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。</p><h3 id="action-匹配规则"><a href="#action-匹配规则" class="headerlink" title="action 匹配规则"></a>action 匹配规则</h3><p>action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。</p><p>action 的匹配规则是：<strong>Intent 中的 action 必须能够和过滤规则中的 action 匹配</strong>，匹配是指两个 action 的字符串完全相同。</p><p>一个过滤规则的中可以有多个 action，<strong>只要 Intent 中的任何一个 action 和其中的一个 action 匹配，则可匹配成功</strong>。</p><p>action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，<strong>action 区分大小写</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(&quot;xxaction&quot;)</span><br><span class="line">intent.setAction(&quot;&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="category-匹配规则"><a href="#category-匹配规则" class="headerlink" title="category 匹配规则"></a>category 匹配规则</h3><p>category 是一个字符串，系统预定义了一些 category，用户也可以定义自己的 category。</p><p>category 的匹配规则：Intent 中如果含有 category，那么 Intent <strong>所有的</strong> category 必须和过滤规则中的一个相同。</p><p>为 Intent 的添加 category 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.addCategory(&quot;xxx&quot;);</span><br></pre></td></tr></table></figure><p>系统在调用 <code>startActivity</code> 或 <code>startActivityForResult</code> 时会为 Intent 添加 <code>android.intent.category.DEFAULT</code> 这个 category,所以在隐式调用 Activity 时需要在清单文件中显示的添加 <code>android.intent.category.DEFAULT</code> 这条过滤规则。</p><p>Activity 的显示调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent(this,SecondActivity::class.java)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>Activity 的隐式调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intent.setAction(&quot;xxx&quot;)</span><br><span class="line">intent.addCategory(&quot;xxx&quot;)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;</span><br><span class="line">    &lt;intent-filter&gt;   </span><br><span class="line">        &lt;category android:name = &quot;android.intent.category.DEFAULT&quot; //&gt;   </span><br><span class="line">    &lt;/intent-filter&gt;       </span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure><h3 id="data-的匹配规则"><a href="#data-的匹配规则" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h3><h4 id="data-的结构"><a href="#data-的结构" class="headerlink" title="data 的结构"></a>data 的结构</h4><p>data 由两部分组成， mimeType 和 URI。</p><ul><li><p>mimeType</p><p>  mimeType 指的是 <strong>媒体类型</strong>，例如：如image/jpeg、audio/mpeg4generic和video/* 等，可以表示图片、文本、视频等不同的媒体类型。</p></li><li><p>URI(统一资源标识符)</p><p>  URI 的结构</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;](中括号中表示三者可选)</span><br></pre></td></tr></table></figure><p>  如下面的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/info</span><br></pre></td></tr></table></figure><ul><li><p>Scheme</p><p>  URI 模式，比如 http、file、content 等，如果 URI 没有指定有效 scheme，那么整个 URI 都是无效的。</p></li><li><p>Host</p><p>  URI 的主机名，如果没有指定 host ，那么其他的参数都是无效的，整个 URI 都是无效的。</p></li><li><p>Port</p><p>  URI 的端口号。当 URI 的 Scheme 和 Host 指定后 Port 才会有效。</p></li><li><p>Path、PathPrefix、PathPattern</p><p>  三者均表示路径信息。Path 表示完整的路径信息，PathPattern 也表示完整的路径信息，但是其中可以包含通配符 “*” ，表示 0 个或任意多个字符；PathPrefix 表示路径的前缀信息。</p></li></ul></li></ul><h4 id="data-的匹配规则-1"><a href="#data-的匹配规则-1" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h4><p>data 的匹配规则：<strong>Intent 中的 data 数据必须和过滤规则中的某一个 data 完全匹配。</strong><br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val intent = Intent()</span><br><span class="line">intnet.setDataAndType((Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)</span><br></pre></td></tr></table></figure><p>那么对应的 IntentFilter 中的匹配过滤信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot; android:scheme=&quot;file&quot; android:host=&quot;abc&quot;&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">OR</span><br><span class="line"></span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">    &lt;data android:mimeType=&quot;image/*&quot;/&gt; </span><br><span class="line">    &lt;data android:scheme=&quot;file&quot;/&gt;</span><br><span class="line">    &lt;data android:host=&quot;abc&quot;/&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br><span class="line"></span><br><span class="line">// 两组是完全相同的，只是第二组把 URI 的各个部分分开表示。</span><br></pre></td></tr></table></figure><p>在 App 中吊起系统相册时，我们就需要设置 Intent 的 data 属性来调取系统中特定的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IntentFilter 中的过滤信息包括 action、category、data，为了匹配过滤列表需要同时匹配 action、category、data ，否则匹配失败。&lt;/p&gt;
&lt;h3 id=&quot;action-匹配规则&quot;&gt;&lt;a href=&quot;#action-匹配规则&quot; class=&quot;headerlink&quot; title=&quot;action 匹配规则&quot;&gt;&lt;/a&gt;action 匹配规则&lt;/h3&gt;&lt;p&gt;action 是一个字符串，系统定义了一些 action，用户自己也可以定义 action。&lt;/p&gt;
&lt;p&gt;action 的匹配规则是：&lt;strong&gt;Intent 中的 action 必须能够和过滤规则中的 action 匹配&lt;/strong&gt;，匹配是指两个 action 的字符串完全相同。&lt;/p&gt;
&lt;p&gt;一个过滤规则的中可以有多个 action，&lt;strong&gt;只要 Intent 中的任何一个 action 和其中的一个 action 匹配，则可匹配成功&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同，&lt;strong&gt;action 区分大小写&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val intent = Intent(&amp;quot;xxaction&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;intent.setAction(&amp;quot;&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android编程中的一些概念(Wiki)</title>
    <link href="/2019/04/01/Android%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/04/01/Android编程中的一些概念/</id>
    <published>2019-04-01T02:38:59.000Z</published>
    <updated>2019-04-09T03:33:34.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译器(compiler) ,是一种 <strong>应用程序</strong>，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。</p><p>它的主要目的是将人编写、维护的高级计算机语言所写出的 <strong>源代码程序</strong>，翻译为计算机能解读、运行的低价 <strong>机器语言</strong> 的程序，也就是 <strong>可执行文件</strong>。</p><p>常见的编译器：</p><ol><li>GCC(GUN Compiler Collection)</li></ol><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><ol start="2"><li>LLVM</li></ol><p>LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。</p><a id="more"></a><h3 id="编译策略"><a href="#编译策略" class="headerlink" title="编译策略"></a>编译策略</h3><ol><li>即时编译(JIT,Just In Time)</li></ol><p>动态编译的一种形式，提高程序运行效率的方法。程序运行有两种方式：<br>    1. 静态编译。执行程序前程序全部被翻译为机器码。<br>    2. 动态解释。解释执行则是边执行边翻译。<br>即时编译器则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。</p><p>即时编译器有两种类型：</p><pre><code>1. 字节码翻译。2. 动态编译翻译。</code></pre><ol start="2"><li>提前编译(AOT,Ahead Of Time)</li></ol><h3 id="运行时系统"><a href="#运行时系统" class="headerlink" title="运行时系统"></a>运行时系统</h3><p>运行环境有称运行时系统，是指把半编译的运行码在目标机器上运行的环境，如 Java<br> 的 JRE。</p><h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p> 可执行文件，是指 <strong>内容可被计算机解释为程序</strong> 的文件，通常可执行文件内含有二进制编码的微处理器指令，所以可执行文件也可被称为 二进制文件。<br> <strong>扩展名：</strong></p><ul><li><p>.exe</p></li><li><p>.com</p></li><li><p>.run</p><p><strong>脚本：</strong></p><p>不是所有的可执行文件都只存在计算机识别的数据，脚本中也是可执行文件，但是内含人类识别的数据，原因：<strong>脚本语言无需经过编译器先编译，就可经过解释器运行(Perl、Python、Shell)</strong>。</p></li></ul><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释器(interpreter),是一种 <strong>计算机程序</strong>，能够把高级编程语言一行一行解释运行，每次运行程序都需要将先转成另外一种语言再作运行，因此解释器的程序运行速度比较慢，运行程序只能将程序一行一行的翻译。</p><p>解释器的好处是它消除了编译整个程序的负担，程序可以拆分成多个部分来模块化，但这会让运行时的效率打了折扣。相对地，编译器已一次将所有源代码翻译成另一种语言，如机器代码，运行时便无需再依赖编译器或额外的程序，故而其运行速度比较快。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>在计算机科学体系结构中，虚拟机指一种 <strong>特殊的软件</strong>，可以在计算机平台和终端用户之间创建一种环境，而终端用户则是 <strong>基于这个软件所创建的环境来操作的软件</strong>。</p><h3 id="Dalvik-虚拟机"><a href="#Dalvik-虚拟机" class="headerlink" title="Dalvik 虚拟机"></a>Dalvik 虚拟机</h3><p>为 Google 开发的 Android 移动设备平台的核心组成部分之一，它支持 .dex(Dalvik Executable) 格式的 Java 应用程序的运行，.dex 格式为专门为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。</p><p>Java 虚拟机和大部分虚拟机包括 JVM 都是基于堆栈的虚拟机，而 Dalvik 虚拟机为 寄存器虚拟机。</p><p>从Android 5.0版起，Android Runtime（ART）取代Dalvik成为系统内默认虚拟机。</p><h3 id="Android-Runtime"><a href="#Android-Runtime" class="headerlink" title="Android Runtime"></a>Android Runtime</h3><p>ART，是一种在 Android 操作系统上的 <strong>运行环境</strong>， ART 能够把应用程序的字节码转换为机器码，是 Android 使用的一种新的虚拟机。与 Dalvik 不同的出 ART 使用的 AOT 技术，而 Dalvik 使用的为 JIT 技术。</p><p>ART 改善了性能、垃圾回收等方面。</p><p>ART引入了 AOT 技术，应用程序在安装时将所有的字节码编译成机器码，所以其在安装时花费的时间更长，同时也会占用更大的内部存储空间，用于存储编译后的代码。</p><h3 id="代码类型"><a href="#代码类型" class="headerlink" title="代码类型"></a>代码类型</h3><p><strong>源代码：</strong></p><p>指人类可读的计算机语言指令，如我们平时编程用到的 Java 、Py、PHP、C++ 等。</p><p><strong>目标代码：</strong></p><p>编译器或汇编器处理源代码后所生成的代码，它一般由机器代码或接近于机器语言的代码组成。存放目标代码的文件称为目标文件，常被称为 <strong>二进制文件</strong>。</p><p>目标文件中包含着机器代码以及代码运行中使用到的数据，以及其他信息。</p><p><strong>字节码：</strong></p><p><img src="/images/2019_04_02_2.jpg" alt="字节码"></p><p>字节码(ByteCode),通常指已经经过编译，但是与特定机器代码无关，需要解释器转译后才能成为机器的中间代码。字节码不能像源代码一样可以供人阅读，而是编译后的数值常量、引用、指令等构成的序列。</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。字节码的实现方式是通过编译器和虚拟机。编译器将源码编译成字节码，特定平台上的虚拟机将字节码转译为可以直接运行的指令。字节码的典型应用为Java bytecode。</p><p><strong>机器语言：</strong></p><p>机器语言是一种指令集体系，这种指令体系称为机器代码，是指计算机的 CPU 可直接解读的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h3&gt;&lt;p&gt;编译器(compiler) ,是一种 &lt;strong&gt;应用程序&lt;/strong&gt;，它会将某种编程语言写成的源代码(原始语言)，转换为另外一种编程语言(目标语言)。&lt;/p&gt;
&lt;p&gt;它的主要目的是将人编写、维护的高级计算机语言所写出的 &lt;strong&gt;源代码程序&lt;/strong&gt;，翻译为计算机能解读、运行的低价 &lt;strong&gt;机器语言&lt;/strong&gt; 的程序，也就是 &lt;strong&gt;可执行文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;常见的编译器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GCC(GUN Compiler Collection)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。它是为了任意一种编程语言而写成的程序，利用虚拟技术创造出编译时期、链接时期、运行时期以及“闲置时期”的最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译技术" scheme="/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>常用的 Gradle 命令</title>
    <link href="/2019/03/28/%E5%B8%B8%E7%94%A8%E7%9A%84-Gradle-%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/28/常用的-Gradle-命令/</id>
    <published>2019-03-28T08:37:33.000Z</published>
    <updated>2019-03-29T10:55:03.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gradlew-q-app-dependencies"><a href="#gradlew-q-app-dependencies" class="headerlink" title="gradlew -q app:dependencies"></a>gradlew -q app:dependencies</h3><p>出现依赖库版本冲突，一般会包如下错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 28.0.0, 25.2.0. Examples include com.android.support:animated-vector-drawable:28.0.0 and com.android.support:support-media-compat:25.2.</span><br></pre></td></tr></table></figure><p>一般出现这种错的原因是自己依赖的库与其他依赖的库所依赖的库为同一个 group 的库，但是版本不同。</p><p>使用 <strong>./gradlew -q app:dependencies</strong> 可以看到自己项目依赖库的层级关系：</p><p>解决：使用 exclude 排除相应的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">api &apos;com.android.support:appcompat-v7:28.0.0&apos;</span><br><span class="line">api (&quot;com.alibaba:arouter-api:1.4.0&quot;)&#123;</span><br><span class="line">    exclude group: &apos;com.android.support&apos;,module:&apos;support-v4&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;gradlew-q-app-dependencies&quot;&gt;&lt;a href=&quot;#gradlew-q-app-dependencies&quot; class=&quot;headerlink&quot; title=&quot;gradlew -q app:dependencies&quot;&gt;&lt;/a&gt;gradlew
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 jar 、aar</title>
    <link href="/2019/03/27/%E6%89%93%E5%8C%85-jar-%E3%80%81aar/"/>
    <id>/2019/03/27/打包-jar-、aar/</id>
    <published>2019-03-27T02:47:06.000Z</published>
    <updated>2019-03-28T10:06:15.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的 aar 文件包括：AndroidManifest.xml，classes.jar，res，R.txt。</p><p>jar：只包含了 class 文件和清单文件，不包含资源文件。</p><p>如果需要资源文件，那么以 aar 的形式引入到工程，反之使用 jar。</p><h3 id="打包-aar、jar"><a href="#打包-aar、jar" class="headerlink" title="打包 aar、jar"></a>打包 aar、jar</h3><p>如果将 Application 打包为 aar，做以下更改：</p><ol><li>将 <code>apply plugin: &#39;com.android.application&#39;</code> 改为 <code>apply plugin: &#39;com.android.library&#39;</code></li><li>去掉 <code>applicationId</code></li><li>项目根目录执行 <code>./gradlew assembleRelease</code>,就可以在相应的目录(build/output/aar)下看到生成的 aar，在 <code>build/intermediates/packed-classes</code> 中看到相应的 jar 包。</li></ol><p>可以使用新建 gradle task 可以将生成的 jar 包直接复制到 libs 下，并完成构建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task copyJar(type: Copy) &#123;</span><br><span class="line">    def name = project.name //Library名称</span><br><span class="line">    delete &apos;libs/&apos; + name + &apos;.jar&apos; //删除之前的旧jar包</span><br><span class="line">    from(&apos;build/intermediates/packaged-classes/release/&apos;) //从这个目录下取出默认jar包</span><br><span class="line">    into(&apos;libs/&apos;) //将jar包输出到指定目录下</span><br><span class="line">    include(&apos;classes.jar&apos;)</span><br><span class="line">    rename(&apos;classes.jar&apos;, name + &apos;.jar&apos;) //自定义jar包的名字</span><br><span class="line">&#125;</span><br><span class="line">copyJar.dependsOn(build)</span><br></pre></td></tr></table></figure><h3 id="自定义-jar"><a href="#自定义-jar" class="headerlink" title="自定义 jar"></a>自定义 jar</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;aar:(Android Archive) 是一个 Android 库项目的二进制归档文件，里面不仅包含工程代码还包括工程资源文件，大部分的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Adb 运行原理和常用命令</title>
    <link href="/2019/03/26/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>/2019/03/26/adb-常用命令/</id>
    <published>2019-03-26T03:32:49.000Z</published>
    <updated>2019-08-12T10:03:10.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：</p><ol><li>客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。</li><li>后台程序。在相应的设备(模拟器、真机)上运行命令，作为<code>后台进程</code> 在 <code>设备</code>上运行。</li><li>服务器。管理客户端和后台程序之间的通信，在 <code>开发计算机</code> 上作为 <code>后台进程</code> 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。</li></ol><p>android_sdk/platform-tools/ 中找到 adb 工具。</p><h3 id="adb-工作方式"><a href="#adb-工作方式" class="headerlink" title="adb 工作方式"></a>adb 工作方式</h3><ol><li>启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。</li><li>服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。</li><li>当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。</li></ol><a id="more"></a><h3 id="通过-WLAN-连接设备"><a href="#通过-WLAN-连接设备" class="headerlink" title="通过 WLAN 连接设备"></a>通过 WLAN 连接设备</h3><p><strong>adb tcpip 5555:</strong> 设置设备监听 5555 端口上的 TCP/IP 的连接。</p><p><strong>adb connect xxx:</strong>  通过目标设备的 IP 连接设备。</p><p><strong>adb disconnect ip:</strong> 断开指定 IP 的设备 </p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>adb devices:</strong> 查找设备</p><p><strong>adb -s serialNum commond:</strong> 指定设备执行命令</p><p><strong>adb install apk:</strong> 安装 apk</p><p><strong>adb -s xxxx install apk:</strong> 指定设备上安装 apk</p><p><strong>adb install -r apk:</strong> 覆盖安装</p><p><strong>adb -d install apk:</strong> 唯一 USB 连接设备安装 apk</p><p><strong>adb -e install apk:</strong> 唯一模拟器设备安装 apk</p><p><strong>adb uninstall packageName:</strong> 卸载 apk</p><p><strong>adb uninsatll -k packageName:</strong> 卸载 apk,但是保留其配置和缓存文件</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><strong>adb push localFile remoteDictory:</strong> 将本地的文件 push 远端指定的目录下</p><p><strong>adb pull file remoteDictory:</strong> 从 remoteDictory 中复制指定的 file 到当前目录下</p><h3 id="adb-服务器"><a href="#adb-服务器" class="headerlink" title="adb 服务器"></a>adb 服务器</h3><p>adb kill-server： 停止 adb 服务器</p><p>adb start-server：开启 adb 服务</p><h3 id="adb-shell"><a href="#adb-shell" class="headerlink" title="adb shell"></a>adb shell</h3><p>在目标设备启动远程 shell </p><h3 id="adb-shell-am"><a href="#adb-shell-am" class="headerlink" title="adb shell am"></a>adb shell am</h3><p>使用 adb shell am 与应用交互。</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>start [option] <intent></intent></td><td>启动 <intent> 指定的 Activity</intent></td></tr><tr><td>startservice [options] <intent></intent></td><td>启动 <intent> 指定的 Service</intent></td></tr><tr><td>broadcast [options] <intent></intent></td><td>发送 <intent> 指定的广播</intent></td></tr><tr><td>force-stop <packagename></packagename></td><td>停止 <packagename> 相关的进程</packagename></td></tr></tbody></table><p><intent> 有关的选项<br>参数|含义<br>–|–<br>-a | <action>    指定 action，比如 android.intent.action.VIEW<br>-c | <category>    指定 category，比如 android.intent.category.APP_CONTACTS<br>-n | <component>    指定完整 component 名，用于明确指定启动哪个 Activity，如 com.gy/.MainActivity</component></category></action></intent></p><p><intent> 可以传参</intent></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb shell start -n com.gy/.MainActivity //启动指定的 Activity</span><br><span class="line"></span><br><span class="line">adb shell startService -n com.gy/.TestService //启动指定的 Service</span><br><span class="line"></span><br><span class="line">adb shell broadcast  -a android.intent.action.BOOT_COMPLETED -n com.gy/.TestBroadcast //向指定的 BroadCast 发送广播</span><br><span class="line"></span><br><span class="line">adb shell am force-stop com.gy // 关闭指定 app 的一切进程与服务</span><br></pre></td></tr></table></figure><h3 id="adb-shell-pm"><a href="#adb-shell-pm" class="headerlink" title="adb shell pm"></a>adb shell pm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br><span class="line"></span><br><span class="line">adb shell pm clear &lt;packagename&gt;:清除数据与缓存</span><br><span class="line"></span><br><span class="line">adb shell pm path &lt;packagename&gt;:应用安装路径</span><br></pre></td></tr></table></figure><h3 id="adb-shell-wm"><a href="#adb-shell-wm" class="headerlink" title="adb shell wm"></a>adb shell wm</h3><p>屏幕相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size: 屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm size 480x1024: 屏幕分辨率修改为 480x1024</span><br><span class="line"></span><br><span class="line">adb shell wm size reset: 恢复屏幕分辨率</span><br><span class="line"></span><br><span class="line">adb shell wm density: 屏幕密度</span><br><span class="line"></span><br><span class="line">adb shell wm density 160 : 屏幕密度设置为 160dpi</span><br><span class="line"></span><br><span class="line">adb shell wm density reset: 恢复屏幕密度</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys"><a href="#adb-shell-dumpsys" class="headerlink" title="adb shell dumpsys"></a>adb shell dumpsys</h3><p>查看运行状态,打印出当前系统的系统信息，默认打印出设备中所有的 service 的信息。</p><p>查看 Service List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys</span><br><span class="line">adb shell service list</span><br></pre></td></tr></table></figure><p>查看正在运行中的 Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure><p>查看应用的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure><p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等</p><p>查看应用安装路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br><span class="line">db shell dumpsys window | grep init</span><br></pre></td></tr></table></figure><h3 id="adb-shell-dumpsys-activity-内容组成"><a href="#adb-shell-dumpsys-activity-内容组成" class="headerlink" title="adb shell dumpsys activity 内容组成"></a>adb shell dumpsys activity 内容组成</h3><ol><li>ACTIVITY MANAGER SETTINGS(dumpsys activity settings)</li><li>ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)</li><li>ACTIVITY MANAGER BROADCAST STATE(dumpsys activity broadcasts)</li><li>ACTIVITY MANAGER CONTENT PROVIDERS(dumpsys activity providers)</li><li>ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)</li><li>ACTIVITY MANAGER SERVICES (dumpsys activity services)</li><li>ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)</li><li>ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)</li><li>ACTIVITY MANAGER STARTER (dumpsys activity starter)</li><li>ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)</li><li>ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)</li></ol><p>使用 <code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code> 限制仅输出 “Running activities” 列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;adb(Android Debug Briage) 一个通用的命令行工具，允许使用它与模拟器或 Android 设备进行通信。 adb 为一个 客户端-服务器程序，包含三个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端。发送命令，在电脑端运行，发出 adb 命令从命令行终端调用客户端。&lt;/li&gt;
&lt;li&gt;后台程序。在相应的设备(模拟器、真机)上运行命令，作为&lt;code&gt;后台进程&lt;/code&gt; 在 &lt;code&gt;设备&lt;/code&gt;上运行。&lt;/li&gt;
&lt;li&gt;服务器。管理客户端和后台程序之间的通信，在 &lt;code&gt;开发计算机&lt;/code&gt; 上作为 &lt;code&gt;后台进程&lt;/code&gt; 运行。 每个设备将获取一对按顺序排列的端口，一个用于控制台的偶数号端口和一个用于 adb 连接的奇数号端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;android_sdk/platform-tools/ 中找到 adb 工具。&lt;/p&gt;
&lt;h3 id=&quot;adb-工作方式&quot;&gt;&lt;a href=&quot;#adb-工作方式&quot; class=&quot;headerlink&quot; title=&quot;adb 工作方式&quot;&gt;&lt;/a&gt;adb 工作方式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;启动 客户端，如果没有 adb 服务器进程，则启动服务器进程。服务器启动后，与本地的 TCP 端口 5037 绑定，它监听从 adb 客户端发送的命令(所有的 adb 命令均使用 5037 端口与 adb 服务器通信)。&lt;/li&gt;
&lt;li&gt;服务器与所有运行的模拟器或设备连接。它扫描5555 到 5585 之间的奇数号端口查找设备。 服务器一旦发现 adb 后台程序，它将与该端口的设备连接。&lt;/li&gt;
&lt;li&gt;当服务器与所有的设备连接后，使用 adb 命令来访问这些设备。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="adb" scheme="/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Java IO 流</title>
    <link href="/2019/03/25/%E6%B5%81/"/>
    <id>/2019/03/25/流/</id>
    <published>2019-03-25T09:03:45.000Z</published>
    <updated>2019-04-09T07:40:35.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>File 为文件和目录路径名的抽象表示方式。<br>一个 File 对象可以代表一个文件或目录的抽象。<br>建立 File 对象不会对文件系统产生影响。</p><p>File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。</p><p>File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。</p><h3 id="File-的基本操作"><a href="#File-的基本操作" class="headerlink" title="File 的基本操作"></a>File 的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getName():获得文件的名字、路径名</span><br><span class="line">getPath():路径名</span><br><span class="line">getAbsoluteFile():绝对路径名</span><br><span class="line">getParentFile():父路径，没有为 null</span><br><span class="line">file 的绝对路径和相对路径</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建文件和删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createNewFile():</span><br><span class="line">createTempFile():创建临时文件，调用 deleteOnExit 会在程序退出后删除。</span><br></pre></td></tr></table></figure><p>文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir():新建文件夹，父路径不存在创建失败,文件夹存在不创建</span><br><span class="line">mkdirs():新建文件夹链，父路径不存在创建父目录</span><br></pre></td></tr></table></figure><h3 id="IO-流原理"><a href="#IO-流原理" class="headerlink" title="IO 流原理"></a>IO 流原理</h3><p>程序与文件、数组、网络连接数据库之间进行进行数据交换。</p><p><strong>IO 流的操作以程序为中心，什么是以程序为中心？</strong></p><p>就是如果要读度文件数据的话，对于文件来说为输出流，而对于程序来说为输入流，那么就以输入流来命名该文件流。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按流向分类</strong>：</p><ol><li>输入流</li><li>输出流</li></ol><p><strong>按处理的数据分类：</strong></p><ol><li>字节流：二进制，可以处理一切文件</li><li>字符流：文本文件 ，只能处理纯文本</li></ol><p><strong>按功能分类：</strong></p><ol><li>节点流：离源头近，包裹源头</li><li>处理流：增强功能，提高效率</li></ol><h3 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h3><p><strong>两种流均为节点流，节点流为直接和源文件相连的流。</strong></p><p>InputStream(输入字节流)、OutputStream(输出字节流)</p><table><thead><tr><th>–</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p><strong>字节流可以处理一切格式的文件</strong>。</p><p><strong>字节流常用 API</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileInputStream</span><br><span class="line">read(byte[] b)、read(byte[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileOutoutStream</span><br><span class="line">writer(byte[] b)、write(byte[],int off,int len)、flush()、close()</span><br></pre></td></tr></table></figure><p>// 读取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileInputStream inputStream = null;</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // 缓存数组</span><br><span class="line">        byte[] array = new byte[10];</span><br><span class="line">        int len = 0;//实际读取的大小</span><br><span class="line">        while ((len = inputStream.read(array)) != -1) &#123;</span><br><span class="line">            String info = new String(array, 0, len);</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 写出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(allPath, &quot;a&quot;);</span><br><span class="line">FileOutputStream outputStream = null;</span><br><span class="line">try &#123;</span><br><span class="line">    outputStream = new FileOutputStream(file, true);</span><br><span class="line">    String inrfo = &quot;wojwoo我们&quot;;</span><br><span class="line">    byte[] data = inrfo.getBytes();</span><br><span class="line">    outputStream.write(data);</span><br><span class="line">    outputStream.flush();//强制刷新，使在数组中的数据强制写出</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符流常用API</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#FileReader</span><br><span class="line">read(char[] b)、read(char[] b,int off,int len)、close()</span><br><span class="line"></span><br><span class="line">#FileWriter</span><br><span class="line">writer(char[] b)、write(char[],int off,int len)、flush()、close</span><br></pre></td></tr></table></figure><p><strong>流的基本操作：</strong></p><ol><li>建立联系。 File 为程序与文件之间的联系,即 建立 File 对象。</li><li>选择合适的流。 </li><li>操作：流的读取，关键：缓存数组。</li><li>关闭流。</li></ol><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p><strong>只可处理纯文本文件，如 .txt、 .html 。</strong>  </p><p>Reader、Writer、FileReader、FileWriter</p><p>纯文本的读取、纯文本的写出</p><p>数组为 char[] </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">File src = new File(allPath, &quot;a&quot;);</span><br><span class="line">Reader reader = null;</span><br><span class="line">if (src.exists()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = new FileReader(src);</span><br><span class="line">        char[] buffer = new char[512];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = reader.read(buffer)) != -1) &#123;</span><br><span class="line">            String str = new String(buffer, 0, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(&quot;file not exist&quot;);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p><img src="/images/2019_04_02_4.jpg" alt="字节流"></p><p><img src="/images/2019_04_02_3.jpg" alt="处理流"></p><p>增强功能，提高性能。</p><p><strong>节点流和处理流的关系：</strong></p><ol><li><p>节点流：可以直接从数据源读取或写出数据。</p></li><li><p>处理流：不直接连接到数据源或目的地，是处理流的流，通过对其他流的处理提高程序的性能。 </p></li><li><p>节点流处于 IO 操作的第一线，所有的操作必须通过它们，处理流可以对其他流进行处理。</p></li><li><p>处理流在节点流之上。</p></li></ol><p><strong>字节流的处理流</strong>：</p><p>BufferredInputStream、BufferendOutoutStream</p><p><strong>为字节流添加处理流</strong>：</p><p>new BufferredInputStream(new FileInputStream(xx,xx));</p><p>new BufferendOutoutStream(new FileOutputStream(xx,xx));</p><p><strong>字符流的处理流</strong>：</p><p>BufferendReader: readLine()</p><p>BufferendWrinter: newLine()</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>将字节流转换为字符流，可以指定编码格式将字节流转换为字符流，处理乱码(编码器、解码集)。</p><p>以程序为中心：</p><p>解码：二进制   –(解码字符集)–&gt;    字符</p><p>编码：字符  –(编码字符集)–&gt; 二进制</p><p>乱码原因：</p><ol><li>编码与解码字符集不同。</li><li>字节数目不完整。</li></ol><p> 字节流转换为字符流：</p><ol><li>输入流：InputStreamReader  解码（读取二进制文件，显示为人类可识别的字符）</li><li>输出流：OutputStreamWriter   编码 （将人类识别的字符转换为字节，写入文件）</li></ol><p>编码要求：使用字符流用指定的解码格式读取文本文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 初步实现如下，但是不能指定解码格式</span><br><span class="line">BufferendReader reader = new BufferendReader(new FileReader(xxx));</span><br><span class="line"></span><br><span class="line">//现在就是转换流出场的时候了，可以使用转换流以指定的解码方式将字节流转换为字符流</span><br><span class="line">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;&quot;),&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;File&quot;&gt;&lt;a href=&quot;#File&quot; class=&quot;headerlink&quot; title=&quot;File&quot;&gt;&lt;/a&gt;File&lt;/h3&gt;&lt;p&gt;File 为文件和目录路径名的抽象表示方式。&lt;br&gt;一个 File 对象可以代表一个文件或目录的抽象。&lt;br&gt;建立 File 对象不会对文件系统产生影响。&lt;/p&gt;
&lt;p&gt;File 为 文件与程序之间的联系，是一个抽象的概念，File 对象不能不能代表一个真正的文件。&lt;/p&gt;
&lt;p&gt;File 不能按其字面意思理解为文件，File 为文件与程序之间的抽象关系，能够建立 File 对象不能说明文件真正的存在，故在使用 File 对象的使用需要对 File 对象关联的文件判断是否存在操作。&lt;/p&gt;
&lt;h3 id=&quot;File-的基本操作&quot;&gt;&lt;a href=&quot;#File-的基本操作&quot; class=&quot;headerlink&quot; title=&quot;File 的基本操作&quot;&gt;&lt;/a&gt;File 的基本操作&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getName():获得文件的名字、路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getPath():路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getAbsoluteFile():绝对路径名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getParentFile():父路径，没有为 null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;file 的绝对路径和相对路径&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="IO 流" scheme="/tags/IO-%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>设计六大准则(设计模式之禅)</title>
    <link href="/2019/03/19/%E8%AE%BE%E8%AE%A1%E5%85%AD%E5%A4%A7%E5%87%86%E5%88%99/"/>
    <id>/2019/03/19/设计六大准则/</id>
    <published>2019-03-19T04:58:37.000Z</published>
    <updated>2019-03-25T07:11:28.685Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则 (Single Responsibility Principle)(SRP)"></a>单一职责原则 (Single Responsibility Principle)(SRP)</h3><p><strong>定义：</strong> 应该有且仅有一个原因引起类的变更。</p><p><strong>操作：</strong></p><ol><li>当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。</li><li>SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。</li></ol><p><strong>好处：</strong></p><ol><li>降低类的复杂度，实现什么职责都有明显的定义</li><li>可读性提高、可维护性强</li><li>变更风险低</li></ol><p><strong>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。</strong></p><a id="more"></a><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)(LSP)"></a>里氏替换原则(Liskov Substitution Principle)(LSP)</h3><p><strong>继承的优点</strong>：</p><ol><li>代码共享，每个子类拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>提高代码的扩展性，可 “随意” 重写父类方法；</li></ol><p><strong>继承的缺点：</strong></p><ol><li>继承具有入侵性，实现父类就必须拥有父类的方法和属性；</li><li>降低代码的灵活性，原因同上；</li><li>增强了耦合性。父类中的常量、变量、方法修改后，影响子类。</li></ol><p><strong>定义：</strong></p><p>凡是引用父类的地方都可以透明的使用其子类对象，反之，不成立。</p><p><strong>引申义：</strong></p><ol><li>子类必须完全实现父类的方法</li></ol><p><em>在类中调用其他类时 <code>务必使用父类或接口</code>，如果不能使用父类或接口，说明类的设计已经违反了 LSP 原则。</em></p><p>如果子类不能完整的实现父类中的方法或者父类中的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合等关系代替继承。</p><ol start="2"><li><p>子类可以有自己的方法。这也就是 LSP 原则不能反过来用的原因。</p></li><li><p>覆盖或实现父类方法时，输入参数可以被放大。 </p></li><li><p>覆盖或实现父类方法时，输出结果可以被缩小。</p></li></ol><p><strong>优点：</strong></p><p>里氏替换原则的目的是增强程序的健壮性，即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对于不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑。</p><h3 id="依赖倒置-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置(Dependence Inversion Principle)(DIP)"></a>依赖倒置(Dependence Inversion Principle)(DIP)</h3><p><strong>依赖倒置含义：</strong></p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖抽象。</li><li>抽象不应该依赖细节。</li><li>细节应该依赖抽象。</li></ol><p><strong>具体含义：</strong></p><p>低层模块：基本逻辑</p><p>高层模块：基本逻辑的组合</p><p>抽象：接口或抽象类</p><p>细节：实现类、继承子类</p><p><strong><em>模块之间的关系通过抽象产生</em></strong>，实现类之间不能直接发生依赖关系，其依赖关系通过上层的接口或者抽象类产生。</p><p>接口或抽象类不依赖实现类，实现类依赖接口或抽象类。</p><p><strong>优点：</strong></p><p>采用依赖倒置原则可以减少类间的耦合关系(更准确的说是(通过抽象类之间的关系)降低实现类之间的关系)，提高系统的稳定性，降低开发风险，提高代码的可读性和维护性。</p><p>抽象是对实现的约束，对依赖者而言，也是一种契约，不仅约束自己，同时还约束自己与外界的关系，其目的是保证所有的而细节不脱离契约的范畴，确保约束的双方按照既定的契约(抽象)共同发展，只要抽象这根基线存在，细节就不会超出范围。</p><p><strong>依赖关系</strong></p><p>依赖关系的概、具体表现、UML 图例表示可以参见 <a href="https://blog.csdn.net/Strange_Monkey/article/details/81531727" target="_blank" rel="noopener">Java 对象间关系以及 UML 类图表示方法</a> 下面简写如下：</p><ol><li>构造器函数传递依赖对象</li><li>方法中参数传递对象</li><li>接口声明中声明依赖对象。</li></ol><p><strong>最佳实践：</strong></p><p>依赖倒置原则的本质是 <code>通过抽象(抽象类或接口类)使各个类或模块的实现彼此独立</code>，不互相影响，实现模块间的松耦合，如何做：</p><ol><li>每个类尽量都有接口或抽象类，这是依赖倒置原则的基本要求，<strong>有了抽象才有可能倒置</strong>。</li><li>变量的表面类型(编译类型)尽量是接口或抽象类。</li><li>任何类都不应该从具体类派生出来。</li><li>尽量不要覆盖基类的方法(该方法已经在基类中实现)。如果说基类是一个抽象类，而且这个方法已经被实现了，子类尽量不要覆写。类间的依赖是抽象，覆写类抽象方法，对依赖的稳定性有所影响。</li><li>集合里氏替换原则。</li></ol><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>再此层面上 接口分为：</p><ol><li>实例接口 (类也是一种接口)</li><li>类接口(interface)</li></ol><p>隔离：即把一个接口中的多种职责进一步拆分出来，作为两个颗粒度更小的接口，此刻两个职责被单独隔离处理。</p><p><strong>定义：</strong></p><p>接口尽量细化，同时接口中的方法尽量少。</p><p><strong>如何对接口进行约束：</strong></p><ol><li>接口尽量小，满足单一职责原则。</li><li>接口高内聚。</li></ol><p>针对于接口高内聚就是要在接口中尽量少公布 public 方法，接口是对外的承诺，对外承诺越少越有利于系统的开发，这样变更的风险越低。</p><h3 id="迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP"><a href="#迪米特法则（最少知识原则）-Least-Knowledge-Principle-LKP" class="headerlink" title="迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)"></a>迪米特法则（最少知识原则）(Least Knowledge Principle,LKP)</h3><p>一个对象应该对其他对象有最少的了解，换句话说，一个类应该对自己需要耦合或调用的类知道的最少，被耦合的类或这被调用的类内部如何复杂都和该类没有关系，我只需知道它们提供的 public 方法。</p><p><strong>只需要和朋友类联系：</strong></p><p>朋友类：出现在成员变量、方法的输入和输出参数的类为朋友类。<br>其实朋友类就是产生 <code>依赖关系的类</code>。</p><p><strong>朋友类中不应该向对方暴露的过多</strong></p><p>如果可能的话，尽量向其他类暴露尽量少的方法。</p><p><strong>自己的自己拥有</strong><br>如果一个类可以放在本类中，既不会增加类间关系，也不会对本类产生负面影响，那就放在本类中。</p><p><strong>尽量少的使用 Serializable</strong></p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>一个软件实体如类、模块、函数应该对扩展开发，对修改关闭。</p><p>开闭原则是最基础的一个原则，前面介绍的 5 个原则都是在开闭原则的具体形态，它们为指导设计的工具和方法，而开闭原则才是精神领袖。</p><p><strong>原则细节</strong></p><p>应该尽量通过扩展实体行为的方式来实现变化，而不是通过修改已有的代码来实现变化。</p><p>在软件开发中，尽可能减少代码粒度，代码粒度越小，被复用的可能越大。</p><p><strong>如何使用</strong></p><ol><li>抽象约束。</li></ol><p>具体表现为：</p><pre><code>1. 在对接口或抽象类进行扩展时，不允许出现接口或抽象类中不存在的 public 方法。2. 参数类型、引用对象尽量使用接口或抽象类，而不是实现类。3. 抽象应保持稳定，一旦确定不允许更改。</code></pre><ol start="2"><li>封装变化</li></ol><p>含义：<br>        1. 将相同的变化封装到接口或抽象类中<br>        2. 将不同的变化封装到不同的接口或抽象类中，不应该两个变化出现在同一个接口或抽象中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单一职责原则-Single-Responsibility-Principle-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-Single-Responsibility-Principle-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则 (Single Responsibility Principle)(SRP)&quot;&gt;&lt;/a&gt;单一职责原则 (Single Responsibility Principle)(SRP)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 应该有且仅有一个原因引起类的变更。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个类的几个职责之间没有相互依赖时，可以考虑将职责进行拆分。&lt;/li&gt;
&lt;li&gt;SRP原则适用于接口、类，同时也适用于方法，一个方法尽可能的做一件事。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;好处：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低类的复杂度，实现什么职责都有明显的定义&lt;/li&gt;
&lt;li&gt;可读性提高、可维护性强&lt;/li&gt;
&lt;li&gt;变更风险低&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只要一个原因引起变化。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式六大原则" scheme="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic Three</title>
    <link href="/2019/03/15/Java-Basic-%E4%B8%89/"/>
    <id>/2019/03/15/Java-Basic-三/</id>
    <published>2019-03-15T09:08:48.000Z</published>
    <updated>2019-05-29T10:11:56.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>存在只定义了方法的签名，没有方法的类称为抽象类。</p><ul><li>抽象类和抽象方法使用 abstract 修饰</li><li>抽象类不能实例化</li><li>抽象类可以没有抽象方法，可以有非抽象方法</li><li>抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)</li><li>含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类</li></ul><p>abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。</p><a id="more"></a><h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><p>抽象类是将多个子类向高层抽象，为子类提供行为模板,定义了子类中存在的共有行为。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口进一步将抽象类抽象。</p><p>接口定义了多个类共同的公共行为规范。</p><p>接口中不能含有</p><ol><li>构造器</li><li>初始化块</li></ol><p>但是接口中包含：</p><ol><li>成员变量(只能是静态)</li><li>方法(抽象实例方法、类方法、默认方法)</li><li>内部类(内部接口、枚举)</li></ol><h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><p>接口中的所有成员的访问权限为 <code>public</code> 。<br>对于接口中的静态常量而言，它们是接口相关的，系统会自动为这些成员变量增加 static 和 final 两个修饰符，必须在定义时进行初始化。</p><h3 id="接口中的默认方法、静态方法"><a href="#接口中的默认方法、静态方法" class="headerlink" title="接口中的默认方法、静态方法"></a>接口中的默认方法、静态方法</h3><p>接口中的默认方法和静态方法都可以实现，拥有方法体。</p><p>在 Java8 之前接口中的所有方法均为抽象方法，但是在 Java8 后系统为接口增加了默认方法，此方法增加了接口的可扩展性，如果需要在已有业务上需要为接口增加新的方法来实现增加业务的目的。那么 Java8 之前如果为接口增加方法，那么所有实现类均需要更改。在 Java8 后增加而 <code>默认方法</code>，实现类不是必须要实现该方法，如果实现了没有显示实现该方法，那么调用时使用默认实现。</p><p>而接口中的静态方法，需要通过接口名实现调用，在默认方法中可以调用本类的默认方法。</p><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p><em>一个类实现了一个接口后，这个类需要实现这个接口中的所有抽象方法，否则，这个类将保留从接口继承的抽象方法，则这个类必须定义为抽象类</em>。</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><strong>同：</strong></p><ol><li>不能被实例化，只能被其他类继承或实现。</li><li>都可以包含抽象方法，实现或继承的子类需要实现这些抽象方法。</li></ol><p><strong>异：</strong></p><p>接口作为系统与外界交互的窗口，接口体现的是一种规范,对于接口的实现者来说，接口规定了实现者必须向外提供哪些服务(以方法的形式)；对于接口的调用者来说，接口规定了可以调用哪些服务，以及如何调用服务(如何调用方法)。</p><p>抽象作为系统中多个子类的共同父类，它体现的是一种模板式设计。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;p&gt;存在只定义了方法的签名，没有方法的类称为抽象类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法使用 abstract 修饰&lt;/li&gt;
&lt;li&gt;抽象类不能实例化&lt;/li&gt;
&lt;li&gt;抽象类可以没有抽象方法，可以有非抽象方法&lt;/li&gt;
&lt;li&gt;抽象类可以有成员变量、方法(抽象方法和非抽象方法)、构造器、初始化块、内部类(接口、枚举)&lt;/li&gt;
&lt;li&gt;含有抽象方法的类(定义了一个抽象方法的类、继承一个抽象方法但是没有完全实现父类中抽象的方法的类、实现一个接口但是没有完全实现接口中的方法)只能为抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;abstract 不能修饰成员变量和类方法，因为成员变量属于类实例，而抽象类不能实例化，抽象方法没有方法体，调用出错。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>requestDisallowInterceptTouchEvent</title>
    <link href="/2019/03/14/requestDisallowInterceptTouchEvent/"/>
    <id>/2019/03/14/requestDisallowInterceptTouchEvent/</id>
    <published>2019-03-14T03:54:33.000Z</published>
    <updated>2019-03-14T11:15:50.581Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p>调用 <code>requestDisallowInterceptTouchEvent</code> 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于 ViewGroup 为什么还是会拦截 ACTION_DOWN 事件，是因为 ViewGruop 在 ACTION_DOWN 事件时会重新置位 FLAG_DISALLOW_INTERCEPTER 标志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;requestDisallowInterceptTouchEvent&lt;/code&gt; 方法会置位 FLAG_DISALLOW_INTERCEPTER 标志位，ViewGroup 将无法拦截除了 ACTION_DOWN 以外的事件,至于
      
    
    </summary>
    
    
      <category term="View" scheme="/tags/View/"/>
    
      <category term="事件分发机制" scheme="/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>拖动百度地图出现黑影的解决方法</title>
    <link href="/2019/03/13/%E6%8B%96%E5%8A%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%87%BA%E7%8E%B0%E9%BB%91%E5%BD%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>/2019/03/13/拖动百度地图出现黑影的解决方法/</id>
    <published>2019-03-13T08:29:09.000Z</published>
    <updated>2019-03-14T02:12:43.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述及解决方案"><a href="#问题描述及解决方案" class="headerlink" title="问题描述及解决方案"></a>问题描述及解决方案</h3><p><code>NestScrollView</code> 嵌套 <code>MapView</code> 在滑动整个布局时，<code>MapView</code> 的上下边界出现黑影。</p><p>问题解决：</p><p>使用 <code>TextureMapView</code> 替换布局中的 <code>MapView</code> 并开启硬件加速，如果只在当前 Activity 中开启硬件加速，执行在清单文件中该 Activity 注册信息中添加标签：<code>android:hardwareAccelerated=&quot;true&quot;</code> 。</p><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述及解决方案&quot;&gt;&lt;a href=&quot;#问题描述及解决方案&quot; class=&quot;headerlink&quot; title=&quot;问题描述及解决方案&quot;&gt;&lt;/a&gt;问题描述及解决方案&lt;/h3&gt;&lt;p&gt;&lt;code&gt;NestScrollView&lt;/code&gt; 嵌套 &lt;code&gt;MapVi
      
    
    </summary>
    
    
      <category term="百度地图黑影" scheme="/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%BB%91%E5%BD%B1/"/>
    
      <category term="硬件加速" scheme="/tags/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 单例的几种写法</title>
    <link href="/2019/03/13/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"/>
    <id>/2019/03/13/单例的几种写法/</id>
    <published>2019-03-13T03:37:05.000Z</published>
    <updated>2019-05-24T10:08:53.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何实现单例类"><a href="#如何实现单例类" class="headerlink" title="如何实现单例类"></a>如何实现单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式()"></a>饿汉式()</h3><p><strong>方式一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private final static Singleton INSTANCE = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方式二:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种实现方法基本一致，均是利用 <strong>类变量会在加载类时完成初始化</strong> 这一特性，实现了 <strong>线程安全</strong>，在加载类的同时就会完成该类单例的创建，即使在多线程情况下访问到的也是同一个对象，当然实现了单例模式。</p><p><strong>饿汉式的 “饿”具体体现在：不管你是否使用，都会实例化该类的单例对象</strong>，正是这个特点造成了如下缺点：</p><pre><code>饿汉式在类加载时就实现了类的单例，但是存在压根就用不到该单例的情况，此时就浪费了内存。</code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>方式一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式的 “懒” 具体体现在:你用的话我就会初始化，你不用我我就不会初始化</strong>,但是也造成了已些缺陷：</p><pre><code>在多线程情况下，有可能一个线程 A 进入了 `getInstance` 方法中但是未完成对象的初始化，但是此时另外的一个线程 B 进入该方法完成初始化初始化一个对象，A 之后重新执行生成一个对象，那么此刻就违背了单例模式的初衷。</code></pre><p><strong>方式二：(改进)</strong></p><p>上面方式一谈到懒汉式存在线程安全的问题，那么改进该问题如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static synchronized Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            INSTANCE = new Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>synchronized</code> 进行线程同步。</p><p>但是同时也需要面临的一个缺点就是每次获得该单例时都需要进行线程同步操作，效率大打折扣。</p><p><strong>方式三</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                INSTANCE = new Singleton(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写虽然杜绝了每次获得实例的线程同步而引起的问题，但是这种方式是有明显的缺点的：一个线程执行 <code>if(INSTANCE == null)</code> 方法时，其他多个线程可能会同时执行该方法，并且执行至 <code>if(INSTANCE == null)</code>代码后 后，虽然多个线程在此排队获得 <code>Singleton</code> 类的锁，但是这样每个运行至此的线程都会实例化对象，造成程序中出现多个实例对象。</p><h3 id="多重检查-饿汉式终极形态"><a href="#多重检查-饿汉式终极形态" class="headerlink" title="多重检查(饿汉式终极形态)"></a>多重检查(饿汉式终极形态)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 静态方法虽然属于类，但是没有调用情况下不会执行,所以为懒汉式。</span><br><span class="line">    */</span><br><span class="line">    public static  Singleton getInstance&#123;</span><br><span class="line">        if(INSTANCE == null)&#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(INSTANCE == null)&#123;</span><br><span class="line">                    INSTANCE = new Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的 饿汉方式三 做出改进，即在同步代码块中再做一次空判断，杜绝了以上方式的明显缺陷。</p><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonInstance&#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类不会再外部类完成类加载的时候进行初始化加载，只会在调用时进行相关的类加载，实现了 <strong>懒加载</strong> 的功能，由于类加载只有在程序中出现一次，其享相应的属性也只会存在一份，实现了单例。</p><h3 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Effective Java 推荐使用，避免线程安全问题，支持自动序列化，注意枚举特性为 JDK 1.5 后添加。</p><h3 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h3><p>一般情况下，推荐使用 <code>饿汉方式</code>，如果项目需求实现懒加载，推荐使用 <code>静态内部类方式</code>，涉及反序列试一下 <code>枚举方式</code>,特殊需求使用 <code>多重检查</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何实现单例类&quot;&gt;&lt;a href=&quot;#如何实现单例类&quot; class=&quot;headerlink&quot; title=&quot;如何实现单例类&quot;&gt;&lt;/a&gt;如何实现单例类&lt;/h3&gt;&lt;p&gt;如果一个类只能创建一个实例，那么这个类称为 &lt;strong&gt;单例类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据良好性封装原则，我们需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把类构造器函数隐藏&lt;/li&gt;
&lt;li&gt;提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;饿汉式&quot;&gt;&lt;a href=&quot;#饿汉式&quot; class=&quot;headerlink&quot; title=&quot;饿汉式()&quot;&gt;&lt;/a&gt;饿汉式()&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private final static Singleton INSTANCE = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Singleton getInstance&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return INSTANCE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Singleton" scheme="/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Android 焦点机制</title>
    <link href="/2019/03/11/Android-%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    <id>/2019/03/11/Android-焦点机制/</id>
    <published>2019-03-11T03:08:29.000Z</published>
    <updated>2019-03-13T02:44:51.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式"><a href="#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式" class="headerlink" title="No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)"></a>No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)</h3><p>Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 <code>触摸模式</code>，而像 Andorid TV、键盘、轨迹球一般为 <code>非触摸模式</code>。</p><h3 id="Focus-焦点-、Focusable-可聚焦"><a href="#Focus-焦点-、Focusable-可聚焦" class="headerlink" title="Focus(焦点)、Focusable(可聚焦)"></a>Focus(焦点)、Focusable(可聚焦)</h3><p>在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。<br>根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。</p><a id="more"></a><p>根据用户的不同行为,两种模式可以不断切换：<br>在用户点击屏幕时，设备会进入触摸模式，而当用户点击轨迹球时，App 会立即退出触摸模式进入非触摸模式，并寻找一个控件获得焦点。</p><h3 id="触摸模式与-Focusable"><a href="#触摸模式与-Focusable" class="headerlink" title="触摸模式与 Focusable"></a>触摸模式与 Focusable</h3><p>Focusable 此特殊模式是为接收文本输入的控件创建的，如 EditText。在触摸模式中，如果控件是可聚焦的(Focusable),只要用户点击该控件，该控件就会得到焦点，反之控件是不会获得焦点的。</p><p>Foucusable 其实为控件的一个属性，可以通过代码 <code>setFocusableInTouchMode</code> 或 xml中<code>android:focusableInTouchMode</code>设置控件是否可聚焦。</p><h3 id="setFocusableInTouchMode-和-setFocusable"><a href="#setFocusableInTouchMode-和-setFocusable" class="headerlink" title="setFocusableInTouchMode 和 setFocusable"></a>setFocusableInTouchMode 和 setFocusable</h3><ul><li>setFocusable:设置控件是否可以获得焦点，可以通过 isFocusable() 获得状态。</li><li>setFocusableInTouchMode: 在触摸模式下，可以通过setFocusableInTouchMode 来设置控件是否可聚焦，可以通过isFocusableInTouchMode() 获得状态。</li></ul><p>大部分控件的 <code>setFocusableInTouchMode</code> 属性均为 false ，至于 EditText 的 <code>setFocusableInTouchMode</code> 的属性为 true，这也就是为什么 EditText 会率先获得屏幕焦点的原因。</p><h3 id="焦点监听与事件监听"><a href="#焦点监听与事件监听" class="headerlink" title="焦点监听与事件监听"></a>焦点监听与事件监听</h3><p>当为控件设置可聚焦属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">      android:id=&quot;@+id/btnOne&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:text=&quot;one&quot;</span><br><span class="line">      android:focusableInTouchMode=&quot;true&quot;   </span><br><span class="line">      android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure><p>同时，为该控件设置了点击事件、焦点监听，此时是需要特别注意的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btnOne.setOnclickListener&#123;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;click&quot;)</span><br><span class="line">&#125;</span><br><span class="line">btnOne.setOnFocusChangeListener&#123; v, hasFocus -&gt;</span><br><span class="line">    Log.e(&quot;TAG&quot;,&quot;focus change&quot; + hasFocus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们点击 Button 时，此时 Log 日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG focus change true</span><br></pre></td></tr></table></figure><p>而不会响应点击事件，想要 Button 响应点击事件，需要再次点击该按钮。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TAG click</span><br></pre></td></tr></table></figure><p>在这种情况下，需要点击两次才能让 Button 响应点击事件：</p><ol><li>Button 获得焦点</li><li>Button 响应点击事件</li></ol><p>所以 Google 建议使用 <code>focusableInTouchMode</code> 之前，需要三思后行。</p><h3 id="descendantFocusability"><a href="#descendantFocusability" class="headerlink" title="descendantFocusability"></a>descendantFocusability</h3><p><code>Defines the relationship between the ViewGroup and its descendants when looking for a View to take focus.</code></p><p>该属性的字面意思: 子代获取焦点的能力。该属性定义的是当一个 子View 获取焦点时， ViewGroup 与 子View 之间的关系。</p><ul><li><strong>beforeDescendants</strong>：Viewgroup 会优先其子类控件而获取到焦点</li><li><strong>afterDescendants</strong>：Viewgroup 只有当其子类控件不需要获取焦点时才获取焦点</li><li><strong>blocksDescendants</strong>：Viewgroup 会覆盖子类控件而直接获得焦点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot;&gt;&lt;a href=&quot;#No-touch-Mode-非触摸模式-和-Touch-Mode-触摸模式&quot; class=&quot;headerlink&quot; title=&quot;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&quot;&gt;&lt;/a&gt;No-touch Mode(非触摸模式) 和 Touch Mode(触摸模式)&lt;/h3&gt;&lt;p&gt;Google 把触摸模式分为 No-touch Mode 和 Touch Mode。Android Phone 由于触摸屏，所以讨论的为 &lt;code&gt;触摸模式&lt;/code&gt;，而像 Andorid TV、键盘、轨迹球一般为 &lt;code&gt;非触摸模式&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Focus-焦点-、Focusable-可聚焦&quot;&gt;&lt;a href=&quot;#Focus-焦点-、Focusable-可聚焦&quot; class=&quot;headerlink&quot; title=&quot;Focus(焦点)、Focusable(可聚焦)&quot;&gt;&lt;/a&gt;Focus(焦点)、Focusable(可聚焦)&lt;/h3&gt;&lt;p&gt;在像 Android TV 、轨迹球这类设备上，我们可能需要通过遥控器等设备选择相应的选项，在交互过程中，我们选中的控件获得焦点，并通过颜色改变、高亮、突出等形式表现出来。&lt;br&gt;根据 Google 官方文档，在触摸模式下，其实没有没有焦点的概念，或者说此模式下的获得焦点的表现形式不同。在触摸模式下，Focus 以一种特别的方式 – Focusable 存在。&lt;/p&gt;
    
    </summary>
    
    
      <category term="焦点机制" scheme="/tags/%E7%84%A6%E7%82%B9%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java Baseic Two</title>
    <link href="/2019/03/07/Java-Basic-%E4%BA%8C/"/>
    <id>/2019/03/07/Java-Basic-二/</id>
    <published>2019-03-07T04:56:36.000Z</published>
    <updated>2019-05-29T10:11:57.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equal-方法"><a href="#与-equal-方法" class="headerlink" title="== 与 equal 方法"></a>== 与 equal 方法</h3><p>Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。</p><p>当使用 <code>==</code> 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 <strong><code>==</code> 不可用于比较类型上没有父子关系的两个对象</strong>。</p><p>equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。</p><p>在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。</p><p>所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。</p><a id="more"></a><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">String c = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>此时堆内存中只会分配一份存储 “abc” 的内存, 变量 a、b、c 的引用地址都指向该内存地址。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池，主要是用来管理编译时被确定并且保存在 .class 文件中的数据，包括类、方法、接口中的常量以及字符串常量。</p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>被 static 修饰的变量、方法、初始化块、内部类等称为类变量。类变量属于类，在第一加载类的时候，系统会为类变量分配内存空间并进行初始化，直到该类被卸载，类变量占用的内存从会被标记成垃圾。</p><p>类变量中不能访问非 static 变量成员(变量、方法等),因为 类成员的作用域比非 static 变量成员的作用域大，存在类变量已经被初始化但是实例变量为被初始化的情况，此时程序就会出现异常。</p><h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>final 修饰的变量不可重复赋值</strong>。</p><p><strong>final 修饰成员变量</strong></p><p>初始化位置：</p><ul><li>初始化块</li><li>构造器</li><li>声明处</li></ul><p><strong>final 修饰类变量</strong><br>初始化位置：</p><ul><li>初始化块</li><li>声明处</li></ul><p>与普通实例变量不同，final 修饰的变量(实例变量和类变量)必须显式的初始化，系统不会为 final 修饰的变量的执行默认初始化。</p><ul><li>final 修饰局部变量</li></ul><p>必须显式的初始化初始值。</p><h3 id="final-修饰基本数据类型和引用数据类型"><a href="#final-修饰基本数据类型和引用数据类型" class="headerlink" title="final 修饰基本数据类型和引用数据类型"></a>final 修饰基本数据类型和引用数据类型</h3><p>final 修饰基本数据变量，则该变量不能被改变。<br>final 修饰引用数据类型变量，说明这个变量指向的内存地址不可更改，但是并不是此对象的各个属性不可变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Person person = new Person(20,&quot;Mike&quot;);</span><br><span class="line">person.setName(&quot;Jim&quot;);</span><br><span class="line">person.age = 21;</span><br></pre></td></tr></table></figure><h3 id="final-、宏变量与宏替换"><a href="#final-、宏变量与宏替换" class="headerlink" title="final 、宏变量与宏替换"></a>final 、宏变量与宏替换</h3><p>只要满足三个条件，这个 final 变量就不再是一个变量，而相当于一个直接量：</p><ol><li>使用 final 修饰</li><li>定义该 final 变量时指定初始值</li><li>该初始值在编译器时被确定下来。</li></ol><p>那么这个变量称为 <strong>宏变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int a =  5;</span><br></pre></td></tr></table></figure><p>那么对于这个程序来说，根本不存在变量 a，出现变量a 的地方全部被 5 替换。</p><p>为了说明宏变量的不同之处，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ab&quot;;</span><br><span class="line">String str2 = &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">sout(str1==str2);// true</span><br><span class="line"></span><br><span class="line">String str3 = &quot;a&quot;;</span><br><span class="line">String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><p>至于第一个日志结果为 true ,应该十分容易理解：str1 在编译时确定值，会被存储在常量池中，str2 通过显示的 <strong>拼装后(不是分别创建“a”和“b”)</strong> 存入 <strong>常量池</strong>，但是常量池中已经存在相同的值，就不会重新创建，直接将该值的内存地址指向 str2，所以结果为 true。</p><p>而第二条日志中，str5 在编译期不会初始化，需要在运行期通过计算获得，其值会被分配在 <code>堆内存</code>去中，所以 str1 和 str5 的引用的地址不同，其打印结果为 false。</p><p>同理有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str6 = new String(&quot;ab&quot;); </span><br><span class="line">sout(str1 == str6);//false</span><br></pre></td></tr></table></figure><p>但是如果 str3 和 str4 被 final 修饰，两者就会变成宏变量，两变量出现的位置会直接被值替换，此时 str5 在编译期就会确定初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final String str3 = &quot;a&quot;;</span><br><span class="line">final String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>final 方法不可被重写，但是可以被重载。</p><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>final 类不能拥有子类。</p><h3 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h3><p>不可变类为创建该类的实例后，该实例的实例变量不可变。</p><p>Java 提供的 8 个包装类和 String 为不可变类。</p><p>自定义不可变类需要遵循以下规则：</p><ol><li>使用 private final 修饰成员变量</li><li>提供构造器，传入初始值</li><li>仅提供 getter 方法</li><li>如果有必要，重新 equal() 和 hashcode() 方法自定义相等的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equal-方法&quot;&gt;&lt;a href=&quot;#与-equal-方法&quot; class=&quot;headerlink&quot; title=&quot;== 与 equal 方法&quot;&gt;&lt;/a&gt;== 与 equal 方法&lt;/h3&gt;&lt;p&gt;Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;==&lt;/code&gt; 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 不可用于比较类型上没有父子关系的两个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。&lt;/p&gt;
&lt;p&gt;在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。&lt;/p&gt;
&lt;p&gt;所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Java Basic One</title>
    <link href="/2019/03/06/Java-Basic-%E4%B8%80/"/>
    <id>/2019/03/06/Java-Basic-一/</id>
    <published>2019-03-06T06:31:33.000Z</published>
    <updated>2019-05-29T10:11:58.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的三大特征"><a href="#对象的三大特征" class="headerlink" title="对象的三大特征"></a>对象的三大特征</h3><p>对象的三种基本特征:继承、封装、多态。</p><p>Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。</p><p><strong>封装</strong>： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。</p><p><strong>继承</strong>：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。</p><p><strong>多态</strong>：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// B 继承 A</span><br><span class="line">A a;</span><br><span class="line">a = new A();</span><br><span class="line">a.testMethod();// 执行 A 中方法</span><br><span class="line">a = new B();</span><br><span class="line">a.testMethod();// 执行 B 中方法</span><br><span class="line"></span><br><span class="line">//在此例中，同一个类型引用执行同一个方法，可能表现多种行为特征：类型为 A ，该类的对象 a 执行 testMethod() 方法会根据其引用对象的具体类型表现出不同的行为特征 -- A#testMethod()或B#testMethod()。</span><br></pre></td></tr></table></figure><h4 id="Java-是静态的强类型的语言"><a href="#Java-是静态的强类型的语言" class="headerlink" title="Java 是静态的强类型的语言"></a>Java 是静态的强类型的语言</h4><p>Java 是静态的，一旦一个类被定义，如果对这个类有所更改，只要不重新编译这个类，那么这个类以及这个类拥有的成员变量就不会发生改变。</p><p>Java 的强类型主要表现在两方面：</p><ol><li>所有的变量必须先声明后使用；</li><li>指定类型的变量只能赋相同类型的值；</li></ol><p>基于上面，Java 在编译期就会确定成员变量的类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>编程的本质就是对内存中的数据访问和修改</strong>，程序所用到的数据都会保存在内存中，程序员需要通过一种机制来访问和修改内存中的数据，这种机制就是 <strong>变量</strong> ，每个变量代表某一小块内存。变量是有名字的，程序对变量 <strong>赋值</strong>，就是把数据装入该变量所代表的内存区的过程；程序 <strong>读取变量</strong>，就是从变量代表的内存区取值的过程。可以简单的理解：变量相当于一个有名称的容器，该容器用于装各种不同类型的数据。</p><h3 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h3><p><img src="/images/19_03_06.jpg" alt="对象与引用"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person(&quot;Mike&quot;,20)</span><br></pre></td></tr></table></figure><p>由上文中变量是需要是需要内存存储数据的，此语句中 <code>new Person(&quot;Mike&quot;,20)</code> 只是在堆内存中开辟出一块内存去存储这个对象，而 <code>Person p</code> 则需要在栈内存中开辟一块内存来存储变量以及相关内容，至于在此区域存储的到底是什么,需要在赋值后才会具体化。在此例中，赋值语句后，变量 p 对应的栈内存存储的为新建对象 – new Person 的内存地址。</p><h3 id="this-引用"><a href="#this-引用" class="headerlink" title="this 引用"></a>this 引用</h3><p>首先 this 代表一定是个对象，其次 this 出现在不同位置含义有所不同：</p><ul><li>在构造器中代表正在初始化的对象</li><li>在方法中代码调用该方法的对象</li></ul><p>因此 static 方法中不能出现 this，因为 static 的方法属于类，是通过类去调用，此时 this 代表了类，违背了 this 代表的为一个对象的前提。</p><p>同时 static 方法不可调用非 static 变量和方法也是基于这个原因，因为类中的变量和方法存在隐式的 this 引用，即为 this 作为调用者必须是一个对象。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法名相同，而参数列表不同的现象称为方法重载。</p><ul><li>为什么返回值不作为方法重载的区分标准？</li></ul><p><strong>Java 调用方法时可以忽略返回值</strong>，如果将返回值作为重载的标准，那么存在以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int method();</span><br><span class="line">void method()</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 Java 系统将不能分辨出 test 方法中调用的 method() 是具体哪一个方法。</p><h3 id="变量及其运行机制"><a href="#变量及其运行机制" class="headerlink" title="变量及其运行机制"></a>变量及其运行机制</h3><p>成员变量：</p><ol><li>类变量：从类的准备阶段开始存在，到系统完全销毁这个类。</li><li>实例变量：从实例的创建始存在，到系统完全销毁这个实例。</li></ol><p>局部变量：</p><ol><li>形参</li><li>方法内局部变量</li><li>代码块中局部变量</li></ol><p>局部变量只要离开了相应的代码块(方法、代码块)，局部变量就会被销毁。</p><h3 id="成员变量的初始化和内存中的运行机制"><a href="#成员变量的初始化和内存中的运行机制" class="headerlink" title="成员变量的初始化和内存中的运行机制"></a>成员变量的初始化和内存中的运行机制</h3><p>JVM 加载类经历以下几个阶段：</p><ol><li>类加载</li><li>类验证</li><li>类准备</li><li>类解析</li><li>类初始化</li></ol><p>当系统加载类或创建类实例时，系统会自动为成员变量分配内存，并赋初值。<br>Person 类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private static int phone;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person 类使用</span><br><span class="line">Person a = new Person();</span><br><span class="line">a.phone = 110;</span><br><span class="line">a.name = &quot;mike&quot;;</span><br></pre></td></tr></table></figure><p>当执行 <code>Person a = new Person();</code> 时，如果程序中第一次使用 Person 类， JVM 将会加载 Person 类，并初始化这个类。在类的准备阶段，<strong>JVM 将会该类的类变量分配内存空间并初始化</strong>。当 Person 类初始化完成后，系统中的内存情况如下图：</p><p><img src="/images/2019_03_06_1.jpg" alt="类初始化"></p><p>当类完成初始化后，JVM 将在 堆内存 中为 Person 类分配一块内存(JVM 会为Person类创建一个对象)，这块内存区包含了类变量 phone 的内存，并初始化它的初值。</p><p>接着，系统创建一个 Person 对象，并把这个对象赋值给 p 变量， Person 对象中包含了实例变量–name，<strong>实例变量在创建实例时分配内存空间并赋初值</strong>。JVM 创建了第一个 Person 对象后，内存分配情况如下：</p><p><img src="/images/2019_03_06_2.jpg" alt="实例变量初始化"></p><p>当再次创建 Person 对象时，不需要再对 Person 类初始化。</p><p>对类变量和实例变量赋值时,内存分配情况如下：</p><p><img src="/images/2019_03_06_3.jpg" alt="赋值"></p><p>其中，类变量为所有实例共有，每个实例都有权对其进行更改。</p><h3 id="局部变量的初始化和内存中的运行机制"><a href="#局部变量的初始化和内存中的运行机制" class="headerlink" title="局部变量的初始化和内存中的运行机制"></a>局部变量的初始化和内存中的运行机制</h3><p>系统不会为局部变量进行初始化，所以局部变量必须手动初始化。</p><p>与成员变量不同，<code>局部变量的分配内存为所在的方法栈区</code>，如果局部变量时基本数据类型，会直接存在方法栈中;如果为引用变量，则存放引用地址，通过该引用地址指向实际引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test(int a,Person p)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 方法栈中内存分配情况如下：</p><p><img src="/images/2019_03_06_4.jpg" alt="局部变量"></p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>private:类私有</li><li>default:同包可访问</li><li>protected:同包及子类可访问</li><li>public:所有类可访问</li></ul><h3 id="构造器与成员变量初始化"><a href="#构造器与成员变量初始化" class="headerlink" title="构造器与成员变量初始化"></a>构造器与成员变量初始化</h3><p>我们知道在创建一个对象时，系统会为这个对象的实例变量进行默认初始化，根据数据类型的不同初始值为：0、falase、null。如果想要改变默认初始化，想让系统创建对象时就位对象的实例变量显示指定初始值，可以通过构造器来实现。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系中，子类和父类拥有相同的实例变量时的内存模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    public String tag = &quot;parent&quot;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Parent&#123;</span><br><span class="line">    private String tag = &quot;son&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Son son = new Son();</span><br><span class="line">// sout(son.tag); 编译错误，不可访问私有变量</span><br><span class="line">sout(((Parent)son).tag); // 打印日志为： parent</span><br></pre></td></tr></table></figure><p><img src="/images/2019_04_02_1.jpg" alt="图"></p><p>子类的实例变量隐藏父类实例变量</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java 引用变量有两个类型：<strong>编译时类型</strong> 和 <strong>运行时类型</strong>。编译时类型是由声明该变量时使用的类型决定，运行时类型是由实际赋给该变量的对象决定。</p><p>当编译时类型和运行时类型不一致，就可能发生所谓的 <strong>多态</strong>。</p><p>引用变量在编译时只能调用编译时类型所拥有的方法，运行时在可以执行其运行时类型所具有的方法。因此，在编写 Java 代码是，引用变量只能调用声明该变量时所用的类(编译时类型)中的方法，例如 <code>Object person = new Person();</code> ,<code>person</code> 只能调用 <code>Object</code> 类中的方法,不能调用 Person 中的方法。</p><p>如果想要编译时类型调用运行时类型的方法，可以对引用变量进行强转型。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>继承是实现类复用的重要手段，但是继承带来了一个坏处：破坏了封装性，即子类可以任意的访问父类的实例变量、重新父类的方法。</p><p>为了保证父类良好的封装性不被子类任意更改，设计父类应遵循如下规则：</p><ol><li>尽量隐藏父类的内部数据，使用 private 修饰;</li><li>不要让子类任意访问和修改方法。辅助方法使用 private 修饰；父类中可以被外界访问但是不可以被子类重新的方法使用 public final 修饰；希望被子类重写的方法使用 protected 修饰。</li><li>尽量不要在父构造器中调用被子类重写的方法。</li></ol><p>针对第 3 条，特殊说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    private String des;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;B&quot; + des.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">B b = new B();</span><br></pre></td></tr></table></figure><p>系统在创建 B 实例时，会首先执行父类的构造器，在父构造器中调用了被父类重写的方法，此时执行的方法为子类的重写后的方法。此时 B 的实例变量 des 还没有初始化为 null，调用会发生空指针异常。</p><p>产生此现象的原因我猜大致是因为这样：</p><blockquote><p>这个问题又牵涉到 this 引用的问题，在这个问题中我们很明确的表明当 this 出现在构造器中表示正在实例化的对象, A 构造器中 test() 方法的调用中隐藏了默认的 this 引用，所以此时 this 代表被实例化的 B 的对象，所以 A 中 test() 执行 B 中的 test() 方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象的三大特征&quot;&gt;&lt;a href=&quot;#对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;对象的三大特征&quot;&gt;&lt;/a&gt;对象的三大特征&lt;/h3&gt;&lt;p&gt;对象的三种基本特征:继承、封装、多态。&lt;/p&gt;
&lt;p&gt;Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Java 继承，对象，类初始化" scheme="/tags/Java-%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于 Java 异常机制的补充</title>
    <link href="/2019/01/26/%E5%85%B3%E4%BA%8E-Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>/2019/01/26/关于-Java-异常机制的补充/</id>
    <published>2019-01-26T10:44:41.000Z</published>
    <updated>2019-01-26T10:51:14.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"><a href="#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？" class="headerlink" title="为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"></a>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</h3><p>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</p><h3 id="如何正确的关闭资源？"><a href="#如何正确的关闭资源？" class="headerlink" title="如何正确的关闭资源？"></a>如何正确的关闭资源？</h3><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="finally-与-return-的关系"><a href="#finally-与-return-的关系" class="headerlink" title="finally 与 return 的关系"></a>finally 与 return 的关系</h3><p>阐述两者的关系，我们主要关注 return 关键字的位置，为了表达的更形象，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int count = 5;</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot;);</span><br><span class="line">            System.out.println(&quot;finally 语句执行 &quot; + count);</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally 语句执行</span><br><span class="line">finally 语句执行 6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当 Java 程序执行 try/catch 中有 return 语句，return 语句会导致方法立即结束。但是系统执行完 return 语句不会马上结束该方法，而是查看在这个异常处理的流程中是否存在 finally 语句，如果存在 finally 语句，那么需要执行 finally 语句。如果 finally 语句中有 return 语句，那么会更新 try/catch 语句 return 返回的值，但是需要注意的是因为该方法已经结束，此处的 return 不会像无法返回到 try/catch 中执行代码(因为 try/catch 之后才会来到 finally 语句)。具体可以参看上例自行揣摩其中含义。</p><p>在举一个例子，我们在 catch 中执行 return 语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int[] counts = new int[]&#123;5,3&#125;;</span><br><span class="line">        int count = counts[0];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int error = counts[2];</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(&quot;catch 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch 语句执行5</span><br><span class="line">finally 语句执行6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>针对该例不做阐述。</p><h3 id="关于异常的捕获"><a href="#关于异常的捕获" class="headerlink" title="关于异常的捕获"></a>关于异常的捕获</h3><p>当 Java 运行时环境接收到异常对象时，系统会根据catch(TypeException e) 来决定使用哪一个异常分支来处理程序引发的异常。程序进入负责异常处理的 catch 块时，系统生成的异常对象 ex 将会被传给 cathc(TypeException ex) 的异常形参，从而可以在 catch 块中访问异常信息。</p><h3 id="关于异常捕获的顺序"><a href="#关于异常捕获的顺序" class="headerlink" title="关于异常捕获的顺序"></a>关于异常捕获的顺序</h3><p>捕获父类异常的 catch 块在捕获子类异常的 catch 块后，即先处理小异常，再处理大异常。</p><h3 id="使用异常机制的注意点"><a href="#使用异常机制的注意点" class="headerlink" title="使用异常机制的注意点"></a>使用异常机制的注意点</h3><ol><li>不要使用 try/catch 来控制流向。</li><li>精准捕获可能抛出的异常，不要乱抛异常，不要放大异常的范围。</li><li>不要在 finally语句中递归调用可能引起异常的方法，因为这将导致该方法的议程不能被正常抛出，甚至StackOverflowError 也不能终止程序，只能强制终止 java 进程才可以终止程序运行。</li><li>在子类复写时，子类方法只能抛出父类方法声明抛出的异常的子类。</li></ol><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/22581959.html" target="_blank" rel="noopener">疯狂 Java 系列书籍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;a href=&quot;#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot; class=&quot;headerlink&quot; title=&quot;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;/a&gt;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&lt;/h3&gt;&lt;p&gt;JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。&lt;/p&gt;
&lt;h3 id=&quot;如何正确的关闭资源？&quot;&gt;&lt;a href=&quot;#如何正确的关闭资源？&quot; class=&quot;headerlink&quot; title=&quot;如何正确的关闭资源？&quot;&gt;&lt;/a&gt;如何正确的关闭资源？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 finall 中执行资源关闭操作。&lt;/li&gt;
&lt;li&gt;保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。&lt;/li&gt;
&lt;li&gt;为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Exception" scheme="/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常机制浅析</title>
    <link href="/2019/01/26/Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>/2019/01/26/Java-异常机制浅析/</id>
    <published>2019-01-26T10:23:46.000Z</published>
    <updated>2019-10-10T02:48:37.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>所有的异常都是继承于 Throwable</p><p><img src="/images/2019_01_26.jpg" alt="运行时内存区域"></p><p> Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。</p><a id="more"></a><p>关于 Exception 派生的两个分支的依据：</p><ul><li><p><strong>RuntimeException: 由程序错误导致导致的异常。</strong></p></li><li><p><strong>其他 Exception： 程序本身没问题，但是由于像 IO 错误这类问题导致的异常属于其他异常。</strong></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RuntimeException 的几种异常：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>ClassCastException:</strong> 类变换异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IllegalArgumentException:</strong> 传递非法参数异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IndexOutOfBoundsException:</strong> 索引越界异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NoSuchElementException:</strong>  表明枚举中没有更多的元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NullPointerException:</strong> 空指针异常</p><p>对于这些异常，我们可以选择进行处理(捕获、抛出)，也可以选择不处理。如果我们不处理的话，那么异常会交给 Java 虚拟机，不断的向上层传递，那么在不同条件下导致的情况是  <strong>当前运行的线程中断或程序中断</strong>。</p><p>一般情况下我们对这类情况是不作处理的，如上文所说 <strong>“RuntimeException: 由程序错误导致导致的异常”</strong>，我们在写代码时应该尽力避免这种异常，而不应该通过 try/catch 、抛出等操作来隐藏异常。</p><p><strong>如果出现了 RuntimeException 异常，那么就一定是你的问题。</strong></p><p><strong>不是派生于 RuntimeException 的异常：</strong></p><ol><li>在文件后面读取数据</li><li>打开一个不存在的文件</li><li>根据给定的字符串去查找 Class 对象，但是这个对象表示的类不存在</li></ol><p><strong>对于这种异常，Java 编译器强制要求对这类异常进行 try/catch 并处理 或将异常抛出，否则程序就不能编译通过。</strong></p><h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>派生于 Error 或 RuntimeException 类所有的异常称为 <strong>非受查异常</strong>，其他所有的异常称为 <strong>受查异常</strong>。</p><p><strong>需要手动的捕获或抛出受检异常，而在代码层面尽力避免非受检异常。</strong></p><p><strong>编译器将检查是否为所有的受查异常提供了异常处理器。</strong></p><p><strong>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什错误</strong>,我们需要在声明方法的时候同时声明该方法可能会抛出的异常。<br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public FileIputStream(String name) throw FileNotFoundException;</span><br></pre></td></tr></table></figure><p>自己在编写方法时，不可能将所有可能抛出的异常声明，下面的 4 种情况应该抛出异常：</p><ol><li>调用一个抛出异常的方法</li><li>程序运行中发现错误，并且利用 throw 语句抛出一个受查异常</li><li>程序出现错误，例如一个数据越界的非受查异常</li><li>Java 虚拟机或运行时库出现内部错误</li></ol><p>如果是前两种异常，则必须告诉调用这个方法的程序员有可能抛出的异常，因为一个抛出异常的方法都有可能是死亡陷阱。</p><p>对于一个有可能被其他人使用的 Java 方法，要根据 Java 异常规范，在方法的首部声明可能会抛出的异常。</p><p>我们不需要声明从 Error 继承的错误，不声明继承于 RuntimeException 的非受查异常。因为这些运行时错误是在我们的控制范围内，我们应该尽力避免这些错误，而不是在可能异常的位置抛出异常。</p><p> 对于一个方法必须声明所有可能抛出的受查异常，而非受查异常要么是不可控制的，要么就必须避免发生。如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。</p><h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p><strong>首先要决定抛出什么类型的异常</strong>。</p><p>对于一个已经存在的异常类，抛出异常有一下几个步骤：</p><ol><li>找到一个合适的类。</li><li>创建这个类的一个对象。</li><li>将对象抛出。</li></ol><p>以下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String readDate(Scanner in) throw EOFException&#123;//声明这个方法可能会抛出的异常</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    if(..)&#123;</span><br><span class="line">        throw new EOFException();//抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一旦方法抛出了异常，这个方法就不可能返回到调用者中，不必为返回的默认值或错误代码担忧。</strong></p><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>定义一个继承于 Exception 的子类，习惯上，这个类应该包含两个构造器，一个默认构造器，另一个带有详细描述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomException extends IOException&#123;</span><br><span class="line">    public CustomException()&#123;&#125;</span><br><span class="line">    public CustomException(String description)&#123;</span><br><span class="line">        super(description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>上面的抛出异常中，我们只需将异常抛出不用理睬了，同时有些异常是需要我们捕获的。</p><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>在异常发生的位置如果没有进行捕获操作，那么程序就会终止执行，并且在控制台打印出异常信息和堆栈内容。</p><p>捕获异常的方法：</p><ol><li>try/catch 语句</li><li>方法首部声明异常，抛给方法调用处理</li></ol><ul><li>try/catch</li></ul><p>我们使用 try/catch 语句，具体语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;catch(ExceptionType e)&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 语句中出现 catch 中出现的异常，那么程序将执行 catch 子句中的代码。</p><ul><li>抛出异常给调用者</li></ul><p>除了自己通过 try/catch 来处理异常，我们有没有更好的处理方式？答案是抛给调用者，很明显嘛，谁使用谁负责，让该方法的调用者去处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void read(String filename) throw IOException&#123;</span><br><span class="line">    InputStream in = new InputStream(filename);</span><br><span class="line">    int b;</span><br><span class="line">    while((in.read()) != -1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器严格执行 throw 说明符，如果调用了一个受查异常的方法，就必须对它进行处理，或者继续传递。</p><ul><li>如果选择 try/catch 处理还是继续传递呢？</li></ul><p><strong>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎么处理的异常继续传递。</strong></p><p>为具体说明，看一个例子：</p><p><strong>抛出异常</strong></p><p>如果传递一个异常，那么应该在方法的首部使用 throw 声明抛出的异常，告诉方法的调用者这个方法可能会抛出的一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename) throws FileNotFoundException &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在定义 read() 方法时，针对方法体中的 FileNotFoundException 异常我们不知道该怎么处理，怎么办？秉持着谁调用谁处理的原则 ，将该异常抛出，即如代码所示在方法头中 throws FileNotFoundException。在调用该方法时对异常进行处理，则有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile.read(&quot;&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样，如果我们还是不知道该如何处理该异常，也可以将异常继续抛出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() throws FileNotFoundException &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>处理异常</strong></p><p>如果我们在定义时方法体知道如何处理该异常，那么我们可以在定义方法处对异常进行处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename)  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们正常调用该方法就可以了， 不再需要对该方法中的异常进行任何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在类继承关系中，如果超类中的方法没有抛出异常，而子类重写了这个方法，那么这个方法必须捕获方法代码出现的每一个受查异常。在子类中不允许出现 throw 说明符中出现超过超类方法声明的异常范围。</p><h4 id="再次抛出异常和异常链"><a href="#再次抛出异常和异常链" class="headerlink" title="再次抛出异常和异常链"></a>再次抛出异常和异常链</h4><p><strong>可以在 catch 字句中抛出一个异常，这样的目的是改变异常的类型。</strong> 原来抛出的异常为 catch(异常) 中的异常，现在在 catch 语句中抛出了一个新的异常，那么最终异常类型为新异常。</p><p>场景描述：</p><p>如果开发一个供其他程序员使用的子系统，那么用于表示子系统故障的异常类型可能有多种。 ServletException 就是这样一个异常的例子，执行servlet 的代码可能不想知道发生错误的细节原因，但是希望知道 servlet 是否有问题，这是可以通过再次抛出异常。下面是一个捕获异常将它再次抛出的基本方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    // 这样的话通过异常信息，可以知道更多出错的细节。</span><br><span class="line">    throw new ServletException(&quot;database error: &quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还是强烈推荐通过包装技术，<strong>将原始异常设置为新异常的原因</strong>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    Throwable se = new ServletException(&quot;database error&quot;);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们捕获异常时，可以重新获取原始异常，不会丢弃原始异常的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable e = se.getCause();</span><br></pre></td></tr></table></figure><p>一个完整的例子，帮助理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## Main.java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    showTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void showTest() &#123;</span><br><span class="line">    ReadFile readFile = new ReadFile();</span><br><span class="line">    try &#123;</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## ReadFile.java    </span><br><span class="line">public void read(String filename) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        Throwable throwable = new CustomFileExpection(&quot;在 catch中再次抛出了异常&quot;);</span><br><span class="line">        throwable.initCause(e);</span><br><span class="line">        throw throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally-字句"><a href="#finally-字句" class="headerlink" title="finally 字句"></a>finally 字句</h4><p>应用场景：<br>在 finally 语句中释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new InputStream(...);</span><br><span class="line">try&#123;</span><br><span class="line">    // 1</span><br><span class="line">    // code that migth throw exception</span><br><span class="line">    //2</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    //3</span><br><span class="line">    show error message</span><br><span class="line">    //4</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    //5</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line">//6</span><br></pre></td></tr></table></figure><ol><li><p>代码没有抛出异常。代码会执行 1、2、5、6</p></li><li><p>抛出一个在 catch 子句中捕获的异常。try 语句中，程序发生异常，跳过剩余代码，执行 catch 子句中代码。</p><ol><li>如果 catch 中子句没有抛出异常，那么执行 1、3、4、5、6。</li><li>如果 catch 中子句抛出一个异常，异常将被抛回给这个方法的调用者，执行 1、3、5.</li></ol></li><li><p>代码抛出了一个不是 catch 捕获的异常(代码 1 处)，这种情况下，程序执行 try 语句中所有的语句，直到有异常被抛出为止，代码执行 1、5。</p></li></ol><p>在日常代码中，<strong>强烈建议解耦 try/catch 和 try/finally</strong>，这样可以提高代码的清晰度，上面的代码可以这样书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in ...;</span><br><span class="line">try&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        code that might throw exception</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内层 try 代码的职责是关闭输入流，外层的 try 语句的职责就是报告出现的错误。</p><p>面临的问题：<br><strong>finally 语句也可能抛出异常，这时会覆盖原来的异常。</strong></p><h4 id="带资源的-try-语句"><a href="#带资源的-try-语句" class="headerlink" title="带资源的 try 语句"></a>带资源的 try 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open a resource</span><br><span class="line">try&#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如资源属于一个实现了 AutoCloseable/Closeable 的类，Java 7 提供了一个有用的快捷方式，AutoCloseable 有一个接口方法：</p><p><code>void close() throw Exception</code></p><p>Closeable 接口的 close() 方法是一个 抛出 IOException 的方法。</p><p>带资源的 try 语句的最简形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try(Resource res = ...;)&#123;</span><br><span class="line">    work with resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 块退出时或者存在一个异常时，<strong>会自动调用 res.close()</strong>，就好像使用了 finally 块一样。 </p><p>可以指定多个资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try(Scanner in = new Scanner(new InputStream(&quot;/usr/share/dict/words&quot;),&quot;UTF-8&quot;);</span><br><span class="line">PrintWriter out = new PrintWrite(&quot;out.txt&quot;);)&#123;</span><br><span class="line">    while(in.hasNext())&#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论这个块怎么退出， in 和 out 都会关闭。</p><p>这种处理异常的方式，就避免了上文所说的在 finally 语句中抛出的异常会覆盖 try 语句抛出异常的情况。</p><p>如果此时在 finally 中 close() 也会抛出异常，那么原来在 try 子句中的异常会被重新抛出，而 close 方法抛出的异常会被抑制，这些异常会被抑制，并由 addSuppressed() 方法增加到原来的异常，可以通过 getSuppressed() 获取这个被抑制的异常。</p><p><strong>在我们查看一些开源库代码时，这种实现 Closeable 接口的方案随处可见，其目的就是在相应的代码执行完毕后，关闭资源。</strong></p><h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，这个列表就会显示出来。</p><ol><li><p>可以调用 Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StringWriter out = new StringWriter();</span><br><span class="line">t.printStackTrace(new PrintWriter(out));</span><br><span class="line">String des = out.toString();</span><br></pre></td></tr></table></figure></li><li><p>一种更为灵活的方法是使用 getStackTrace 方法，他会得到 StackTraceElement 对象的一个数组，可以在你的程序中分析这个对象数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStaceTrace();</span><br><span class="line">for(StackTraceElement frame: frames)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法，同时还含有获得类名和方法名的方法</strong>，这是一切能够实现的基础。</p><p>静态的Thread.getAllStackTrace() 方法，它可以产生所有线程的堆栈轨迹，下面给出这个方法的具体方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread,StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line">for(Thread t : map.keySet())&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以上方法我们可以自定义 Android 的 LogCat 的打印信息，具体代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static String generateTag() &#123;</span><br><span class="line">       StackTraceElement caller = new Throwable().getStackTrace()[2];</span><br><span class="line">       String tag = &quot;%s.%s(L:%d)&quot;;</span><br><span class="line">       String callerClazzName = caller.getClassName();</span><br><span class="line">       callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(&quot;.&quot;) + 1);</span><br><span class="line">       tag = String.format(Locale.CHINA, tag, callerClazzName, caller.getMethodName(),</span><br><span class="line">               caller.getLineNumber());</span><br><span class="line">       String customTagPrefix = &quot;h_log&quot;;</span><br><span class="line">       tag = TextUtils.isEmpty(customTagPrefix) ? tag : customTagPrefix + &quot;:&quot; + tag;</span><br><span class="line">       return tag;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void d(Object content) &#123;</span><br><span class="line">       if (!isDebug||content==null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       String tag = generateTag();</span><br><span class="line">       Log.d(tag, content.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ul><li>异常处理不能代替简单的测试</li></ul><p>捕获异常的时间较代码此时花的时间较长，只有在异常情况下使用异常机制。</p><ul><li><p>不过过分细化异常</p></li><li><p>利用异常层次结构</p></li></ul><p>根据具体代码寻找更适合的子类或创建自己的异常子类。</p><ul><li>不要压制异常</li></ul><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>在执行以下代码时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int = a/b;</span><br></pre></td></tr></table></figure><p>那么我们需要确认的是，a、b 为数值，并且 b 的值不为 0，我们可以做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(b=0) throw new IllegalAraumentException(&quot;b=0&quot;);</span><br></pre></td></tr></table></figure><p>但是以上代码会一直保存在代码中，测试工作完毕后也不会自动删除，如果代码中含有大量的这种检查，程序运行起来就会变慢。</p><p><strong>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会自动的移走。</strong></p><p>Java 引入了关键字 assert，有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：表达式;</span><br></pre></td></tr></table></figure><p>这两种形式都会对条件进行检测，如果结果为 false，则抛出一个 AssertionError 异常。在第二种形式中，表达式将会被传入 AssertionError 的构造器，并转换成一个消息字符串。</p><h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>启动或禁用断言是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码。</p><ul><li>启用断言</li></ul><p><code>java -enablessertions(-ea) MyApp</code></p><p>在某个类或整个包下使用断言：</p><p><code>java -ea:MyClass -ea:com.xx.xxx MyApp</code></p><ul><li>禁用断言</li></ul><p><code>java -disablessertions(-da) MyApp</code></p><p>有些类不是由类加载器加载，而是有直接虚拟机加载。对于不是由类加载器的系统类可是使用 -enablesystemssertions/-esa 启用断言。</p><h4 id="使用断言完成代码检查"><a href="#使用断言完成代码检查" class="headerlink" title="使用断言完成代码检查"></a>使用断言完成代码检查</h4><p>Java 中有 3 种处理系统错误的机制：</p><ol><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ol><p>选择断言记住以下几点：</p><ul><li>断言失败是致命的、不可恢复的错误</li><li>断言只用于开发和测试阶段</li></ul><p>所以不应该使用断言向程序的其他部分通告发生了可恢复性的错误，断言只应该用于在测试阶段确定程序内部的错误位置。</p><p><strong>前置条件</strong></p><p>在声明一些方法时，往往针对该方法的使用有一定的说明，有些方法往往定义一些 <strong>前置条件</strong> 来进一步指导方法的使用，如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param a array to be sorted (must not be null)</span><br><span class="line">*/</span><br><span class="line">static void sort(int[] a, int fromIndex, int toIndex)</span><br></pre></td></tr></table></figure><p>那么 对数组的限制就是定义了一个前置条件，在使用这个方法时就不允许用 null 数组调用这个方法，并在这个方法的开头使用以下断言：<br><code>assert a != null;</code></p><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>我们在代码添加 <code>System.out.println()</code> 方法来调用程序员观察具体的运行过程和结果，记录日志 API 就是为了这种情况下而设计的。记录日志 API 的有点：<br>1.可以轻易的取消全部日志记录。</p><ol start="2"><li>可以很简单的禁止日志的输出。</li><li>可进行条件过滤。</li><li>日志记录可以被定向到不同的处理器，用于控制台输出，用于存储在文件中等。</li><li></li></ol><h4 id="关于异常的补充"><a href="#关于异常的补充" class="headerlink" title="关于异常的补充"></a>关于异常的补充</h4><ul><li>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</li></ul><p><strong>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</strong></p><ul><li>如何正确的关闭资源？</li></ul><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/24035306.html" target="_blank" rel="noopener">Java 核心知识 卷1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;处理错误&quot;&gt;&lt;a href=&quot;#处理错误&quot; class=&quot;headerlink&quot; title=&quot;处理错误&quot;&gt;&lt;/a&gt;处理错误&lt;/h3&gt;&lt;h4 id=&quot;异常分类&quot;&gt;&lt;a href=&quot;#异常分类&quot; class=&quot;headerlink&quot; title=&quot;异常分类&quot;&gt;&lt;/a&gt;异常分类&lt;/h4&gt;&lt;p&gt;所有的异常都是继承于 Throwable&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_26.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;p&gt; Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="/tags/Java-Basic/"/>
    
      <category term="Exception" scheme="/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>RxJava Transformer</title>
    <link href="/2019/01/17/RxJava%20%E4%BD%BF%E7%94%A8%20Transformer%20%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2/"/>
    <id>/2019/01/17/RxJava 使用 Transformer 进行变换/</id>
    <published>2019-01-17T09:26:13.000Z</published>
    <updated>2019-01-17T10:51:43.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Observable、Observer-线程切换"><a href="#0x81-Observable、Observer-线程切换" class="headerlink" title="0x81 Observable、Observer 线程切换"></a>0x81 Observable、Observer 线程切换</h3><p>在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。</p><h3 id="0x82-Transformer-实现对调用链的处理"><a href="#0x82-Transformer-实现对调用链的处理" class="headerlink" title="0x82 Transformer 实现对调用链的处理"></a>0x82 Transformer 实现对调用链的处理</h3><p>我们可能有以下实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">abstract class SchedulerTransformer&lt;T&gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), </span><br><span class="line">                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&lt;T, T&gt;,</span><br><span class="line">        SingleTransformer&lt;T, T&gt;,</span><br><span class="line">        MaybeTransformer&lt;T, T&gt;,</span><br><span class="line">        CompletableTransformer,</span><br><span class="line">        FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Completable): CompletableSource &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Flowable&lt;T&gt;): Publisher&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Maybe&lt;T&gt;): MaybeSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Observable&lt;T&gt;): ObservableSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Single&lt;T&gt;): SingleSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在具体业务中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(ObservableOnSubscribe&lt;Int&gt; &#123; emitter -&gt; emitter.onNext(1) &#125;).compose(SchedulerTransformer(Schedulers.io(),AndroidSchedulers.mainThread())).subscribe(...);</span><br></pre></td></tr></table></figure><p></p><h3 id="0x83-RxLifeCycle2-中的实现"><a href="#0x83-RxLifeCycle2-中的实现" class="headerlink" title="0x83 RxLifeCycle2 中的实现"></a>0x83 RxLifeCycle2 中的实现</h3><p>RxLifeCycle2 中使用相同的机制，在事件处理过程中对针对生命周期做出处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(ActivityEvent.DESTROY));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity, ActivityEvent event) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(event));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在Fragment的destroy中取消订阅，防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; fragmentLifecycle(RxFragment fragment) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(fragment.bindUntilEvent(FragmentEvent.DESTROY));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x84-在-Kotlin-中的实现"><a href="#0x84-在-Kotlin-中的实现" class="headerlink" title="0x84 在 Kotlin 中的实现"></a>0x84 在 Kotlin 中的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SchedulersApply.kt</span><br><span class="line">fun &lt;T&gt; transformerSchedluer(): ObservableTransformer&lt;T, T&gt; =</span><br><span class="line">        ObservableTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) &#125;</span><br></pre></td></tr></table></figure><p>直接在调用链中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obserable..compose(transformerSchedluer2()).subscribe(....);</span><br></pre></td></tr></table></figure><h3 id="0x85-compose-操作符的功能"><a href="#0x85-compose-操作符的功能" class="headerlink" title="0x85 compose 操作符的功能"></a>0x85 compose 操作符的功能</h3><p>以上对 Observable 的变换最终插入调用链中，主要是因为 compose() 的作用。compose 操作符可以对调用链的原始 Observable 产生作用。</p><p>compose() 除了 实现上述对 Observable 进行变换外我们可以做一些其他处理，如 网络请求过程中 Dialog 的显示和隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity, String message) &#123;</span><br><span class="line">      SpotsDialog dialog = DialogUtil.showLoadingDialog(activity, message);</span><br><span class="line">      return observable -&gt; observable</span><br><span class="line">              .doOnSubscribe(disposable -&gt; &#123;</span><br><span class="line">                  if (dialog != null) &#123;</span><br><span class="line">                      dialog.show();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .doOnComplete(() -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnError(throwable -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnNext(t -&gt; DialogUtil.dismiss(dialog));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity) &#123;</span><br><span class="line">      return loadingDialog(activity, &quot;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Observable、Observer-线程切换&quot;&gt;&lt;a href=&quot;#0x81-Observable、Observer-线程切换&quot; class=&quot;headerlink&quot; title=&quot;0x81 Observable、Observer 线程切换&quot;&gt;&lt;/a&gt;0x81 Observable、Observer 线程切换&lt;/h3&gt;&lt;p&gt;在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。&lt;/p&gt;
&lt;h3 id=&quot;0x82-Transformer-实现对调用链的处理&quot;&gt;&lt;a href=&quot;#0x82-Transformer-实现对调用链的处理&quot; class=&quot;headerlink&quot; title=&quot;0x82 Transformer 实现对调用链的处理&quot;&gt;&lt;/a&gt;0x82 Transformer 实现对调用链的处理&lt;/h3&gt;&lt;p&gt;我们可能有以下实现方式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class SchedulerTransformer&amp;lt;T&amp;gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SingleTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MaybeTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CompletableTransformer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FlowableTransformer&amp;lt;T, T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Completable): CompletableSource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Flowable&amp;lt;T&amp;gt;): Publisher&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Maybe&amp;lt;T&amp;gt;): MaybeSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Observable&amp;lt;T&amp;gt;): ObservableSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Single&amp;lt;T&amp;gt;): SingleSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="/tags/RxJava/"/>
    
      <category term="Transformer" scheme="/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 前奏篇:依赖注入概念</title>
    <link href="/2019/01/17/Dagger2%20%E5%89%8D%E5%A5%8F%E7%AF%87%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A6%82%E5%BF%B5/"/>
    <id>/2019/01/17/Dagger2 前奏篇：依赖注入概念/</id>
    <published>2019-01-17T06:57:56.000Z</published>
    <updated>2019-01-26T11:10:20.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、What-is-Dagger2"><a href="#一、What-is-Dagger2" class="headerlink" title="一、What is Dagger2 ?"></a>一、What is Dagger2 ?</h2><p> <a href="https://github.com/google/dagger" target="_blank" rel="noopener">Dagger2</a> 是一个谷歌开源的依赖注入(<code>Dependency Injection</code>)框架，简称<code>DI</code>。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 <strong>2</strong> 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。<br> 那么 <strong>什么是 <code>依赖注入</code></strong> 呢？</p><h3 id="1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））"><a href="#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））" class="headerlink" title="1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））"></a>1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））</h3><p>我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：</p><a id="more"></a><ol><li>在一个类的具体业务逻辑中，需要另一个类的实例进行相应的操作时，在传统的设计中，通常由调用者来创建被调用者的实例（一般的，我们通过 new 的方式创建），然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由 <code>IOC 容器</code> 来完成，然后<code>注入</code>到调用者。因此也被称为 <strong><code>依赖注入</code></strong>。</li><li><strong><code>依赖注入</code></strong> 就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。那么这个外部，到底指的是哪里，如果指的是另一个类，那么，另一个类内部就耦合了,这种拆东墙补西墙的做法我们是不推荐的。能不能有一种方式，将这些构造的对象放到一个容器中，具体需要哪个实例时，就从这个容器中取就行了。那么，类的实例和使用就不在有联系了，而是通过一个容器将他们联系起来。实现了解耦。</li></ol><p>个人理解：<strong>控制反转</strong> ,把自己新建实例对象的权利由交给了第三方工具或容器。<br>目标类将创建其他实例类的权利交给了第三方工具，也就是说，原来需要程序员把自主在目标类通过 new 的方式创建相关类的实例的权利，交给具体的业务（所谓的 IOC 容器） ，该容器在需要的时候通过它自己的方式创建该类的实例，即：<code>创建类实例权利的移交</code>。</p><h2 id="1-2-依赖注入的好处"><a href="#1-2-依赖注入的好处" class="headerlink" title="1.2 依赖注入的好处"></a>1.2 依赖注入的好处</h2><p><code>依赖注入</code>就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。</p><p>通俗一点讲：将该对象的实例化交给其调用者，通过某种方式传入进来，这种模式就是依赖注入。常见的降低耦合的方式： </p><ul><li>构造方法注入。 </li><li>Setter方式注入。 </li><li>接口注入。</li></ul><h2 id="二、Why-Dagger2"><a href="#二、Why-Dagger2" class="headerlink" title="二、Why Dagger2"></a>二、Why Dagger2</h2><p>Dagger2 的原理是在<code>编译期生成相应的依赖注入代码</code>。这也是和其他依赖注入框架不同的地方，其他框架是在运行时期反射获取注解内容，影响了运行效率。</p><p><strong>栗子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MainClass &#123;</span><br><span class="line">    private  void main(String [] args)&#123;</span><br><span class="line">        John john = new John(&quot;john&quot;,12);</span><br><span class="line">        john.introduceSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子面临着一个问题，一旦 <code>John</code> 的创建方式（如构造参数）发生改变，那么你不但需要修改 <code>MainClass</code> 中创建<code>John</code>的代码，还要修改其他所有地方创建 <code>John</code> 的代码。如果我们使用了<code>Dagger2</code> 的话，就不需要管这些了，只需要在需要<code>John</code>的地方写下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">John john;</span><br></pre></td></tr></table></figure><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="https://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger 详解</a>、<a href="http://www.qingpingshan.com/rjbc/az/170191.html" target="_blank" rel="noopener">这就是Dagger2</a>、<a href="https://juejin.im/entry/589bd2cf8d6d8100585fd86c" target="_blank" rel="noopener">Dagger2 入门实践</a>、<a href="https://blog.csdn.net/lisdye2/article/details/51942511" target="_blank" rel="noopener">最简单的Dagger2入门教程</a>、<a href="https://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、What-is-Dagger2&quot;&gt;&lt;a href=&quot;#一、What-is-Dagger2&quot; class=&quot;headerlink&quot; title=&quot;一、What is Dagger2 ?&quot;&gt;&lt;/a&gt;一、What is Dagger2 ?&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/google/dagger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dagger2&lt;/a&gt; 是一个谷歌开源的依赖注入(&lt;code&gt;Dependency Injection&lt;/code&gt;)框架，简称&lt;code&gt;DI&lt;/code&gt;。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 &lt;strong&gt;2&lt;/strong&gt; 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。&lt;br&gt; 那么 &lt;strong&gt;什么是 &lt;code&gt;依赖注入&lt;/code&gt;&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;h3 id=&quot;1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot;&gt;&lt;a href=&quot;#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot; class=&quot;headerlink&quot; title=&quot;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&quot;&gt;&lt;/a&gt;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&lt;/h3&gt;&lt;p&gt;我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dagger2" scheme="/tags/Dagger2/"/>
    
      <category term="DI" scheme="/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>OKhttp3 核心拦截器、应用拦截器、网络拦截器</title>
    <link href="/2019/01/17/OKhttp3%20%E7%B3%BB%E7%BB%9F%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>/2019/01/17/OKhttp3 系统拦截器简介/</id>
    <published>2019-01-17T06:31:26.000Z</published>
    <updated>2019-08-26T08:06:41.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>功能：实现重试、跟踪</p><p>实现原理： </p><p>while(true) 死循环的实现。</p><p>检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 <code>return Response</code>, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。</p><p>检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。</p><a id="more"></a><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>将用户构建的 Request 请求转换为能够进行网络访问的请求。</li></ul><p>在用户构建的 Request 的基础上 <strong>添加了许多的请求头</strong>，具体内容参看代码。</p><ul><li>将符合网络请求的 Request 进行网络请求。</li></ul><p>在责任链模式的过程中，在此拦截器的到响应 Response。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br></pre></td></tr></table></figure><ul><li>将请求回来的响应 Response 转化为用户可用的 Response。</li></ul><p>主要是根据响应是否对 Response 进行 gzip 压缩，具体是使用 Okio 的库对 Response 进行压缩，并返回 Response。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>功能： 实现缓存功能的拦截器</p><h4 id="设置启用缓存功能"><a href="#设置启用缓存功能" class="headerlink" title="设置启用缓存功能"></a>设置启用缓存功能</h4><p>在新建 OkhttpClient.Builder 的时候进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File sdcache = getExternalCacheDir();</span><br><span class="line">int cacheSize = 10 * 1024 * 1024;</span><br><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">    .cache(new Cache(sdcache.getAbsoluteFile(), cacheSize));</span><br><span class="line">mOkHttpClient = builder.build();</span><br></pre></td></tr></table></figure><p>其底层实现还是 大神 的 开源库 DiskLruCache，如下可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache(File directory, long maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存策略的基本流程"><a href="#缓存策略的基本流程" class="headerlink" title="缓存策略的基本流程"></a>缓存策略的基本流程</h4><h5 id="1-获取缓存响应"><a href="#1-获取缓存响应" class="headerlink" title="1. 获取缓存响应"></a>1. 获取缓存响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h5 id="2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略"><a href="#2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略" class="headerlink" title="2. 根据 request 和 缓存响应 cacheCandidate 获取缓存策略"></a>2. 根据 <strong>request</strong> 和 <strong>缓存响应 cacheCandidate</strong> 获取缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><h5 id="3-获取响应缓存策略下的-request-和-response"><a href="#3-获取响应缓存策略下的-request-和-response" class="headerlink" title="3. 获取响应缓存策略下的 request 和 response"></a>3. 获取响应缓存策略下的 request 和 response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//缓存策略中的请求</span><br><span class="line">Request networkRequest = strategy.networkRequest;</span><br><span class="line">//缓存策略中的响应</span><br><span class="line">Response cacheResponse = strategy.cacheResponse;</span><br></pre></td></tr></table></figure><h5 id="4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。"><a href="#4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。" class="headerlink" title="4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。"></a>4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。</h5><h6 id="1-缓存响应不为空但是策略的响应为空，关闭缓存响应流"><a href="#1-缓存响应不为空但是策略的响应为空，关闭缓存响应流" class="headerlink" title="1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流"></a>1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。"><a href="#2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。" class="headerlink" title="2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。"></a>2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(504)</span><br><span class="line">            .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-1L)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-networkRequest-为空，直接使用缓存，-返回缓存响应-。"><a href="#3-networkRequest-为空，直接使用缓存，-返回缓存响应-。" class="headerlink" title="3. networkRequest 为空，直接使用缓存，==返回缓存响应==。"></a>3. networkRequest 为空，直接使用缓存，==返回缓存响应==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-获取网络请求的响应后，进行操作，此时也要分情况讨论。"><a href="#4-获取网络请求的响应后，进行操作，此时也要分情况讨论。" class="headerlink" title="4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。"></a>4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = null;</span><br><span class="line">networkResponse = chain.proceed(networkRequest);</span><br></pre></td></tr></table></figure><ol><li>networkResponse 的响应码为 304，说明请求的资源未过期，构建 Response 对象，==直接反正该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (cacheResponse != null) &#123;</span><br><span class="line">    // 304 304 的标准解释是：Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（</span><br><span class="line">    // 一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">    // 服务器告诉客户，原来缓冲的文档还可以继续使用。</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">     // Update the cache after combining headers but before stripping the</span><br><span class="line">    // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">    cache.trackConditionalCacheHit();</span><br><span class="line">    cache.update(cacheResponse, response);</span><br><span class="line">    return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 构建 Response，==并直接返回该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Response response = networkResponse.newBuilder()</span><br><span class="line">    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">    .networkResponse(stripBody(networkResponse))</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure><h5 id="5-将-Response-写入缓存"><a href="#5-将-Response-写入缓存" class="headerlink" title="5. 将 Response 写入缓存"></a>5. 将 Response 写入缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上被标注为 ==== 的字样，说明执行 <code>return Response</code> 操作,直接返回响应，进入下一个拦截器的相关处理。</p></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>功能： Opens a connection to the target server and proceeds to the next interceptor。</p><p>打开一个面向指定服务器的连接，并且执行下一个拦截器。</p><h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>在这个拦截器中 HttpCodec 的作用是编码 Http 请求和解码 Http 响应。根据 HTTP版本不同分为 </p><ul><li>Http1Codec(HTTP/1.1) </li><li>Http2Codec(HTTP/2)</li></ul><p>打开连接的关键代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure><p>以下为具体代码调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamAllocation#newStream() </span><br><span class="line">--&gt; this#findHealthyConnection(..) </span><br><span class="line">--&gt;this#findHealthyConnection(..)//获得连接的顺序：存在的链接 、 连接池、新建一个连接</span><br><span class="line">--&gt;this#findConnection(...)</span><br><span class="line">--&gt;RealConnection#connect(...)// 连接并握手</span><br><span class="line">--&gt;RealConnection#connectTunnel(...)或</span><br><span class="line">   RealConnection#connectSocket(..)(最终都会调用connectSocket(...))</span><br><span class="line">--&gt;Platform.get()#connectSocket(...)</span><br><span class="line">--&gt;socket.connect(address, connectTimeout);//最终可以获得建立连接后的 Socket</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;RealConnection#newCodec(..)// 返回 HttpCode</span><br></pre></td></tr></table></figure><p>在 findHealthyConnection() 中有以下代码进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br></pre></td></tr></table></figure><p>至此连接指定服务器的 connection 已经建立。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>这是 Okhttp 库中拦截器链的最后一个拦截器，也是这个拦截器区具体发起请求和获取响应。</p><p>大致分为以下几个步骤：</p><ol><li>写入请求头</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据具体情况判断是否读取</p></li><li><p>根据具体情况判断是否写入相应请求头</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (responseBuilder == null) &#123;</span><br><span class="line">                // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection from</span><br><span class="line">                // being reused. Otherwise we&apos;re still obligated to transmit the request body to leave the</span><br><span class="line">                // connection in a consistent state.</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>构建 Response </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response = responseBuilder</span><br><span class="line">               .request(request)</span><br><span class="line">               .handshake(streamAllocation.connection().handshake())</span><br><span class="line">               .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">               .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></li><li><p>写入 Response 的 body</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>至此，网络请求经过拦截器链获得 Response ，那么再按照拦截器链逆向返回 Response，在此过程中对 Response 进行相应的处理。</p><h3 id="addInterceptor-与-addNetworkInterceptor-的区别"><a href="#addInterceptor-与-addNetworkInterceptor-的区别" class="headerlink" title="addInterceptor 与 addNetworkInterceptor 的区别"></a>addInterceptor 与 addNetworkInterceptor 的区别</h3><p><img src="https://images2018.cnblogs.com/blog/1105320/201804/1105320-20180403182754939-2128769288.png" alt></p><p>通过 addInterceptor 添加的拦截器称为 <strong>应用拦截器</strong>，通过 addNetworkInterceptor 添加的拦截器称为 <strong>网络拦截器</strong>。由官方给出的示意图可知，两者都能够对请求的 requests 和 responses 进行拦截，并进行相关的操作，但是 <strong>两者不同的时在整个网络请求链中位置不同</strong>：</p><p>具体可以看一下 OkHttp 的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    // Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">    // 首先添加 应用拦截器</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    // 然后添加 OkhttpCore 的核心拦截器，这是 Okhttp 能够完成网络请求的核心代码</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));// 在 CacheInterceptor 中传入 缓存路径、大小等相关的对象</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    // 接着添加 网络拦截器</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line">    //originalRequest 最原始的 request</span><br><span class="line">    Interceptor.Chain chain = new RealInterceptorChain(</span><br><span class="line">            interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用拦截器在 Application 与 OkhttpCore 之间。</li><li>网络拦截器在 OkhttpCore 与 NetWork 服务器之间。</li></ul><p>由于其位置的不同，那么 <strong>应用拦截器</strong> 能够拦截的是应用发起的请求的requests、responses以及其他操作，而 <strong>网络拦截器</strong> 可以拦截的是 OkhttpCore 与 NetWork 服务器间网络请求的 requests、responses。</p><p>由于存在重定向等操作，由应用发起的一次网络请求可能会多次请求网络服务器，这时 应用拦截器 与 网络拦截器 的不同就显示出来了：</p><ul><li>应用拦截器 只能拦截到一次网络请求相关的 requests、responses 以及其他信息。</li><li>由于存在重定向，网络拦截器 可以拦截到多次 OkhttpCore 与 NetWork 服务器间的requests、responses 以及其他信息。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对开源库的研读中，我们首先需要做的是对大致流程有个清晰的认识，但是不能深陷细节、具体实现上在后期对相关功能的具体使用时在进行相关研究。而自己在此过程中，就深陷入细节，针对具体的实现真是绞尽脑汁，最后还是 “一败涂地”。此处再次告诫自己和后来人：对开源库的研读不要纠结于细节、不要纠结于细节、不要纠结于细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;a href=&quot;#RetryAndFollowUpInterceptor&quot; class=&quot;headerlink&quot; title=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;/a&gt;RetryAndFollowUpInterceptor&lt;/h3&gt;&lt;p&gt;功能：实现重试、跟踪&lt;/p&gt;
&lt;p&gt;实现原理： &lt;/p&gt;
&lt;p&gt;while(true) 死循环的实现。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 &lt;code&gt;return Response&lt;/code&gt;, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Okhttp3" scheme="/tags/Okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客维护</title>
    <link href="/2019/01/17/Hexo%20%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    <id>/2019/01/17/Hexo 博客维护/</id>
    <published>2019-01-17T02:26:43.000Z</published>
    <updated>2019-01-17T07:13:41.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Hexo-博客建站"><a href="#关于-Hexo-博客建站" class="headerlink" title="关于 Hexo 博客建站"></a>关于 Hexo 博客建站</h3><p>自己在 2016 基于 Hexo + GitPage 搭建个人博客，但是看到推到 Github 上的代码是 hexo g 生成的 public 文件夹下文件，那我日后怎么维护。自己看到别人上传的代码却是真正的 source 文件。</p><p>今日自己才知道，需要维护两套代码，一套真正的 source 文件，一套部署到 github 的代码，真是废柴。</p><h3 id="关于-Hexo-主题"><a href="#关于-Hexo-主题" class="headerlink" title="关于 Hexo 主题"></a>关于 Hexo 主题</h3><p>自己在网上搜索了一部分主题，有的页面概念过于繁杂，有的页面过于花哨，自己的主要目的是博客记录，搭建时默认的 Hexo 主题已经满足要求，就不再更换主题(于今日有效，万一哪天遇到称心得主题)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于-Hexo-博客建站&quot;&gt;&lt;a href=&quot;#关于-Hexo-博客建站&quot; class=&quot;headerlink&quot; title=&quot;关于 Hexo 博客建站&quot;&gt;&lt;/a&gt;关于 Hexo 博客建站&lt;/h3&gt;&lt;p&gt;自己在 2016 基于 Hexo + GitPage 搭建个
      
    
    </summary>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存空间类别</title>
    <link href="/2019/01/16/Java%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%88%AB/"/>
    <id>/2019/01/16/Java 内存空间类别/</id>
    <published>2019-01-16T07:23:17.000Z</published>
    <updated>2019-08-05T06:12:35.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h2><p>JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。</p><p><img src="/images/2019_01_16.jpg" alt="运行时内存区域"></p><!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存，它可以看作 <strong>当前线程</strong> 所执行的 <strong>字节码的行号指示器</strong>。<strong>在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值</strong> 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成**。</p><p>如上图所示，程序计数器是线程私有的。</p><p><strong>如何执行工作</strong></p><p>如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。</p><a id="more"></a><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>Java 虚拟机栈是线程私有的，其生命周期与线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的内存模型： 每个 Java 方法执行的同时都会创建一个 <strong>栈帧(stack frame)</strong>,栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>平时的把 Java 内存分为 堆内存(heap) 和 栈内存(stack) 的分类方法是比较粗糙的，实际分类方法十分复杂。这种分类方法中栈即为虚拟机栈，或为虚拟机中的局部变量表。</p><p>局部变量表存放了编译期可知的各种数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress(指向一条字节码指令的地址)。</p><p>局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多的的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量表的大小。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>本地方方法栈与虚拟机栈发挥的作用相似，不同的是该栈为 Native 方法服务。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java 堆对于大部分应用来说都是 JVM 所管理的内存中最大的一块。Java 堆是 <strong>所有线程共享</strong> 的一块内存区域,<strong>在虚拟机启动时创建</strong>。</p><p>Java 堆的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存 – <strong>所有的对象实例以及数组都要在堆上分配</strong>。</p><p>Java 堆的分配可以在物理上不连续的内存空间，只要逻辑上连续就可以，可以固定大小，也可以扩展空间。</p><p>Java 堆是 GC 发生的主要区域。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样是所有线程共享的内存空间，<strong>它用于储存已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据</strong>。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它还有一个别名 – Non-Heap(非堆)，目的应该是与 Java 堆区分。</p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行区常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong>常量池</strong> ，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字面量和符号引用--&gt;常量池--&gt;运行时常量池</span><br></pre></td></tr></table></figure><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><blockquote><p>没有接触过相关概念。</p></blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><table><thead><tr><th>数据区域</th><th>功能</th><th>线程相关</th><th align="center">备注</th></tr></thead><tbody><tr><td>程序计数器</td><td>字节码执行指示器</td><td>线程私有</td><td align="center"></td></tr><tr><td>Java 虚拟机栈</td><td>为 Java方法服务、存放编译期基本数据类型以及对象引用</td><td>线程私有</td><td align="center">平常被称为的 “栈”、空间较小</td></tr><tr><td></td><td>本地方法栈</td><td>与 Java 虚拟机栈类似，为 Native 方法服务</td><td align="center">线程私有</td></tr><tr><td></td><td>Java 堆</td><td>存放对象(对象实例以及数组)</td><td align="center">线程共享</td></tr><tr><td></td><td>方法区</td><td>存储类信息、常量、静态变量、即时编译器编译后等数据</td><td align="center">线程共享</td></tr><tr><td></td><td>运行时常量池</td><td>常量池存放编译期生成的各种字面量和符号引用、常量池在类加载后存储在运行时常量池</td><td align="center">线程共享</td></tr><tr><td></td><td>直接内存</td><td></td><td align="center"></td></tr></tbody></table><hr><p><strong>知识链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://product.dangdang.com/23259731.html" target="_blank" rel="noopener">深入理解Java虚拟机：JVM高级特性与最佳实践</a></p><p><strong>发现好的博文</strong></p><p><a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="noopener">这一次，彻底解决Java的值传递和引用传递</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。&lt;/p&gt;
&lt;h2 id=&quot;2-运行时数据区域&quot;&gt;&lt;a href=&quot;#2-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;2. 运行时数据区域&quot;&gt;&lt;/a&gt;2. 运行时数据区域&lt;/h2&gt;&lt;p&gt;JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_16.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --&gt;

&lt;h3 id=&quot;2-1-程序计数器&quot;&gt;&lt;a href=&quot;#2-1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;2.1 程序计数器&quot;&gt;&lt;/a&gt;2.1 程序计数器&lt;/h3&gt;&lt;p&gt;程序计数器是一块较小的内存，它可以看作 &lt;strong&gt;当前线程&lt;/strong&gt; 所执行的 &lt;strong&gt;字节码的行号指示器&lt;/strong&gt;。&lt;strong&gt;在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个计数器的值&lt;/strong&gt; 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成**。&lt;/p&gt;
&lt;p&gt;如上图所示，程序计数器是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何执行工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="/tags/Java/"/>
    
      <category term="内存分区" scheme="/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建 GitPage 静态博客</title>
    <link href="/2019/01/16/%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%20GitPage%20%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>/2019/01/16/使用 Hexo 搭建 GitPage 静态博客/</id>
    <published>2019-01-16T06:08:29.821Z</published>
    <updated>2019-01-17T07:13:32.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必要工具的安装-Mac"><a href="#必要工具的安装-Mac" class="headerlink" title="必要工具的安装(Mac)"></a>必要工具的安装(Mac)</h2><h3 id="nmp"><a href="#nmp" class="headerlink" title="nmp"></a>nmp</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 官方网站</a>下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。</p><p>或使用相关命令行进行安装，具体步骤自行搜索。</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>具体参见 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo 建站"></a>Hexo 建站</h2><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>编辑 <code>_config.yml</code> 文件，进行相关配置。</p><a id="more"></a><h2 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览</p><h2 id="博文部署"><a href="#博文部署" class="headerlink" title="博文部署"></a>博文部署</h2><p><code>_congfig.yml</code> 有关文件编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><p>在每次编辑文章后执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean //清理 public 文件夹和 database 文件</span><br><span class="line">$ hexo generate // 重新生成 public 文件夹和 database 文件</span><br><span class="line">$ hexo deploy // 部署到 github page 上</span><br></pre></td></tr></table></figure><p>观察了以下目录文件夹，部署到 GitPage 上应该为 <code>hexo g</code> 生成的 public 文件夹下的内容。</p><hr><p><strong>知识链接：</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cherryblog.site/categories/Hexo%E5%BB%BA%E7%AB%99/" target="_blank" rel="noopener">Hexo建站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;必要工具的安装-Mac&quot;&gt;&lt;a href=&quot;#必要工具的安装-Mac&quot; class=&quot;headerlink&quot; title=&quot;必要工具的安装(Mac)&quot;&gt;&lt;/a&gt;必要工具的安装(Mac)&lt;/h2&gt;&lt;h3 id=&quot;nmp&quot;&gt;&lt;a href=&quot;#nmp&quot; class=&quot;headerlink&quot; title=&quot;nmp&quot;&gt;&lt;/a&gt;nmp&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node 官方网站&lt;/a&gt;下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。&lt;/p&gt;
&lt;p&gt;或使用相关命令行进行安装，具体步骤自行搜索。&lt;/p&gt;
&lt;h3 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;具体参见 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hexo-建站&quot;&gt;&lt;a href=&quot;#Hexo-建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo 建站&quot;&gt;&lt;/a&gt;Hexo 建站&lt;/h2&gt;&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;编辑 &lt;code&gt;_config.yml&lt;/code&gt; 文件，进行相关配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="/tags/Hexo/"/>
    
      <category term="GitPage" scheme="/tags/GitPage/"/>
    
  </entry>
  
</feed>
