<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enjoy</title>
  
  <subtitle>Enjoy the technology，Enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mllgy.github.io/"/>
  <updated>2019-01-17T07:00:16.427Z</updated>
  <id>https://mllgy.github.io/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dagger2 前奏篇:依赖注入概念</title>
    <link href="https://mllgy.github.io/2019/01/17/Dagger2%20%E5%89%8D%E5%A5%8F%E7%AF%87%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A6%82%E5%BF%B5/"/>
    <id>https://mllgy.github.io/2019/01/17/Dagger2 前奏篇：依赖注入概念/</id>
    <published>2019-01-17T06:57:56.000Z</published>
    <updated>2019-01-17T07:00:16.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、What-is-Dagger2"><a href="#一、What-is-Dagger2" class="headerlink" title="一、What is Dagger2 ?"></a>一、What is Dagger2 ?</h2><p> <a href="https://github.com/google/dagger" target="_blank" rel="noopener">Dagger2</a> 是一个谷歌开源的依赖注入(<code>Dependency Injection</code>)框架，简称<code>DI</code>。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 <strong>2</strong> 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。<br> 那么 <strong>什么是 <code>依赖注入</code></strong> 呢？</p><h3 id="1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））"><a href="#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））" class="headerlink" title="1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））"></a>1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））</h3><p>我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：</p><ol><li>在一个类的具体业务逻辑中，需要另一个类的实例进行相应的操作时，在传统的设计中，通常由调用者来创建被调用者的实例（一般的，我们通过 new 的方式创建），然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由 <code>IOC 容器</code> 来完成，然后<code>注入</code>到调用者。因此也被称为 <strong><code>依赖注入</code></strong>。</li><li><strong><code>依赖注入</code></strong> 就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。那么这个外部，到底指的是哪里，如果指的是另一个类，那么，另一个类内部就耦合了,这种拆东墙补西墙的做法我们是不推荐的。能不能有一种方式，将这些构造的对象放到一个容器中，具体需要哪个实例时，就从这个容器中取就行了。那么，类的实例和使用就不在有联系了，而是通过一个容器将他们联系起来。实现了解耦。<blockquote><p>个人理解：<strong>控制反转</strong> – 把自己新建实例对象的权利由交给了第三方工具或容器。<br>目标类将创建其他实例类的权利交给了第三方工具，也就是说，原来需要程序员把自主在目标类通过 new 的方式创建相关类的实例的权利，交给具体的业务（所谓的 IOC 容器） ，该容器在需要的时候通过它自己的方式创建该类的实例，即：<code>创建类实例权利的移交</code>。</p></blockquote></li></ol><h2 id="1-2-依赖注入的好处"><a href="#1-2-依赖注入的好处" class="headerlink" title="1.2 依赖注入的好处"></a>1.2 依赖注入的好处</h2><p><code>依赖注入</code>就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。</p><p>通俗一点讲：将该对象的实例化交给其调用者，通过某种方式传入进来，这种模式就是依赖注入。常见的降低耦合的方式： </p><ul><li>构造方法注入。 </li><li>Setter方式注入。 </li><li>接口注入。</li></ul><h2 id="二、Why-Dagger2"><a href="#二、Why-Dagger2" class="headerlink" title="二、Why Dagger2"></a>二、Why Dagger2</h2><p>Dagger2 的原理是在<code>编译期生成相应的依赖注入代码</code>。这也是和其他依赖注入框架不同的地方，其他框架是在运行时期反射获取注解内容，影响了运行效率。</p><p><strong>栗子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MainClass &#123;</span><br><span class="line">    private  void main(String [] args)&#123;</span><br><span class="line">        John john = new John(&quot;john&quot;,12);</span><br><span class="line">        john.introduceSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面例子面临着一个问题，一旦 <code>John</code> 的创建方式（如构造参数）发生改变，那么你不但需要修改 <code>MainClass</code> 中创建<code>John</code>的代码，还要修改其他所有地方创建 <code>John</code> 的代码。如果我们使用了<code>Dagger2</code> 的话，就不需要管这些了，只需要在需要<code>John</code>的地方写下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">John john;</span><br></pre></td></tr></table></figure></p><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="https://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger 详解</a></p><p><a href="http://www.qingpingshan.com/rjbc/az/170191.html" target="_blank" rel="noopener">这就是Dagger2</a></p><p><a href="https://juejin.im/entry/589bd2cf8d6d8100585fd86c" target="_blank" rel="noopener">Dagger2 入门实践</a></p><p><a href="https://blog.csdn.net/lisdye2/article/details/51942511" target="_blank" rel="noopener">最简单的Dagger2入门教程</a></p><p><a href="https://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、What-is-Dagger2&quot;&gt;&lt;a href=&quot;#一、What-is-Dagger2&quot; class=&quot;headerlink&quot; title=&quot;一、What is Dagger2 ?&quot;&gt;&lt;/a&gt;一、What is Dagger2 ?&lt;/h2&gt;&lt;p&gt; &lt;a hr
      
    
    </summary>
    
    
      <category term="Dagger2" scheme="https://mllgy.github.io/tags/Dagger2/"/>
    
      <category term="DI" scheme="https://mllgy.github.io/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>OKhttp3 拦截器</title>
    <link href="https://mllgy.github.io/2019/01/17/OKhttp3%20%E7%B3%BB%E7%BB%9F%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://mllgy.github.io/2019/01/17/OKhttp3 系统拦截器简介/</id>
    <published>2019-01-17T06:31:26.000Z</published>
    <updated>2019-01-17T06:55:14.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>功能：实现重试、跟踪</p><p>实现原理： </p><p>while(true) 死循环的实现。</p><p>检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 <code>return Response</code>, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。</p><p>检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。</p><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>将用户构建的 Request 请求转换为能够进行网络访问的请求。</li></ul><p>在用户构建的 Request 的基础上 <strong>添加了许多的请求头</strong>，具体内容参看代码。</p><ul><li>将符合网络请求的 Request 进行网络请求。</li></ul><p>在责任链模式的过程中，在此拦截器的到响应 Response。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br></pre></td></tr></table></figure><ul><li>将请求回来的响应 Response 转化为用户可用的 Response。</li></ul><p>主要是根据响应是否对 Response 进行 gzip 压缩，具体是使用 Okio 的库对 Response 进行压缩，并返回 Response。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>功能： 实现缓存功能的拦截器</p><h4 id="设置启用缓存功能"><a href="#设置启用缓存功能" class="headerlink" title="设置启用缓存功能"></a>设置启用缓存功能</h4><p>在新建 OkhttpClient.Builder 的时候进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File sdcache = getExternalCacheDir();</span><br><span class="line">int cacheSize = 10 * 1024 * 1024;</span><br><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">    .cache(new Cache(sdcache.getAbsoluteFile(), cacheSize));</span><br><span class="line">mOkHttpClient = builder.build();</span><br></pre></td></tr></table></figure><p>其底层实现还是 大神 的 开源库 DiskLruCache，如下可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache(File directory, long maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存策略的基本流程"><a href="#缓存策略的基本流程" class="headerlink" title="缓存策略的基本流程"></a>缓存策略的基本流程</h4><h5 id="1-获取缓存响应"><a href="#1-获取缓存响应" class="headerlink" title="1. 获取缓存响应"></a>1. 获取缓存响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h5 id="2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略"><a href="#2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略" class="headerlink" title="2. 根据 request 和 缓存响应 cacheCandidate 获取缓存策略"></a>2. 根据 <strong>request</strong> 和 <strong>缓存响应 cacheCandidate</strong> 获取缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><h5 id="3-获取响应缓存策略下的-request-和-response"><a href="#3-获取响应缓存策略下的-request-和-response" class="headerlink" title="3. 获取响应缓存策略下的 request 和 response"></a>3. 获取响应缓存策略下的 request 和 response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//缓存策略中的请求</span><br><span class="line">Request networkRequest = strategy.networkRequest;</span><br><span class="line">//缓存策略中的响应</span><br><span class="line">Response cacheResponse = strategy.cacheResponse;</span><br></pre></td></tr></table></figure><h5 id="4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。"><a href="#4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。" class="headerlink" title="4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。"></a>4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。</h5><h6 id="1-缓存响应不为空但是策略的响应为空，关闭缓存响应流"><a href="#1-缓存响应不为空但是策略的响应为空，关闭缓存响应流" class="headerlink" title="1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流"></a>1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。"><a href="#2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。" class="headerlink" title="2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。"></a>2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(504)</span><br><span class="line">            .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-1L)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-networkRequest-为空，直接使用缓存，-返回缓存响应-。"><a href="#3-networkRequest-为空，直接使用缓存，-返回缓存响应-。" class="headerlink" title="3. networkRequest 为空，直接使用缓存，==返回缓存响应==。"></a>3. networkRequest 为空，直接使用缓存，==返回缓存响应==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-获取网络请求的响应后，进行操作，此时也要分情况讨论。"><a href="#4-获取网络请求的响应后，进行操作，此时也要分情况讨论。" class="headerlink" title="4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。"></a>4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = null;</span><br><span class="line">networkResponse = chain.proceed(networkRequest);</span><br></pre></td></tr></table></figure><ol><li>networkResponse 的响应码为 304，说明请求的资源未过期，构建 Response 对象，==直接反正该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (cacheResponse != null) &#123;</span><br><span class="line">    // 304 304 的标准解释是：Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（</span><br><span class="line">    // 一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">    // 服务器告诉客户，原来缓冲的文档还可以继续使用。</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">     // Update the cache after combining headers but before stripping the</span><br><span class="line">    // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">    cache.trackConditionalCacheHit();</span><br><span class="line">    cache.update(cacheResponse, response);</span><br><span class="line">    return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 构建 Response，==并直接返回该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Response response = networkResponse.newBuilder()</span><br><span class="line">    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">    .networkResponse(stripBody(networkResponse))</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure><h5 id="5-将-Response-写入缓存"><a href="#5-将-Response-写入缓存" class="headerlink" title="5. 将 Response 写入缓存"></a>5. 将 Response 写入缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上被标注为 ==== 的字样，说明执行 <code>return Response</code> 操作,直接返回响应，进入下一个拦截器的相关处理。</p></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>功能： Opens a connection to the target server and proceeds to the next interceptor。</p><p>打开一个面向指定服务器的连接，并且执行下一个拦截器。</p><h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>在这个拦截器中 HttpCodec 的作用是编码 Http 请求和解码 Http 响应。根据 HTTP版本不同分为 </p><ul><li>Http1Codec(HTTP/1.1) </li><li>Http2Codec(HTTP/2)</li></ul><p>打开连接的关键代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure><p>以下为具体代码调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamAllocation#newStream() </span><br><span class="line">--&gt; this#findHealthyConnection(..) </span><br><span class="line">--&gt;this#findHealthyConnection(..)//获得连接的顺序：存在的链接 、 连接池、新建一个连接</span><br><span class="line">--&gt;this#findConnection(...)</span><br><span class="line">--&gt;RealConnection#connect(...)// 连接并握手</span><br><span class="line">--&gt;RealConnection#connectTunnel(...)或</span><br><span class="line">   RealConnection#connectSocket(..)(最终都会调用connectSocket(...))</span><br><span class="line">--&gt;Platform.get()#connectSocket(...)</span><br><span class="line">--&gt;socket.connect(address, connectTimeout);//最终可以获得建立连接后的 Socket</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;RealConnection#newCodec(..)// 返回 HttpCode</span><br></pre></td></tr></table></figure><p>在 findHealthyConnection() 中有以下代码进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br></pre></td></tr></table></figure><p>至此连接指定服务器的 connection 已经建立。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>这是 Okhttp 库中拦截器链的最后一个拦截器，也是这个拦截器区具体发起请求和获取响应。</p><p>大致分为以下几个步骤：</p><ol><li>写入请求头</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据具体情况判断是否读取</p></li><li><p>根据具体情况判断是否写入相应请求头</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (responseBuilder == null) &#123;</span><br><span class="line">                // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection from</span><br><span class="line">                // being reused. Otherwise we&apos;re still obligated to transmit the request body to leave the</span><br><span class="line">                // connection in a consistent state.</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>构建 Response </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response = responseBuilder</span><br><span class="line">               .request(request)</span><br><span class="line">               .handshake(streamAllocation.connection().handshake())</span><br><span class="line">               .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">               .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></li><li><p>写入 Response 的 body</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>至此，网络请求经过拦截器链获得 Response ，那么再按照拦截器链逆向返回 Response，在此过程中对 Response 进行相应的处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对开源库的研读中，我们首先需要做的是对大致流程有个清晰的认识，但是不能深陷细节、具体实现上在后期对相关功能的具体使用时在进行相关研究。而自己在此过程中，就深陷入细节，针对具体的实现真是绞尽脑汁，最后还是 “一败涂地”。此处再次告诫自己和后来人：对开源库的研读不要纠结于细节，不要纠结于细节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;a href=&quot;#RetryAndFollowUpInterceptor&quot; class=&quot;headerlink&quot; title=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;/a&gt;Retry
      
    
    </summary>
    
    
      <category term="Okhttp3" scheme="https://mllgy.github.io/tags/Okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客维护</title>
    <link href="https://mllgy.github.io/2019/01/17/Hexo%20%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    <id>https://mllgy.github.io/2019/01/17/Hexo 博客维护/</id>
    <published>2019-01-17T02:26:43.000Z</published>
    <updated>2019-01-17T02:48:46.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Hexo-博客建站"><a href="#关于-Hexo-博客建站" class="headerlink" title="关于 Hexo 博客建站"></a>关于 Hexo 博客建站</h3><p>自己在 2016 基于 Hexo + GitPage 搭建个人博客，但是看到推到 Github 上的代码是 hexo g 生成的 public 文件夹下文件，那我日后怎么维护。自己看到别人上传的代码却是真正的 source 文件。</p><p>今日自己才知道，需要维护两套代码，一套真正的 source 文件，一套部署到 github 的代码，真是废柴。</p><h3 id="关于-Hexo-主题"><a href="#关于-Hexo-主题" class="headerlink" title="关于 Hexo 主题"></a>关于 Hexo 主题</h3><p>自己在网上搜索了一部分主题，有的页面概念过于繁杂，有的页面过于花哨，自己的主要目的是博客记录，搭建时默认的 Hexo 主题已经满足要求，就不再更换主题(于今日有效，万一哪天遇到称心得主题)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于-Hexo-博客建站&quot;&gt;&lt;a href=&quot;#关于-Hexo-博客建站&quot; class=&quot;headerlink&quot; title=&quot;关于 Hexo 博客建站&quot;&gt;&lt;/a&gt;关于 Hexo 博客建站&lt;/h3&gt;&lt;p&gt;自己在 2016 基于 Hexo + GitPage 搭建个
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mllgy.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存空间类别</title>
    <link href="https://mllgy.github.io/2019/01/16/Java%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%88%AB/"/>
    <id>https://mllgy.github.io/2019/01/16/Java 内存空间类别/</id>
    <published>2019-01-16T07:23:17.000Z</published>
    <updated>2019-01-17T02:26:59.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h2><p>JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。</p><p><img src="/images/2019_01_16.jpg" alt="运行时内存区域"></p><!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存，它可以看作 <strong>当前线程</strong> 所执行的字节码的行号指示器。<strong>在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个 </strong>计数器的值<strong> 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成</strong>。</p><p>如上图所示，程序计数器是线程私有的。</p><blockquote><p><strong>如何执行工作</strong></p></blockquote><p>如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。</p><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>Java 虚拟机栈是线程私有的，其生命周期与线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的内存模型： 每个 Java 方法执行的同时都会创建一个 <strong>栈帧(stack frame)</strong> 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>平时的把 Java 内存分为 堆内存(heap) 和 栈内存(stack) 的分类方法是比较粗糙的，实际分类方法十分复杂。这种分类方法中栈即为虚拟机栈，或为虚拟机中的局部变量表。</p><p>局部变量表存放了编译期可知的各种数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress(指向一条字节码指令的地址)。</p><p>局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多的的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量表的大小。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>本地方方法栈与虚拟机栈发挥的作用相似，不同的是该栈为 Native 方法服务。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java 堆对于大部分应用来说都是 JVM 所管理的内存中最大的一块。Java 堆是 <strong>所有线程共享</strong> 的一块内存区域,<strong>在虚拟机启动时创建</strong>。Java 堆的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存 – <strong>所有的对象实例以及数组都要在堆上分配</strong>。</p><p>Java 堆的分配可以在物理上不连续的内存空间，只要逻辑上连续就可以，可以固定大小，也可以扩展空间。</p><p>Java 堆是 GC 发生的主要区域。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样是所有线程共享的内存空间，<strong>它用于储存已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据</strong>。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它还有一个别名 – Non-Heap(非堆)，目的应该是与 Java 堆区分。</p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行区常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong>常量池</strong> ，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字面量和符号引用--&gt;常量池--&gt;运行时常量池</span><br></pre></td></tr></table></figure><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><blockquote><p>没有接触过相关概念。</p></blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><table><thead><tr><th>数据区域</th><th>功能</th><th>线程相关</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>程序计数器</td><td>字节码执行指示器</td><td>线程私有</td><td style="text-align:center"></td></tr><tr><td>Java 虚拟机栈</td><td>为 Java方法服务、存放编译期基本数据类型以及对象引用</td><td>线程私有</td><td style="text-align:center">平常被称为的 “栈”、空间较小</td></tr><tr><td></td><td>本地方法栈</td><td>与 Java 虚拟机栈类似，为 Native 方法服务</td><td style="text-align:center">线程私有</td><td></td><td></td></tr><tr><td></td><td>Java 堆</td><td>存放对象(对象实例以及数组)</td><td style="text-align:center">线程共享</td><td>GC 主要区域、空间较大</td><td></td></tr><tr><td></td><td>方法区</td><td>存储类信息、常量、静态变量、即时编译器编译后等数据</td><td style="text-align:center">线程共享</td><td></td><td></td></tr><tr><td></td><td>运行时常量池</td><td>常量池存放编译期生成的各种字面量和符号引用、常量池在类加载后存储在运行时常量池</td><td style="text-align:center">线程共享</td><td>方法区的一部分、常量池会存储在其中</td><td></td></tr><tr><td></td><td>直接内存</td><td></td><td style="text-align:center"></td><td></td><td></td></tr></tbody></table><hr><p><strong>知识链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://product.dangdang.com/23259731.html" target="_blank" rel="noopener">深入理解Java虚拟机：JVM高级特性与最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Java" scheme="https://mllgy.github.io/tags/Java/"/>
    
      <category term="内存分区" scheme="https://mllgy.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建 GitPage 静态博客</title>
    <link href="https://mllgy.github.io/2019/01/16/%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%20GitPage%20%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>https://mllgy.github.io/2019/01/16/使用 Hexo 搭建 GitPage 静态博客/</id>
    <published>2019-01-16T06:08:29.821Z</published>
    <updated>2019-01-16T07:12:37.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必要工具的安装-Mac"><a href="#必要工具的安装-Mac" class="headerlink" title="必要工具的安装(Mac)"></a>必要工具的安装(Mac)</h2><h3 id="nmp"><a href="#nmp" class="headerlink" title="nmp"></a>nmp</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 官方网站</a>下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。</p><p>或使用相关命令行进行安装，具体步骤自行搜索。</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>具体参见 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo 建站"></a>Hexo 建站</h2><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>编辑 <code>_config.yml</code> 文件，进行相关配置。</p><h2 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览</p><h2 id="博文部署"><a href="#博文部署" class="headerlink" title="博文部署"></a>博文部署</h2><p><code>_congfig.yml</code> 有关文件编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><p>在每次编辑文章后执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean //清理 public 文件夹和 database 文件</span><br><span class="line">$ hexo generate // 重新生成 public 文件夹和 database 文件</span><br><span class="line">$ hexo deploy // 部署到 github page 上</span><br></pre></td></tr></table></figure><p>观察了以下目录文件夹，部署到 GitPage 上应该为 <code>hexo g</code> 生成的 public 文件夹下的内容。</p><hr><p><strong>知识链接：</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cherryblog.site/categories/Hexo%E5%BB%BA%E7%AB%99/" target="_blank" rel="noopener">Hexo建站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;必要工具的安装-Mac&quot;&gt;&lt;a href=&quot;#必要工具的安装-Mac&quot; class=&quot;headerlink&quot; title=&quot;必要工具的安装(Mac)&quot;&gt;&lt;/a&gt;必要工具的安装(Mac)&lt;/h2&gt;&lt;h3 id=&quot;nmp&quot;&gt;&lt;a href=&quot;#nmp&quot; class
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mllgy.github.io/tags/Hexo/"/>
    
      <category term="GitPage" scheme="https://mllgy.github.io/tags/GitPage/"/>
    
  </entry>
  
</feed>
