<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enjoy</title>
  
  <subtitle>Enjoy the technology，Enjoy the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mllgy.github.io/"/>
  <updated>2019-03-08T03:52:16.292Z</updated>
  <id>https://mllgy.github.io/</id>
  
  <author>
    <name>GY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://mllgy.github.io/2019/03/08/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://mllgy.github.io/2019/03/08/字符串/</id>
    <published>2019-03-08T03:52:16.254Z</published>
    <updated>2019-03-08T03:52:16.292Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Baseic 二</title>
    <link href="https://mllgy.github.io/2019/03/07/Java-Baseic-%E4%BA%8C/"/>
    <id>https://mllgy.github.io/2019/03/07/Java-Baseic-二/</id>
    <published>2019-03-07T04:56:36.000Z</published>
    <updated>2019-03-12T06:47:07.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equal-方法"><a href="#与-equal-方法" class="headerlink" title="== 与 equal 方法"></a>== 与 equal 方法</h3><p>Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。</p><p>当使用 <code>==</code> 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 <strong><code>==</code> 不可用于比较类型上没有父子关系的两个对象</strong>。</p><p>equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。</p><p>在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。</p><p>所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。<br><a id="more"></a></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">String b = &quot;abc&quot;;</span><br><span class="line">String c = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;</span><br></pre></td></tr></table></figure><p>此时堆内存中只会分配一份存储 “abc” 的内存, 变量 a、b、c 的引用地址都指向该内存地址。</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池，主要是用来管理编译时被确定并且保存在 .class 文件中的数据，包括类、方法、接口中的常量以及字符串常量。</p><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>被 static 修饰的变量、方法、初始化块、内部类等称为类变量。类变量属于类，在第一加载类的时候，系统会为类变量分配内存空间并进行初始化，直到该类被卸载，类变量占用的内存从会被标记成垃圾。</p><p>类变量中不能访问非 static 变量成员(变量、方法等),因为 类成员的作用域比非 static 变量成员的作用域大，存在类变量已经被初始化但是实例变量为被初始化的情况，此时程序就会出现异常。</p><h3 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h3><p>如果一个类只能创建一个实例，那么这个类称为 <strong>单例类</strong>。</p><p>根据良好性封装原则，我们需要：</p><ol><li>把类构造器函数隐藏</li><li>提供 public 方法获取类的实例对象，并用 static 方法修饰,因为调用该方法前该对象还不存在，所以该方法应该属于类。</li></ol><h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>final 修饰的变量不可重复赋值</strong>。</p><p><strong>final 修饰成员变量</strong></p><p>初始化位置：</p><ul><li>初始化块</li><li>构造器</li><li>声明处</li></ul><p><strong>final 修饰类变量</strong><br>初始化位置：</p><ul><li>初始化块</li><li>声明处</li></ul><p>与普通实例变量不同，final 修饰的变量(实例变量和类变量)必须显式的初始化，系统不会为 final 修饰的变量的执行默认初始化。</p><ul><li>final 修饰局部变量</li></ul><p>必须显式的初始化初始值。</p><h3 id="final-修饰基本数据类型和引用数据类型"><a href="#final-修饰基本数据类型和引用数据类型" class="headerlink" title="final 修饰基本数据类型和引用数据类型"></a>final 修饰基本数据类型和引用数据类型</h3><p>final 修饰基本数据变量，则该变量不能被改变。<br>final 修饰引用数据类型变量，说明这个变量指向的内存地址不可更改，但是并不是此对象的各个属性不可变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">final Person person = new Person(20,&quot;Mike&quot;);</span><br><span class="line">person.setName(&quot;Jim&quot;);</span><br><span class="line">person.age = 21;</span><br></pre></td></tr></table></figure><h3 id="final-、宏变量与宏替换"><a href="#final-、宏变量与宏替换" class="headerlink" title="final 、宏变量与宏替换"></a>final 、宏变量与宏替换</h3><p>只要满足三个条件，这个 final 变量就不再是一个变量，而相当于一个直接量：</p><ol><li>使用 final 修饰</li><li>定义该 final 变量时指定初始值</li><li>该初始值在编译器时被确定下来。</li></ol><p>那么这个变量称为 <strong>宏变量</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int a =  5;</span><br></pre></td></tr></table></figure><p>那么对于这个程序来说，根本不存在变量 a，出现变量a 的地方全部被 5 替换。</p><p>为了说明宏变量的不同之处，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ab&quot;;</span><br><span class="line">String str2 = &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">sout(str1==str2);// true</span><br><span class="line"></span><br><span class="line">String str3 = &quot;a&quot;;</span><br><span class="line">String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><p>至于第一个日志结果为 true ,应该十分容易理解：str1 在编译时确定值，会被存储在常量池中，str2 通过显示的 <strong>拼装后(不是分别创建“a”和“b”)</strong> 存入 <strong>常量池</strong>，但是常量池中已经存在相同的值，就不会重新创建，直接将该值的内存地址指向 str2，所以结果为 true。</p><p>而第二条日志中，str5 在编译期不会初始化，需要在运行期通过计算获得，其值会被分配在 <code>堆内存</code>去中，所以 str1 和 str5 的引用的地址不同，其打印结果为 false。</p><p>同理有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str6 = new String(&quot;ab&quot;); </span><br><span class="line">sout(str1 == str6);//false</span><br></pre></td></tr></table></figure></p><p>但是如果 str3 和 str4 被 final 修饰，两者就会变成宏变量，两变量出现的位置会直接被值替换，此时 str5 在编译期就会确定初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final String str3 = &quot;a&quot;;</span><br><span class="line">final String str4 = &quot;b&quot;;</span><br><span class="line">String str5 = str3 + str4;</span><br><span class="line">sout(str1 == str5);//false</span><br></pre></td></tr></table></figure><h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法"></a>final 方法</h3><p>final 方法不可被重写，但是可以被重载。</p><h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类"></a>final 类</h3><p>final 类不能拥有子类。</p><h3 id="不可变类-immutable"><a href="#不可变类-immutable" class="headerlink" title="不可变类(immutable)"></a>不可变类(immutable)</h3><p>不可变类为创建该类的实例后，该实例的实例变量不可变。</p><p>Java 提供的 8 个包装类和 String 为不可变类。</p><p>自定义不可变类需要遵循以下规则：</p><ol><li>使用 private final 修饰成员变量</li><li>提供构造器，传入初始值</li><li>仅提供 getter 方法</li><li>如果有必要，重新 equal() 和 hashcode() 方法自定义相等的逻辑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;与-equal-方法&quot;&gt;&lt;a href=&quot;#与-equal-方法&quot; class=&quot;headerlink&quot; title=&quot;== 与 equal 方法&quot;&gt;&lt;/a&gt;== 与 equal 方法&lt;/h3&gt;&lt;p&gt;Java 中判断两个变量是否相等有两个方法: == 和 equal 方法。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;==&lt;/code&gt; 是，如果两个变量为基本数据类型，且都是数值类型，那么只要求两个变量的值相等，则为 true；如果两个变量为引用类型，那么只有当它们指向同一个对象时，返回值才为 true。但是 &lt;strong&gt;&lt;code&gt;==&lt;/code&gt; 不可用于比较类型上没有父子关系的两个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;equal 为 Object 的方法，所有的引用变量都可以调用该方法。但是使用 equal 方法判断两个对象是否相等的标准和 == 是一致的，都是在两个变量指向同一个对象时，才会返回 true。直接使用 Object 的 equal 方法没有什么意义，一般需要我们自己定义 equal 方法自定义相等的标准。&lt;/p&gt;
&lt;p&gt;在平常的开发中我们会有这样的一个误区： == 是判断两个变量是否相等， equal 是用来判断两个变量的值是否相等，其实后半句话有一个前提，就是变量的类型为 String ，这是因为 String 已经为我们重写了 equal 方法，用于判断两个字符串的值是否相等,具体可以参见 String 的源码。&lt;/p&gt;
&lt;p&gt;所以在两个变量皆为引用数据类型是， == 与 equal 方法没有什么区别,都是判断两个变量是否指向同一个变量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Basic</title>
    <link href="https://mllgy.github.io/2019/03/06/Java-Basic/"/>
    <id>https://mllgy.github.io/2019/03/06/Java-Basic/</id>
    <published>2019-03-06T06:31:33.000Z</published>
    <updated>2019-03-07T04:55:56.207Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的三大特征"><a href="#对象的三大特征" class="headerlink" title="对象的三大特征"></a>对象的三大特征</h3><p>对象的三种基本特征:继承、封装、多态。</p><p>Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。</p><p><strong>封装</strong>： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。</p><p><strong>继承</strong>：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。</p><p><strong>多态</strong>：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// B 继承 A</span><br><span class="line">A a;</span><br><span class="line">a = new A();</span><br><span class="line">a.testMethod();// 执行 A 中方法</span><br><span class="line">a = new B();</span><br><span class="line">a.testMethod();// 执行 B 中方法</span><br><span class="line"></span><br><span class="line">//在此例中，同一个类型引用执行同一个方法，可能表现多种行为特征：类型为 A ，该类的对象 a 执行 testMethod() 方法会根据其引用对象的具体类型表现出不同的行为特征 -- A#testMethod()或B#testMethod()。</span><br></pre></td></tr></table></figure></p><h4 id="Java-是静态的强类型的语言"><a href="#Java-是静态的强类型的语言" class="headerlink" title="Java 是静态的强类型的语言"></a>Java 是静态的强类型的语言</h4><p>Java 是静态的，一旦一个类被定义，如果对这个类有所更改，只要不重新编译这个类，那么这个类以及这个类拥有的成员变量就不会发生改变。</p><p>Java 的强类型主要表现在两方面：</p><ol><li>所有的变量必须先声明后使用；</li><li>指定类型的变量只能赋相同类型的值；</li></ol><p>基于上面，Java 在编译期就会确定成员变量的类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>编程的本质就是对内存中的数据访问和修改</strong>，程序所用到的数据都会保存在内存中，程序员需要通过一种机制来访问和修改内存中的数据，这种机制就是 <strong>变量</strong> ，每个变量代表某一小块内存。变量是有名字的，程序对变量 <strong>赋值</strong>，就是把数据装入该变量所代表的内存区的过程；程序 <strong>读取变量</strong>，就是从变量代表的内存区取值的过程。可以简单的理解：变量相当于一个有名称的容器，该容器用于装各种不同类型的数据。</p><h3 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h3><p><img src="/images/19_03_06.jpg" alt="对象与引用"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person(&quot;Mike&quot;,20)</span><br></pre></td></tr></table></figure><p>由上文中变量是需要是需要内存存储数据的，此语句中 <code>new Person(&quot;Mike&quot;,20)</code> 只是在堆内存中开辟出一块内存去存储这个对象，而 <code>Person p</code> 则需要在栈内存中开辟一块内存来存储变量以及相关内容，至于在此区域存储的到底是什么需要在赋值后才会具体化。在此例中，赋值语句后，变量 p 对应的栈内存存储的为新建对象 – new Person 的内存地址。</p><h3 id="this-引用"><a href="#this-引用" class="headerlink" title="this 引用"></a>this 引用</h3><p>首先 this 代表一定是个对象，其次 this 出现在不同位置含义有所不同：</p><ul><li>在构造器中代表正在初始化的对象</li><li>在方法中代码调用该方法的对象</li></ul><p>因此 static 方法中不能出现 this，因为 static 的方法属于类，是通过类去调用，此时 this 代表了类，违背了 this 代表的为一个对像的前提。</p><p>同时 static 方法不可调用非 static 变量和方法也是基于这个原因，因为类中的变量和方法存在隐式的 this 引用，即为 this 作为调用者必须是一个对象。</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法名相同，而参数列表不同的现象称为方法重载。</p><ul><li>为什么返回值不作为方法重载的区分标准？</li></ul><p><strong>Java 调用方法时可以忽略返回值</strong>，如果将返回值作为重载的标准，那么存在以下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int method();</span><br><span class="line">void method()</span><br><span class="line"></span><br><span class="line">void test()&#123;</span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 Java 系统将不能分辨出 test 方法中调用的 method() 是具体哪一个方法。</p><h3 id="变量及其运行机制"><a href="#变量及其运行机制" class="headerlink" title="变量及其运行机制"></a>变量及其运行机制</h3><p>成员变量：</p><ol><li>类变量：从类的准备阶段开始存在，到系统完全销毁这个类。</li><li>实例变量：从实例的创建始存在，到系统完全销毁这个实例。</li></ol><p>局部变量：</p><ol><li>形参</li><li>方法内局部变量</li><li>代码块中局部变量</li></ol><p>局部变量只要离开了相应的代码块(方法、代码块)，局部变量就会被销毁。</p><h3 id="成员变量的初始化和内存中的运行机制"><a href="#成员变量的初始化和内存中的运行机制" class="headerlink" title="成员变量的初始化和内存中的运行机制"></a>成员变量的初始化和内存中的运行机制</h3><p>JVM 加载类经历以下几个阶段：</p><ol><li>类加载</li><li>类验证</li><li>类准备</li><li>类解析</li><li>类初始化</li></ol><p>当系统加载类或创建类实例时，系统会自动为成员变量分配内存，并赋初值。<br>Person 类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private static int phone;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Person 类使用</span><br><span class="line">Person a = new Person();</span><br><span class="line">a.phone = 110;</span><br><span class="line">a.name = &quot;mike&quot;;</span><br></pre></td></tr></table></figure></p><p>当执行 <code>Person a = new Person();</code> 时，如果程序中第一次使用 Person 类， JVM 将会加载 Person 类，并初始化这个类。在类的准备阶段，<strong>JVM 将会该类的类变量分配内存空间并初始化</strong>。当 Person 类初始化完成后，系统中的内存情况如下图：</p><p><img src="/images/2019_03_06_1.jpg" alt="类初始化"></p><p>当类完成初始化后，JVM 将在 堆内存 中为 Person 类分配一块内存(JVM 会为Person类创建一个对象)，这块内存区包含了类变量 phone 的内存，并初始化它的初值。</p><p>接着，系统创建一个 Person 对象，并把这个对象赋值给 p 变量， Person 对象中包含了实例变量–name，<strong>实例变量在创建实例时分配内存空间并赋初值</strong>。JVM 创建了第一个 Person 对象后，内存分配情况如下：</p><p><img src="/images/2019_03_06_2.jpg" alt="实例变量初始化"></p><p>当再次创建 Person 对象时，不需要再对 Person 类初始化。</p><p>对类变量和实例变量赋值时,内存分配情况如下：</p><p><img src="/images/2019_03_06_3.jpg" alt="赋值"></p><p>其中，类变量为所有实例共有，每个实例都有权对其进行更改。</p><h3 id="局部变量的初始化和内存中的运行机制"><a href="#局部变量的初始化和内存中的运行机制" class="headerlink" title="局部变量的初始化和内存中的运行机制"></a>局部变量的初始化和内存中的运行机制</h3><p>系统不会为局部变量进行初始化，所以局部变量必须手动初始化。</p><p>与成员变量不同，局部变量的分配内存为所在的方法栈区，如果局部变量时基本数据类型，会直接存在方法栈中;如果为引用变量，则存放引用地址，通过该引用地址指向实际引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void test(int a,Person p)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test 方法栈中内存分配情况如下：</p><p><img src="/images/2019_03_06_4.jpg" alt="局部变量"></p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>private:类私有</li><li>default:同包可访问</li><li>protected:同包及子类可访问</li><li>public:所有类可访问</li></ul><h3 id="构造器与成员变量初始化"><a href="#构造器与成员变量初始化" class="headerlink" title="构造器与成员变量初始化"></a>构造器与成员变量初始化</h3><p>我们知道在创建一个对象时，系统会为这个对象的实例变量进行默认初始化，根据数据类型的不同初始值为：0、falase、null。如果想要改变默认初始化，想让系统创建对象时就位对象的实例变量显示指定初始值，可以通过构造器来实现。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系中，子类和父类拥有相同的实例变量时的内存模型：</p><p><img src="" alt="图"></p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Java 引用变量有两个类型：<strong>编译时类型</strong> 和 <strong>运行时类型</strong>。编译时类型是由声明该变量时使用的类型决定，运行时类型是由实际赋给该变量的对象决定。</p><p>当编译时类型和运行时类型不一致，就可能发生所谓的 <strong>多态</strong>。</p><p>引用变量在编译时只能调用编译时类型所拥有的方法，运行时在可以执行其运行时类型所具有的方法。因此，在编写 Java 代码是，引用变量只能调用声明该变量时所用的类(编译时类型)中的方法，例如 <code>Object person = new Person();</code> ,<code>person</code> 只能调用 <code>Object</code> 类中的方法,不能调用 Person 中的方法。</p><p>如果想要编译时类型调用运行时类型的方法，可以对引用变量进行强转型。</p><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><p>继承是实现类复用的重要手段，但是继承带来了一个坏处：破坏了封装性，即子类可以任意的访问父类的实例变量、重新父类的方法。</p><p>为了保证父类良好的封装性不被子类任意更改，设计父类应遵循如下规则：</p><ol><li>尽量隐藏父类的内部数据，使用 private 修饰;</li><li>不要让子类任意访问和修改方法。辅助方法使用 private 修饰；父类中可以被外界访问但是不可以被子类重新的方法使用 public final 修饰；希望被子类重写的方法使用 protected 修饰。</li><li>尽量不要在父构造器中调用被子类重新的方法。</li></ol><p>针对第 3 条，特殊说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public A()&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    private String des;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        sout(&quot;B&quot; + des.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">B b = new B();</span><br></pre></td></tr></table></figure><p>系统在创建 B 实例时，会首先执行父类的构造器，在父构造器中调用了被父类重写的方法，此时执行的方法为子类的重写后的方法。此时 B 的实例变量 des 还没有初始化为 null，调用会发生空指针异常。</p><p>产生此现象的原因我猜大致是因为这样：</p><blockquote><p>这个问题又牵涉到 this 引用的问题，在这个问题中我们很明确的表明当 this 出现在构造器中表示正在实例化的对象, A 构造器中 test() 方法的调用中隐藏了默认的 this 引用，所以此时 this 代表被实例化的 B 的对象，所以 A 中 test() 执行 B 中的 test() 方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;对象的三大特征&quot;&gt;&lt;a href=&quot;#对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;对象的三大特征&quot;&gt;&lt;/a&gt;对象的三大特征&lt;/h3&gt;&lt;p&gt;对象的三种基本特征:继承、封装、多态。&lt;/p&gt;
&lt;p&gt;Java 语言为纯粹的面向对象的程序编程语言，主要表现为 Java 完全支持对象的三大基本特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;： 将对象的实现细节隐藏起来，然后通过一些公用方法暴露该对象的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;：子类继承父类，子类作为一种特殊的父类，将直接获得父类的属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;：子类对象可以直接赋给父类变量，但在运行时依然表现出子类的行为特征，这意味着同一个类型的引用对象在执行同一个方法时，可能表现出多种行为特征。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java 继承，对象，类初始化" scheme="https://mllgy.github.io/tags/Java-%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于 Java 异常机制的补充</title>
    <link href="https://mllgy.github.io/2019/01/26/%E5%85%B3%E4%BA%8E-Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%85%85/"/>
    <id>https://mllgy.github.io/2019/01/26/关于-Java-异常机制的补充/</id>
    <published>2019-01-26T10:44:41.000Z</published>
    <updated>2019-01-26T10:51:14.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"><a href="#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？" class="headerlink" title="为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？"></a>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</h3><p>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</p><h3 id="如何正确的关闭资源？"><a href="#如何正确的关闭资源？" class="headerlink" title="如何正确的关闭资源？"></a>如何正确的关闭资源？</h3><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="finally-与-return-的关系"><a href="#finally-与-return-的关系" class="headerlink" title="finally 与 return 的关系"></a>finally 与 return 的关系</h3><p>阐述两者的关系，我们主要关注 return 关键字的位置，为了表达的更形象，看下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int count = 5;</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot;);</span><br><span class="line">            System.out.println(&quot;finally 语句执行 &quot; + count);</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally 语句执行</span><br><span class="line">finally 语句执行 6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>当 Java 程序执行 try/catch 中有 return 语句，return 语句会导致方法立即结束。但是系统执行完 return 语句不会马上结束该方法，而是查看在这个异常处理的流程中是否存在 finally 语句，如果存在 finally 语句，那么需要执行 finally 语句。如果 finally 语句中有 return 语句，那么会更新 try/catch 语句 return 返回的值，但是需要注意的是因为该方法已经结束，此处的 return 不会像无法返回到 try/catch 中执行代码(因为 try/catch 之后才会来到 finally 语句)。具体可以参看上例自行揣摩其中含义。</p><p>在举一个例子，我们在 catch 中执行 return 语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static int test()&#123;</span><br><span class="line">        int[] counts = new int[]&#123;5,3&#125;;</span><br><span class="line">        int count = counts[0];</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            int error = counts[2];</span><br><span class="line">            count++;</span><br><span class="line">            return count;</span><br><span class="line">        &#125;catch (ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            System.out.println(&quot;catch 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(&quot;finally 语句执行&quot; + count);</span><br><span class="line">            return count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int  a = test();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印日志为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch 语句执行5</span><br><span class="line">finally 语句执行6</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>针对该例不做阐述。</p><h3 id="关于异常的捕获"><a href="#关于异常的捕获" class="headerlink" title="关于异常的捕获"></a>关于异常的捕获</h3><p>当 Java 运行时环境接收到异常对象时，系统会根据catch(TypeException e) 来决定使用哪一个异常分支来处理程序引发的异常。程序进入负责异常处理的 catch 块时，系统生成的异常对象 ex 将会被传给 cathc(TypeException ex) 的异常形参，从而可以在 catch 块中访问异常信息。</p><h3 id="关于异常捕获的顺序"><a href="#关于异常捕获的顺序" class="headerlink" title="关于异常捕获的顺序"></a>关于异常捕获的顺序</h3><p>捕获父类异常的 catch 块在捕获子类异常的 catch 块后，即先处理小异常，再处理大异常。</p><h3 id="使用异常机制的注意点"><a href="#使用异常机制的注意点" class="headerlink" title="使用异常机制的注意点"></a>使用异常机制的注意点</h3><ol><li>不要使用 try/catch 来控制流向。</li><li>精准捕获可能抛出的异常，不要乱抛异常，不要放大异常的范围。</li><li>不要在 finally语句中递归调用可能引起异常的方法，因为这将导致该方法的议程不能被正常抛出，甚至StackOverflowError 也不能终止程序，只能强制终止 java 进程才可以终止程序运行。</li><li>在子类复写时，子类方法只能抛出父类方法声明抛出的异常的子类。</li></ol><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/22581959.html" target="_blank" rel="noopener">疯狂 Java 系列书籍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;a href=&quot;#为什么-Java-中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot; class=&quot;headerlink&quot; title=&quot;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&quot;&gt;&lt;/a&gt;为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？&lt;/h3&gt;&lt;p&gt;JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。&lt;/p&gt;
&lt;h3 id=&quot;如何正确的关闭资源？&quot;&gt;&lt;a href=&quot;#如何正确的关闭资源？&quot; class=&quot;headerlink&quot; title=&quot;如何正确的关闭资源？&quot;&gt;&lt;/a&gt;如何正确的关闭资源？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 finall 中执行资源关闭操作。&lt;/li&gt;
&lt;li&gt;保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。&lt;/li&gt;
&lt;li&gt;为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Exception" scheme="https://mllgy.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常机制浅析</title>
    <link href="https://mllgy.github.io/2019/01/26/Java-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/"/>
    <id>https://mllgy.github.io/2019/01/26/Java-异常机制浅析/</id>
    <published>2019-01-26T10:23:46.000Z</published>
    <updated>2019-01-26T11:08:34.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p>所有的异常都是继承于 Throwable</p><p><img src="/images/2019_01_26.jpg" alt="运行时内存区域"></p><p> Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。</p><a id="more"></a><p>关于 Exception 派生的两个分支的依据：</p><ul><li><p><strong>RuntimeException: 由程序错误导致导致的异常。</strong></p></li><li><p><strong>其他 Exception： 程序本身没问题，但是由于像 IO 错误这类问题导致的异常属于其他异常。</strong></p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RuntimeException 的几种异常：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>ClassCastException:</strong> 类变换异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IllegalArgumentException:</strong> 传递非法参数异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>IndexOutOfBoundsException:</strong> 索引越界异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NoSuchElementException:</strong>  表明枚举中没有更多的元素</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>NullPointerException:</strong> 空指针异常</p><p>对于这些异常，我们可以选择进行处理(捕获、抛出)，也可以选择不处理。如果我们不处理的话，那么异常会交给 Java 虚拟机，不断的向上层传递，那么在不同条件下导致的情况是  <strong>当前运行的线程中断或程序中断</strong>。</p><p>一般情况下我们对这类情况是不作处理的，如上文所说 <strong>“RuntimeException: 由程序错误导致导致的异常”</strong>，我们在写代码时应该尽力避免这种异常，而不应该通过 try/catch 、抛出等操作来隐藏异常。</p><p><strong>如果出现了 RuntimeException 异常，那么就一定是你的问题。</strong></p><p><strong>不是派生于 RuntimeException 的异常：</strong></p><ol><li>在文件后面读取数据</li><li>打开一个不存在的文件</li><li>根据给定的字符串去查找 Class 对象，但是这个对象表示的类不存在</li></ol><p><strong>对于这种异常，Java 编译器强制要求对这类异常进行 try/catch 并处理 或将异常抛出，否则程序就不能编译通过。</strong></p><h4 id="声明受查异常"><a href="#声明受查异常" class="headerlink" title="声明受查异常"></a>声明受查异常</h4><p>派生于 Error 或 RuntimeException 类所有的异常称为 <strong>非受查异常</strong>，其他所有的异常称为 <strong>受查异常</strong>。</p><p><strong>编译器将检查是否为所有的受查异常提供了异常处理器。</strong></p><p><strong>一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什错误</strong>,我们需要在声明方法的时候同时声明该方法可能会抛出的异常。<br>如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public FileIputStream(String name) throw FileNotFoundException;</span><br></pre></td></tr></table></figure><p>自己在编写方法时，不可能将所有可能抛出的异常声明，下面的 4 种情况应该抛出异常：</p><ol><li>调用一个抛出异常的方法</li><li>程序运行中发现错误，并且利用 throw 语句抛出一个受查异常</li><li>程序出现错误，例如一个数据越界的非受查异常</li><li>Java 虚拟机或运行时库出现内部错误</li></ol><p>如果是前两种异常，则必须告诉调用这个方法的程序员有可能抛出的异常，因为一个抛出异常的方法都有可能是死亡陷阱。</p><p>对于一个有可能被其他人使用的 Java 方法，要根据 Java 异常规范，在方法的首部声明可能会抛出的异常。</p><p>我们不需要声明从 Error 继承的错误，不声明继承于 RuntimeException 的非受查异常。因为这些运行时错误是在我们的控制范围内，我们应该尽力避免这些错误，而不是在可能异常的位置抛出异常。</p><p> 对于一个方法必须声明所有可能抛出的受查异常，而非受查异常要么是不可控制的，要么就必须避免发生。如果方法没有声明所有可能发生的受查异常，编译器就会发出一个错误消息。</p><h4 id="如何抛出异常"><a href="#如何抛出异常" class="headerlink" title="如何抛出异常"></a>如何抛出异常</h4><p><strong>首先要决定抛出什么类型的异常</strong>。</p><p>对于一个已经存在的异常类，抛出异常有一下几个步骤：</p><ol><li>找到一个合适的类。</li><li>创建这个类的一个对象。</li><li>将对象抛出。</li></ol><p>以下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String readDate(Scanner in) throw EOFException&#123;//声明这个方法可能会抛出的异常</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    if(..)&#123;</span><br><span class="line">        throw new EOFException();//抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一旦方法抛出了异常，这个方法就不可能返回到调用者中，不必为返回的默认值或错误代码担忧。</strong></p><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>定义一个继承于 Exception 的子类，习惯上，这个类应该包含两个构造器，一个默认构造器，另一个带有详细描述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CustomException extends IOException&#123;</span><br><span class="line">    public CustomException()&#123;&#125;</span><br><span class="line">    public CustomException(String description)&#123;</span><br><span class="line">        super(description);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>上面的抛出异常中，我们只需将异常抛出不用理睬了，同时有些异常是需要我们捕获的。</p><h4 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>在异常发生的位置如果没有进行捕获操作，那么程序就会终止执行，并且在控制台打印出异常信息和堆栈内容。</p><p>捕获异常的方法：</p><ol><li>try/catch 语句</li><li>方法首部声明异常，抛给方法调用处理</li></ol><ul><li>try/catch</li></ul><p>我们使用 try/catch 语句，具体语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;catch(ExceptionType e)&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 语句中出现 catch 中出现的异常，那么程序将执行 catch 子句中的代码。</p><ul><li>抛出异常给调用者</li></ul><p>除了自己通过 try/catch 来处理异常，我们有没有更好的处理方式？答案是抛给调用者，很明显嘛，谁使用谁负责，让该方法的调用者去处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void read(String filename) throw IOException&#123;</span><br><span class="line">    InputStream in = new InputStream(filename);</span><br><span class="line">    int b;</span><br><span class="line">    while((in.read()) != -1)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器严格执行 throw 说明符，如果调用了一个受查异常的方法，就必须对它进行处理，或者继续传递。</p><ul><li>如果选择 try/catch 处理还是继续传递呢？</li></ul><p><strong>通常，应该捕获那些知道如何处理的异常，而将那些不知道怎么处理的异常继续传递。</strong></p><p>为具体说明，看一个例子：</p><p><strong>抛出异常</strong></p><p>如果传递一个异常，那么应该在方法的首部使用 throw 声明抛出的异常，告诉方法的调用者这个方法可能会抛出的一个异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename) throws FileNotFoundException &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在定义 read() 方法时，针对方法体中的 FileNotFoundException 异常我们不知道该怎么处理，怎么办？秉持着谁调用谁处理的原则 ，将该异常抛出，即如代码所示在方法头中 throws FileNotFoundException。在调用该方法时对异常进行处理，则有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        try &#123;</span><br><span class="line">            readFile.read(&quot;&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同样，如果我们还是不知道该如何处理该异常，也可以将异常继续抛出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() throws FileNotFoundException &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>处理异常</strong></p><p>如果我们在定义时方法体知道如何处理该异常，那么我们可以在定义方法处对异常进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ReadFile &#123;</span><br><span class="line">    public void read(String filename)  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们正常调用该方法就可以了， 不再需要对该方法中的异常进行任何处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void showTest() &#123;</span><br><span class="line">        ReadFile readFile = new ReadFile();</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在类继承关系中，如果超类中的方法没有抛出异常，而子类重写了这个方法，那么这个方法必须捕获方法代码出现的每一个受查异常。在子类中不允许出现 throw 说明符中出现超过超类方法声明的异常范围。</p><h4 id="再次抛出异常和异常链"><a href="#再次抛出异常和异常链" class="headerlink" title="再次抛出异常和异常链"></a>再次抛出异常和异常链</h4><p><strong>可以在 catch 字句中抛出一个异常，这样的目的是改变异常的类型。</strong> 原来抛出的异常为 catch(异常) 中的异常，现在在 catch 语句中抛出了一个新的异常，那么最终异常类型为新异常。</p><p>场景描述：</p><p>如果开发一个供其他程序员使用的子系统，那么用于表示子系统故障的异常类型可能有多种。 ServletException 就是这样一个异常的例子，执行servlet 的代码可能不想知道发生错误的细节原因，但是希望知道 servlet 是否有问题。</p><p>下面是一个捕获异常将它再次抛出的基本方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    throw new ServletException(&quot;database error: &quot; + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还是强烈推荐通过包装技术，<strong>将原始异常设置为新异常的原因</strong>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    acess the database</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">    Throwable se = new ServletException(&quot;database error&quot;);</span><br><span class="line">    se.initCause(e);</span><br><span class="line">    throw se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当我们捕获异常时，可以重新获取原始异常，不会丢弃原始异常的细节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Throwable e = se.getCause();</span><br></pre></td></tr></table></figure></p><p>一个完整的例子，帮助理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">## Main.java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    showTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void showTest() &#123;</span><br><span class="line">    ReadFile readFile = new ReadFile();</span><br><span class="line">    try &#123;</span><br><span class="line">        readFile.read(&quot;&quot;);</span><br><span class="line">    &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## ReadFile.java    </span><br><span class="line">public void read(String filename) throws Throwable &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream inputStream = new FileInputStream(filename);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        Throwable throwable = new CustomFileExpection(&quot;在 catch中再次抛出了异常&quot;);</span><br><span class="line">        throwable.initCause(e);</span><br><span class="line">        throw throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finally-字句"><a href="#finally-字句" class="headerlink" title="finally 字句"></a>finally 字句</h4><p>应用场景：<br>在 finally 语句中释放资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = new InputStream(...);</span><br><span class="line">try&#123;</span><br><span class="line">    // 1</span><br><span class="line">    // code that migth throw exception</span><br><span class="line">    //2</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    //3</span><br><span class="line">    show error message</span><br><span class="line">    //4</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    //5</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line">//6</span><br></pre></td></tr></table></figure><ol><li>代码没有抛出异常。代码会执行 1、2、5、6</li><li>抛出一个在 catch 子句中捕获的异常。try 语句中，程序发生异常，跳过剩余代码，执行 catch 子句中代码。<ol><li>如果 catch 中子句没有抛出异常，那么执行 1、3、4、5、6。</li><li>如果 catch 中子句抛出一个异常，异常将被抛回给这个方法的调用者，执行 1、3、5.</li></ol></li><li>代码抛出了一个不是 catch 捕获的异常，这种情况下，程序执行 try 语句中所有的语句，直到有异常被抛出为止，代码执行 1、5。</li></ol><p>在日常代码中，<strong>强烈建议解耦 try/catch 和 try/finally</strong>，这样可以提高代码的清晰度，上面的代码可以这样书写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in ...;</span><br><span class="line">try&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        code that might throw exception</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(IOException e)&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存 try 代码的职责是关闭输入流，外层的 try 语句的职责就是报告出现的错误。</p><p>面临的问题：<br><strong>finally 语句也可能抛出异常，这时会覆盖原来的异常。</strong></p><h4 id="带资源的-try-语句"><a href="#带资源的-try-语句" class="headerlink" title="带资源的 try 语句"></a>带资源的 try 语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open a resource</span><br><span class="line">try&#123;</span><br><span class="line">    work with the resource</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    close the resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如资源属于一个实现了 AutoCloseable/Closeable 的类，Java 7 提供了一个有用的快捷方式，AutoCloseable 与一个接口方法：</p><p><code>void close() throw Exception</code></p><p>Closeable 接口的 close() 方法是一个 抛出 IOException 的方法。</p><p>带资源的 try 语句的最简形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try(Resource res = ...;)&#123;</span><br><span class="line">    work with resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 块退出时或者存在一个异常时，<strong>会自动调用 res.close()</strong>，就好像使用了 finally 块一样。 </p><p>可以指定多个资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try(Scanner in = new Scanner(new InputStream(&quot;/usr/share/dict/words&quot;),&quot;UTF-8&quot;);</span><br><span class="line">PrintWriter out = new PrintWrite(&quot;out.txt&quot;);)&#123;</span><br><span class="line">    while(in.hasNext())&#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不论这个块怎么退出， in 和 out 都会关闭。</p><p>这种处理异常的方式，就避免了上文所说的在 finally 语句中抛出的异常会覆盖 try 语句抛出异常的情况。</p><p>如果此时在 finally 中 close() 也会抛出异常，那么原来在 try 子句中的异常会被重新抛出，而 close 方法抛出的异常会被抑制，这些异常会被抑制，并由 addSuppressed() 方法增加到原来的异常，可以通过 getSuppressed() 获取这个被抑制的异常。</p><p><strong>在我们查看一些开源库代码时，这种实现 Closeable 接口的方案随处可见，其目的就是在相应的代码执行完毕后，关闭资源。</strong></p><h4 id="分析堆栈轨迹元素"><a href="#分析堆栈轨迹元素" class="headerlink" title="分析堆栈轨迹元素"></a>分析堆栈轨迹元素</h4><p>堆栈轨迹 (stack trace) 是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。当 Java 程序正常终止，而没有捕获异常时，这个列表就会显示出来。</p><ol><li><p>可以调用 Throwable 类的 printStackTrace 方法访问堆栈轨迹的文本描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StringWriter out = new StringWriter();</span><br><span class="line">t.printStackTrace(new PrintWriter(out));</span><br><span class="line">String des = out.toString();</span><br></pre></td></tr></table></figure></li><li><p>一种更为灵活的方法是使用 getStackTrace 方法，他会得到 StackTraceElement 对象的一个数组，可以在你的程序中分析这个对象数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable t = new Throwable();</span><br><span class="line">StackTraceElement[] frames = t.getStaceTrace();</span><br><span class="line">for(StackTraceElement frame: frames)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>StackTraceElement 类含有能够获得文件名和当前执行的代码行号的方法，同时还含有获得类名和方法名的方法。</p><p>静态的Thread.getAllStackTrace() 方法，它可以产生所有线程的堆栈轨迹，下面给出这个方法的绝唱方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Thread,StackTraceElement[]&gt; map = Thread.getAllStackTrace();</span><br><span class="line">for(Thread t : map.keySet())&#123;</span><br><span class="line">    StackTraceElement[] frames = map.get(t);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以上方法我们可以自定义 Android 的 LogCat 的打印信息，具体代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static String generateTag() &#123;</span><br><span class="line">       StackTraceElement caller = new Throwable().getStackTrace()[2];</span><br><span class="line">       String tag = &quot;%s.%s(L:%d)&quot;;</span><br><span class="line">       String callerClazzName = caller.getClassName();</span><br><span class="line">       callerClazzName = callerClazzName.substring(callerClazzName.lastIndexOf(&quot;.&quot;) + 1);</span><br><span class="line">       tag = String.format(Locale.CHINA, tag, callerClazzName, caller.getMethodName(),</span><br><span class="line">               caller.getLineNumber());</span><br><span class="line">       String customTagPrefix = &quot;h_log&quot;;</span><br><span class="line">       tag = TextUtils.isEmpty(customTagPrefix) ? tag : customTagPrefix + &quot;:&quot; + tag;</span><br><span class="line">       return tag;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void d(Object content) &#123;</span><br><span class="line">       if (!isDebug||content==null) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       String tag = generateTag();</span><br><span class="line">       Log.d(tag, content.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="使用异常机制的技巧"><a href="#使用异常机制的技巧" class="headerlink" title="使用异常机制的技巧"></a>使用异常机制的技巧</h3><ul><li>异常处理不能代替简单的测试</li></ul><p>捕获异常的时间较代码此时花的时间较长，只有在异常情况下使用异常机制。</p><ul><li><p>不过过分细化异常</p></li><li><p>利用异常层次结构</p></li></ul><p>根据具体代码寻找更适合的子类或创建自己的异常子类。</p><ul><li>不要压制异常</li></ul><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>在执行以下代码时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int = a/b;</span><br></pre></td></tr></table></figure><p>那么我们需要确认的是，a、b 为数值，并且 b 的值不为 0，我们可以做如下操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(b=0) throw new IllegalAraumentException(&quot;b=0&quot;);</span><br></pre></td></tr></table></figure></p><p>但是以上代码会一直保存在代码中，测试工作完毕后也不会自动删除，如果代码中含有大量的这种检查，程序运行起来就会变慢。</p><p><strong>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会自动的移走。</strong></p><p>Java 引入了关键字 assert，有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：</span><br></pre></td></tr></table></figure><p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件：表达式;</span><br></pre></td></tr></table></figure></p><p>这两种形式都会对条件进行检测，如果结果为 false，则抛出一个 AssertionError 异常。在第二种形式中，表达式将会被传入 AssertionError 的构造器，并转换成一个消息字符串。</p><h4 id="启用和禁用断言"><a href="#启用和禁用断言" class="headerlink" title="启用和禁用断言"></a>启用和禁用断言</h4><p>启动或禁用断言是类加载器的功能，当断言被禁用时，类加载器将跳过断言代码。</p><ul><li>启用断言</li></ul><p><code>java -enablessertions(-ea) MyApp</code></p><p>在某个类或整个包下使用断言：</p><p><code>java -ea:MyClass -ea:com.xx.xxx MyApp</code></p><ul><li>禁用断言</li></ul><p><code>java -disablessertions(-da) MyApp</code></p><p>有些类不是由类加载器加载，而是有直接虚拟机加载。对于不是由类加载器的系统类可是使用 -enablesystemssertions/-esa 启用断言。</p><h4 id="使用断言完成代码检查"><a href="#使用断言完成代码检查" class="headerlink" title="使用断言完成代码检查"></a>使用断言完成代码检查</h4><p>Java 中有 3 种处理系统错误的机制：</p><ol><li>抛出一个异常</li><li>日志</li><li>使用断言</li></ol><p>选择断言记住以下几点：</p><ul><li>断言失败是致命的、不可恢复的错误</li><li>断言只用于开发和测试阶段</li></ul><p>所以不应该使用断言向程序的其他部分通告发生了可恢复性的错误，断言只应该用于在测试阶段确定程序内部的错误位置。</p><p><strong>前置条件</strong></p><p>在声明一些方法时，往往针对该方法的使用有一定的说明，有些方法往往定义一些 <strong>前置条件</strong> 来进一步指导方法的使用，如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param a array to be sorted (must not be null)</span><br><span class="line">*/</span><br><span class="line">static void sort(int[] a, int fromIndex, int toIndex)</span><br></pre></td></tr></table></figure></p><p>那么 对数组的限制就是定义了一个前置条件，在使用这个方法时就不允许用 null 数组调用这个方法，并在这个方法的开头使用以下断言：<br><code>assert a != null;</code></p><h3 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h3><p>我们在代码添加 <code>System.out.println()</code> 方法来调用程序员观察具体的运行过程和结果，记录日志 API 就是为了这种情况下而设计的。记录日志 API 的有点：<br>1.可以轻易的取消全部日志记录。</p><ol start="2"><li>可以很简单的禁止日志的输出。</li><li>可进行条件过滤。</li><li>日志记录可以被定向到不同的处理器，用于控制台输出，用于存储在文件中等。</li><li></li></ol><h4 id="关于异常的补充"><a href="#关于异常的补充" class="headerlink" title="关于异常的补充"></a>关于异常的补充</h4><ul><li>为什么 Java 中打开物理资源，如磁盘文件、网络连接、数据库连接等，必须需要显式的关闭？</li></ul><p><strong>JVM 提供的垃圾回收机制只负责堆内存分配出来的内存，打开的物理资源，GC 是不进行回收的，所以需要手动的关闭。</strong></p><ul><li>如何正确的关闭资源？</li></ul><ol><li>在 finall 中执行资源关闭操作。</li><li>保证关闭资源前资源不为 null,因为存在资源初始化前就发生异常情况，所以在 finally 语句中对资源对象进行非空判断。</li><li>为每个资源关闭操作执行 try/catch 操作，因为在资源关闭过程中也有可能发生异常，导致程序中断。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        FileOutputStream outputStream = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(&quot;srcPath&quot;);</span><br><span class="line">            outputStream = new FileOutputStream(&quot;destPath&quot;);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;//操作1</span><br><span class="line">            if(inputStream != null)&#123;//操作2</span><br><span class="line">                try &#123;//操作3</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(outputStream != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="http://product.dangdang.com/24035306.html" target="_blank" rel="noopener">Java 核心知识 卷1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;处理错误&quot;&gt;&lt;a href=&quot;#处理错误&quot; class=&quot;headerlink&quot; title=&quot;处理错误&quot;&gt;&lt;/a&gt;处理错误&lt;/h3&gt;&lt;h4 id=&quot;异常分类&quot;&gt;&lt;a href=&quot;#异常分类&quot; class=&quot;headerlink&quot; title=&quot;异常分类&quot;&gt;&lt;/a&gt;异常分类&lt;/h4&gt;&lt;p&gt;所有的异常都是继承于 Throwable&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_26.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;p&gt; Error 类层次结构描述了 Java 运行时内部的错误以及资源耗尽错误，应用程序不应该抛出这种类型的对象，而是让程序来处理，一般情况下程序会直接中断，并报出错误以及堆栈信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Exception" scheme="https://mllgy.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>RxJava Transformer</title>
    <link href="https://mllgy.github.io/2019/01/17/RxJava%20%E4%BD%BF%E7%94%A8%20Transformer%20%E8%BF%9B%E8%A1%8C%E5%8F%98%E6%8D%A2/"/>
    <id>https://mllgy.github.io/2019/01/17/RxJava 使用 Transformer 进行变换/</id>
    <published>2019-01-17T09:26:13.000Z</published>
    <updated>2019-01-17T10:51:43.986Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x81-Observable、Observer-线程切换"><a href="#0x81-Observable、Observer-线程切换" class="headerlink" title="0x81 Observable、Observer 线程切换"></a>0x81 Observable、Observer 线程切换</h3><p>在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。</p><h3 id="0x82-Transformer-实现对调用链的处理"><a href="#0x82-Transformer-实现对调用链的处理" class="headerlink" title="0x82 Transformer 实现对调用链的处理"></a>0x82 Transformer 实现对调用链的处理</h3><p>我们可能有以下实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">abstract class SchedulerTransformer&lt;T&gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), </span><br><span class="line">                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&lt;T, T&gt;,</span><br><span class="line">        SingleTransformer&lt;T, T&gt;,</span><br><span class="line">        MaybeTransformer&lt;T, T&gt;,</span><br><span class="line">        CompletableTransformer,</span><br><span class="line">        FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Completable): CompletableSource &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Flowable&lt;T&gt;): Publisher&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Maybe&lt;T&gt;): MaybeSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Observable&lt;T&gt;): ObservableSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun apply(upstream: Single&lt;T&gt;): SingleSource&lt;T&gt; &#123;</span><br><span class="line">        return upstream.subscribeOn(subscribeOnScheduler)</span><br><span class="line">                .observeOn(observeOnScheduler)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在具体业务中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(ObservableOnSubscribe&lt;Int&gt; &#123; emitter -&gt; emitter.onNext(1) &#125;).compose(SchedulerTransformer(Schedulers.io(),AndroidSchedulers.mainThread())).subscribe(...);</span><br></pre></td></tr></table></figure><p></p><h3 id="0x83-RxLifeCycle2-中的实现"><a href="#0x83-RxLifeCycle2-中的实现" class="headerlink" title="0x83 RxLifeCycle2 中的实现"></a>0x83 RxLifeCycle2 中的实现</h3><p>RxLifeCycle2 中使用相同的机制，在事件处理过程中对针对生命周期做出处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(ActivityEvent.DESTROY));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在activity的destroy中取消订阅,防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; activityLifecycle(RxAppCompatActivity activity, ActivityEvent event) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(activity.bindUntilEvent(event));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //手动设置在Fragment的destroy中取消订阅，防止内存泄漏</span><br><span class="line">   public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; fragmentLifecycle(RxFragment fragment) &#123;</span><br><span class="line">       return observable -&gt;</span><br><span class="line">               observable.compose(fragment.bindUntilEvent(FragmentEvent.DESTROY));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x84-在-Kotlin-中的实现"><a href="#0x84-在-Kotlin-中的实现" class="headerlink" title="0x84 在 Kotlin 中的实现"></a>0x84 在 Kotlin 中的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// SchedulersApply.kt</span><br><span class="line">fun &lt;T&gt; transformerSchedluer(): ObservableTransformer&lt;T, T&gt; =</span><br><span class="line">        ObservableTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) &#125;</span><br></pre></td></tr></table></figure><p>直接在调用链中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obserable..compose(transformerSchedluer2()).subscribe(....);</span><br></pre></td></tr></table></figure><h3 id="0x85-compose-操作符的功能"><a href="#0x85-compose-操作符的功能" class="headerlink" title="0x85 compose 操作符的功能"></a>0x85 compose 操作符的功能</h3><p>以上对 Observable 的变换最终插入调用链中，主要是因为 compose() 的作用。compose 操作符可以对调用链的原始 Observable 产生作用。</p><p>compose() 除了 实现上述对 Observable 进行变换外我们可以做一些其他处理，如 网络请求过程中 Dialog 的显示和隐藏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity, String message) &#123;</span><br><span class="line">      SpotsDialog dialog = DialogUtil.showLoadingDialog(activity, message);</span><br><span class="line">      return observable -&gt; observable</span><br><span class="line">              .doOnSubscribe(disposable -&gt; &#123;</span><br><span class="line">                  if (dialog != null) &#123;</span><br><span class="line">                      dialog.show();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .doOnComplete(() -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnError(throwable -&gt; DialogUtil.dismiss(dialog))</span><br><span class="line">              .doOnNext(t -&gt; DialogUtil.dismiss(dialog));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; loadingDialog(BaseActivity activity) &#123;</span><br><span class="line">      return loadingDialog(activity, &quot;&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x81-Observable、Observer-线程切换&quot;&gt;&lt;a href=&quot;#0x81-Observable、Observer-线程切换&quot; class=&quot;headerlink&quot; title=&quot;0x81 Observable、Observer 线程切换&quot;&gt;&lt;/a&gt;0x81 Observable、Observer 线程切换&lt;/h3&gt;&lt;p&gt;在 Retrofit 结合 RxJava 进行开发时，我们可以通过 subscribeOn()、observeOn() 分别设置被订阅者和订阅者的线程。在此场景中，我们要在应用中的所有请求中执行上面操作，这下重复工作就需要 Transformer 来优化。&lt;/p&gt;
&lt;h3 id=&quot;0x82-Transformer-实现对调用链的处理&quot;&gt;&lt;a href=&quot;#0x82-Transformer-实现对调用链的处理&quot; class=&quot;headerlink&quot; title=&quot;0x82 Transformer 实现对调用链的处理&quot;&gt;&lt;/a&gt;0x82 Transformer 实现对调用链的处理&lt;/h3&gt;&lt;p&gt;我们可能有以下实现方式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;abstract class SchedulerTransformer&amp;lt;T&amp;gt; protected constructor(private val subscribeOnScheduler: Scheduler = Schedulers.io(), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                      private val observeOnScheduler: Scheduler = AndroidSchedulers.mainThread()) : ObservableTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SingleTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MaybeTransformer&amp;lt;T, T&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CompletableTransformer,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FlowableTransformer&amp;lt;T, T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Completable): CompletableSource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Flowable&amp;lt;T&amp;gt;): Publisher&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Maybe&amp;lt;T&amp;gt;): MaybeSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Observable&amp;lt;T&amp;gt;): ObservableSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override fun apply(upstream: Single&amp;lt;T&amp;gt;): SingleSource&amp;lt;T&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return upstream.subscribeOn(subscribeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .observeOn(observeOnScheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="https://mllgy.github.io/tags/RxJava/"/>
    
      <category term="Transformer" scheme="https://mllgy.github.io/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 前奏篇:依赖注入概念</title>
    <link href="https://mllgy.github.io/2019/01/17/Dagger2%20%E5%89%8D%E5%A5%8F%E7%AF%87%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A6%82%E5%BF%B5/"/>
    <id>https://mllgy.github.io/2019/01/17/Dagger2 前奏篇：依赖注入概念/</id>
    <published>2019-01-17T06:57:56.000Z</published>
    <updated>2019-01-26T11:10:20.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、What-is-Dagger2"><a href="#一、What-is-Dagger2" class="headerlink" title="一、What is Dagger2 ?"></a>一、What is Dagger2 ?</h2><p> <a href="https://github.com/google/dagger" target="_blank" rel="noopener">Dagger2</a> 是一个谷歌开源的依赖注入(<code>Dependency Injection</code>)框架，简称<code>DI</code>。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 <strong>2</strong> 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。<br> 那么 <strong>什么是 <code>依赖注入</code></strong> 呢？</p><h3 id="1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））"><a href="#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））" class="headerlink" title="1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））"></a>1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））</h3><p>我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：</p><a id="more"></a><ol><li>在一个类的具体业务逻辑中，需要另一个类的实例进行相应的操作时，在传统的设计中，通常由调用者来创建被调用者的实例（一般的，我们通过 new 的方式创建），然而依赖注入的方式，创建被调用者不再由调用者创建实例，创建被调用者的实例的工作由 <code>IOC 容器</code> 来完成，然后<code>注入</code>到调用者。因此也被称为 <strong><code>依赖注入</code></strong>。</li><li><strong><code>依赖注入</code></strong> 就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。那么这个外部，到底指的是哪里，如果指的是另一个类，那么，另一个类内部就耦合了,这种拆东墙补西墙的做法我们是不推荐的。能不能有一种方式，将这些构造的对象放到一个容器中，具体需要哪个实例时，就从这个容器中取就行了。那么，类的实例和使用就不在有联系了，而是通过一个容器将他们联系起来。实现了解耦。</li></ol><p>个人理解：<strong>控制反转</strong> ,把自己新建实例对象的权利由交给了第三方工具或容器。<br>目标类将创建其他实例类的权利交给了第三方工具，也就是说，原来需要程序员把自主在目标类通过 new 的方式创建相关类的实例的权利，交给具体的业务（所谓的 IOC 容器） ，该容器在需要的时候通过它自己的方式创建该类的实例，即：<code>创建类实例权利的移交</code>。</p><h2 id="1-2-依赖注入的好处"><a href="#1-2-依赖注入的好处" class="headerlink" title="1.2 依赖注入的好处"></a>1.2 依赖注入的好处</h2><p><code>依赖注入</code>就是调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，<code>解决了各个类之间的耦合</code>。</p><p>通俗一点讲：将该对象的实例化交给其调用者，通过某种方式传入进来，这种模式就是依赖注入。常见的降低耦合的方式： </p><ul><li>构造方法注入。 </li><li>Setter方式注入。 </li><li>接口注入。</li></ul><h2 id="二、Why-Dagger2"><a href="#二、Why-Dagger2" class="headerlink" title="二、Why Dagger2"></a>二、Why Dagger2</h2><p>Dagger2 的原理是在<code>编译期生成相应的依赖注入代码</code>。这也是和其他依赖注入框架不同的地方，其他框架是在运行时期反射获取注解内容，影响了运行效率。</p><p><strong>栗子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MainClass &#123;</span><br><span class="line">    private  void main(String [] args)&#123;</span><br><span class="line">        John john = new John(&quot;john&quot;,12);</span><br><span class="line">        john.introduceSelf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面例子面临着一个问题，一旦 <code>John</code> 的创建方式（如构造参数）发生改变，那么你不但需要修改 <code>MainClass</code> 中创建<code>John</code>的代码，还要修改其他所有地方创建 <code>John</code> 的代码。如果我们使用了<code>Dagger2</code> 的话，就不需要管这些了，只需要在需要<code>John</code>的地方写下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Inject</span><br><span class="line">John john;</span><br></pre></td></tr></table></figure></p><h3 id="知识链接"><a href="#知识链接" class="headerlink" title="知识链接"></a>知识链接</h3><p><a href="https://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger 详解</a>、<br><a href="http://www.qingpingshan.com/rjbc/az/170191.html" target="_blank" rel="noopener">这就是Dagger2</a>、<br><a href="https://juejin.im/entry/589bd2cf8d6d8100585fd86c" target="_blank" rel="noopener">Dagger2 入门实践</a>、<br><a href="https://blog.csdn.net/lisdye2/article/details/51942511" target="_blank" rel="noopener">最简单的Dagger2入门教程</a>、<br><a href="https://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noopener">Android：dagger2让你爱不释手-终结篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、What-is-Dagger2&quot;&gt;&lt;a href=&quot;#一、What-is-Dagger2&quot; class=&quot;headerlink&quot; title=&quot;一、What is Dagger2 ?&quot;&gt;&lt;/a&gt;一、What is Dagger2 ?&lt;/h2&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/google/dagger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dagger2&lt;/a&gt; 是一个谷歌开源的依赖注入(&lt;code&gt;Dependency Injection&lt;/code&gt;)框架，简称&lt;code&gt;DI&lt;/code&gt;。Dagger2 是 Google 出的依赖注入框架。肯定有小伙伴疑问，为什么会有个 &lt;strong&gt;2&lt;/strong&gt; 呢。该框架是基于 Square 开发的 Dagger 基础上开发的。&lt;br&gt; 那么 &lt;strong&gt;什么是 &lt;code&gt;依赖注入&lt;/code&gt;&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;h3 id=&quot;1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot;&gt;&lt;a href=&quot;#1-1-何为依赖注入（控制反转-–-IOC（Inversion-of-Control））&quot; class=&quot;headerlink&quot; title=&quot;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&quot;&gt;&lt;/a&gt;1.1 何为依赖注入（控制反转 – IOC（Inversion of Control））&lt;/h3&gt;&lt;p&gt;我在网上搜索了相关内容，觉得以下解释相对容易理解（自定义后）：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dagger2" scheme="https://mllgy.github.io/tags/Dagger2/"/>
    
      <category term="DI" scheme="https://mllgy.github.io/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>OKhttp3 拦截器</title>
    <link href="https://mllgy.github.io/2019/01/17/OKhttp3%20%E7%B3%BB%E7%BB%9F%E6%8B%A6%E6%88%AA%E5%99%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://mllgy.github.io/2019/01/17/OKhttp3 系统拦截器简介/</id>
    <published>2019-01-17T06:31:26.000Z</published>
    <updated>2019-01-26T11:11:00.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>功能：实现重试、跟踪</p><p>实现原理： </p><p>while(true) 死循环的实现。</p><p>检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 <code>return Response</code>, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。</p><p>检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。</p><a id="more"></a><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>将用户构建的 Request 请求转换为能够进行网络访问的请求。</li></ul><p>在用户构建的 Request 的基础上 <strong>添加了许多的请求头</strong>，具体内容参看代码。</p><ul><li>将符合网络请求的 Request 进行网络请求。</li></ul><p>在责任链模式的过程中，在此拦截器的到响应 Response。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = chain.proceed(requestBuilder.build());</span><br></pre></td></tr></table></figure><ul><li>将请求回来的响应 Response 转化为用户可用的 Response。</li></ul><p>主要是根据响应是否对 Response 进行 gzip 压缩，具体是使用 Okio 的库对 Response 进行压缩，并返回 Response。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>功能： 实现缓存功能的拦截器</p><h4 id="设置启用缓存功能"><a href="#设置启用缓存功能" class="headerlink" title="设置启用缓存功能"></a>设置启用缓存功能</h4><p>在新建 OkhttpClient.Builder 的时候进行设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File sdcache = getExternalCacheDir();</span><br><span class="line">int cacheSize = 10 * 1024 * 1024;</span><br><span class="line">OkHttpClient.Builder builder = new OkHttpClient.Builder()</span><br><span class="line">    .cache(new Cache(sdcache.getAbsoluteFile(), cacheSize));</span><br><span class="line">mOkHttpClient = builder.build();</span><br></pre></td></tr></table></figure><p>其底层实现还是 大神 的 开源库 DiskLruCache，如下可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache(File directory, long maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存策略的基本流程"><a href="#缓存策略的基本流程" class="headerlink" title="缓存策略的基本流程"></a>缓存策略的基本流程</h4><h5 id="1-获取缓存响应"><a href="#1-获取缓存响应" class="headerlink" title="1. 获取缓存响应"></a>1. 获取缓存响应</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate = cache != null</span><br><span class="line">                ? cache.get(chain.request())</span><br><span class="line">                : null;//本地缓存</span><br></pre></td></tr></table></figure><h5 id="2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略"><a href="#2-根据-request-和-缓存响应-cacheCandidate-获取缓存策略" class="headerlink" title="2. 根据 request 和 缓存响应 cacheCandidate 获取缓存策略"></a>2. 根据 <strong>request</strong> 和 <strong>缓存响应 cacheCandidate</strong> 获取缓存策略</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br></pre></td></tr></table></figure><h5 id="3-获取响应缓存策略下的-request-和-response"><a href="#3-获取响应缓存策略下的-request-和-response" class="headerlink" title="3. 获取响应缓存策略下的 request 和 response"></a>3. 获取响应缓存策略下的 request 和 response</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//缓存策略中的请求</span><br><span class="line">Request networkRequest = strategy.networkRequest;</span><br><span class="line">//缓存策略中的响应</span><br><span class="line">Response cacheResponse = strategy.cacheResponse;</span><br></pre></td></tr></table></figure><h5 id="4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。"><a href="#4-根据响应缓存策略下的-request-和-response-分情况判断几种具体情况。" class="headerlink" title="4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。"></a>4. 根据响应缓存策略下的 request 和 response 分情况判断几种具体情况。</h5><h6 id="1-缓存响应不为空但是策略的响应为空，关闭缓存响应流"><a href="#1-缓存响应不为空但是策略的响应为空，关闭缓存响应流" class="headerlink" title="1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流"></a>1. 缓存响应不为空但是策略的响应为空，关闭缓存响应流</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。"><a href="#2-networkRequest-和-cacheResponse-皆为空，构建-504-的响应，-直接返回-。" class="headerlink" title="2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。"></a>2. networkRequest 和 cacheResponse 皆为空，构建 504 的响应，==直接返回==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(504)</span><br><span class="line">            .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-1L)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="3-networkRequest-为空，直接使用缓存，-返回缓存响应-。"><a href="#3-networkRequest-为空，直接使用缓存，-返回缓存响应-。" class="headerlink" title="3. networkRequest 为空，直接使用缓存，==返回缓存响应==。"></a>3. networkRequest 为空，直接使用缓存，==返回缓存响应==。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-获取网络请求的响应后，进行操作，此时也要分情况讨论。"><a href="#4-获取网络请求的响应后，进行操作，此时也要分情况讨论。" class="headerlink" title="4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。"></a>4. 获取网络请求的响应后，进行操作，此时也要分情况讨论。</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse = null;</span><br><span class="line">networkResponse = chain.proceed(networkRequest);</span><br></pre></td></tr></table></figure><ol><li>networkResponse 的响应码为 304，说明请求的资源未过期，构建 Response 对象，==直接反正该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (cacheResponse != null) &#123;</span><br><span class="line">    // 304 304 的标准解释是：Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（</span><br><span class="line">    // 一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。</span><br><span class="line">    // 服务器告诉客户，原来缓冲的文档还可以继续使用。</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        Response response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">     // Update the cache after combining headers but before stripping the</span><br><span class="line">    // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">    cache.trackConditionalCacheHit();</span><br><span class="line">    cache.update(cacheResponse, response);</span><br><span class="line">    return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据 构建 Response，==并直接返回该对象==。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Response response = networkResponse.newBuilder()</span><br><span class="line">    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">    .networkResponse(stripBody(networkResponse))</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure><h5 id="5-将-Response-写入缓存"><a href="#5-将-Response-写入缓存" class="headerlink" title="5. 将 Response 写入缓存"></a>5. 将 Response 写入缓存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (cache != null) &#123;</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    // Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">        return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">        &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上被标注为 ==== 的字样，说明执行 <code>return Response</code> 操作,直接返回响应，进入下一个拦截器的相关处理。</p></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>功能： Opens a connection to the target server and proceeds to the next interceptor。</p><p>打开一个面向指定服务器的连接，并且执行下一个拦截器。</p><h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>在这个拦截器中 HttpCodec 的作用是编码 Http 请求和解码 Http 响应。根据 HTTP版本不同分为 </p><ul><li>Http1Codec(HTTP/1.1) </li><li>Http2Codec(HTTP/2)</li></ul><p>打开连接的关键代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure><p>以下为具体代码调用链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamAllocation#newStream() </span><br><span class="line">--&gt; this#findHealthyConnection(..) </span><br><span class="line">--&gt;this#findHealthyConnection(..)//获得连接的顺序：存在的链接 、 连接池、新建一个连接</span><br><span class="line">--&gt;this#findConnection(...)</span><br><span class="line">--&gt;RealConnection#connect(...)// 连接并握手</span><br><span class="line">--&gt;RealConnection#connectTunnel(...)或</span><br><span class="line">   RealConnection#connectSocket(..)(最终都会调用connectSocket(...))</span><br><span class="line">--&gt;Platform.get()#connectSocket(...)</span><br><span class="line">--&gt;socket.connect(address, connectTimeout);//最终可以获得建立连接后的 Socket</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;RealConnection#newCodec(..)// 返回 HttpCode</span><br></pre></td></tr></table></figure><p>在 findHealthyConnection() 中有以下代码进行连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br></pre></td></tr></table></figure><p>至此连接指定服务器的 connection 已经建立。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>这是 Okhttp 库中拦截器链的最后一个拦截器，也是这个拦截器区具体发起请求和获取响应。</p><p>大致分为以下几个步骤：</p><ol><li>写入请求头</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpCodec.writeRequestHeaders(request);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>根据具体情况判断是否读取</p></li><li><p>根据具体情况判断是否写入相应请求头</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (responseBuilder == null) &#123;</span><br><span class="line">                // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">                Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">                // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection from</span><br><span class="line">                // being reused. Otherwise we&apos;re still obligated to transmit the request body to leave the</span><br><span class="line">                // connection in a consistent state.</span><br><span class="line">                streamAllocation.noNewStreams();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>构建 Response </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Response response = responseBuilder</span><br><span class="line">               .request(request)</span><br><span class="line">               .handshake(streamAllocation.connection().handshake())</span><br><span class="line">               .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">               .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure></li><li><p>写入 Response 的 body</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">            // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .body(httpCodec.openResponseBody(response))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>至此，网络请求经过拦截器链获得 Response ，那么再按照拦截器链逆向返回 Response，在此过程中对 Response 进行相应的处理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对开源库的研读中，我们首先需要做的是对大致流程有个清晰的认识，但是不能深陷细节、具体实现上在后期对相关功能的具体使用时在进行相关研究。而自己在此过程中，就深陷入细节，针对具体的实现真是绞尽脑汁，最后还是 “一败涂地”。此处再次告诫自己和后来人：对开源库的研读不要纠结于细节，不要纠结于细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;a href=&quot;#RetryAndFollowUpInterceptor&quot; class=&quot;headerlink&quot; title=&quot;RetryAndFollowUpInterceptor&quot;&gt;&lt;/a&gt;RetryAndFollowUpInterceptor&lt;/h3&gt;&lt;p&gt;功能：实现重试、跟踪&lt;/p&gt;
&lt;p&gt;实现原理： &lt;/p&gt;
&lt;p&gt;while(true) 死循环的实现。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果没有异常（包括请求失败、重定向等），那么执行 &lt;code&gt;return Response&lt;/code&gt;, return 会直接结束循环操作，将结果返回到下一个拦截器中进行处理。&lt;/p&gt;
&lt;p&gt;检验返回的 Response ，如果出现异常情况，那么会根据 Response 新建 Request，并且执行一些必要的检查（是否为同一个 connnetion ，是的话抛出异常，不是的话是否旧的 connection 的资源，并新建一个 connection），进入死循环的下一次循环，那么此时将进行新一轮的拦截器的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Okhttp3" scheme="https://mllgy.github.io/tags/Okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>hexo 博客维护</title>
    <link href="https://mllgy.github.io/2019/01/17/Hexo%20%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/"/>
    <id>https://mllgy.github.io/2019/01/17/Hexo 博客维护/</id>
    <published>2019-01-17T02:26:43.000Z</published>
    <updated>2019-01-17T07:13:41.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Hexo-博客建站"><a href="#关于-Hexo-博客建站" class="headerlink" title="关于 Hexo 博客建站"></a>关于 Hexo 博客建站</h3><p>自己在 2016 基于 Hexo + GitPage 搭建个人博客，但是看到推到 Github 上的代码是 hexo g 生成的 public 文件夹下文件，那我日后怎么维护。自己看到别人上传的代码却是真正的 source 文件。</p><p>今日自己才知道，需要维护两套代码，一套真正的 source 文件，一套部署到 github 的代码，真是废柴。</p><h3 id="关于-Hexo-主题"><a href="#关于-Hexo-主题" class="headerlink" title="关于 Hexo 主题"></a>关于 Hexo 主题</h3><p>自己在网上搜索了一部分主题，有的页面概念过于繁杂，有的页面过于花哨，自己的主要目的是博客记录，搭建时默认的 Hexo 主题已经满足要求，就不再更换主题(于今日有效，万一哪天遇到称心得主题)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于-Hexo-博客建站&quot;&gt;&lt;a href=&quot;#关于-Hexo-博客建站&quot; class=&quot;headerlink&quot; title=&quot;关于 Hexo 博客建站&quot;&gt;&lt;/a&gt;关于 Hexo 博客建站&lt;/h3&gt;&lt;p&gt;自己在 2016 基于 Hexo + GitPage 搭建个
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mllgy.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存空间类别</title>
    <link href="https://mllgy.github.io/2019/01/16/Java%20%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%88%AB/"/>
    <id>https://mllgy.github.io/2019/01/16/Java 内存空间类别/</id>
    <published>2019-01-16T07:23:17.000Z</published>
    <updated>2019-01-17T07:13:44.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2. 运行时数据区域"></a>2. 运行时数据区域</h2><p>JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。</p><p><img src="/images/2019_01_16.jpg" alt="运行时内存区域"></p><!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存，它可以看作 <strong>当前线程</strong> 所执行的字节码的行号指示器。<strong>在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个 </strong>计数器的值<strong> 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成</strong>。</p><p>如上图所示，程序计数器是线程私有的。</p><p><strong>如何执行工作</strong></p><p>如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。</p><a id="more"></a><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>Java 虚拟机栈是线程私有的，其生命周期与线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的内存模型： 每个 Java 方法执行的同时都会创建一个 <strong>栈帧(stack frame)</strong> 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>平时的把 Java 内存分为 堆内存(heap) 和 栈内存(stack) 的分类方法是比较粗糙的，实际分类方法十分复杂。这种分类方法中栈即为虚拟机栈，或为虚拟机中的局部变量表。</p><p>局部变量表存放了编译期可知的各种数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(不等同于对象本身，可能是一个对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress(指向一条字节码指令的地址)。</p><p>局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多的的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量表的大小。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>本地方方法栈与虚拟机栈发挥的作用相似，不同的是该栈为 Native 方法服务。</p><h3 id="2-4-Java-堆"><a href="#2-4-Java-堆" class="headerlink" title="2.4 Java 堆"></a>2.4 Java 堆</h3><p>Java 堆对于大部分应用来说都是 JVM 所管理的内存中最大的一块。Java 堆是 <strong>所有线程共享</strong> 的一块内存区域,<strong>在虚拟机启动时创建</strong>。Java 堆的唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存 – <strong>所有的对象实例以及数组都要在堆上分配</strong>。</p><p>Java 堆的分配可以在物理上不连续的内存空间，只要逻辑上连续就可以，可以固定大小，也可以扩展空间。</p><p>Java 堆是 GC 发生的主要区域。</p><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样是所有线程共享的内存空间，<strong>它用于储存已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据</strong>。Java 虚拟机把方法区描述为堆的一个逻辑部分，但是它还有一个别名 – Non-Heap(非堆)，目的应该是与 Java 堆区分。</p><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行区常量池是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong>常量池</strong> ，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法去的运行时常量池中存放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字面量和符号引用--&gt;常量池--&gt;运行时常量池</span><br></pre></td></tr></table></figure><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><blockquote><p>没有接触过相关概念。</p></blockquote><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><h3 id="2-8-小结"><a href="#2-8-小结" class="headerlink" title="2.8 小结"></a>2.8 小结</h3><table><thead><tr><th>数据区域</th><th>功能</th><th>线程相关</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td>程序计数器</td><td>字节码执行指示器</td><td>线程私有</td><td style="text-align:center"></td></tr><tr><td>Java 虚拟机栈</td><td>为 Java方法服务、存放编译期基本数据类型以及对象引用</td><td>线程私有</td><td style="text-align:center">平常被称为的 “栈”、空间较小</td></tr><tr><td></td><td>本地方法栈</td><td>与 Java 虚拟机栈类似，为 Native 方法服务</td><td style="text-align:center">线程私有</td><td></td><td></td></tr><tr><td></td><td>Java 堆</td><td>存放对象(对象实例以及数组)</td><td style="text-align:center">线程共享</td><td>GC 主要区域、空间较大</td><td></td></tr><tr><td></td><td>方法区</td><td>存储类信息、常量、静态变量、即时编译器编译后等数据</td><td style="text-align:center">线程共享</td><td></td><td></td></tr><tr><td></td><td>运行时常量池</td><td>常量池存放编译期生成的各种字面量和符号引用、常量池在类加载后存储在运行时常量池</td><td style="text-align:center">线程共享</td><td>方法区的一部分、常量池会存储在其中</td><td></td></tr><tr><td></td><td>直接内存</td><td></td><td style="text-align:center"></td><td></td><td></td></tr></tbody></table><hr><p><strong>知识链接</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://product.dangdang.com/23259731.html" target="_blank" rel="noopener">深入理解Java虚拟机：JVM高级特性与最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Java 不像 C/C++ 需要程序员自己管理内存，Java 把内存控制的权利交给类 Java 虚拟机。&lt;/p&gt;
&lt;h2 id=&quot;2-运行时数据区域&quot;&gt;&lt;a href=&quot;#2-运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;2. 运行时数据区域&quot;&gt;&lt;/a&gt;2. 运行时数据区域&lt;/h2&gt;&lt;p&gt;JVM 在 Java 程序运行时把它所管理的内存划分为几个不同的数据区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2019_01_16.jpg&quot; alt=&quot;运行时内存区域&quot;&gt;&lt;/p&gt;
&lt;!-- (https://img-blog.csdnimg.cn/20190111154945144.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0cmFuZ2VfTW9ua2V5,size_16,color_FFFFFF,t_70) --&gt;
&lt;h3 id=&quot;2-1-程序计数器&quot;&gt;&lt;a href=&quot;#2-1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;2.1 程序计数器&quot;&gt;&lt;/a&gt;2.1 程序计数器&lt;/h3&gt;&lt;p&gt;程序计数器是一块较小的内存，它可以看作 &lt;strong&gt;当前线程&lt;/strong&gt; 所执行的字节码的行号指示器。&lt;strong&gt;在虚拟机的概念模型里，字节码解释器的工作就是通过改变这个 &lt;/strong&gt;计数器的值&lt;strong&gt; 来选取下一条需要执行的字节码，分支、循环、跳转、异常处理、线程恢复等基础功能都需要这个计数器来完成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如上图所示，程序计数器是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何执行工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果线程正在执行一个 Java 方法，这个计数器记录的正是执行的虚拟机字节码指令的地址，如果执行的是 Native 方法，这个计数器值为空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mllgy.github.io/tags/Java/"/>
    
      <category term="内存分区" scheme="https://mllgy.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建 GitPage 静态博客</title>
    <link href="https://mllgy.github.io/2019/01/16/%E4%BD%BF%E7%94%A8%20Hexo%20%E6%90%AD%E5%BB%BA%20GitPage%20%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>https://mllgy.github.io/2019/01/16/使用 Hexo 搭建 GitPage 静态博客/</id>
    <published>2019-01-16T06:08:29.821Z</published>
    <updated>2019-01-17T07:13:32.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="必要工具的安装-Mac"><a href="#必要工具的安装-Mac" class="headerlink" title="必要工具的安装(Mac)"></a>必要工具的安装(Mac)</h2><h3 id="nmp"><a href="#nmp" class="headerlink" title="nmp"></a>nmp</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 官方网站</a>下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。</p><p>或使用相关命令行进行安装，具体步骤自行搜索。</p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>具体参见 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h2 id="Hexo-建站"><a href="#Hexo-建站" class="headerlink" title="Hexo 建站"></a>Hexo 建站</h2><p>执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>编辑 <code>_config.yml</code> 文件，进行相关配置。</p><a id="more"></a><h2 id="文章编写"><a href="#文章编写" class="headerlink" title="文章编写"></a>文章编写</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 进行预览</p><h2 id="博文部署"><a href="#博文部署" class="headerlink" title="博文部署"></a>博文部署</h2><p><code>_congfig.yml</code> 有关文件编辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="进行部署"><a href="#进行部署" class="headerlink" title="进行部署"></a>进行部署</h3><p>在每次编辑文章后执行以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean //清理 public 文件夹和 database 文件</span><br><span class="line">$ hexo generate // 重新生成 public 文件夹和 database 文件</span><br><span class="line">$ hexo deploy // 部署到 github page 上</span><br></pre></td></tr></table></figure><p>观察了以下目录文件夹，部署到 GitPage 上应该为 <code>hexo g</code> 生成的 public 文件夹下的内容。</p><hr><p><strong>知识链接：</strong></p><p>  &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://cherryblog.site/categories/Hexo%E5%BB%BA%E7%AB%99/" target="_blank" rel="noopener">Hexo建站</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;必要工具的安装-Mac&quot;&gt;&lt;a href=&quot;#必要工具的安装-Mac&quot; class=&quot;headerlink&quot; title=&quot;必要工具的安装(Mac)&quot;&gt;&lt;/a&gt;必要工具的安装(Mac)&lt;/h2&gt;&lt;h3 id=&quot;nmp&quot;&gt;&lt;a href=&quot;#nmp&quot; class=&quot;headerlink&quot; title=&quot;nmp&quot;&gt;&lt;/a&gt;nmp&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node 官方网站&lt;/a&gt;下载 pkg 包，进行安装 node.js 环境，安装完毕 npm 也被安装完成。&lt;/p&gt;
&lt;p&gt;或使用相关命令行进行安装，具体步骤自行搜索。&lt;/p&gt;
&lt;h3 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a&gt;hexo&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体参见 &lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Hexo-建站&quot;&gt;&lt;a href=&quot;#Hexo-建站&quot; class=&quot;headerlink&quot; title=&quot;Hexo 建站&quot;&gt;&lt;/a&gt;Hexo 建站&lt;/h2&gt;&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd &amp;lt;folder&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编辑 &lt;code&gt;_config.yml&lt;/code&gt; 文件，进行相关配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://mllgy.github.io/tags/Hexo/"/>
    
      <category term="GitPage" scheme="https://mllgy.github.io/tags/GitPage/"/>
    
  </entry>
  
</feed>
