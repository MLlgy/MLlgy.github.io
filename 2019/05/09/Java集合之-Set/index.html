<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java 集合之 Set 集合  | 玛斯特・布兰迪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Set 集合 Set 集合的特点无序、不可重复。 Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。 HashSet 类HashSet 集合按 Hash 算法 来存储集合的元素，因此具有很好的存取和查找功能。 HashSet 具有以下特点：  不能保证元素的排列顺序，这">
<meta name="keywords" content="Java,Java Collection,Set">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合之 Set 集合 ">
<meta property="og:url" content="/2019/05/09/Java集合之-Set/index.html">
<meta property="og:site_name" content="玛斯特・布兰迪">
<meta property="og:description" content="Set 集合 Set 集合的特点无序、不可重复。 Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。 HashSet 类HashSet 集合按 Hash 算法 来存储集合的元素，因此具有很好的存取和查找功能。 HashSet 具有以下特点：  不能保证元素的排列顺序，这">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="/images/2019_05_09_01.jpg">
<meta property="og:updated_time" content="2020-07-13T09:27:10.740Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 集合之 Set 集合 ">
<meta name="twitter:description" content="Set 集合 Set 集合的特点无序、不可重复。 Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。 HashSet 类HashSet 集合按 Hash 算法 来存储集合的元素，因此具有很好的存取和查找功能。 HashSet 具有以下特点：  不能保证元素的排列顺序，这">
<meta name="twitter:image" content="/images/2019_05_09_01.jpg">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.proxy.ustclug.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">玛斯特・布兰迪</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Enjoy the life, enjoy the code.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">文章</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java集合之-Set" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/09/Java集合之-Set/" class="article-date">
  <time datetime="2019-05-09T07:49:35.000Z" itemprop="datePublished">2019-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java 集合之 Set 集合 
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p><img src="/../images/2019_05_09_01.jpg" alt="List、Set、Queue"></p>
<p>Set 集合的特点无序、不可重复。</p>
<p>Set 集合不能记住元素的添加顺序。Set 集合不能包含相同的元素，把两个相同的元素添加到同一个 Set 集合中，则添加失败，add() 方法返回 false，且新元素不会被添加。</p>
<h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>HashSet 集合按 <code>Hash 算法</code> 来存储集合的元素，<strong>因此具有很好的存取和查找功能</strong>。</p>
<p>HashSet 具有以下特点：</p>
<ol>
<li>不能保证元素的排列顺序，这也是 Set 集合元素不能通过索引只能通过元素本身访问的原因。</li>
<li>HashSet 不是线程安全的。</li>
<li>元素可以为 null。</li>
</ol>
<a id="more"></a>

<h3 id="如何存储元素"><a href="#如何存储元素" class="headerlink" title="如何存储元素"></a>如何存储元素</h3><p>当向 HashSet 集合存入一个元素时， HashSet 会调用该对象的 <code>hashcode()</code> 方法来得到对象的 <code>hashcode</code> 值，<strong>然后根据该 hashcode 值决定对象在 HashSet 中的存储位置</strong>。如果两个元素通过 equals() 方法比较返回 true，但是它们的 hashcode() 方法返回值不相等，那么 HashSet 会把它们存储在不同的位置，可以添加成功。</p>
<h3 id="HashSet-如果定义元素相等"><a href="#HashSet-如果定义元素相等" class="headerlink" title="HashSet 如果定义元素相等"></a>HashSet 如果定义元素相等</h3><p>HashSet 集合判断两个元素相等的标准是：</p>
<ol>
<li>两个对象通过 equals() 方法比较相等。</li>
<li>两个对象的 hashcode() 方法的返回值也相等。</li>
</ol>
<p><strong>两者缺一不可</strong>。</p>
<p>所以当把一个对象放入 HashSet 中时，如果需要重写对象的 equals() 方法，那么也应该重写 hashcode() 方法。<strong>重写两方法的规则是：如果两个对象的 equals() 方法返回 true，这两个对象的 hashcode 也应该相同。</strong></p>
<p>两个对象的 equals() 方法返回 true，hashcode 返回不同的 hashcode 值，HashSet 会把两个对象保存在 Hash 表的不同位置，两个元素都会添加成功，但是这与 Set 集合的规则冲(元素不可重复)突了。如果是 equals() 方法返回 false，但是 hashcode 值相同，也会导致一些问题：hashcode 相同，HashSet 会尝试将多个元素保存在同一个位置，但又不行(这样的结果就是只剩下一个对象)，所以这样的结果就是在这个位置上通过链式结构来保存多个对象。HashSet 的特点就是通过元素的 hashcode 值来快速定位，而现在 HashSet 对象中有两个以上的元素具有相同的hashcode 值，导致性能下降。</p>
<h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><p>哈希算法的功能是，他能快速的查找被检索的对象，<strong>hash 算法的价值在于速度</strong>。当查询集合中的某个元素时，hash 算法可以直接根据该元素的 hashcode 值计算出该元素的存储位置，从而快速定位该元素。实现快速定位的原因是 HashSet 通过 hashcode 的值进行存储元素。</p>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><p>由上面可知 hashCode() 方法对于 HashSet 的重要性，那么针对 hashCode() 方法的重写有如下规则：</p>
<ol>
<li>同一个对象多次调用 hashCode 方法应该返回相同的值。</li>
<li>两个对象通过 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法应返回相同的值。</li>
<li>对象中用于比较 equals() 方法比较标准的实例变量都应该用于计算 hashCode 值。</li>
<li>程序把可变对象添加到 HashSet 中之后，尽量不要去修改集合元素中参与计算 hashCode()、equals() 的实例变量，否则会导致 HashSet 无法正确的操作这些集合元素。</li>
</ol>
<h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>LinkedHashSet 为 HashSet 的一个子类，LinkedHashSet 也是通过hashcode 的值来决定元素的存储位置，<strong>但同时使用链表维护元素的次序</strong>，使得元素看起来是以插入顺序保存的。因为需要维护元素的插入顺序，所以性能略低于 HashSet。但是在迭代访问 Set 集合中的全部元素时有很好的性能，因为它以链表维护内部顺序。</p>
<p>遍历 LinkedHashSet 集合元素时，元素的顺序与添加顺序一致。</p>
<h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>TreeSet 为 SortSet 接口的实现类，其可以确保集合元素处于 <strong>排序状态</strong>。TreeSet 不是根据添加顺序进行排序而是 <strong>根据元素的实际值进行排序</strong>。</p>
<p>与 HashSet 根据 hash 算法来决定元素的存储位置不同，TreeSet 采用 <strong>红黑树</strong> 的数据结构来存储集合元素。TreeSet 支持两种排序算法：自然排序(默认)和定制排序。</p>
<h3 id="TreeSet-自然排序"><a href="#TreeSet-自然排序" class="headerlink" title="TreeSet 自然排序"></a>TreeSet 自然排序</h3><p>如果将一个对象添加到 TreeSet 中，那么 <strong>这个对象必须实现 Comparable 接口</strong>，依次来实现排序功能，否则程序会报出异常。</p>
<p>TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后按升序排列，这就是 TreeSet 的自然排序。</p>
<p><strong>元素如何存储到集合中</strong></p>
<p>当把一个元素添加到 TreeSet 集合中， TreeSet 会调用这个对象的 compareTo(Object obj) 方法与集合中的其他元素比较大小，<strong>然后根据红黑树结构找到它的存储位置</strong>。如果两个对象通过 compareTo(Object obj) 方法比较相等，那么新的对象将不会添加到集合中。</p>
<p>如果想要 TreeSet 能够正常运行，那么 TreeSet 只能添加同一种类型的对象。</p>
<p><strong>判断集合元素相同</strong></p>
<p><strong>TreeSet 集合元素相等的唯一标准为：两个对象的 compareTo(Object obj) 方法是否返回 0，返回 0 则认为两个对象相等，反之不相等</strong>。基于以上标准，在重写 equals() 方法时，其返回值需要与 compareTo(Object obj) 的返回结果一致，否则 equals() 方法的返回值没有实际意义。</p>
<p>通过重写 compareTo(Object obj) 方法，使其不返回 0，此时可以实现将一个对象多次添加到 TreeSet集合中，但是此时集合多个元素均指向一个对象引用，如果对象发生变化，那么集合中的多个元素会同时发生相同变化。</p>
<p>基于以上描述，在重写对象类的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果，如果equals() 方法返回 true ，那么这两个对象通过 compareTo(Object obj) 方法应该返回 0。</p>
<p>改变Treeset 集合中的可变元素的实例变量后，这会导致它与其他对象的大小顺序发生改变，但是 TreeSet 不会再次调整它们的顺序。当尝试删除该对象时，TreeSet 也会删除失败。所以基于此原因 <strong>TreeSet 可以删除没有被修改实例变量、且不与其他被修改的实例变量的对象重复的对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TreeSet treeSet = new TreeSet();</span><br><span class="line">Dog dog1 = new Dog(&quot;mike&quot;,1);</span><br><span class="line">Dog dog2 = new Dog(&quot;mike&quot;,2);</span><br><span class="line">Dog dog3 = new Dog(&quot;mike&quot;,3);</span><br><span class="line">Dog dog4 = new Dog(&quot;mike&quot;,4);</span><br><span class="line">treeSet.add(dog1);</span><br><span class="line">treeSet.add(dog2);</span><br><span class="line">treeSet.add(dog3);</span><br><span class="line">treeSet.add(dog4);</span><br><span class="line">System.out.println(&quot;1 &quot; + treeSet);</span><br><span class="line">treeSet.remove(dog1);</span><br><span class="line">System.out.println(&quot;2 &quot; +treeSet);</span><br><span class="line">Dog showDog = (Dog) treeSet.first();</span><br><span class="line">showDog.setAge(6);</span><br><span class="line">System.out.println(&quot;3 &quot; +treeSet);</span><br><span class="line">System.out.println(&quot;4 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,6)));</span><br><span class="line">System.out.println(&quot;5 &quot; +treeSet.remove(new Dog(&quot;Mike&quot;,2)));</span><br><span class="line">System.out.println(&quot;6 &quot; +treeSet.first());</span><br><span class="line">System.out.println(&quot;7 &quot; +treeSet.remove(treeSet.first()));</span><br><span class="line">System.out.println(&quot;8 &quot; +treeSet);</span><br></pre></td></tr></table></figure>

<p>打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 [Dog&#123;name=&apos;mike&apos;, age=1&#125;, Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">2 [Dog&#123;name=&apos;mike&apos;, age=2&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">3 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br><span class="line">4 false</span><br><span class="line">5 false</span><br><span class="line">6 Dog&#123;name=&apos;mike&apos;, age=6&#125;</span><br><span class="line">7 false</span><br><span class="line">8 [Dog&#123;name=&apos;mike&apos;, age=6&#125;, Dog&#123;name=&apos;mike&apos;, age=3&#125;, Dog&#123;name=&apos;mike&apos;, age=4&#125;]</span><br></pre></td></tr></table></figure>

<p>可以看到 日志3 TreeSet 对象并没有重新排序，通过日志 4、5、7 可以对象更改后 TreeSet 无法对其进行删除。</p>
<h3 id="TreeSet-定制排序"><a href="#TreeSet-定制排序" class="headerlink" title="TreeSet 定制排序"></a>TreeSet 定制排序</h3><p>实现定制排序，则需要在创建 TreeSet 集合对象时结合 Comparator 对象，<strong>并由 Comparator 负责集合元素的排序逻辑</strong>。</p>
<p>如例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void test2() &#123;</span><br><span class="line">        TreeSet treeSet = new TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            ClassD classD1 = (ClassD) o1;</span><br><span class="line">            ClassD classD2 = (ClassD) o2;</span><br><span class="line">            if(classD1.getNum() == classD2.getNum())&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return classD1.getNum() &gt; classD2.getNum() ? -1 : 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeSet.add(new ClassD(1));</span><br><span class="line">        treeSet.add(new ClassD(-1));</span><br><span class="line">        treeSet.add(new ClassD(0));</span><br><span class="line">//        ClassD classD = new ClassD(2);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">//        treeSet.add(classD);</span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// 打印日志：[ClassD&#123;num=1&#125;, ClassD&#123;num=0&#125;, ClassD&#123;num=-1&#125;]</span><br></pre></td></tr></table></figure>

<p>对于自然排序和定制排序而言，添加到 TreeSet 集合对象中的元素应该为同一种类型的对象，否则会引发 ClassCastException 异常。</p>
<h3 id="3-EnumSet-类"><a href="#3-EnumSet-类" class="headerlink" title="3. EnumSet 类"></a>3. EnumSet 类</h3><p>EnumSet 是一个专门为枚举类设计的集合类， EnumSet 中的所有的元素都必须是枚举类型的枚举值，该枚举类型在创建 EnumSet 时显式或隐式的指定。EnumSet 的集合元素也是有顺序的，<strong>EnumSet 以枚举值在枚举类中的定义顺序来决定集合元素在顺序</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum  EnumA &#123;</span><br><span class="line">    ONE,TWO,THREE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static void test4() &#123;</span><br><span class="line">        EnumSet enumSet = EnumSet.noneOf(EnumA.class);</span><br><span class="line">        enumSet.add(EnumA.ONE);</span><br><span class="line">        enumSet.add(EnumA.THREE);</span><br><span class="line">        enumSet.add(EnumA.TWO);</span><br><span class="line">        System.out.println(enumSet);</span><br><span class="line">        EnumSet enumSet2 = EnumSet.allOf(EnumA.class);</span><br><span class="line">        System.out.println(enumSet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line">// 打印日志：</span><br><span class="line">[ONE, TWO, THREE]</span><br><span class="line">[ONE, TWO, THREE]</span><br></pre></td></tr></table></figure>

<p>EnumSet在内部以位向量的形式保存，这种存储方式十分的高效，所以 EnumSet 占用的内存小、运行效率高。</p>
<p><strong>EnumSet 不可添加 null 元素。</strong></p>
<h3 id="各-Set-集合的性能"><a href="#各-Set-集合的性能" class="headerlink" title="各 Set 集合的性能"></a>各 Set 集合的性能</h3><p>HashSet 和 TreeSet 为 Set 集合的两个典型实现，两者如何选择呢？</p>
<p>由于 TreeSet 内部需要额外的红黑二叉树维护元素的添加顺序，所以 HashSet 的效率高于 TreeSet。<strong>当需要保持排序的 Set 时才使用 TreeSet，否则使用 HashSet。</strong></p>
<p>LinkedHashSet 为 HashSet 的子类，对于删除、插入操作 LinkedHashSet 比 HashSet 稍慢一些，这是因为 LinkedHashSet 内部需要维护链表造成的，但正是这个原因，遍历操作时 LinkedHashSet 会更快一些。</p>
<p>EnumSet 是所有 Set 集合中效率最好的，但是它只能保存他一个枚举类的枚举值作为集合元素。</p>
<p>Set 的三个实现类 HashSet 、TreeSet、 EnumSet 都是 <strong>线程不安全的</strong>，多个线程操作 Set 集合时需保证线程同步。通常使用 Collections  工具类的 synchronizedSortSet 方法来包装该 Set 集合，此操作最好在创建时进行，以防止对 Set 集合意外的非同步访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet treeSet = Collections.synchronizedSortedSet(new TreeSet((o1,o2)-&gt;&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="/2019/05/09/Java集合之-Set/" data-id="ckh5xpt2e00ivyjfyysctmndm" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Collection/">Java Collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Set/">Set</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/10/Jetpack之 Lifecycle 组件学习笔记/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">这些东西可能太新了</strong>
      <div class="article-nav-title">
        
          Jetpack 之 Lifecycle 组件学习笔记
        
      </div>
    </a>
  
  
    <a href="/2019/05/09/Java集合概述/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">这些东西可能过时了</strong>
      <div class="article-nav-title">Java 集合概述</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 11.11px;">AIDL</a> <a href="/tags/Alfred/" style="font-size: 10px;">Alfred</a> <a href="/tags/Android/" style="font-size: 15.56px;">Android</a> <a href="/tags/Android-刷机/" style="font-size: 10px;">Android 刷机</a> <a href="/tags/Android-性能优化/" style="font-size: 12.22px;">Android 性能优化</a> <a href="/tags/Android绘制机制/" style="font-size: 10px;">Android绘制机制</a> <a href="/tags/Binder/" style="font-size: 10px;">Binder</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/CPU-Profiler/" style="font-size: 10px;">CPU Profiler</a> <a href="/tags/CPU-架构/" style="font-size: 10px;">CPU 架构</a> <a href="/tags/Charles/" style="font-size: 10px;">Charles</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Coroutines/" style="font-size: 11.11px;">Coroutines</a> <a href="/tags/Coroutines协程/" style="font-size: 10px;">Coroutines协程</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/Dart/" style="font-size: 10px;">Dart</a> <a href="/tags/EventBus/" style="font-size: 13.33px;">EventBus</a> <a href="/tags/EventBus-APT/" style="font-size: 10px;">EventBus APT</a> <a href="/tags/Exception/" style="font-size: 11.11px;">Exception</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Future/" style="font-size: 10px;">Future</a> <a href="/tags/FutureTask/" style="font-size: 10px;">FutureTask</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitPage/" style="font-size: 10px;">GitPage</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Gradle-in-action/" style="font-size: 15.56px;">Gradle in action</a> <a href="/tags/Gradle-基本原理/" style="font-size: 15.56px;">Gradle 基本原理</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/Hexo/" style="font-size: 11.11px;">Hexo</a> <a href="/tags/Hprof/" style="font-size: 10px;">Hprof</a> <a href="/tags/IO-流/" style="font-size: 10px;">IO 流</a> <a href="/tags/Inflection/" style="font-size: 10px;">Inflection</a> <a href="/tags/JNI/" style="font-size: 11.11px;">JNI</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Java-Collection/" style="font-size: 15.56px;">Java Collection</a> <a href="/tags/Java-多线程/" style="font-size: 15.56px;">Java 多线程</a> <a href="/tags/Java-异常/" style="font-size: 10px;">Java 异常</a> <a href="/tags/Java-继承，对象，类初始化/" style="font-size: 10px;">Java 继承，对象，类初始化</a> <a href="/tags/Jetpack/" style="font-size: 15.56px;">Jetpack</a> <a href="/tags/JobScheduler/" style="font-size: 10px;">JobScheduler</a> <a href="/tags/Kindle/" style="font-size: 10px;">Kindle</a> <a href="/tags/Kotin/" style="font-size: 11.11px;">Kotin</a> <a href="/tags/Kotlin/" style="font-size: 18.89px;">Kotlin</a> <a href="/tags/Kotlin-协程/" style="font-size: 14.44px;">Kotlin 协程</a> <a href="/tags/Kotlin-核心编程/" style="font-size: 16.67px;">Kotlin 核心编程</a> <a href="/tags/LeakCanary/" style="font-size: 10px;">LeakCanary</a> <a href="/tags/Lifecycle/" style="font-size: 10px;">Lifecycle</a> <a href="/tags/Linux/" style="font-size: 15.56px;">Linux</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/LiveData/" style="font-size: 10px;">LiveData</a> <a href="/tags/Logcat-日志格式/" style="font-size: 10px;">Logcat 日志格式</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/Okhttp3/" style="font-size: 12.22px;">Okhttp3</a> <a href="/tags/Okhttp3-缓存文件/" style="font-size: 10px;">Okhttp3 缓存文件</a> <a href="/tags/Okio/" style="font-size: 10px;">Okio</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Rxjava-源码分析/" style="font-size: 13.33px;">Rxjava 源码分析</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/Shell/" style="font-size: 14.44px;">Shell</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/Sticky-Event/" style="font-size: 10px;">Sticky Event</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/TraceView/" style="font-size: 10px;">TraceView</a> <a href="/tags/Transformer/" style="font-size: 10px;">Transformer</a> <a href="/tags/VIM/" style="font-size: 10px;">VIM</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewModle/" style="font-size: 10px;">ViewModle</a> <a href="/tags/WorkManager/" style="font-size: 12.22px;">WorkManager</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/《深入理解-Java-虚拟机》读书笔记/" style="font-size: 10px;">《深入理解 Java 虚拟机》读书笔记</a> <a href="/tags/三方库/" style="font-size: 10px;">三方库</a> <a href="/tags/事件分发机制/" style="font-size: 10px;">事件分发机制</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/内存分区/" style="font-size: 10px;">内存分区</a> <a href="/tags/内存泄漏/" style="font-size: 11.11px;">内存泄漏</a> <a href="/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/tags/单例/" style="font-size: 10px;">单例</a> <a href="/tags/图解-HTTP/" style="font-size: 11.11px;">图解 HTTP</a> <a href="/tags/堆栈轨迹/" style="font-size: 10px;">堆栈轨迹</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/对象拷贝/" style="font-size: 10px;">对象拷贝</a> <a href="/tags/工具/" style="font-size: 11.11px;">工具</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/性能优化工具/" style="font-size: 10px;">性能优化工具</a> <a href="/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/tags/极客时间专栏/" style="font-size: 10px;">极客时间专栏</a> <a href="/tags/极客时间笔记/" style="font-size: 10px;">极客时间笔记</a> <a href="/tags/泛型/" style="font-size: 12.22px;">泛型</a> <a href="/tags/浮点型精度问题/" style="font-size: 10px;">浮点型精度问题</a> <a href="/tags/深入浅出计算机组成原理-徐文浩/" style="font-size: 11.11px;">深入浅出计算机组成原理(徐文浩)</a> <a href="/tags/深入理解-Android-读书笔记/" style="font-size: 10px;">深入理解 Android 读书笔记</a> <a href="/tags/源码解析/" style="font-size: 11.11px;">源码解析</a> <a href="/tags/焦点机制/" style="font-size: 10px;">焦点机制</a> <a href="/tags/百度地图黑影/" style="font-size: 10px;">百度地图黑影</a> <a href="/tags/硬件加速/" style="font-size: 10px;">硬件加速</a> <a href="/tags/编译技术/" style="font-size: 10px;">编译技术</a> <a href="/tags/网络协议/" style="font-size: 12.22px;">网络协议</a> <a href="/tags/网络安全/" style="font-size: 10px;">网络安全</a> <a href="/tags/计算机基础/" style="font-size: 10px;">计算机基础</a> <a href="/tags/设计模式六大原则/" style="font-size: 10px;">设计模式六大原则</a> <a href="/tags/读书笔记/" style="font-size: 17.78px;">读书笔记</a> <a href="/tags/趣谈网络协议-刘超/" style="font-size: 10px;">趣谈网络协议(刘超)</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/Okio/">Okio 的基本原理(译文)</a>
          </li>
        
          <li>
            <a href="/2020/07/30/记一次-Charles-抓包-Android-10-0-HTTPS-请求/">记一次 Charles 抓包 Android 10.0 HTTPS 请求</a>
          </li>
        
          <li>
            <a href="/2020/07/29/HTTPS-防止被抓包/">Https 如何反抓包</a>
          </li>
        
          <li>
            <a href="/2020/07/19/Kotlin-之-Backing-Field/">Kotlin 之对 Backing Field 的理解</a>
          </li>
        
          <li>
            <a href="/2020/07/17/Alfred4-使用/">Alfred4 使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 玛斯特・布兰迪<br>
      巨大能量来源 <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">文章</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>