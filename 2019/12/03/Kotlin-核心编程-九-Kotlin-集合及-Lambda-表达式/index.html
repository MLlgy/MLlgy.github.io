<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Kotlin 核心编程(九):Kotlin 集合及 Lambda 表达式 | 玛斯特・布兰迪</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。 Kotlin 集合中的 API 大量使用了 Lambda。 0x0001 Kotlin 调用 Java 的函数式接口Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：">
<meta name="keywords" content="Kotlin 核心编程,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin 核心编程(九):Kotlin 集合及 Lambda 表达式">
<meta property="og:url" content="/2019/12/03/Kotlin-核心编程-九-Kotlin-集合及-Lambda-表达式/index.html">
<meta property="og:site_name" content="玛斯特・布兰迪">
<meta property="og:description" content="虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。 Kotlin 集合中的 API 大量使用了 Lambda。 0x0001 Kotlin 调用 Java 的函数式接口Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-03T05:30:41.335Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin 核心编程(九):Kotlin 集合及 Lambda 表达式">
<meta name="twitter:description" content="虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。 Kotlin 集合中的 API 大量使用了 Lambda。 0x0001 Kotlin 调用 Java 的函数式接口Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.proxy.ustclug.org/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">玛斯特・布兰迪</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Enjoy the life, enjoy the code.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives/">文章</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value=""></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Kotlin-核心编程-九-Kotlin-集合及-Lambda-表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/03/Kotlin-核心编程-九-Kotlin-集合及-Lambda-表达式/" class="article-date">
  <time datetime="2019-12-03T05:24:43.000Z" itemprop="datePublished">2019-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Kotlin 核心编程(九):Kotlin 集合及 Lambda 表达式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>虽然 Lambda 表达式使用起来十分的优雅、简洁，但是在 Kotlin 中使用 Lambda 表达式会有一些额外的开销，而这个问题可以使用内联函数解决。</p>
<p>Kotlin 集合中的 API 大量使用了 Lambda。</p>
<h3 id="0x0001-Kotlin-调用-Java-的函数式接口"><a href="#0x0001-Kotlin-调用-Java-的函数式接口" class="headerlink" title="0x0001 Kotlin 调用 Java 的函数式接口"></a>0x0001 Kotlin 调用 Java 的函数式接口</h3><p>Kotlin 调用 Java 的函数式接口在之前的相关篇章以及提及，如下所示：</p>
<a id="more"></a>
<p>Java 的函数式接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IClick&#123;</span><br><span class="line">    void onClick()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.setIClickListener(new IClick()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClik()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上例子在 Kotlin 中做如下调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener(object:IClick&#123;</span><br><span class="line"></span><br><span class="line">    override public void onClik()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 语法进行简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由 Kotlin 语法糖的存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setIClickListener&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0x0002-带接收者的-Lambda-这个是什么？"><a href="#0x0002-带接收者的-Lambda-这个是什么？" class="headerlink" title="0x0002 带接收者的 Lambda  这个是什么？"></a>0x0002 带接收者的 Lambda  这个是什么？</h3><p>通过之前的内容我们知道了函数的类型，比如以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Int) -&gt; String// 参数类型为 Int ，返回值类型为 String 的函数</span><br><span class="line">(Int) -&gt; (Int,String) -&gt; String</span><br></pre></td></tr></table></figure>

<p>同时在 Kotlin 中还允许定义带有参数的函数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int.(Int) -&gt; Int</span><br></pre></td></tr></table></figure>

<p>具体应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sum:Int.(Int) -&gt; Int = &#123;other -&gt; plus(other)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型安全构造器：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class HTML&#123;</span><br><span class="line">    fun body()&#123;</span><br><span class="line">        println(&quot;body&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun header()&#123;</span><br><span class="line">        println(&quot;head&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    fun content(num:Int):Int&#123;</span><br><span class="line">        println(&quot;content $num&quot;)</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun showText(a:Int):String =&quot;showText&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun html(init:HTML.() -&gt; Unit):HTML&#123;</span><br><span class="line">    val html = HTML()//创建接受者</span><br><span class="line">    html.init()// 把接受者对象传给 Lambda</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun html2(init:HTML.() -&gt; String):HTML&#123;</span><br><span class="line">    val html = HTML()</span><br><span class="line">    html.init()</span><br><span class="line">    return html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;R&gt; html4(init:HTML.() -&gt; R):R&#123;</span><br><span class="line">    val html = HTML()</span><br><span class="line">    val result = html.init()</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    html &#123; body() &#125;// 调用接受者对象的 body 方法，调用 1</span><br><span class="line">    html &#123; header() &#125;// 调用 2，往下依次类推</span><br><span class="line">    html &#123; content(2) &#125;</span><br><span class="line">    html &#123; showText(2) &#125;</span><br><span class="line"></span><br><span class="line">//    html2 &#123; body() &#125;</span><br><span class="line">//    html2 &#123; header() &#125;</span><br><span class="line">//    html2 &#123; content(2) &#125;</span><br><span class="line">    html2 &#123; showText(2) &#125;</span><br><span class="line"></span><br><span class="line">//    html3 &#123; body() &#125;</span><br><span class="line">//    html3 &#123; header() &#125;</span><br><span class="line">    html3 &#123; content(2) &#125;</span><br><span class="line">//    html3 &#123; showText(3) &#125;   </span><br><span class="line"></span><br><span class="line">    val result = html4 &#123; showText(3)</span><br><span class="line">    &quot;3435&quot;&#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个概念虽然看示例挺容易看懂，但是概念确实是难以理解，经过验证有以下结论：</p>
<p><code>init:HTML.() -&gt; Unit</code>: 其中 <code>HTML</code> 代表 Lambda 表达式 init 为 HTML 类中的函数，而 <code>Unit</code> 代表 Lambda 表达式的返回值，这里需要注意的是，当此处声明返回值类型为 Unit 时，可以调用 HTML 中返回值类型为各个类型的函数，所以 调用 1~4 均是可以的，但是当声明返回值类型为非 Unit 时，只能调用返回值类型相同的函数，所以调用 5、6、7、9、10、12 是非法调用。需要注意调用 13 是可以有返回值的。</p>
<p>其实我们常见的 with、apply 就是这样的函数，正式因为这种机制，我们可以在相应的闭包中使用 this 代指调用接收者,并且 this 可以省略，但是不同的是 with 可以返回自由类型，如上例中的 html4，with、apply 的使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val html = HTML()</span><br><span class="line">with(html)&#123;</span><br><span class="line">    body()</span><br><span class="line">    header()</span><br><span class="line">    content(2)</span><br><span class="line">    showText(2)</span><br><span class="line">    &quot;over&quot;</span><br><span class="line">&#125;</span><br><span class="line">html.apply &#123;</span><br><span class="line">    body()</span><br><span class="line">    header()</span><br><span class="line">    content(2)</span><br><span class="line">    showText(3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 with 和 apply 的源码，通过源码更深理解两者的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    return receiver.block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0X0003-使用内联函数优化-Kotlin-中-Lambda-表达式额外的开销"><a href="#0X0003-使用内联函数优化-Kotlin-中-Lambda-表达式额外的开销" class="headerlink" title="0X0003 使用内联函数优化 Kotlin 中 Lambda 表达式额外的开销"></a>0X0003 使用内联函数优化 Kotlin 中 Lambda 表达式额外的开销</h3><p>Kotlin 中 Lambda 的额外开销：在 Kotliln 声明的每一个 Lambda 会在字节码中产生一个匿名类，每次调用都会创建一个新的对象，所以存在额外开销。而 Java 中通过 invokedynamic 技术实现了在运行期才产生相应的翻译代码。</p>
<p><strong>内联函数：</strong><br>使用 <strong>inline</strong> 关键字来修饰函数，这些函数就成为了内联函数。内联函数的函数体在编译期会被嵌入每一个调用的地方，以免减少额外生产的匿名类数量，同时减少函数执行的时间开销。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo &#123; println(&quot;block&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun foo(block:()-&gt;Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码反编译后的相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class TwoKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      foo((Function0)null.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      String var1 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">      block.invoke();</span><br><span class="line">      var1 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的内容，我们知道 Lambda 表达式会生成相应的匿名内部类，在这里调用 foo 会产生一个 Function0 类型的 block 类，通过调用其 invoke 方法来执行，这就是所说的增加的额外的生成类和调用开销。</p>
<p>使用 inline 关键子修饰 foo 函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline fun foo(block:()-&gt;Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var1 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">      // block 函数体从这里开始粘贴</span><br><span class="line">      String var2 = &quot;block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      // block 函数体从这里结束粘贴</span><br><span class="line">      var1 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      String var2 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">      block.invoke();</span><br><span class="line">      var2 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 foo 函数体代码以及被调用的 Lambda 代码都粘贴到了相应的调用位置，从而减少匿名类的生产和调用开销。但是内联函数存在的一个问题是会增加空间复杂度，通过空间换取时间上的优势。</p>
<p>使用内联函数需要注意：</p>
<ul>
<li>普通函数不需要使用 inline 关键字修饰。</li>
<li>避免对具有大量函数体的函数进行内联，会导致过多的字节码数量。</li>
<li>函数被定义为内联函数，则不能访问闭包类中的私有成员，除非声明为 internal。</li>
</ul>
<h3 id="0X0004-使用-noinline-避免参数被内联"><a href="#0X0004-使用-noinline-避免参数被内联" class="headerlink" title="0X0004 使用 noinline 避免参数被内联"></a>0X0004 使用 noinline 避免参数被内联</h3><p>通过上节可是看到内联函数的整个函数会被粘贴到调用函数中，但是存在这样一种情况：函数接收多个参数，我们只想对部分 Lambda 参数进行内联，而其他不内联，应该如何操作。</p>
<p>针对以上情况，我们可以使用关键字 <strong>noline</strong> 来修饰不想内联的参数，那么该参数就不会有内联效果。我们对以上的示例进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo (&#123; println(&quot;block1&quot;)&#125;,&#123; println(&quot;block2&quot;)&#125;, &quot;tree&quot;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline fun foo(block:()-&gt;Unit,noinline block2: () -&gt; Unit,mess:String)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    block2()</span><br><span class="line">    println(mess)</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      Function0 block2$iv = (Function0)null.INSTANCE;</span><br><span class="line">      String mess$iv = &quot;tree&quot;;</span><br><span class="line">      String var3 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">      String var4 = &quot;block1&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      block2$iv.invoke();</span><br><span class="line">      System.out.println(mess$iv);</span><br><span class="line">      var3 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static final void foo(@NotNull Function0 block, @NotNull Function0 block2, @NotNull String mess) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block, &quot;block&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(block2, &quot;block2&quot;);</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(mess, &quot;mess&quot;);</span><br><span class="line">      String var4 = &quot;before block&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      block.invoke();</span><br><span class="line">      block2.invoke();</span><br><span class="line">      System.out.println(mess);</span><br><span class="line">      var4 = &quot;after block&quot;;</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 online 修饰的 block2 Lambda 表达式， 在调用时并没有将其函数体复制到调用处。</p>
<h3 id="0X0005-非局部返回和具体化参数类型"><a href="#0X0005-非局部返回和具体化参数类型" class="headerlink" title="0X0005 非局部返回和具体化参数类型"></a>0X0005 非局部返回和具体化参数类型</h3><p><strong>使用 inline 实现非局部返回</strong></p>
<p>非局部返回，那么就是全局返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // foo &#123; return&#125; 促成为非法调用，Lambda 中不允许 return 关键字出现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun foo(block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时通过 inline 修饰 foo 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    foo &#123; return&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun foo(block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是打印日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before block</span><br></pre></td></tr></table></figure>

<p>只执行 block 上面的操作，原因很容易理解，使用 inline 将代码进行替换，那么 return 在编译期会出现在 main 函数中，当然会针对全局生效。</p>
<p><strong>crossinline 关键字</strong></p>
<p>但是在某些情况下，非局部返回可能会引发某些问题，因为有时候内联函数所接收的 Lambda 常数往往来自上下文的其他地方。为了避免带有 return 的 Lambda参数带来破话，使用 <strong>crossinline</strong> 来避免非局部返回的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    //foo &#123; return&#125; 此时 Lambda 中带有 return 参数是非法的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun foo(crossinline block:() -&gt; Unit)&#123;</span><br><span class="line">    println(&quot;before block&quot;)</span><br><span class="line">    block()</span><br><span class="line">    println(&quot;after block&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 inline 实现具体化参数类型</strong></p>
<p>其实这部分内容在 Kotlin 泛型提及过，在此处探究器原因。</p>
<p>和 Java 一样，由于运行时存心类型擦除，所以不能直接获取一个参数的类型，而使用内联函数会直接在字节码中生成相应的函数体，这种情况下可以获得参数类型，可以通过关键字 <strong>reified</strong> 实现这一效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    getType&lt;String&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inline fun &lt;reified T&gt; getType()&#123;</span><br><span class="line">    println(T::class)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure>

<p>反编译后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class TwioKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      KClass var1 = Reflection.getOrCreateKotlinClass(String.class);</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static final void getType() &#123;</span><br><span class="line">      Intrinsics.reifiedOperationMarker(4, &quot;T&quot;);</span><br><span class="line">      KClass var1 = Reflection.getOrCreateKotlinClass(Object.class);</span><br><span class="line">      System.out.println(var1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="/2019/12/03/Kotlin-核心编程-九-Kotlin-集合及-Lambda-表达式/" data-id="ckbg6fr7700hhxzfyffmybzbd" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin-核心编程/">Kotlin 核心编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/10/图解-HTTP-学习笔记一/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">这些东西可能太新了</strong>
      <div class="article-nav-title">
        
          图解 HTTP 学习笔记(一)：网络基础
        
      </div>
    </a>
  
  
    <a href="/2019/12/03/Kotlin-核心编程-十一-作用域函数/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">这些东西可能过时了</strong>
      <div class="article-nav-title">Kotlin 核心编程(十一):作用域函数 let、run、with、apply、also</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 13.75px;">Android</a> <a href="/tags/Android-刷机/" style="font-size: 10px;">Android 刷机</a> <a href="/tags/Binder/" style="font-size: 10px;">Binder</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/CPU-Profiler，Android-性能优化/" style="font-size: 10px;">CPU Profiler，Android 性能优化</a> <a href="/tags/CPU-架构/" style="font-size: 10px;">CPU 架构</a> <a href="/tags/Collections/" style="font-size: 10px;">Collections</a> <a href="/tags/Coroutines/" style="font-size: 11.25px;">Coroutines</a> <a href="/tags/Coroutines协程/" style="font-size: 10px;">Coroutines协程</a> <a href="/tags/DI/" style="font-size: 10px;">DI</a> <a href="/tags/Dagger2/" style="font-size: 10px;">Dagger2</a> <a href="/tags/Dart/" style="font-size: 10px;">Dart</a> <a href="/tags/EventBus/" style="font-size: 13.75px;">EventBus</a> <a href="/tags/EventBus-APT/" style="font-size: 10px;">EventBus APT</a> <a href="/tags/Exception/" style="font-size: 11.25px;">Exception</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Future/" style="font-size: 10px;">Future</a> <a href="/tags/FutureTask/" style="font-size: 10px;">FutureTask</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitPage/" style="font-size: 10px;">GitPage</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Gradle-in-action/" style="font-size: 16.25px;">Gradle in action</a> <a href="/tags/Gradle-基本原理/" style="font-size: 16.25px;">Gradle 基本原理</a> <a href="/tags/Hexo/" style="font-size: 11.25px;">Hexo</a> <a href="/tags/Hprof/" style="font-size: 10px;">Hprof</a> <a href="/tags/IO-流/" style="font-size: 10px;">IO 流</a> <a href="/tags/Inflection/" style="font-size: 10px;">Inflection</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/Java/" style="font-size: 13.75px;">Java</a> <a href="/tags/Java-Basic/" style="font-size: 20px;">Java Basic</a> <a href="/tags/Java-Collection/" style="font-size: 16.25px;">Java Collection</a> <a href="/tags/Java-多线程/" style="font-size: 16.25px;">Java 多线程</a> <a href="/tags/Java-异常/" style="font-size: 10px;">Java 异常</a> <a href="/tags/Java-继承，对象，类初始化/" style="font-size: 10px;">Java 继承，对象，类初始化</a> <a href="/tags/Jetpack/" style="font-size: 16.25px;">Jetpack</a> <a href="/tags/JobScheduler/" style="font-size: 10px;">JobScheduler</a> <a href="/tags/Kindle/" style="font-size: 10px;">Kindle</a> <a href="/tags/Kotlin/" style="font-size: 11.25px;">Kotlin</a> <a href="/tags/Kotlin-协程/" style="font-size: 15px;">Kotlin 协程</a> <a href="/tags/Kotlin-官方文档/" style="font-size: 11.25px;">Kotlin 官方文档</a> <a href="/tags/Kotlin-核心编程/" style="font-size: 17.5px;">Kotlin 核心编程</a> <a href="/tags/Kotlin-泛型/" style="font-size: 10px;">Kotlin 泛型</a> <a href="/tags/LeakCanary/" style="font-size: 10px;">LeakCanary</a> <a href="/tags/Lifecycle/" style="font-size: 10px;">Lifecycle</a> <a href="/tags/Linux/" style="font-size: 16.25px;">Linux</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/LiveData/" style="font-size: 10px;">LiveData</a> <a href="/tags/Logcat-日志格式/" style="font-size: 10px;">Logcat 日志格式</a> <a href="/tags/Map/" style="font-size: 10px;">Map</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/Okhttp3/" style="font-size: 11.25px;">Okhttp3</a> <a href="/tags/Okhttp3-缓存文件/" style="font-size: 10px;">Okhttp3 缓存文件</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a> <a href="/tags/Rxjava-源码分析/" style="font-size: 13.75px;">Rxjava 源码分析</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Singleton/" style="font-size: 11.25px;">Singleton</a> <a href="/tags/Sticky-Event/" style="font-size: 10px;">Sticky Event</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Thread/" style="font-size: 10px;">Thread</a> <a href="/tags/TraceView/" style="font-size: 10px;">TraceView</a> <a href="/tags/Transformer/" style="font-size: 10px;">Transformer</a> <a href="/tags/VIM/" style="font-size: 10px;">VIM</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/ViewModle/" style="font-size: 10px;">ViewModle</a> <a href="/tags/WorkManager/" style="font-size: 12.5px;">WorkManager</a> <a href="/tags/adb/" style="font-size: 10px;">adb</a> <a href="/tags/《深入理解-Java-虚拟机》读书笔记/" style="font-size: 10px;">《深入理解 Java 虚拟机》读书笔记</a> <a href="/tags/三方库/" style="font-size: 10px;">三方库</a> <a href="/tags/事件分发机制/" style="font-size: 10px;">事件分发机制</a> <a href="/tags/内存优化/" style="font-size: 10px;">内存优化</a> <a href="/tags/内存分区/" style="font-size: 10px;">内存分区</a> <a href="/tags/内存泄漏/" style="font-size: 11.25px;">内存泄漏</a> <a href="/tags/内部类/" style="font-size: 10px;">内部类</a> <a href="/tags/图解-HTTP/" style="font-size: 11.25px;">图解 HTTP</a> <a href="/tags/堆栈轨迹/" style="font-size: 10px;">堆栈轨迹</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/对象拷贝/" style="font-size: 10px;">对象拷贝</a> <a href="/tags/工具/" style="font-size: 11.25px;">工具</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/性能优化工具/" style="font-size: 10px;">性能优化工具</a> <a href="/tags/数据压缩/" style="font-size: 10px;">数据压缩</a> <a href="/tags/极客时间专栏/" style="font-size: 10px;">极客时间专栏</a> <a href="/tags/极客时间笔记/" style="font-size: 10px;">极客时间笔记</a> <a href="/tags/泛型/" style="font-size: 12.5px;">泛型</a> <a href="/tags/浮点型精度问题/" style="font-size: 10px;">浮点型精度问题</a> <a href="/tags/深入浅出计算机组成原理-徐文浩/" style="font-size: 11.25px;">深入浅出计算机组成原理(徐文浩)</a> <a href="/tags/深入理解-Android-读书笔记/" style="font-size: 10px;">深入理解 Android 读书笔记</a> <a href="/tags/源码解析/" style="font-size: 10px;">源码解析</a> <a href="/tags/焦点机制/" style="font-size: 10px;">焦点机制</a> <a href="/tags/百度地图黑影/" style="font-size: 10px;">百度地图黑影</a> <a href="/tags/硬件加速/" style="font-size: 10px;">硬件加速</a> <a href="/tags/编译技术/" style="font-size: 10px;">编译技术</a> <a href="/tags/网络协议/" style="font-size: 12.5px;">网络协议</a> <a href="/tags/计算机基础/" style="font-size: 10px;">计算机基础</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/设计模式六大原则/" style="font-size: 10px;">设计模式六大原则</a> <a href="/tags/读书笔记/" style="font-size: 18.75px;">读书笔记</a> <a href="/tags/趣谈网络协议-刘超/" style="font-size: 10px;">趣谈网络协议(刘超)</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/15/性能优化工具-一-TraceView/">性能优化工具(一):TraceView</a>
          </li>
        
          <li>
            <a href="/2020/06/08/CMake-常用的-API以及-Gradle-关联到原生库/">CMake 常用的 API以及 Gradle 关联到原生库</a>
          </li>
        
          <li>
            <a href="/2020/06/08/装饰模式/">装饰模式</a>
          </li>
        
          <li>
            <a href="/2020/06/03/iTerm2常用快捷键/">iTerm2常用快捷键</a>
          </li>
        
          <li>
            <a href="/2020/02/24/Android-Logcat-基本信息细述/">Android Logcat 基本信息细述</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 玛斯特・布兰迪<br>
      巨大能量来源 <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">文章</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>